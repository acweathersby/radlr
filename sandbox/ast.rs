
/* **** DO NOT MODIFY **** DO NOT MODIFY **** DO NOT MODIFY ****
 * 
 * This code has been automatically generated by Hydrocarbon Toolkit
 * 
 * ###################################################################
 * 
 * Copyright 2022 Anthony C. Weathersby
 * 
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included 
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 */


use std::cell::UnsafeCell;

use hctk::ast::{HCObj, HCObjTrait, ReduceFunction};

use hctk::Token;

type RF = ReduceFunction<ASTNode>;

type HCO = HCObj<ASTNode>;


enum Grammar{   
    Grammar(Box<Grammar>) 
}



enum Version_6{   
    Grammar(Box<Grammar>) 
}



enum IR{   
    IR_STATE(Box<IR_STATE>),
ASSERT(Box<ASSERT>),
PEEK(Box<PEEK>),
Reduce(Box<Reduce>),
TokenAssign(Box<TokenAssign>),
SetProd(Box<SetProd>),
ForkTo(Box<ForkTo>),
ScanUntil(Box<ScanUntil>),
TokenId(Box<TokenId>),
Pass(Box<Pass>),
Fail(Box<Fail>),
NotInScope(Box<NotInScope>),
SetScope(Box<SetScope>),
Consume(Box<Consume>),
Goto(Box<Goto>),
FailState(Box<FailState>),
Symbols(Box<Symbols>),
Repeat(Box<Repeat>),
Lazy(Box<Lazy>) 
}



enum IrState{   
    IR_STATE(Box<IR_STATE>) 
}



enum IR_Instruction{   
    ASSERT(Box<ASSERT>),
Reduce(Box<Reduce>),
TokenAssign(Box<TokenAssign>),
SetProd(Box<SetProd>),
ForkTo(Box<ForkTo>),
ScanUntil(Box<ScanUntil>),
TokenId(Box<TokenId>),
Pass(Box<Pass>),
Fail(Box<Fail>),
NotInScope(Box<NotInScope>),
SetScope(Box<SetScope>),
Consume(Box<Consume>),
Goto(Box<Goto>),
Repeat(Box<Repeat>),
Lazy(Box<Lazy>) 
}



enum IR_Branch{   
    ASSERT(Box<ASSERT>),
PEEK(Box<PEEK>) 
}



enum IR_Instructio{   
    PEEK(Box<PEEK>) 
}



enum Symbol{   
    Production_Symbol(Box<Production_Symbol>),
Production_Import_Symbol(Box<Production_Import_Symbol>),
Reference(Box<Reference>),
Generated(Box<Generated>),
Exclusive_Literal(Box<Exclusive_Literal>),
Literal(Box<Literal>),
End_Of_File(Box<End_Of_File>),
Production_Token(Box<Production_Token>),
Not_Symbol(Box<Not_Symbol>),
Look_Behind(Box<Look_Behind>),
List_Production(Box<List_Production>),
Group_Production(Box<Group_Production>),
Exclude(Box<Exclude>),
Look_Ignore(Box<Look_Ignore>),
Empty(Box<Empty>) 
}



enum Function{   
    Returned(Box<Returned>),
Referenced(Box<Referenced>),
Out_Of_Band(Box<Out_Of_Band>) 
}



enum Token{   
    Generated(Box<Generated>),
Exclusive_Literal(Box<Exclusive_Literal>),
Literal(Box<Literal>),
End_Of_File(Box<End_Of_File>),
Production_Token(Box<Production_Token>) 
}



enum Meta{   
    Space(Box<Space>),
NewLine(Box<NewLine>),
IncreaseIndent(Box<IncreaseIndent>),
DecreaseIndent(Box<DecreaseIndent>),
Exclude(Box<Exclude>),
Look_Ignore(Box<Look_Ignore>) 
}



enum Format{   
    Space(Box<Space>),
NewLine(Box<NewLine>),
IncreaseIndent(Box<IncreaseIndent>),
DecreaseIndent(Box<DecreaseIndent>) 
}



enum IR_State{   
    FailState(Box<FailState>) 
}



enum Production{   
    Body(Box<Body>),
Production(Box<Production>),
ProductionMerged(Box<ProductionMerged>) 
}



enum Preamble{   
    Ignore(Box<Ignore>),
Import(Box<Import>),
Export(Box<Export>) 
}



#[derive(Debug, Clone)]
pub enum ASTNode {NONE,Meta(Box<Meta>),
Grammar(Box<Grammar>),
IR_STATE(Box<IR_STATE>),
ASSERT(Box<ASSERT>),
PEEK(Box<PEEK>),
Production_Symbol(Box<Production_Symbol>),
Production_Import_Symbol(Box<Production_Import_Symbol>),
Reduce(Box<Reduce>),
TokenAssign(Box<TokenAssign>),
SetProd(Box<SetProd>),
ForkTo(Box<ForkTo>),
ScanUntil(Box<ScanUntil>),
TokenId(Box<TokenId>),
Pass(Box<Pass>),
Fail(Box<Fail>),
NotInScope(Box<NotInScope>),
SetScope(Box<SetScope>),
Consume(Box<Consume>),
Returned(Box<Returned>),
Referenced(Box<Referenced>),
Reference(Box<Reference>),
Generated(Box<Generated>),
Exclusive_Literal(Box<Exclusive_Literal>),
Literal(Box<Literal>),
End_Of_File(Box<End_Of_File>),
Space(Box<Space>),
NewLine(Box<NewLine>),
IncreaseIndent(Box<IncreaseIndent>),
DecreaseIndent(Box<DecreaseIndent>),
Production_Token(Box<Production_Token>),
Goto(Box<Goto>),
FailState(Box<FailState>),
Symbols(Box<Symbols>),
Not_Symbol(Box<Not_Symbol>),
Look_Behind(Box<Look_Behind>),
List_Production(Box<List_Production>),
Group_Production(Box<Group_Production>),
Body(Box<Body>),
Exclude(Box<Exclude>),
Look_Ignore(Box<Look_Ignore>),
Empty(Box<Empty>),
Production(Box<Production>),
ProductionMerged(Box<ProductionMerged>),
Ignore(Box<Ignore>),
Import(Box<Import>),
Export(Box<Export>),
Productions(Box<Productions>),
Out_Of_Band(Box<Out_Of_Band>),
Repeat(Box<Repeat>),
Lazy(Box<Lazy>),
Num(Box<Num>),
HASH_NAME(Box<HASH_NAME>) 
}
    
impl HCObjTrait for ASTNode {
    fn String(&self) -> String {
        String::from("")
        /* use ASTNode::*;
        match self {
            
            Meta(bx) => bx.tok.String(),

            Grammar(bx) => bx.tok.String(),

            IR_STATE(bx) => bx.tok.String(),

            ASSERT(bx) => bx.tok.String(),

            PEEK(bx) => bx.tok.String(),

            Production_Symbol(bx) => bx.tok.String(),

            Production_Import_Symbol(bx) => bx.tok.String(),

            Reduce(bx) => bx.tok.String(),

            TokenAssign(bx) => bx.tok.String(),

            SetProd(bx) => bx.tok.String(),

            ForkTo(bx) => bx.tok.String(),

            ScanUntil(bx) => bx.tok.String(),

            TokenId(bx) => bx.tok.String(),

            Pass(bx) => bx.tok.String(),

            Fail(bx) => bx.tok.String(),

            NotInScope(bx) => bx.tok.String(),

            SetScope(bx) => bx.tok.String(),

            Consume(bx) => bx.tok.String(),

            Returned(bx) => bx.tok.String(),

            Referenced(bx) => bx.tok.String(),

            Reference(bx) => bx.tok.String(),

            Generated(bx) => bx.tok.String(),

            Exclusive_Literal(bx) => bx.tok.String(),

            Literal(bx) => bx.tok.String(),

            End_Of_File(bx) => bx.tok.String(),

            Space(bx) => bx.tok.String(),

            NewLine(bx) => bx.tok.String(),

            IncreaseIndent(bx) => bx.tok.String(),

            DecreaseIndent(bx) => bx.tok.String(),

            Production_Token(bx) => bx.tok.String(),

            Goto(bx) => bx.tok.String(),

            FailState(bx) => bx.tok.String(),

            Symbols(bx) => bx.tok.String(),

            Not_Symbol(bx) => bx.tok.String(),

            Look_Behind(bx) => bx.tok.String(),

            List_Production(bx) => bx.tok.String(),

            Group_Production(bx) => bx.tok.String(),

            Body(bx) => bx.tok.String(),

            Exclude(bx) => bx.tok.String(),

            Look_Ignore(bx) => bx.tok.String(),

            Empty(bx) => bx.tok.String(),

            Production(bx) => bx.tok.String(),

            ProductionMerged(bx) => bx.tok.String(),

            Ignore(bx) => bx.tok.String(),

            Import(bx) => bx.tok.String(),

            Export(bx) => bx.tok.String(),

            Productions(bx) => bx.tok.String(),

            Out_Of_Band(bx) => bx.tok.String(),

            Repeat(bx) => bx.tok.String(),

            Lazy(bx) => bx.tok.String(),

            Num(bx) => bx.tok.String(),

            HASH_NAME(bx) => bx.tok.String(),
            _ => String::from(""),
        } */
    }
}



#[derive(Debug)]
pub enum NodeIteration<'a> {
    NONE,
    STOP,
    CONTINUE,
    REPLACE(ASTNode),
    Meta(&'a mut Meta),
Grammar(&'a mut Grammar),
IR_STATE(&'a mut IR_STATE),
ASSERT(&'a mut ASSERT),
PEEK(&'a mut PEEK),
Production_Symbol(&'a mut Production_Symbol),
Production_Import_Symbol(&'a mut Production_Import_Symbol),
Reduce(&'a mut Reduce),
TokenAssign(&'a mut TokenAssign),
SetProd(&'a mut SetProd),
ForkTo(&'a mut ForkTo),
ScanUntil(&'a mut ScanUntil),
TokenId(&'a mut TokenId),
Pass(&'a mut Pass),
Fail(&'a mut Fail),
NotInScope(&'a mut NotInScope),
SetScope(&'a mut SetScope),
Consume(&'a mut Consume),
Returned(&'a mut Returned),
Referenced(&'a mut Referenced),
Reference(&'a mut Reference),
Generated(&'a mut Generated),
Exclusive_Literal(&'a mut Exclusive_Literal),
Literal(&'a mut Literal),
End_Of_File(&'a mut End_Of_File),
Space(&'a mut Space),
NewLine(&'a mut NewLine),
IncreaseIndent(&'a mut IncreaseIndent),
DecreaseIndent(&'a mut DecreaseIndent),
Production_Token(&'a mut Production_Token),
Goto(&'a mut Goto),
FailState(&'a mut FailState),
Symbols(&'a mut Symbols),
Not_Symbol(&'a mut Not_Symbol),
Look_Behind(&'a mut Look_Behind),
List_Production(&'a mut List_Production),
Group_Production(&'a mut Group_Production),
Body(&'a mut Body),
Exclude(&'a mut Exclude),
Look_Ignore(&'a mut Look_Ignore),
Empty(&'a mut Empty),
Production(&'a mut Production),
ProductionMerged(&'a mut ProductionMerged),
Ignore(&'a mut Ignore),
Import(&'a mut Import),
Export(&'a mut Export),
Productions(&'a mut Productions),
Out_Of_Band(&'a mut Out_Of_Band),
Repeat(&'a mut Repeat),
Lazy(&'a mut Lazy),
Num(&'a mut Num),
HASH_NAME(&'a mut HASH_NAME)
}

impl<'a> NodeIteration<'a> {
    pub fn name(&self) -> &str {
        use NodeIteration::*;
        match self {
            STOP => "stop",
            
                Meta(_0) => {
                    "node-Meta"
                },
                Grammar(_0) => {
                    "node-Grammar"
                },
                IR_STATE(_0) => {
                    "node-IR_STATE"
                },
                ASSERT(_0) => {
                    "node-ASSERT"
                },
                PEEK(_0) => {
                    "node-PEEK"
                },
                Production_Symbol(_0) => {
                    "node-Production_Symbol"
                },
                Production_Import_Symbol(_0) => {
                    "node-Production_Import_Symbol"
                },
                Reduce(_0) => {
                    "node-Reduce"
                },
                TokenAssign(_0) => {
                    "node-TokenAssign"
                },
                SetProd(_0) => {
                    "node-SetProd"
                },
                ForkTo(_0) => {
                    "node-ForkTo"
                },
                ScanUntil(_0) => {
                    "node-ScanUntil"
                },
                TokenId(_0) => {
                    "node-TokenId"
                },
                Pass(_0) => {
                    "node-Pass"
                },
                Fail(_0) => {
                    "node-Fail"
                },
                NotInScope(_0) => {
                    "node-NotInScope"
                },
                SetScope(_0) => {
                    "node-SetScope"
                },
                Consume(_0) => {
                    "node-Consume"
                },
                Returned(_0) => {
                    "node-Returned"
                },
                Referenced(_0) => {
                    "node-Referenced"
                },
                Reference(_0) => {
                    "node-Reference"
                },
                Generated(_0) => {
                    "node-Generated"
                },
                Exclusive_Literal(_0) => {
                    "node-Exclusive_Literal"
                },
                Literal(_0) => {
                    "node-Literal"
                },
                End_Of_File(_0) => {
                    "node-End_Of_File"
                },
                Space(_0) => {
                    "node-Space"
                },
                NewLine(_0) => {
                    "node-NewLine"
                },
                IncreaseIndent(_0) => {
                    "node-IncreaseIndent"
                },
                DecreaseIndent(_0) => {
                    "node-DecreaseIndent"
                },
                Production_Token(_0) => {
                    "node-Production_Token"
                },
                Goto(_0) => {
                    "node-Goto"
                },
                FailState(_0) => {
                    "node-FailState"
                },
                Symbols(_0) => {
                    "node-Symbols"
                },
                Not_Symbol(_0) => {
                    "node-Not_Symbol"
                },
                Look_Behind(_0) => {
                    "node-Look_Behind"
                },
                List_Production(_0) => {
                    "node-List_Production"
                },
                Group_Production(_0) => {
                    "node-Group_Production"
                },
                Body(_0) => {
                    "node-Body"
                },
                Exclude(_0) => {
                    "node-Exclude"
                },
                Look_Ignore(_0) => {
                    "node-Look_Ignore"
                },
                Empty(_0) => {
                    "node-Empty"
                },
                Production(_0) => {
                    "node-Production"
                },
                ProductionMerged(_0) => {
                    "node-ProductionMerged"
                },
                Ignore(_0) => {
                    "node-Ignore"
                },
                Import(_0) => {
                    "node-Import"
                },
                Export(_0) => {
                    "node-Export"
                },
                Productions(_0) => {
                    "node-Productions"
                },
                Out_Of_Band(_0) => {
                    "node-Out_Of_Band"
                },
                Repeat(_0) => {
                    "node-Repeat"
                },
                Lazy(_0) => {
                    "node-Lazy"
                },
                Num(_0) => {
                    "node-Num"
                },
                HASH_NAME(_0) => {
                    "node-HASH_NAME"
                }
            REPLACE(node) => "replace",
            _ => "unknown",
        }
    }
}

pub trait ASTNodeTraits<'a>
where
    Self: Sized,
{
    fn iterate(
        self: &'a mut Box<Self>,
        _yield: &'a mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>) -> NodeIteration<'a>,
    ) {
        let mut closure = |a: &mut NodeIteration<'a>, b: &mut NodeIteration<'a>, ty:u32, c: i32, d: i32| {
            use NodeIteration::*;
            match _yield(a, b) {
                STOP => false,
                REPLACE(node) => match b {
                    
                    Meta(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Grammar(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    IR_STATE(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    ASSERT(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    PEEK(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Production_Symbol(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Production_Import_Symbol(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Reduce(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    TokenAssign(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    SetProd(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    ForkTo(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    ScanUntil(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    TokenId(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Pass(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Fail(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    NotInScope(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    SetScope(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Consume(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Returned(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Referenced(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Reference(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Generated(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Exclusive_Literal(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Literal(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    End_Of_File(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Space(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    NewLine(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    IncreaseIndent(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    DecreaseIndent(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Production_Token(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Goto(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    FailState(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Symbols(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Not_Symbol(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Look_Behind(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    List_Production(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Group_Production(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Body(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Exclude(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Look_Ignore(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Empty(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Production(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    ProductionMerged(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Ignore(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Import(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Export(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Productions(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Out_Of_Band(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Repeat(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Lazy(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    Num(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    HASH_NAME(par) => {
                        par.Replace(node, c, d);
                        true
                    }
                    _ => true,
                },
                _ => true,
            }
        };

        self.Iterate(&mut closure, &mut NodeIteration::NONE, 0, 0)
    }
    fn Replace(&mut self, node: ASTNode, i: i32, j: i32) -> ASTNode {
        ASTNode::NONE
    }
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    );
    fn Token(&self) -> Token;
    fn Type() -> u32;
    fn GetType(&self) -> u32;

    //fn serialize(ByteWriter) -> none
    //fn deserialize(ByteReader) -> Self
}



impl<'a> ASTNodeTraits<'a> for ASTNode
where
    Self: Sized,
{
    fn Replace(&mut self, n: ASTNode, i: i32, j: i32) -> ASTNode {
        use ASTNode::*;
        match self {
            _ => ASTNode::NONE,
            
                Meta(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Grammar(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                IR_STATE(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                ASSERT(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                PEEK(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Production_Symbol(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Production_Import_Symbol(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Reduce(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                TokenAssign(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                SetProd(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                ForkTo(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                ScanUntil(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                TokenId(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Pass(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Fail(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                NotInScope(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                SetScope(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Consume(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Returned(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Referenced(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Reference(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Generated(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Exclusive_Literal(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Literal(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                End_Of_File(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Space(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                NewLine(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                IncreaseIndent(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                DecreaseIndent(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Production_Token(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Goto(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                FailState(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Symbols(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Not_Symbol(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Look_Behind(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                List_Production(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Group_Production(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Body(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Exclude(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Look_Ignore(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Empty(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Production(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                ProductionMerged(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Ignore(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Import(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Export(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Productions(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Out_Of_Band(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Repeat(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Lazy(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                Num(node) => {
                    node.as_mut().Replace(n, i, j)
            },
                HASH_NAME(node) => {
                    node.as_mut().Replace(n, i, j)
            }}
    }

    fn Iterate(&'a mut self, 
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ){
        use ASTNode::*;
        match self {
            _ => {},
            
                Meta(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Grammar(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                IR_STATE(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                ASSERT(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                PEEK(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Production_Symbol(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Production_Import_Symbol(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Reduce(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                TokenAssign(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                SetProd(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                ForkTo(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                ScanUntil(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                TokenId(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Pass(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Fail(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                NotInScope(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                SetScope(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Consume(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Returned(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Referenced(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Reference(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Generated(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Exclusive_Literal(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Literal(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                End_Of_File(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Space(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                NewLine(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                IncreaseIndent(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                DecreaseIndent(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Production_Token(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Goto(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                FailState(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Symbols(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Not_Symbol(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Look_Behind(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                List_Production(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Group_Production(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Body(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Exclude(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Look_Ignore(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Empty(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Production(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                ProductionMerged(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Ignore(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Import(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Export(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Productions(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Out_Of_Band(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Repeat(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Lazy(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                Num(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            },
                HASH_NAME(node) => {
                    node.as_mut().Iterate(_yield, parent, i, j)
            }}
    }

    fn Token(&self) -> Token {
        Token::empty()
        /* 
        use ASTNode::*;
        match self {
            _ => Token::empty(),
            
                Meta(node) => node.as_ref().Token(),
                Grammar(node) => node.as_ref().Token(),
                IR_STATE(node) => node.as_ref().Token(),
                ASSERT(node) => node.as_ref().Token(),
                PEEK(node) => node.as_ref().Token(),
                Production_Symbol(node) => node.as_ref().Token(),
                Production_Import_Symbol(node) => node.as_ref().Token(),
                Reduce(node) => node.as_ref().Token(),
                TokenAssign(node) => node.as_ref().Token(),
                SetProd(node) => node.as_ref().Token(),
                ForkTo(node) => node.as_ref().Token(),
                ScanUntil(node) => node.as_ref().Token(),
                TokenId(node) => node.as_ref().Token(),
                Pass(node) => node.as_ref().Token(),
                Fail(node) => node.as_ref().Token(),
                NotInScope(node) => node.as_ref().Token(),
                SetScope(node) => node.as_ref().Token(),
                Consume(node) => node.as_ref().Token(),
                Returned(node) => node.as_ref().Token(),
                Referenced(node) => node.as_ref().Token(),
                Reference(node) => node.as_ref().Token(),
                Generated(node) => node.as_ref().Token(),
                Exclusive_Literal(node) => node.as_ref().Token(),
                Literal(node) => node.as_ref().Token(),
                End_Of_File(node) => node.as_ref().Token(),
                Space(node) => node.as_ref().Token(),
                NewLine(node) => node.as_ref().Token(),
                IncreaseIndent(node) => node.as_ref().Token(),
                DecreaseIndent(node) => node.as_ref().Token(),
                Production_Token(node) => node.as_ref().Token(),
                Goto(node) => node.as_ref().Token(),
                FailState(node) => node.as_ref().Token(),
                Symbols(node) => node.as_ref().Token(),
                Not_Symbol(node) => node.as_ref().Token(),
                Look_Behind(node) => node.as_ref().Token(),
                List_Production(node) => node.as_ref().Token(),
                Group_Production(node) => node.as_ref().Token(),
                Body(node) => node.as_ref().Token(),
                Exclude(node) => node.as_ref().Token(),
                Look_Ignore(node) => node.as_ref().Token(),
                Empty(node) => node.as_ref().Token(),
                Production(node) => node.as_ref().Token(),
                ProductionMerged(node) => node.as_ref().Token(),
                Ignore(node) => node.as_ref().Token(),
                Import(node) => node.as_ref().Token(),
                Export(node) => node.as_ref().Token(),
                Productions(node) => node.as_ref().Token(),
                Out_Of_Band(node) => node.as_ref().Token(),
                Repeat(node) => node.as_ref().Token(),
                Lazy(node) => node.as_ref().Token(),
                Num(node) => node.as_ref().Token(),
                HASH_NAME(node) => node.as_ref().Token()} */
    }

    fn GetType(&self) -> u32 {
        use ASTNode::*;
        match self {
            _ => 0,
            
                Meta(node) => 
                    node.as_ref().GetType(),
                Grammar(node) => 
                    node.as_ref().GetType(),
                IR_STATE(node) => 
                    node.as_ref().GetType(),
                ASSERT(node) => 
                    node.as_ref().GetType(),
                PEEK(node) => 
                    node.as_ref().GetType(),
                Production_Symbol(node) => 
                    node.as_ref().GetType(),
                Production_Import_Symbol(node) => 
                    node.as_ref().GetType(),
                Reduce(node) => 
                    node.as_ref().GetType(),
                TokenAssign(node) => 
                    node.as_ref().GetType(),
                SetProd(node) => 
                    node.as_ref().GetType(),
                ForkTo(node) => 
                    node.as_ref().GetType(),
                ScanUntil(node) => 
                    node.as_ref().GetType(),
                TokenId(node) => 
                    node.as_ref().GetType(),
                Pass(node) => 
                    node.as_ref().GetType(),
                Fail(node) => 
                    node.as_ref().GetType(),
                NotInScope(node) => 
                    node.as_ref().GetType(),
                SetScope(node) => 
                    node.as_ref().GetType(),
                Consume(node) => 
                    node.as_ref().GetType(),
                Returned(node) => 
                    node.as_ref().GetType(),
                Referenced(node) => 
                    node.as_ref().GetType(),
                Reference(node) => 
                    node.as_ref().GetType(),
                Generated(node) => 
                    node.as_ref().GetType(),
                Exclusive_Literal(node) => 
                    node.as_ref().GetType(),
                Literal(node) => 
                    node.as_ref().GetType(),
                End_Of_File(node) => 
                    node.as_ref().GetType(),
                Space(node) => 
                    node.as_ref().GetType(),
                NewLine(node) => 
                    node.as_ref().GetType(),
                IncreaseIndent(node) => 
                    node.as_ref().GetType(),
                DecreaseIndent(node) => 
                    node.as_ref().GetType(),
                Production_Token(node) => 
                    node.as_ref().GetType(),
                Goto(node) => 
                    node.as_ref().GetType(),
                FailState(node) => 
                    node.as_ref().GetType(),
                Symbols(node) => 
                    node.as_ref().GetType(),
                Not_Symbol(node) => 
                    node.as_ref().GetType(),
                Look_Behind(node) => 
                    node.as_ref().GetType(),
                List_Production(node) => 
                    node.as_ref().GetType(),
                Group_Production(node) => 
                    node.as_ref().GetType(),
                Body(node) => 
                    node.as_ref().GetType(),
                Exclude(node) => 
                    node.as_ref().GetType(),
                Look_Ignore(node) => 
                    node.as_ref().GetType(),
                Empty(node) => 
                    node.as_ref().GetType(),
                Production(node) => 
                    node.as_ref().GetType(),
                ProductionMerged(node) => 
                    node.as_ref().GetType(),
                Ignore(node) => 
                    node.as_ref().GetType(),
                Import(node) => 
                    node.as_ref().GetType(),
                Export(node) => 
                    node.as_ref().GetType(),
                Productions(node) => 
                    node.as_ref().GetType(),
                Out_Of_Band(node) => 
                    node.as_ref().GetType(),
                Repeat(node) => 
                    node.as_ref().GetType(),
                Lazy(node) => 
                    node.as_ref().GetType(),
                Num(node) => 
                    node.as_ref().GetType(),
                HASH_NAME(node) => 
                    node.as_ref().GetType()}
    }

    fn Type() -> u32 { 0 }
    
}





#[derive(Debug, Clone)]
pub struct Meta {
    pub all_symbols:Vec<ASTNode> /* VECTOR */,
pub ignore_symbols:Vec<ASTNode> /* VECTOR */
}

impl Meta {
fn new( _all_symbols:Vec<ASTNode>, _ignore_symbols:Vec<ASTNode>) -> Box<Self> {
    Box::new(Meta{
        all_symbols : _all_symbols,
        ignore_symbols : _ignore_symbols,
    })
}




fn  replace_all_symbols(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Production_Symbol(_)|ASTNode::Production_Import_Symbol(_)|ASTNode::Reference(_)|ASTNode::Generated(_)|ASTNode::Exclusive_Literal(_)|ASTNode::Literal(_)|ASTNode::End_Of_File(_)|ASTNode::Production_Token(_)|ASTNode::Not_Symbol(_)|ASTNode::Look_Behind(_)|ASTNode::List_Production(_)|ASTNode::Group_Production(_)|ASTNode::Exclude(_)|ASTNode::Look_Ignore(_)|ASTNode::Empty(_) => {
            if index as usize >= self.all_symbols.len() {
                self.all_symbols.push(child);
                None
            }else {
                self.all_symbols.push(child);
                let node = self.all_symbols.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.all_symbols.len() {
                let node = self.all_symbols.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}
}



impl<'a> ASTNodeTraits<'a> for Meta
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Meta(*mut_me), parent, 720896, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).all_symbols.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).all_symbols[j];

                match child {
                    
                        ASTNode::Production_Symbol(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Meta(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Production_Import_Symbol(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Meta(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Reference(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Meta(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Generated(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Meta(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Exclusive_Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Meta(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Meta(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::End_Of_File(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Meta(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Production_Token(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Meta(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Not_Symbol(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Meta(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Look_Behind(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Meta(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::List_Production(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Meta(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Group_Production(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Meta(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Exclude(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Meta(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Look_Ignore(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Meta(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Empty(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Meta(*mut_me), 0, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_all_symbols(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 720896;
}

fn GetType(&self) -> u32 {
    return 720896;
}
}




#[derive(Debug, Clone)]
pub struct Grammar {
    pub preamble:Vec<ASTNode> /* VECTOR */,
pub productions:Vec<ASTNode> /* VECTOR */,
pub ir_states:Vec<ASTNode> /* VECTOR */,
pub functions:Vec<ASTNode> /* VECTOR */,
pub imported_grammars:Vec<ASTNode> /* VECTOR */,
pub meta:Box<Meta> /* Meta */,
pub bodies:Vec<ASTNode> /* VECTOR */,
pub tok:Token /* TOKEN */
}

impl Grammar {
fn new( _preamble:Vec<ASTNode>, _productions:Vec<ASTNode>, _ir_states:Vec<ASTNode>, _functions:Vec<ASTNode>, _imported_grammars:Vec<ASTNode>, _meta:Box<Meta>, _bodies:Vec<ASTNode>, _tok:Token) -> Box<Self> {
    Box::new(Grammar{
        preamble : _preamble,
        productions : _productions,
        ir_states : _ir_states,
        functions : _functions,
        imported_grammars : _imported_grammars,
        meta : _meta,
        bodies : _bodies,
        tok : _tok,
    })
}




fn  replace_preamble(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Ignore(_)|ASTNode::Import(_)|ASTNode::Export(_) => {
            if index as usize >= self.preamble.len() {
                self.preamble.push(child);
                None
            }else {
                self.preamble.push(child);
                let node = self.preamble.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.preamble.len() {
                let node = self.preamble.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_productions(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Production(_)|ASTNode::ProductionMerged(_) => {
            if index as usize >= self.productions.len() {
                self.productions.push(child);
                None
            }else {
                self.productions.push(child);
                let node = self.productions.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.productions.len() {
                let node = self.productions.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_ir_states(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::IR_STATE(_) => {
            if index as usize >= self.ir_states.len() {
                self.ir_states.push(child);
                None
            }else {
                self.ir_states.push(child);
                let node = self.ir_states.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.ir_states.len() {
                let node = self.ir_states.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_functions(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Out_Of_Band(_) => {
            if index as usize >= self.functions.len() {
                self.functions.push(child);
                None
            }else {
                self.functions.push(child);
                let node = self.functions.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.functions.len() {
                let node = self.functions.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_imported_grammars(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Grammar(_) => {
            if index as usize >= self.imported_grammars.len() {
                self.imported_grammars.push(child);
                None
            }else {
                self.imported_grammars.push(child);
                let node = self.imported_grammars.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.imported_grammars.len() {
                let node = self.imported_grammars.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_meta(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    if let ASTNode::Meta(child) = child {
        return Some(ASTNode::Meta(std::mem::replace(&mut self.meta, child)))
    }else {
        return None
    }
    
}

fn  replace_bodies(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Body(_) => {
            if index as usize >= self.bodies.len() {
                self.bodies.push(child);
                None
            }else {
                self.bodies.push(child);
                let node = self.bodies.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.bodies.len() {
                let node = self.bodies.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}
}



impl<'a> ASTNodeTraits<'a> for Grammar
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Grammar(*mut_me), parent, 786438, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).preamble.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).preamble[j];

                match child {
                    
                        ASTNode::Ignore(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Import(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Export(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 0, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).productions.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).productions[j];

                match child {
                    
                        ASTNode::Production(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::ProductionMerged(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 1, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).ir_states.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).ir_states[j];

                
                if let ASTNode::IR_STATE(child) = child {
                    unsafe { 
                        let mut_me = node.get();
                        child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 2, j as i32)   
                    };
                }
            }
        }
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).functions.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).functions[j];

                
                if let ASTNode::Out_Of_Band(child) = child {
                    unsafe { 
                        let mut_me = node.get();
                        child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 3, j as i32)   
                    };
                }
            }
        }
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).imported_grammars.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).imported_grammars[j];

                
                if let ASTNode::Grammar(child) = child {
                    unsafe { 
                        let mut_me = node.get();
                        child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 4, j as i32)   
                    };
                }
            }
        }
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).meta).Iterate( _yield, &mut NodeIteration::Grammar(*mut_me_b), 5, 0);
            
        }
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).bodies.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).bodies[j];

                
                if let ASTNode::Body(child) = child {
                    unsafe { 
                        let mut_me = node.get();
                        child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 6, j as i32)   
                    };
                }
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_preamble(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    1 => {
                    
        if let Some(old) = self.replace_productions(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    2 => {
                    
        if let Some(old) = self.replace_ir_states(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    3 => {
                    
        if let Some(old) = self.replace_functions(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    4 => {
                    
        if let Some(old) = self.replace_imported_grammars(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    5 => {
                    
        if let Some(old) = self.replace_meta(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    6 => {
                    
        if let Some(old) = self.replace_bodies(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 786438;
}

fn GetType(&self) -> u32 {
    return 786438;
}
}




#[derive(Debug, Clone)]
pub struct IR_STATE {
    pub id:String /* STRING */,
pub instructions:Vec<ASTNode> /* VECTOR */,
pub fail:Option<Box<FailState>> /* FailState */,
pub symbol_meta:Option<Box<Symbols>> /* Symbols */,
pub prod:ASTNode /* Production_Symbol | Production_Import_Symbol */
}

impl IR_STATE {
fn new( _id:String, _instructions:Vec<ASTNode>, _fail:Option<Box<FailState>>, _symbol_meta:Option<Box<Symbols>>, _prod:ASTNode) -> Box<Self> {
    Box::new(IR_STATE{
        id : _id,
        instructions : _instructions,
        fail : _fail,
        symbol_meta : _symbol_meta,
        prod : _prod,
    })
}




fn  replace_instructions(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::ASSERT(_)|ASTNode::PEEK(_)|ASTNode::Repeat(_)|ASTNode::Reduce(_)|ASTNode::TokenAssign(_)|ASTNode::SetProd(_)|ASTNode::ForkTo(_)|ASTNode::ScanUntil(_)|ASTNode::TokenId(_)|ASTNode::Pass(_)|ASTNode::Fail(_)|ASTNode::NotInScope(_)|ASTNode::SetScope(_)|ASTNode::Consume(_)|ASTNode::Goto(_)|ASTNode::Lazy(_) => {
            if index as usize >= self.instructions.len() {
                self.instructions.push(child);
                None
            }else {
                self.instructions.push(child);
                let node = self.instructions.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.instructions.len() {
                let node = self.instructions.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_fail(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.fail.is_some() {
                let old = std::mem::replace(&mut self.fail, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::FailState(old_node));
                }
            }
        }

        ASTNode::FailState(child) => {
            if self.fail.is_none() {
                self.fail = Some(child);
            } else {
                let old = std::mem::replace(&mut self.fail, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::FailState(old_node));
                }
            }
        }
        _ => {}
    }
    None
}

fn  replace_symbol_meta(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.symbol_meta.is_some() {
                let old = std::mem::replace(&mut self.symbol_meta, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Symbols(old_node));
                }
            }
        }

        ASTNode::Symbols(child) => {
            if self.symbol_meta.is_none() {
                self.symbol_meta = Some(child);
            } else {
                let old = std::mem::replace(&mut self.symbol_meta, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Symbols(old_node));
                }
            }
        }
        _ => {}
    }
    None
}

fn  replace_prod(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.prod, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Production_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.prod, child));
        },

        ASTNode::Production_Import_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.prod, child));
        }
        _ => None
        
    }
}
}



impl<'a> ASTNodeTraits<'a> for IR_STATE
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::IR_STATE(*mut_me), parent, 851992, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).instructions.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).instructions[j];

                match child {
                    
                        ASTNode::ASSERT(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::PEEK(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Repeat(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Reduce(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::TokenAssign(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::SetProd(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::ForkTo(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::ScanUntil(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::TokenId(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Pass(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Fail(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::NotInScope(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::SetScope(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Consume(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Goto(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Lazy(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).fail /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::IR_STATE(*mut_me_b), 1, 0);
            }
        }
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).symbol_meta /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::IR_STATE(*mut_me_b), 2, 0);
            }
        }
    
        unsafe {
            let reference = node.get();
            if let child = &mut (*reference).prod /* HAS_NULL:true */{
                 
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::IR_STATE(*mut_me_b), 3, 0);
    
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_instructions(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    1 => {
                    
        if let Some(old) = self.replace_fail(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    2 => {
                    
        if let Some(old) = self.replace_symbol_meta(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    3 => {
                    
        if let Some(old) = self.replace_prod(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 851992;
}

fn GetType(&self) -> u32 {
    return 851992;
}
}




#[derive(Debug, Clone)]
pub struct ASSERT {
    pub mode:String /* STRING */,
pub ids:Vec<ASTNode> /* VECTOR */,
pub instructions:Vec<ASTNode> /* VECTOR */
}

impl ASSERT {
fn new( _mode:String, _ids:Vec<ASTNode>, _instructions:Vec<ASTNode>) -> Box<Self> {
    Box::new(ASSERT{
        mode : _mode,
        ids : _ids,
        instructions : _instructions,
    })
}




fn  replace_ids(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Production_Symbol(_)|ASTNode::Production_Import_Symbol(_)|ASTNode::Num(_) => {
            if index as usize >= self.ids.len() {
                self.ids.push(child);
                None
            }else {
                self.ids.push(child);
                let node = self.ids.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.ids.len() {
                let node = self.ids.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_instructions(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Repeat(_)|ASTNode::Reduce(_)|ASTNode::TokenAssign(_)|ASTNode::SetProd(_)|ASTNode::ForkTo(_)|ASTNode::ScanUntil(_)|ASTNode::TokenId(_)|ASTNode::Pass(_)|ASTNode::Fail(_)|ASTNode::NotInScope(_)|ASTNode::SetScope(_)|ASTNode::Consume(_)|ASTNode::Goto(_)|ASTNode::Lazy(_) => {
            if index as usize >= self.instructions.len() {
                self.instructions.push(child);
                None
            }else {
                self.instructions.push(child);
                let node = self.instructions.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.instructions.len() {
                let node = self.instructions.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}
}



impl<'a> ASTNodeTraits<'a> for ASSERT
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::ASSERT(*mut_me), parent, 917608, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).ids.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).ids[j];

                match child {
                    
                        ASTNode::Production_Symbol(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Production_Import_Symbol(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Num(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 0, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).instructions.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).instructions[j];

                match child {
                    
                        ASTNode::Repeat(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Reduce(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::TokenAssign(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::SetProd(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::ForkTo(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::ScanUntil(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::TokenId(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Pass(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Fail(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::NotInScope(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::SetScope(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Consume(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Goto(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Lazy(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_ids(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    1 => {
                    
        if let Some(old) = self.replace_instructions(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 917608;
}

fn GetType(&self) -> u32 {
    return 917608;
}
}




#[derive(Debug, Clone)]
pub struct PEEK {
    pub mode:String /* STRING */,
pub ids:Vec<ASTNode> /* VECTOR */,
pub instructions:Vec<ASTNode> /* VECTOR */
}

impl PEEK {
fn new( _mode:String, _ids:Vec<ASTNode>, _instructions:Vec<ASTNode>) -> Box<Self> {
    Box::new(PEEK{
        mode : _mode,
        ids : _ids,
        instructions : _instructions,
    })
}




fn  replace_ids(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Generated(_)|ASTNode::Exclusive_Literal(_)|ASTNode::Literal(_)|ASTNode::End_Of_File(_)|ASTNode::Space(_)|ASTNode::NewLine(_)|ASTNode::IncreaseIndent(_)|ASTNode::DecreaseIndent(_)|ASTNode::Production_Token(_)|ASTNode::Num(_) => {
            if index as usize >= self.ids.len() {
                self.ids.push(child);
                None
            }else {
                self.ids.push(child);
                let node = self.ids.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.ids.len() {
                let node = self.ids.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_instructions(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Repeat(_)|ASTNode::Reduce(_)|ASTNode::TokenAssign(_)|ASTNode::SetProd(_)|ASTNode::ForkTo(_)|ASTNode::ScanUntil(_)|ASTNode::TokenId(_)|ASTNode::Pass(_)|ASTNode::Fail(_)|ASTNode::NotInScope(_)|ASTNode::SetScope(_)|ASTNode::Consume(_)|ASTNode::Goto(_)|ASTNode::Lazy(_) => {
            if index as usize >= self.instructions.len() {
                self.instructions.push(child);
                None
            }else {
                self.instructions.push(child);
                let node = self.instructions.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.instructions.len() {
                let node = self.instructions.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}
}



impl<'a> ASTNodeTraits<'a> for PEEK
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::PEEK(*mut_me), parent, 983240, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).ids.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).ids[j];

                match child {
                    
                        ASTNode::Generated(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Exclusive_Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::End_Of_File(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Space(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::NewLine(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::IncreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::DecreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Production_Token(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Num(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 0, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).instructions.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).instructions[j];

                match child {
                    
                        ASTNode::Repeat(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Reduce(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::TokenAssign(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::SetProd(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::ForkTo(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::ScanUntil(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::TokenId(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Pass(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Fail(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::NotInScope(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::SetScope(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Consume(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Goto(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Lazy(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::PEEK(*mut_me), 1, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_ids(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    1 => {
                    
        if let Some(old) = self.replace_instructions(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 983240;
}

fn GetType(&self) -> u32 {
    return 983240;
}
}




#[derive(Debug, Clone)]
pub struct Production_Symbol {
    pub name:String /* STRING */,
pub production:ASTNode /* Body | Production | ProductionMerged */,
pub val:f64 /* F64 */,
pub annotation:Option<Box<Reference>> /* Reference */,
pub tok:Token /* TOKEN */,
pub IS_OPTIONAL:f64 /* F64 */,
pub IS_NON_CAPTURE:bool /* BOOL */
}

impl Production_Symbol {
fn new( _name:String, _production:ASTNode, _val:f64, _annotation:Option<Box<Reference>>, _tok:Token, _IS_OPTIONAL:f64, _IS_NON_CAPTURE:bool) -> Box<Self> {
    Box::new(Production_Symbol{
        name : _name,
        production : _production,
        val : _val,
        annotation : _annotation,
        tok : _tok,
        IS_OPTIONAL : _IS_OPTIONAL,
        IS_NON_CAPTURE : _IS_NON_CAPTURE,
    })
}




fn  replace_production(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.production, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Body(_) => { 
            return Some(std::mem::replace(&mut self.production, child));
        },

        ASTNode::Production(_) => { 
            return Some(std::mem::replace(&mut self.production, child));
        },

        ASTNode::ProductionMerged(_) => { 
            return Some(std::mem::replace(&mut self.production, child));
        }
        _ => None
        
    }
}

fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.annotation.is_some() {
                let old = std::mem::replace(&mut self.annotation, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }

        ASTNode::Reference(child) => {
            if self.annotation.is_none() {
                self.annotation = Some(child);
            } else {
                let old = std::mem::replace(&mut self.annotation, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for Production_Symbol
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Production_Symbol(*mut_me), parent, 1048832, i, j) { return };
    }
        
    
        unsafe {
            let reference = node.get();
            if let child = &mut (*reference).production /* HAS_NULL:true */{
                 
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Production_Symbol(*mut_me_b), 0, 0);
    
            }
        }
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).annotation /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Production_Symbol(*mut_me_b), 1, 0);
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_production(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    1 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 1048832;
}

fn GetType(&self) -> u32 {
    return 1048832;
}
}




#[derive(Debug, Clone)]
pub struct Production_Import_Symbol {
    pub module:String /* STRING */,
pub name:String /* STRING */,
pub production:ASTNode /* Body | Production | ProductionMerged */,
pub annotation:Option<Box<Reference>> /* Reference */,
pub tok:Token /* TOKEN */,
pub IS_OPTIONAL:f64 /* F64 */,
pub IS_NON_CAPTURE:bool /* BOOL */
}

impl Production_Import_Symbol {
fn new( _module:String, _name:String, _production:ASTNode, _annotation:Option<Box<Reference>>, _tok:Token, _IS_OPTIONAL:f64, _IS_NON_CAPTURE:bool) -> Box<Self> {
    Box::new(Production_Import_Symbol{
        module : _module,
        name : _name,
        production : _production,
        annotation : _annotation,
        tok : _tok,
        IS_OPTIONAL : _IS_OPTIONAL,
        IS_NON_CAPTURE : _IS_NON_CAPTURE,
    })
}




fn  replace_production(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.production, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Body(_) => { 
            return Some(std::mem::replace(&mut self.production, child));
        },

        ASTNode::Production(_) => { 
            return Some(std::mem::replace(&mut self.production, child));
        },

        ASTNode::ProductionMerged(_) => { 
            return Some(std::mem::replace(&mut self.production, child));
        }
        _ => None
        
    }
}

fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.annotation.is_some() {
                let old = std::mem::replace(&mut self.annotation, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }

        ASTNode::Reference(child) => {
            if self.annotation.is_none() {
                self.annotation = Some(child);
            } else {
                let old = std::mem::replace(&mut self.annotation, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for Production_Import_Symbol
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Production_Import_Symbol(*mut_me), parent, 1114368, i, j) { return };
    }
        
    
        unsafe {
            let reference = node.get();
            if let child = &mut (*reference).production /* HAS_NULL:true */{
                 
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Production_Import_Symbol(*mut_me_b), 0, 0);
    
            }
        }
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).annotation /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Production_Import_Symbol(*mut_me_b), 1, 0);
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_production(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    1 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 1114368;
}

fn GetType(&self) -> u32 {
    return 1114368;
}
}




#[derive(Debug, Clone)]
pub struct Reduce {
    pub len:i32 /* I32 */,
pub body_id:i32 /* I32 */,
pub reduce_fn:ASTNode /* Returned | Referenced */
}

impl Reduce {
fn new( _len:i32, _body_id:i32, _reduce_fn:ASTNode) -> Box<Self> {
    Box::new(Reduce{
        len : _len,
        body_id : _body_id,
        reduce_fn : _reduce_fn,
    })
}




fn  replace_reduce_fn(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.reduce_fn, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Returned(_) => { 
            return Some(std::mem::replace(&mut self.reduce_fn, child));
        },

        ASTNode::Referenced(_) => { 
            return Some(std::mem::replace(&mut self.reduce_fn, child));
        }
        _ => None
        
    }
}
}



impl<'a> ASTNodeTraits<'a> for Reduce
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Reduce(*mut_me), parent, 1179688, i, j) { return };
    }
        
    
        unsafe {
            let reference = node.get();
            if let child = &mut (*reference).reduce_fn /* HAS_NULL:true */{
                 
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Reduce(*mut_me_b), 0, 0);
    
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_reduce_fn(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 1179688;
}

fn GetType(&self) -> u32 {
    return 1179688;
}
}




#[derive(Debug, Clone)]
pub struct TokenAssign {
    pub ids:Vec<ASTNode> /* VECTOR */
}

impl TokenAssign {
fn new( _ids:Vec<ASTNode>) -> Box<Self> {
    Box::new(TokenAssign{
        ids : _ids,
    })
}




fn  replace_ids(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Generated(_)|ASTNode::Exclusive_Literal(_)|ASTNode::Literal(_)|ASTNode::End_Of_File(_)|ASTNode::Space(_)|ASTNode::NewLine(_)|ASTNode::IncreaseIndent(_)|ASTNode::DecreaseIndent(_)|ASTNode::Production_Token(_)|ASTNode::Num(_) => {
            if index as usize >= self.ids.len() {
                self.ids.push(child);
                None
            }else {
                self.ids.push(child);
                let node = self.ids.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.ids.len() {
                let node = self.ids.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}
}



impl<'a> ASTNodeTraits<'a> for TokenAssign
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::TokenAssign(*mut_me), parent, 1245224, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).ids.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).ids[j];

                match child {
                    
                        ASTNode::Generated(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::TokenAssign(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Exclusive_Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::TokenAssign(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::TokenAssign(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::End_Of_File(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::TokenAssign(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Space(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::TokenAssign(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::NewLine(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::TokenAssign(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::IncreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::TokenAssign(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::DecreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::TokenAssign(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Production_Token(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::TokenAssign(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Num(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::TokenAssign(*mut_me), 0, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_ids(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 1245224;
}

fn GetType(&self) -> u32 {
    return 1245224;
}
}




#[derive(Debug, Clone)]
pub struct SetProd {
    pub id:ASTNode /* Production_Symbol | Production_Import_Symbol | Num */
}

impl SetProd {
fn new( _id:ASTNode) -> Box<Self> {
    Box::new(SetProd{
        id : _id,
    })
}




fn  replace_id(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.id, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Production_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.id, child));
        },

        ASTNode::Production_Import_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.id, child));
        },

        ASTNode::Num(_) => { 
            return Some(std::mem::replace(&mut self.id, child));
        }
        _ => None
        
    }
}
}



impl<'a> ASTNodeTraits<'a> for SetProd
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::SetProd(*mut_me), parent, 1310760, i, j) { return };
    }
        
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).id).Iterate( _yield, &mut NodeIteration::SetProd(*mut_me_b), 0, 0);
            
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_id(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 1310760;
}

fn GetType(&self) -> u32 {
    return 1310760;
}
}




#[derive(Debug, Clone)]
pub struct ForkTo {
    pub states:Vec<ASTNode> /* VECTOR */
}

impl ForkTo {
fn new( _states:Vec<ASTNode>) -> Box<Self> {
    Box::new(ForkTo{
        states : _states,
    })
}




fn  replace_states(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Production_Symbol(_)|ASTNode::Production_Import_Symbol(_)|ASTNode::HASH_NAME(_) => {
            if index as usize >= self.states.len() {
                self.states.push(child);
                None
            }else {
                self.states.push(child);
                let node = self.states.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.states.len() {
                let node = self.states.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}
}



impl<'a> ASTNodeTraits<'a> for ForkTo
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::ForkTo(*mut_me), parent, 1376296, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).states.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).states[j];

                match child {
                    
                        ASTNode::Production_Symbol(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ForkTo(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Production_Import_Symbol(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ForkTo(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::HASH_NAME(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ForkTo(*mut_me), 0, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_states(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 1376296;
}

fn GetType(&self) -> u32 {
    return 1376296;
}
}




#[derive(Debug, Clone)]
pub struct ScanUntil {
    pub ids:Vec<ASTNode> /* VECTOR */,
pub SCAN_BACKWARDS:bool /* BOOL */
}

impl ScanUntil {
fn new( _ids:Vec<ASTNode>, _SCAN_BACKWARDS:bool) -> Box<Self> {
    Box::new(ScanUntil{
        ids : _ids,
        SCAN_BACKWARDS : _SCAN_BACKWARDS,
    })
}




fn  replace_ids(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Generated(_)|ASTNode::Exclusive_Literal(_)|ASTNode::Literal(_)|ASTNode::End_Of_File(_)|ASTNode::Space(_)|ASTNode::NewLine(_)|ASTNode::IncreaseIndent(_)|ASTNode::DecreaseIndent(_)|ASTNode::Production_Token(_)|ASTNode::Num(_) => {
            if index as usize >= self.ids.len() {
                self.ids.push(child);
                None
            }else {
                self.ids.push(child);
                let node = self.ids.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.ids.len() {
                let node = self.ids.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}
}



impl<'a> ASTNodeTraits<'a> for ScanUntil
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::ScanUntil(*mut_me), parent, 1441832, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).ids.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).ids[j];

                match child {
                    
                        ASTNode::Generated(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ScanUntil(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Exclusive_Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ScanUntil(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ScanUntil(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::End_Of_File(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ScanUntil(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Space(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ScanUntil(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::NewLine(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ScanUntil(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::IncreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ScanUntil(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::DecreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ScanUntil(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Production_Token(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ScanUntil(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Num(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::ScanUntil(*mut_me), 0, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_ids(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 1441832;
}

fn GetType(&self) -> u32 {
    return 1441832;
}
}




#[derive(Debug, Clone)]
pub struct TokenId {
    pub id:ASTNode /* Generated | Exclusive_Literal | Literal | End_Of_File | Space | NewLine | IncreaseIndent | DecreaseIndent | Production_Token | Num */
}

impl TokenId {
fn new( _id:ASTNode) -> Box<Self> {
    Box::new(TokenId{
        id : _id,
    })
}




fn  replace_id(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.id, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Generated(_) => { 
            return Some(std::mem::replace(&mut self.id, child));
        },

        ASTNode::Exclusive_Literal(_) => { 
            return Some(std::mem::replace(&mut self.id, child));
        },

        ASTNode::Literal(_) => { 
            return Some(std::mem::replace(&mut self.id, child));
        },

        ASTNode::End_Of_File(_) => { 
            return Some(std::mem::replace(&mut self.id, child));
        },

        ASTNode::Space(_) => { 
            return Some(std::mem::replace(&mut self.id, child));
        },

        ASTNode::NewLine(_) => { 
            return Some(std::mem::replace(&mut self.id, child));
        },

        ASTNode::IncreaseIndent(_) => { 
            return Some(std::mem::replace(&mut self.id, child));
        },

        ASTNode::DecreaseIndent(_) => { 
            return Some(std::mem::replace(&mut self.id, child));
        },

        ASTNode::Production_Token(_) => { 
            return Some(std::mem::replace(&mut self.id, child));
        },

        ASTNode::Num(_) => { 
            return Some(std::mem::replace(&mut self.id, child));
        }
        _ => None
        
    }
}
}



impl<'a> ASTNodeTraits<'a> for TokenId
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::TokenId(*mut_me), parent, 1507368, i, j) { return };
    }
        
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).id).Iterate( _yield, &mut NodeIteration::TokenId(*mut_me_b), 0, 0);
            
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_id(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 1507368;
}

fn GetType(&self) -> u32 {
    return 1507368;
}
}




#[derive(Debug, Clone)]
pub struct Pass {
    
}

impl Pass {
fn new( ) -> Box<Self> {
    Box::new(Pass{
        
    })
}




}



impl<'a> ASTNodeTraits<'a> for Pass
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Pass(*mut_me), parent, 1572904, i, j) { return };
    }
        
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 1572904;
}

fn GetType(&self) -> u32 {
    return 1572904;
}
}




#[derive(Debug, Clone)]
pub struct Fail {
    
}

impl Fail {
fn new( ) -> Box<Self> {
    Box::new(Fail{
        
    })
}




}



impl<'a> ASTNodeTraits<'a> for Fail
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Fail(*mut_me), parent, 1638440, i, j) { return };
    }
        
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 1638440;
}

fn GetType(&self) -> u32 {
    return 1638440;
}
}




#[derive(Debug, Clone)]
pub struct NotInScope {
    pub ids:Vec<ASTNode> /* VECTOR */
}

impl NotInScope {
fn new( _ids:Vec<ASTNode>) -> Box<Self> {
    Box::new(NotInScope{
        ids : _ids,
    })
}




fn  replace_ids(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Production_Symbol(_)|ASTNode::Production_Import_Symbol(_)|ASTNode::Num(_) => {
            if index as usize >= self.ids.len() {
                self.ids.push(child);
                None
            }else {
                self.ids.push(child);
                let node = self.ids.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.ids.len() {
                let node = self.ids.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}
}



impl<'a> ASTNodeTraits<'a> for NotInScope
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::NotInScope(*mut_me), parent, 1703976, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).ids.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).ids[j];

                match child {
                    
                        ASTNode::Production_Symbol(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::NotInScope(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Production_Import_Symbol(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::NotInScope(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Num(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::NotInScope(*mut_me), 0, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_ids(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 1703976;
}

fn GetType(&self) -> u32 {
    return 1703976;
}
}




#[derive(Debug, Clone)]
pub struct SetScope {
    pub scope:164 /* I64 */
}

impl SetScope {
fn new( _scope:164) -> Box<Self> {
    Box::new(SetScope{
        scope : _scope,
    })
}




}



impl<'a> ASTNodeTraits<'a> for SetScope
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::SetScope(*mut_me), parent, 1769512, i, j) { return };
    }
        
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 1769512;
}

fn GetType(&self) -> u32 {
    return 1769512;
}
}




#[derive(Debug, Clone)]
pub struct Consume {
    pub EMPTY:bool /* BOOL */
}

impl Consume {
fn new( _EMPTY:bool) -> Box<Self> {
    Box::new(Consume{
        EMPTY : _EMPTY,
    })
}




}



impl<'a> ASTNodeTraits<'a> for Consume
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Consume(*mut_me), parent, 1835048, i, j) { return };
    }
        
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 1835048;
}

fn GetType(&self) -> u32 {
    return 1835048;
}
}




#[derive(Debug, Clone)]
pub struct Returned {
    pub txt:String /* STRING */,
pub name:String /* STRING */,
pub env:bool /* BOOL */,
pub IS_CONDITION:bool /* BOOL */
}

impl Returned {
fn new( _txt:String, _name:String, _env:bool, _IS_CONDITION:bool) -> Box<Self> {
    Box::new(Returned{
        txt : _txt,
        name : _name,
        env : _env,
        IS_CONDITION : _IS_CONDITION,
    })
}




}



impl<'a> ASTNodeTraits<'a> for Returned
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Returned(*mut_me), parent, 1901056, i, j) { return };
    }
        
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 1901056;
}

fn GetType(&self) -> u32 {
    return 1901056;
}
}




#[derive(Debug, Clone)]
pub struct Referenced {
    pub reference:Box<Reference> /* Reference */
}

impl Referenced {
fn new( _reference:Box<Reference>) -> Box<Self> {
    Box::new(Referenced{
        reference : _reference,
    })
}




fn  replace_reference(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    if let ASTNode::Reference(child) = child {
        return Some(ASTNode::Reference(std::mem::replace(&mut self.reference, child)))
    }else {
        return None
    }
    
}
}



impl<'a> ASTNodeTraits<'a> for Referenced
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Referenced(*mut_me), parent, 1966592, i, j) { return };
    }
        
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).reference).Iterate( _yield, &mut NodeIteration::Referenced(*mut_me_b), 0, 0);
            
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_reference(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 1966592;
}

fn GetType(&self) -> u32 {
    return 1966592;
}
}




#[derive(Debug, Clone)]
pub struct Reference {
    pub val:String /* STRING */
}

impl Reference {
fn new( _val:String) -> Box<Self> {
    Box::new(Reference{
        val : _val,
    })
}




}



impl<'a> ASTNodeTraits<'a> for Reference
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Reference(*mut_me), parent, 2031872, i, j) { return };
    }
        
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 2031872;
}

fn GetType(&self) -> u32 {
    return 2031872;
}
}




#[derive(Debug, Clone)]
pub struct Generated {
    pub val:String /* STRING */,
pub annotation:Option<Box<Reference>> /* Reference */,
pub tok:Token /* TOKEN */,
pub IS_OPTIONAL:f64 /* F64 */,
pub IS_NON_CAPTURE:bool /* BOOL */
}

impl Generated {
fn new( _val:String, _annotation:Option<Box<Reference>>, _tok:Token, _IS_OPTIONAL:f64, _IS_NON_CAPTURE:bool) -> Box<Self> {
    Box::new(Generated{
        val : _val,
        annotation : _annotation,
        tok : _tok,
        IS_OPTIONAL : _IS_OPTIONAL,
        IS_NON_CAPTURE : _IS_NON_CAPTURE,
    })
}




fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.annotation.is_some() {
                let old = std::mem::replace(&mut self.annotation, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }

        ASTNode::Reference(child) => {
            if self.annotation.is_none() {
                self.annotation = Some(child);
            } else {
                let old = std::mem::replace(&mut self.annotation, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for Generated
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Generated(*mut_me), parent, 2098432, i, j) { return };
    }
        
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).annotation /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Generated(*mut_me_b), 0, 0);
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 2098432;
}

fn GetType(&self) -> u32 {
    return 2098432;
}
}




#[derive(Debug, Clone)]
pub struct Exclusive_Literal {
    pub val:String /* STRING */,
pub annotation:Option<Box<Reference>> /* Reference */,
pub tok:Token /* TOKEN */,
pub IS_OPTIONAL:f64 /* F64 */,
pub IS_NON_CAPTURE:bool /* BOOL */
}

impl Exclusive_Literal {
fn new( _val:String, _annotation:Option<Box<Reference>>, _tok:Token, _IS_OPTIONAL:f64, _IS_NON_CAPTURE:bool) -> Box<Self> {
    Box::new(Exclusive_Literal{
        val : _val,
        annotation : _annotation,
        tok : _tok,
        IS_OPTIONAL : _IS_OPTIONAL,
        IS_NON_CAPTURE : _IS_NON_CAPTURE,
    })
}




fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.annotation.is_some() {
                let old = std::mem::replace(&mut self.annotation, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }

        ASTNode::Reference(child) => {
            if self.annotation.is_none() {
                self.annotation = Some(child);
            } else {
                let old = std::mem::replace(&mut self.annotation, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for Exclusive_Literal
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Exclusive_Literal(*mut_me), parent, 2163968, i, j) { return };
    }
        
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).annotation /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Exclusive_Literal(*mut_me_b), 0, 0);
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 2163968;
}

fn GetType(&self) -> u32 {
    return 2163968;
}
}




#[derive(Debug, Clone)]
pub struct Literal {
    pub val:String /* STRING */,
pub annotation:Option<Box<Reference>> /* Reference */,
pub tok:Token /* TOKEN */,
pub IS_OPTIONAL:f64 /* F64 */,
pub IS_NON_CAPTURE:bool /* BOOL */
}

impl Literal {
fn new( _val:String, _annotation:Option<Box<Reference>>, _tok:Token, _IS_OPTIONAL:f64, _IS_NON_CAPTURE:bool) -> Box<Self> {
    Box::new(Literal{
        val : _val,
        annotation : _annotation,
        tok : _tok,
        IS_OPTIONAL : _IS_OPTIONAL,
        IS_NON_CAPTURE : _IS_NON_CAPTURE,
    })
}




fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.annotation.is_some() {
                let old = std::mem::replace(&mut self.annotation, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }

        ASTNode::Reference(child) => {
            if self.annotation.is_none() {
                self.annotation = Some(child);
            } else {
                let old = std::mem::replace(&mut self.annotation, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for Literal
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Literal(*mut_me), parent, 2229504, i, j) { return };
    }
        
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).annotation /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Literal(*mut_me_b), 0, 0);
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 2229504;
}

fn GetType(&self) -> u32 {
    return 2229504;
}
}




#[derive(Debug, Clone)]
pub struct End_Of_File {
    pub val:String /* STRING */,
pub annotation:Option<Box<Reference>> /* Reference */,
pub tok:Token /* TOKEN */,
pub IS_OPTIONAL:f64 /* F64 */,
pub IS_NON_CAPTURE:bool /* BOOL */
}

impl End_Of_File {
fn new( _val:String, _annotation:Option<Box<Reference>>, _tok:Token, _IS_OPTIONAL:f64, _IS_NON_CAPTURE:bool) -> Box<Self> {
    Box::new(End_Of_File{
        val : _val,
        annotation : _annotation,
        tok : _tok,
        IS_OPTIONAL : _IS_OPTIONAL,
        IS_NON_CAPTURE : _IS_NON_CAPTURE,
    })
}




fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.annotation.is_some() {
                let old = std::mem::replace(&mut self.annotation, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }

        ASTNode::Reference(child) => {
            if self.annotation.is_none() {
                self.annotation = Some(child);
            } else {
                let old = std::mem::replace(&mut self.annotation, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for End_Of_File
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::End_Of_File(*mut_me), parent, 2295040, i, j) { return };
    }
        
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).annotation /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::End_Of_File(*mut_me_b), 0, 0);
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 2295040;
}

fn GetType(&self) -> u32 {
    return 2295040;
}
}




#[derive(Debug, Clone)]
pub struct Space {
    pub position:i16 /* I16 */,
pub IS_OPTIONAL:f64 /* F64 */,
pub IS_NON_CAPTURE:bool /* BOOL */,
pub annotation:Box<Reference> /* Reference */
}

impl Space {
fn new( _position:i16, _IS_OPTIONAL:f64, _IS_NON_CAPTURE:bool, _annotation:Box<Reference>) -> Box<Self> {
    Box::new(Space{
        position : _position,
        IS_OPTIONAL : _IS_OPTIONAL,
        IS_NON_CAPTURE : _IS_NON_CAPTURE,
        annotation : _annotation,
    })
}




fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    if let ASTNode::Reference(child) = child {
        return Some(ASTNode::Reference(std::mem::replace(&mut self.annotation, child)))
    }else {
        return None
    }
    
}
}



impl<'a> ASTNodeTraits<'a> for Space
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Space(*mut_me), parent, 2365440, i, j) { return };
    }
        
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).annotation).Iterate( _yield, &mut NodeIteration::Space(*mut_me_b), 0, 0);
            
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 2365440;
}

fn GetType(&self) -> u32 {
    return 2365440;
}
}




#[derive(Debug, Clone)]
pub struct NewLine {
    pub position:i16 /* I16 */,
pub IS_OPTIONAL:f64 /* F64 */,
pub IS_NON_CAPTURE:bool /* BOOL */,
pub annotation:Box<Reference> /* Reference */
}

impl NewLine {
fn new( _position:i16, _IS_OPTIONAL:f64, _IS_NON_CAPTURE:bool, _annotation:Box<Reference>) -> Box<Self> {
    Box::new(NewLine{
        position : _position,
        IS_OPTIONAL : _IS_OPTIONAL,
        IS_NON_CAPTURE : _IS_NON_CAPTURE,
        annotation : _annotation,
    })
}




fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    if let ASTNode::Reference(child) = child {
        return Some(ASTNode::Reference(std::mem::replace(&mut self.annotation, child)))
    }else {
        return None
    }
    
}
}



impl<'a> ASTNodeTraits<'a> for NewLine
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::NewLine(*mut_me), parent, 2430976, i, j) { return };
    }
        
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).annotation).Iterate( _yield, &mut NodeIteration::NewLine(*mut_me_b), 0, 0);
            
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 2430976;
}

fn GetType(&self) -> u32 {
    return 2430976;
}
}




#[derive(Debug, Clone)]
pub struct IncreaseIndent {
    pub position:i16 /* I16 */,
pub IS_OPTIONAL:f64 /* F64 */,
pub IS_NON_CAPTURE:bool /* BOOL */,
pub annotation:Box<Reference> /* Reference */
}

impl IncreaseIndent {
fn new( _position:i16, _IS_OPTIONAL:f64, _IS_NON_CAPTURE:bool, _annotation:Box<Reference>) -> Box<Self> {
    Box::new(IncreaseIndent{
        position : _position,
        IS_OPTIONAL : _IS_OPTIONAL,
        IS_NON_CAPTURE : _IS_NON_CAPTURE,
        annotation : _annotation,
    })
}




fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    if let ASTNode::Reference(child) = child {
        return Some(ASTNode::Reference(std::mem::replace(&mut self.annotation, child)))
    }else {
        return None
    }
    
}
}



impl<'a> ASTNodeTraits<'a> for IncreaseIndent
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::IncreaseIndent(*mut_me), parent, 2496512, i, j) { return };
    }
        
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).annotation).Iterate( _yield, &mut NodeIteration::IncreaseIndent(*mut_me_b), 0, 0);
            
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 2496512;
}

fn GetType(&self) -> u32 {
    return 2496512;
}
}




#[derive(Debug, Clone)]
pub struct DecreaseIndent {
    pub position:i16 /* I16 */,
pub IS_OPTIONAL:f64 /* F64 */,
pub IS_NON_CAPTURE:bool /* BOOL */,
pub annotation:Box<Reference> /* Reference */
}

impl DecreaseIndent {
fn new( _position:i16, _IS_OPTIONAL:f64, _IS_NON_CAPTURE:bool, _annotation:Box<Reference>) -> Box<Self> {
    Box::new(DecreaseIndent{
        position : _position,
        IS_OPTIONAL : _IS_OPTIONAL,
        IS_NON_CAPTURE : _IS_NON_CAPTURE,
        annotation : _annotation,
    })
}




fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    if let ASTNode::Reference(child) = child {
        return Some(ASTNode::Reference(std::mem::replace(&mut self.annotation, child)))
    }else {
        return None
    }
    
}
}



impl<'a> ASTNodeTraits<'a> for DecreaseIndent
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::DecreaseIndent(*mut_me), parent, 2562048, i, j) { return };
    }
        
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).annotation).Iterate( _yield, &mut NodeIteration::DecreaseIndent(*mut_me_b), 0, 0);
            
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 2562048;
}

fn GetType(&self) -> u32 {
    return 2562048;
}
}




#[derive(Debug, Clone)]
pub struct Production_Token {
    pub name:String /* STRING */,
pub production:ASTNode /* Production_Symbol | Production_Import_Symbol */,
pub val:f64 /* F64 */,
pub annotation:Option<Box<Reference>> /* Reference */,
pub tok:Token /* TOKEN */,
pub IS_OPTIONAL:f64 /* F64 */,
pub IS_NON_CAPTURE:bool /* BOOL */
}

impl Production_Token {
fn new( _name:String, _production:ASTNode, _val:f64, _annotation:Option<Box<Reference>>, _tok:Token, _IS_OPTIONAL:f64, _IS_NON_CAPTURE:bool) -> Box<Self> {
    Box::new(Production_Token{
        name : _name,
        production : _production,
        val : _val,
        annotation : _annotation,
        tok : _tok,
        IS_OPTIONAL : _IS_OPTIONAL,
        IS_NON_CAPTURE : _IS_NON_CAPTURE,
    })
}




fn  replace_production(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.production, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Production_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.production, child));
        },

        ASTNode::Production_Import_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.production, child));
        }
        _ => None
        
    }
}

fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.annotation.is_some() {
                let old = std::mem::replace(&mut self.annotation, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }

        ASTNode::Reference(child) => {
            if self.annotation.is_none() {
                self.annotation = Some(child);
            } else {
                let old = std::mem::replace(&mut self.annotation, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for Production_Token
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Production_Token(*mut_me), parent, 2622720, i, j) { return };
    }
        
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).production).Iterate( _yield, &mut NodeIteration::Production_Token(*mut_me_b), 0, 0);
            
        }
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).annotation /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Production_Token(*mut_me_b), 1, 0);
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_production(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    1 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 2622720;
}

fn GetType(&self) -> u32 {
    return 2622720;
}
}




#[derive(Debug, Clone)]
pub struct Goto {
    pub state:ASTNode /* Production_Symbol | Production_Import_Symbol | HASH_NAME */
}

impl Goto {
fn new( _state:ASTNode) -> Box<Self> {
    Box::new(Goto{
        state : _state,
    })
}




fn  replace_state(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.state, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Production_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.state, child));
        },

        ASTNode::Production_Import_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.state, child));
        },

        ASTNode::HASH_NAME(_) => { 
            return Some(std::mem::replace(&mut self.state, child));
        }
        _ => None
        
    }
}
}



impl<'a> ASTNodeTraits<'a> for Goto
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Goto(*mut_me), parent, 2687016, i, j) { return };
    }
        
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).state).Iterate( _yield, &mut NodeIteration::Goto(*mut_me_b), 0, 0);
            
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_state(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 2687016;
}

fn GetType(&self) -> u32 {
    return 2687016;
}
}




#[derive(Debug, Clone)]
pub struct FailState {
    pub id:String /* STRING */,
pub instructions:Vec<ASTNode> /* VECTOR */,
pub symbol_meta:Option<Box<Symbols>> /* Symbols */,
pub fail:Option<Box<FailState>> /* FailState */
}

impl FailState {
fn new( _id:String, _instructions:Vec<ASTNode>, _symbol_meta:Option<Box<Symbols>>, _fail:Option<Box<FailState>>) -> Box<Self> {
    Box::new(FailState{
        id : _id,
        instructions : _instructions,
        symbol_meta : _symbol_meta,
        fail : _fail,
    })
}




fn  replace_instructions(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::ASSERT(_)|ASTNode::PEEK(_)|ASTNode::Repeat(_)|ASTNode::Reduce(_)|ASTNode::TokenAssign(_)|ASTNode::SetProd(_)|ASTNode::ForkTo(_)|ASTNode::ScanUntil(_)|ASTNode::TokenId(_)|ASTNode::Pass(_)|ASTNode::Fail(_)|ASTNode::NotInScope(_)|ASTNode::SetScope(_)|ASTNode::Consume(_)|ASTNode::Goto(_)|ASTNode::Lazy(_) => {
            if index as usize >= self.instructions.len() {
                self.instructions.push(child);
                None
            }else {
                self.instructions.push(child);
                let node = self.instructions.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.instructions.len() {
                let node = self.instructions.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_symbol_meta(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.symbol_meta.is_some() {
                let old = std::mem::replace(&mut self.symbol_meta, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Symbols(old_node));
                }
            }
        }

        ASTNode::Symbols(child) => {
            if self.symbol_meta.is_none() {
                self.symbol_meta = Some(child);
            } else {
                let old = std::mem::replace(&mut self.symbol_meta, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Symbols(old_node));
                }
            }
        }
        _ => {}
    }
    None
}

fn  replace_fail(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.fail.is_some() {
                let old = std::mem::replace(&mut self.fail, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::FailState(old_node));
                }
            }
        }

        ASTNode::FailState(child) => {
            if self.fail.is_none() {
                self.fail = Some(child);
            } else {
                let old = std::mem::replace(&mut self.fail, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::FailState(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for FailState
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::FailState(*mut_me), parent, 2760712, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).instructions.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).instructions[j];

                match child {
                    
                        ASTNode::ASSERT(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::PEEK(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Repeat(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Reduce(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::TokenAssign(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::SetProd(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::ForkTo(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::ScanUntil(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::TokenId(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Pass(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Fail(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::NotInScope(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::SetScope(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Consume(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Goto(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Lazy(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).symbol_meta /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::FailState(*mut_me_b), 1, 0);
            }
        }
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).fail /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::FailState(*mut_me_b), 2, 0);
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_instructions(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    1 => {
                    
        if let Some(old) = self.replace_symbol_meta(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    2 => {
                    
        if let Some(old) = self.replace_fail(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 2760712;
}

fn GetType(&self) -> u32 {
    return 2760712;
}
}




#[derive(Debug, Clone)]
pub struct Symbols {
    pub expected:Vec<ASTNode> /* VECTOR */,
pub skipped:Vec<ASTNode> /* VECTOR */
}

impl Symbols {
fn new( _expected:Vec<ASTNode>, _skipped:Vec<ASTNode>) -> Box<Self> {
    Box::new(Symbols{
        expected : _expected,
        skipped : _skipped,
    })
}




fn  replace_expected(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Generated(_)|ASTNode::Exclusive_Literal(_)|ASTNode::Literal(_)|ASTNode::End_Of_File(_)|ASTNode::Space(_)|ASTNode::NewLine(_)|ASTNode::IncreaseIndent(_)|ASTNode::DecreaseIndent(_)|ASTNode::Production_Token(_)|ASTNode::Num(_) => {
            if index as usize >= self.expected.len() {
                self.expected.push(child);
                None
            }else {
                self.expected.push(child);
                let node = self.expected.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.expected.len() {
                let node = self.expected.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_skipped(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Generated(_)|ASTNode::Exclusive_Literal(_)|ASTNode::Literal(_)|ASTNode::End_Of_File(_)|ASTNode::Space(_)|ASTNode::NewLine(_)|ASTNode::IncreaseIndent(_)|ASTNode::DecreaseIndent(_)|ASTNode::Production_Token(_)|ASTNode::Num(_) => {
            if index as usize >= self.skipped.len() {
                self.skipped.push(child);
                None
            }else {
                self.skipped.push(child);
                let node = self.skipped.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.skipped.len() {
                let node = self.skipped.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}
}



impl<'a> ASTNodeTraits<'a> for Symbols
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Symbols(*mut_me), parent, 2818056, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).expected.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).expected[j];

                match child {
                    
                        ASTNode::Generated(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Exclusive_Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::End_Of_File(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Space(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::NewLine(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::IncreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::DecreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Production_Token(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Num(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 0, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).skipped.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).skipped[j];

                match child {
                    
                        ASTNode::Generated(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Exclusive_Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::End_Of_File(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Space(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::NewLine(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::IncreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::DecreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Production_Token(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::Num(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 1, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_expected(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    1 => {
                    
        if let Some(old) = self.replace_skipped(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 2818056;
}

fn GetType(&self) -> u32 {
    return 2818056;
}
}




#[derive(Debug, Clone)]
pub struct Not_Symbol {
    pub val:String /* STRING */,
pub symbol:ASTNode /* Exclusive_Literal | Literal */,
pub tok:Token /* TOKEN */,
pub IS_OPTIONAL:f64 /* F64 */,
pub IS_NON_CAPTURE:bool /* BOOL */,
pub annotation:Box<Reference> /* Reference */
}

impl Not_Symbol {
fn new( _val:String, _symbol:ASTNode, _tok:Token, _IS_OPTIONAL:f64, _IS_NON_CAPTURE:bool, _annotation:Box<Reference>) -> Box<Self> {
    Box::new(Not_Symbol{
        val : _val,
        symbol : _symbol,
        tok : _tok,
        IS_OPTIONAL : _IS_OPTIONAL,
        IS_NON_CAPTURE : _IS_NON_CAPTURE,
        annotation : _annotation,
    })
}




fn  replace_symbol(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.symbol, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Exclusive_Literal(_) => { 
            return Some(std::mem::replace(&mut self.symbol, child));
        },

        ASTNode::Literal(_) => { 
            return Some(std::mem::replace(&mut self.symbol, child));
        }
        _ => None
        
    }
}

fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    if let ASTNode::Reference(child) = child {
        return Some(ASTNode::Reference(std::mem::replace(&mut self.annotation, child)))
    }else {
        return None
    }
    
}
}



impl<'a> ASTNodeTraits<'a> for Not_Symbol
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Not_Symbol(*mut_me), parent, 2883840, i, j) { return };
    }
        
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).symbol).Iterate( _yield, &mut NodeIteration::Not_Symbol(*mut_me_b), 0, 0);
            
        }
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).annotation).Iterate( _yield, &mut NodeIteration::Not_Symbol(*mut_me_b), 1, 0);
            
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_symbol(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    1 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 2883840;
}

fn GetType(&self) -> u32 {
    return 2883840;
}
}




#[derive(Debug, Clone)]
pub struct Look_Behind {
    pub val:(String | String | f64) /* STRING | STRING | F64 */,
pub symbol:ASTNode /* Generated | Exclusive_Literal | Literal | End_Of_File | Space | NewLine | IncreaseIndent | DecreaseIndent | Production_Token */,
pub tok:Token /* TOKEN */,
pub IS_OPTIONAL:f64 /* F64 */,
pub IS_NON_CAPTURE:bool /* BOOL */,
pub annotation:Box<Reference> /* Reference */
}

impl Look_Behind {
fn new( _val:(String | String | f64), _symbol:ASTNode, _tok:Token, _IS_OPTIONAL:f64, _IS_NON_CAPTURE:bool, _annotation:Box<Reference>) -> Box<Self> {
    Box::new(Look_Behind{
        val : _val,
        symbol : _symbol,
        tok : _tok,
        IS_OPTIONAL : _IS_OPTIONAL,
        IS_NON_CAPTURE : _IS_NON_CAPTURE,
        annotation : _annotation,
    })
}




fn  replace_symbol(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.symbol, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Generated(_) => { 
            return Some(std::mem::replace(&mut self.symbol, child));
        },

        ASTNode::Exclusive_Literal(_) => { 
            return Some(std::mem::replace(&mut self.symbol, child));
        },

        ASTNode::Literal(_) => { 
            return Some(std::mem::replace(&mut self.symbol, child));
        },

        ASTNode::End_Of_File(_) => { 
            return Some(std::mem::replace(&mut self.symbol, child));
        },

        ASTNode::Space(_) => { 
            return Some(std::mem::replace(&mut self.symbol, child));
        },

        ASTNode::NewLine(_) => { 
            return Some(std::mem::replace(&mut self.symbol, child));
        },

        ASTNode::IncreaseIndent(_) => { 
            return Some(std::mem::replace(&mut self.symbol, child));
        },

        ASTNode::DecreaseIndent(_) => { 
            return Some(std::mem::replace(&mut self.symbol, child));
        },

        ASTNode::Production_Token(_) => { 
            return Some(std::mem::replace(&mut self.symbol, child));
        }
        _ => None
        
    }
}

fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    if let ASTNode::Reference(child) = child {
        return Some(ASTNode::Reference(std::mem::replace(&mut self.annotation, child)))
    }else {
        return None
    }
    
}
}



impl<'a> ASTNodeTraits<'a> for Look_Behind
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Look_Behind(*mut_me), parent, 2949376, i, j) { return };
    }
        
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).symbol).Iterate( _yield, &mut NodeIteration::Look_Behind(*mut_me_b), 0, 0);
            
        }
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).annotation).Iterate( _yield, &mut NodeIteration::Look_Behind(*mut_me_b), 1, 0);
            
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_symbol(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    1 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 2949376;
}

fn GetType(&self) -> u32 {
    return 2949376;
}
}




#[derive(Debug, Clone)]
pub struct List_Production {
    pub terminal_symbol:ASTNode /* Generated | Exclusive_Literal | Literal | End_Of_File | Space | NewLine | IncreaseIndent | DecreaseIndent | Production_Token */,
pub IS_OPTIONAL:f64 /* F64 | F64 */,
pub symbols:ASTNode /* Not_Symbol | Look_Behind | List_Production | Generated | Exclusive_Literal | Literal | End_Of_File | Space | NewLine | IncreaseIndent | DecreaseIndent | Production_Token | Group_Production | Production_Symbol | Production_Import_Symbol */,
pub annotation:Option<Box<Reference>> /* Reference */,
pub tok:Token /* TOKEN */,
pub IS_NON_CAPTURE:bool /* BOOL */
}

impl List_Production {
fn new( _terminal_symbol:ASTNode, _IS_OPTIONAL:f64, _symbols:ASTNode, _annotation:Option<Box<Reference>>, _tok:Token, _IS_NON_CAPTURE:bool) -> Box<Self> {
    Box::new(List_Production{
        terminal_symbol : _terminal_symbol,
        IS_OPTIONAL : _IS_OPTIONAL,
        symbols : _symbols,
        annotation : _annotation,
        tok : _tok,
        IS_NON_CAPTURE : _IS_NON_CAPTURE,
    })
}




fn  replace_terminal_symbol(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.terminal_symbol, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Generated(_) => { 
            return Some(std::mem::replace(&mut self.terminal_symbol, child));
        },

        ASTNode::Exclusive_Literal(_) => { 
            return Some(std::mem::replace(&mut self.terminal_symbol, child));
        },

        ASTNode::Literal(_) => { 
            return Some(std::mem::replace(&mut self.terminal_symbol, child));
        },

        ASTNode::End_Of_File(_) => { 
            return Some(std::mem::replace(&mut self.terminal_symbol, child));
        },

        ASTNode::Space(_) => { 
            return Some(std::mem::replace(&mut self.terminal_symbol, child));
        },

        ASTNode::NewLine(_) => { 
            return Some(std::mem::replace(&mut self.terminal_symbol, child));
        },

        ASTNode::IncreaseIndent(_) => { 
            return Some(std::mem::replace(&mut self.terminal_symbol, child));
        },

        ASTNode::DecreaseIndent(_) => { 
            return Some(std::mem::replace(&mut self.terminal_symbol, child));
        },

        ASTNode::Production_Token(_) => { 
            return Some(std::mem::replace(&mut self.terminal_symbol, child));
        }
        _ => None
        
    }
}

fn  replace_symbols(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.symbols, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Not_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.symbols, child));
        },

        ASTNode::Look_Behind(_) => { 
            return Some(std::mem::replace(&mut self.symbols, child));
        },

        ASTNode::List_Production(_) => { 
            return Some(std::mem::replace(&mut self.symbols, child));
        },

        ASTNode::Generated(_) => { 
            return Some(std::mem::replace(&mut self.symbols, child));
        },

        ASTNode::Exclusive_Literal(_) => { 
            return Some(std::mem::replace(&mut self.symbols, child));
        },

        ASTNode::Literal(_) => { 
            return Some(std::mem::replace(&mut self.symbols, child));
        },

        ASTNode::End_Of_File(_) => { 
            return Some(std::mem::replace(&mut self.symbols, child));
        },

        ASTNode::Space(_) => { 
            return Some(std::mem::replace(&mut self.symbols, child));
        },

        ASTNode::NewLine(_) => { 
            return Some(std::mem::replace(&mut self.symbols, child));
        },

        ASTNode::IncreaseIndent(_) => { 
            return Some(std::mem::replace(&mut self.symbols, child));
        },

        ASTNode::DecreaseIndent(_) => { 
            return Some(std::mem::replace(&mut self.symbols, child));
        },

        ASTNode::Production_Token(_) => { 
            return Some(std::mem::replace(&mut self.symbols, child));
        },

        ASTNode::Group_Production(_) => { 
            return Some(std::mem::replace(&mut self.symbols, child));
        },

        ASTNode::Production_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.symbols, child));
        },

        ASTNode::Production_Import_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.symbols, child));
        }
        _ => None
        
    }
}

fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.annotation.is_some() {
                let old = std::mem::replace(&mut self.annotation, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }

        ASTNode::Reference(child) => {
            if self.annotation.is_none() {
                self.annotation = Some(child);
            } else {
                let old = std::mem::replace(&mut self.annotation, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for List_Production
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::List_Production(*mut_me), parent, 3014912, i, j) { return };
    }
        
    
        unsafe {
            let reference = node.get();
            if let child = &mut (*reference).terminal_symbol /* HAS_NULL:true */{
                 
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::List_Production(*mut_me_b), 0, 0);
    
            }
        }
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).symbols).Iterate( _yield, &mut NodeIteration::List_Production(*mut_me_b), 1, 0);
            
        }
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).annotation /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::List_Production(*mut_me_b), 2, 0);
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_terminal_symbol(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    1 => {
                    
        if let Some(old) = self.replace_symbols(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    2 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 3014912;
}

fn GetType(&self) -> u32 {
    return 3014912;
}
}




#[derive(Debug, Clone)]
pub struct Group_Production {
    pub bodies:Vec<ASTNode> /* VECTOR */,
pub annotation:Option<Box<Reference>> /* Reference */,
pub tok:Token /* TOKEN */,
pub IS_OPTIONAL:f64 /* F64 */,
pub IS_NON_CAPTURE:bool /* BOOL */
}

impl Group_Production {
fn new( _bodies:Vec<ASTNode>, _annotation:Option<Box<Reference>>, _tok:Token, _IS_OPTIONAL:f64, _IS_NON_CAPTURE:bool) -> Box<Self> {
    Box::new(Group_Production{
        bodies : _bodies,
        annotation : _annotation,
        tok : _tok,
        IS_OPTIONAL : _IS_OPTIONAL,
        IS_NON_CAPTURE : _IS_NON_CAPTURE,
    })
}




fn  replace_bodies(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Body(_) => {
            if index as usize >= self.bodies.len() {
                self.bodies.push(child);
                None
            }else {
                self.bodies.push(child);
                let node = self.bodies.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.bodies.len() {
                let node = self.bodies.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.annotation.is_some() {
                let old = std::mem::replace(&mut self.annotation, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }

        ASTNode::Reference(child) => {
            if self.annotation.is_none() {
                self.annotation = Some(child);
            } else {
                let old = std::mem::replace(&mut self.annotation, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for Group_Production
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Group_Production(*mut_me), parent, 3080448, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).bodies.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).bodies[j];

                
                if let ASTNode::Body(child) = child {
                    unsafe { 
                        let mut_me = node.get();
                        child.Iterate(_yield, &mut NodeIteration::Group_Production(*mut_me), 0, j as i32)   
                    };
                }
            }
        }
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).annotation /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Group_Production(*mut_me_b), 1, 0);
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_bodies(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    1 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 3080448;
}

fn GetType(&self) -> u32 {
    return 3080448;
}
}




#[derive(Debug, Clone)]
pub struct Body {
    pub priority:f64 /* F64 | F64 */,
pub symbols:Vec<ASTNode> /* VECTOR */,
pub reference:Option<Box<Reference>> /* Reference */,
pub reduce_function:ASTNode /* Returned | Referenced */,
pub FORCE_FORK:bool /* BOOL */,
pub id:f64 /* F64 */,
pub production:Option<Box<Production>> /* Production */
}

impl Body {
fn new( _priority:f64, _symbols:Vec<ASTNode>, _reference:Option<Box<Reference>>, _reduce_function:ASTNode, _FORCE_FORK:bool, _id:f64, _production:Option<Box<Production>>) -> Box<Self> {
    Box::new(Body{
        priority : _priority,
        symbols : _symbols,
        reference : _reference,
        reduce_function : _reduce_function,
        FORCE_FORK : _FORCE_FORK,
        id : _id,
        production : _production,
    })
}




fn  replace_symbols(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Not_Symbol(_)|ASTNode::Look_Behind(_)|ASTNode::List_Production(_)|ASTNode::Generated(_)|ASTNode::Exclusive_Literal(_)|ASTNode::Literal(_)|ASTNode::End_Of_File(_)|ASTNode::Space(_)|ASTNode::NewLine(_)|ASTNode::IncreaseIndent(_)|ASTNode::DecreaseIndent(_)|ASTNode::Production_Token(_)|ASTNode::Group_Production(_)|ASTNode::Production_Symbol(_)|ASTNode::Production_Import_Symbol(_)|ASTNode::Exclude(_)|ASTNode::Look_Ignore(_) => {
            if index as usize >= self.symbols.len() {
                self.symbols.push(child);
                None
            }else {
                self.symbols.push(child);
                let node = self.symbols.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.symbols.len() {
                let node = self.symbols.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_reference(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.reference.is_some() {
                let old = std::mem::replace(&mut self.reference, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }

        ASTNode::Reference(child) => {
            if self.reference.is_none() {
                self.reference = Some(child);
            } else {
                let old = std::mem::replace(&mut self.reference, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }
        _ => {}
    }
    None
}

fn  replace_reduce_function(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.reduce_function, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Returned(_) => { 
            return Some(std::mem::replace(&mut self.reduce_function, child));
        },

        ASTNode::Referenced(_) => { 
            return Some(std::mem::replace(&mut self.reduce_function, child));
        }
        _ => None
        
    }
}

fn  replace_production(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.production.is_some() {
                let old = std::mem::replace(&mut self.production, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Production(old_node));
                }
            }
        }

        ASTNode::Production(child) => {
            if self.production.is_none() {
                self.production = Some(child);
            } else {
                let old = std::mem::replace(&mut self.production, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Production(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for Body
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Body(*mut_me), parent, 3162112, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).symbols.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).symbols[j];

                match child {
                    
                        ASTNode::Not_Symbol(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Look_Behind(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::List_Production(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Generated(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Exclusive_Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::End_Of_File(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Space(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::NewLine(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::IncreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::DecreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Production_Token(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Group_Production(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Production_Symbol(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Production_Import_Symbol(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Exclude(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Look_Ignore(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).reference /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Body(*mut_me_b), 1, 0);
            }
        }
    
        unsafe {
            let reference = node.get();
            if let child = &mut (*reference).reduce_function /* HAS_NULL:true */{
                 
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Body(*mut_me_b), 2, 0);
    
            }
        }
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).production /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Body(*mut_me_b), 3, 0);
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_symbols(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    1 => {
                    
        if let Some(old) = self.replace_reference(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    2 => {
                    
        if let Some(old) = self.replace_reduce_function(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    3 => {
                    
        if let Some(old) = self.replace_production(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 3162112;
}

fn GetType(&self) -> u32 {
    return 3162112;
}
}




#[derive(Debug, Clone)]
pub struct Exclude {
    pub sym:Vec<ASTNode> /* VECTOR */,
pub index:f64 /* F64 */,
pub annotation:Option<Box<Reference>> /* Reference */,
pub tok:Token /* TOKEN */
}

impl Exclude {
fn new( _sym:Vec<ASTNode>, _index:f64, _annotation:Option<Box<Reference>>, _tok:Token) -> Box<Self> {
    Box::new(Exclude{
        sym : _sym,
        index : _index,
        annotation : _annotation,
        tok : _tok,
    })
}




fn  replace_sym(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Generated(_)|ASTNode::Exclusive_Literal(_)|ASTNode::Literal(_)|ASTNode::End_Of_File(_)|ASTNode::Space(_)|ASTNode::NewLine(_)|ASTNode::IncreaseIndent(_)|ASTNode::DecreaseIndent(_)|ASTNode::Production_Token(_) => {
            if index as usize >= self.sym.len() {
                self.sym.push(child);
                None
            }else {
                self.sym.push(child);
                let node = self.sym.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.sym.len() {
                let node = self.sym.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.annotation.is_some() {
                let old = std::mem::replace(&mut self.annotation, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }

        ASTNode::Reference(child) => {
            if self.annotation.is_none() {
                self.annotation = Some(child);
            } else {
                let old = std::mem::replace(&mut self.annotation, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for Exclude
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Exclude(*mut_me), parent, 3213568, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).sym.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).sym[j];

                match child {
                    
                        ASTNode::Generated(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Exclusive_Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::End_Of_File(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Space(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::NewLine(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::IncreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::DecreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Production_Token(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).annotation /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Exclude(*mut_me_b), 1, 0);
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_sym(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    1 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 3213568;
}

fn GetType(&self) -> u32 {
    return 3213568;
}
}




#[derive(Debug, Clone)]
pub struct Look_Ignore {
    pub sym:Vec<ASTNode> /* VECTOR */,
pub index:f64 /* F64 */,
pub annotation:Option<Box<Reference>> /* Reference */,
pub tok:Token /* TOKEN */
}

impl Look_Ignore {
fn new( _sym:Vec<ASTNode>, _index:f64, _annotation:Option<Box<Reference>>, _tok:Token) -> Box<Self> {
    Box::new(Look_Ignore{
        sym : _sym,
        index : _index,
        annotation : _annotation,
        tok : _tok,
    })
}




fn  replace_sym(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Generated(_)|ASTNode::Exclusive_Literal(_)|ASTNode::Literal(_)|ASTNode::End_Of_File(_)|ASTNode::Space(_)|ASTNode::NewLine(_)|ASTNode::IncreaseIndent(_)|ASTNode::DecreaseIndent(_)|ASTNode::Production_Token(_) => {
            if index as usize >= self.sym.len() {
                self.sym.push(child);
                None
            }else {
                self.sym.push(child);
                let node = self.sym.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.sym.len() {
                let node = self.sym.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.annotation.is_some() {
                let old = std::mem::replace(&mut self.annotation, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }

        ASTNode::Reference(child) => {
            if self.annotation.is_none() {
                self.annotation = Some(child);
            } else {
                let old = std::mem::replace(&mut self.annotation, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for Look_Ignore
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Look_Ignore(*mut_me), parent, 3279104, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).sym.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).sym[j];

                match child {
                    
                        ASTNode::Generated(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Exclusive_Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::End_Of_File(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Space(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::NewLine(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::IncreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::DecreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Production_Token(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).annotation /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Look_Ignore(*mut_me_b), 1, 0);
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_sym(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    1 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 3279104;
}

fn GetType(&self) -> u32 {
    return 3279104;
}
}




#[derive(Debug, Clone)]
pub struct Empty {
    pub val:String /* STRING */,
pub annotation:Option<Box<Reference>> /* Reference */,
pub tok:Token /* TOKEN */
}

impl Empty {
fn new( _val:String, _annotation:Option<Box<Reference>>, _tok:Token) -> Box<Self> {
    Box::new(Empty{
        val : _val,
        annotation : _annotation,
        tok : _tok,
    })
}




fn  replace_annotation(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.annotation.is_some() {
                let old = std::mem::replace(&mut self.annotation, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }

        ASTNode::Reference(child) => {
            if self.annotation.is_none() {
                self.annotation = Some(child);
            } else {
                let old = std::mem::replace(&mut self.annotation, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for Empty
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Empty(*mut_me), parent, 3342592, i, j) { return };
    }
        
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).annotation /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Empty(*mut_me_b), 0, 0);
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_annotation(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 3342592;
}

fn GetType(&self) -> u32 {
    return 3342592;
}
}




#[derive(Debug, Clone)]
pub struct Production {
    pub priority:f64 /* F64 | F64 */,
pub symbol:ASTNode /* Production_Symbol | Production_Import_Symbol */,
pub bodies:Vec<ASTNode> /* VECTOR */,
pub id:f64 /* F64 */,
pub LAZY:bool /* BOOL */,
pub entry_name:String /* STRING */
}

impl Production {
fn new( _priority:f64, _symbol:ASTNode, _bodies:Vec<ASTNode>, _id:f64, _LAZY:bool, _entry_name:String) -> Box<Self> {
    Box::new(Production{
        priority : _priority,
        symbol : _symbol,
        bodies : _bodies,
        id : _id,
        LAZY : _LAZY,
        entry_name : _entry_name,
    })
}




fn  replace_symbol(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.symbol, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Production_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.symbol, child));
        },

        ASTNode::Production_Import_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.symbol, child));
        }
        _ => None
        
    }
}

fn  replace_bodies(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Body(_) => {
            if index as usize >= self.bodies.len() {
                self.bodies.push(child);
                None
            }else {
                self.bodies.push(child);
                let node = self.bodies.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.bodies.len() {
                let node = self.bodies.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}
}



impl<'a> ASTNodeTraits<'a> for Production
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Production(*mut_me), parent, 3424256, i, j) { return };
    }
        
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).symbol).Iterate( _yield, &mut NodeIteration::Production(*mut_me_b), 0, 0);
            
        }
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).bodies.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).bodies[j];

                
                if let ASTNode::Body(child) = child {
                    unsafe { 
                        let mut_me = node.get();
                        child.Iterate(_yield, &mut NodeIteration::Production(*mut_me), 1, j as i32)   
                    };
                }
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_symbol(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    1 => {
                    
        if let Some(old) = self.replace_bodies(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 3424256;
}

fn GetType(&self) -> u32 {
    return 3424256;
}
}




#[derive(Debug, Clone)]
pub struct ProductionMerged {
    pub symbol:ASTNode /* Production_Symbol | Production_Import_Symbol */,
pub bodies:Vec<ASTNode> /* VECTOR */,
pub id:f64 /* F64 */
}

impl ProductionMerged {
fn new( _symbol:ASTNode, _bodies:Vec<ASTNode>, _id:f64) -> Box<Self> {
    Box::new(ProductionMerged{
        symbol : _symbol,
        bodies : _bodies,
        id : _id,
    })
}




fn  replace_symbol(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.symbol, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Production_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.symbol, child));
        },

        ASTNode::Production_Import_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.symbol, child));
        }
        _ => None
        
    }
}

fn  replace_bodies(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Body(_) => {
            if index as usize >= self.bodies.len() {
                self.bodies.push(child);
                None
            }else {
                self.bodies.push(child);
                let node = self.bodies.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.bodies.len() {
                let node = self.bodies.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}
}



impl<'a> ASTNodeTraits<'a> for ProductionMerged
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::ProductionMerged(*mut_me), parent, 3489792, i, j) { return };
    }
        
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).symbol).Iterate( _yield, &mut NodeIteration::ProductionMerged(*mut_me_b), 0, 0);
            
        }
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).bodies.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).bodies[j];

                
                if let ASTNode::Body(child) = child {
                    unsafe { 
                        let mut_me = node.get();
                        child.Iterate(_yield, &mut NodeIteration::ProductionMerged(*mut_me), 1, j as i32)   
                    };
                }
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_symbol(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    1 => {
                    
        if let Some(old) = self.replace_bodies(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 3489792;
}

fn GetType(&self) -> u32 {
    return 3489792;
}
}




#[derive(Debug, Clone)]
pub struct Ignore {
    pub symbols:Vec<ASTNode> /* VECTOR */
}

impl Ignore {
fn new( _symbols:Vec<ASTNode>) -> Box<Self> {
    Box::new(Ignore{
        symbols : _symbols,
    })
}




fn  replace_symbols(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Generated(_)|ASTNode::Exclusive_Literal(_)|ASTNode::Literal(_)|ASTNode::End_Of_File(_)|ASTNode::Space(_)|ASTNode::NewLine(_)|ASTNode::IncreaseIndent(_)|ASTNode::DecreaseIndent(_)|ASTNode::Production_Token(_) => {
            if index as usize >= self.symbols.len() {
                self.symbols.push(child);
                None
            }else {
                self.symbols.push(child);
                let node = self.symbols.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.symbols.len() {
                let node = self.symbols.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}
}



impl<'a> ASTNodeTraits<'a> for Ignore
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Ignore(*mut_me), parent, 3571712, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).symbols.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).symbols[j];

                match child {
                    
                        ASTNode::Generated(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Exclusive_Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Literal(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::End_Of_File(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Space(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::NewLine(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::IncreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::DecreaseIndent(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)   
                            };
                        },

                        ASTNode::Production_Token(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_symbols(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 3571712;
}

fn GetType(&self) -> u32 {
    return 3571712;
}
}




#[derive(Debug, Clone)]
pub struct Import {
    pub uri:String /* STRING | STRING */,
pub reference:Token /* TOKEN */
}

impl Import {
fn new( _uri:String, _reference:Token) -> Box<Self> {
    Box::new(Import{
        uri : _uri,
        reference : _reference,
    })
}




}



impl<'a> ASTNodeTraits<'a> for Import
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Import(*mut_me), parent, 3637248, i, j) { return };
    }
        
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 3637248;
}

fn GetType(&self) -> u32 {
    return 3637248;
}
}




#[derive(Debug, Clone)]
pub struct Export {
    pub production:ASTNode /* Production_Symbol | Production_Import_Symbol */,
pub reference:Token /* TOKEN */
}

impl Export {
fn new( _production:ASTNode, _reference:Token) -> Box<Self> {
    Box::new(Export{
        production : _production,
        reference : _reference,
    })
}




fn  replace_production(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.production, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Production_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.production, child));
        },

        ASTNode::Production_Import_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.production, child));
        }
        _ => None
        
    }
}
}



impl<'a> ASTNodeTraits<'a> for Export
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Export(*mut_me), parent, 3702784, i, j) { return };
    }
        
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).production).Iterate( _yield, &mut NodeIteration::Export(*mut_me_b), 0, 0);
            
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_production(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 3702784;
}

fn GetType(&self) -> u32 {
    return 3702784;
}
}




#[derive(Debug, Clone)]
pub struct Productions {
    pub functions:Vec<ASTNode> /* VECTOR */,
pub productions:Vec<ASTNode> /* VECTOR */,
pub ir:Vec<ASTNode> /* VECTOR */,
pub tok:Token /* TOKEN */
}

impl Productions {
fn new( _functions:Vec<ASTNode>, _productions:Vec<ASTNode>, _ir:Vec<ASTNode>, _tok:Token) -> Box<Self> {
    Box::new(Productions{
        functions : _functions,
        productions : _productions,
        ir : _ir,
        tok : _tok,
    })
}




fn  replace_functions(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Out_Of_Band(_) => {
            if index as usize >= self.functions.len() {
                self.functions.push(child);
                None
            }else {
                self.functions.push(child);
                let node = self.functions.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.functions.len() {
                let node = self.functions.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_productions(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::Production(_)|ASTNode::ProductionMerged(_) => {
            if index as usize >= self.productions.len() {
                self.productions.push(child);
                None
            }else {
                self.productions.push(child);
                let node = self.productions.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.productions.len() {
                let node = self.productions.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_ir(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::IR_STATE(_) => {
            if index as usize >= self.ir.len() {
                self.ir.push(child);
                None
            }else {
                self.ir.push(child);
                let node = self.ir.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.ir.len() {
                let node = self.ir.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}
}



impl<'a> ASTNodeTraits<'a> for Productions
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Productions(*mut_me), parent, 3735552, i, j) { return };
    }
        
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).functions.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).functions[j];

                
                if let ASTNode::Out_Of_Band(child) = child {
                    unsafe { 
                        let mut_me = node.get();
                        child.Iterate(_yield, &mut NodeIteration::Productions(*mut_me), 0, j as i32)   
                    };
                }
            }
        }
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).productions.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).productions[j];

                match child {
                    
                        ASTNode::Production(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Productions(*mut_me), 1, j as i32)   
                            };
                        },

                        ASTNode::ProductionMerged(child) => { 
                            unsafe { 
                                let mut_me = node.get();
                                child.Iterate(_yield, &mut NodeIteration::Productions(*mut_me), 1, j as i32)   
                            };
                        }
                    _ => {}
                }
            }
        }
    
        unsafe {

            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).ir.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).ir[j];

                
                if let ASTNode::IR_STATE(child) = child {
                    unsafe { 
                        let mut_me = node.get();
                        child.Iterate(_yield, &mut NodeIteration::Productions(*mut_me), 2, j as i32)   
                    };
                }
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_functions(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    1 => {
                    
        if let Some(old) = self.replace_productions(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    2 => {
                    
        if let Some(old) = self.replace_ir(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 3735552;
}

fn GetType(&self) -> u32 {
    return 3735552;
}
}




#[derive(Debug, Clone)]
pub struct Out_Of_Band {
    pub reference:Option<Box<Reference>> /* Reference */,
pub txt:(Token | String) /* TOKEN | STRING */,
pub production:ASTNode /* Production_Symbol | Production_Import_Symbol */,
pub index:Token /* TOKEN */
}

impl Out_Of_Band {
fn new( _reference:Option<Box<Reference>>, _txt:(Token | String), _production:ASTNode, _index:Token) -> Box<Self> {
    Box::new(Out_Of_Band{
        reference : _reference,
        txt : _txt,
        production : _production,
        index : _index,
    })
}




fn  replace_reference(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.reference.is_some() {
                let old = std::mem::replace(&mut self.reference, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }

        ASTNode::Reference(child) => {
            if self.reference.is_none() {
                self.reference = Some(child);
            } else {
                let old = std::mem::replace(&mut self.reference, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::Reference(old_node));
                }
            }
        }
        _ => {}
    }
    None
}

fn  replace_production(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.production, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Production_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.production, child));
        },

        ASTNode::Production_Import_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.production, child));
        }
        _ => None
        
    }
}
}



impl<'a> ASTNodeTraits<'a> for Out_Of_Band
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Out_Of_Band(*mut_me), parent, 3801600, i, j) { return };
    }
        
    
        unsafe { 
            let reference = node.get();
            if let Some(child) = &mut ( *reference).reference /* HAS_NULL:true */{
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Out_Of_Band(*mut_me_b), 0, 0);
            }
        }
    
        unsafe {
            let reference = node.get();
            if let child = &mut (*reference).production /* HAS_NULL:true */{
                 
                let mut_me_b = node.get();
                child.Iterate( _yield, &mut NodeIteration::Out_Of_Band(*mut_me_b), 1, 0);
    
            }
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_reference(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    1 => {
                    
        if let Some(old) = self.replace_production(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 3801600;
}

fn GetType(&self) -> u32 {
    return 3801600;
}
}




#[derive(Debug, Clone)]
pub struct Repeat {
    
}

impl Repeat {
fn new( ) -> Box<Self> {
    Box::new(Repeat{
        
    })
}




}



impl<'a> ASTNodeTraits<'a> for Repeat
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Repeat(*mut_me), parent, 3866664, i, j) { return };
    }
        
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 3866664;
}

fn GetType(&self) -> u32 {
    return 3866664;
}
}




#[derive(Debug, Clone)]
pub struct Lazy {
    pub cp_start:Token /* TOKEN */,
pub cp_end:Token /* TOKEN */,
pub state:ASTNode /* Production_Symbol | Production_Import_Symbol | HASH_NAME */
}

impl Lazy {
fn new( _cp_start:Token, _cp_end:Token, _state:ASTNode) -> Box<Self> {
    Box::new(Lazy{
        cp_start : _cp_start,
        cp_end : _cp_end,
        state : _state,
    })
}




fn  replace_state(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.state, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::Production_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.state, child));
        },

        ASTNode::Production_Import_Symbol(_) => { 
            return Some(std::mem::replace(&mut self.state, child));
        },

        ASTNode::HASH_NAME(_) => { 
            return Some(std::mem::replace(&mut self.state, child));
        }
        _ => None
        
    }
}
}



impl<'a> ASTNodeTraits<'a> for Lazy
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Lazy(*mut_me), parent, 3932200, i, j) { return };
    }
        
    
        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).state).Iterate( _yield, &mut NodeIteration::Lazy(*mut_me_b), 0, 0);
            
        }
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_state(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 3932200;
}

fn GetType(&self) -> u32 {
    return 3932200;
}
}




#[derive(Debug, Clone)]
pub struct Num {
    pub val:(164 | i32) /* I64 | I32 */
}

impl Num {
fn new( _val:(164 | i32)) -> Box<Self> {
    Box::new(Num{
        val : _val,
    })
}




}



impl<'a> ASTNodeTraits<'a> for Num
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::Num(*mut_me), parent, 3997696, i, j) { return };
    }
        
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 3997696;
}

fn GetType(&self) -> u32 {
    return 3997696;
}
}




#[derive(Debug, Clone)]
pub struct HASH_NAME {
    pub val:String /* STRING */
}

impl HASH_NAME {
fn new( _val:String) -> Box<Self> {
    Box::new(HASH_NAME{
        val : _val,
    })
}




}



impl<'a> ASTNodeTraits<'a> for HASH_NAME
where
    Self: Sized,
{

fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    unsafe{
        let mut_me = node.get();

        if !_yield(&mut NodeIteration::HASH_NAME(*mut_me), parent, 4063232, i, j) { return };
    }
        
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    Token::empty()
    //return self.tok;
}

fn Type()-> u32{
    return 4063232;
}

fn GetType(&self) -> u32 {
    return 4063232;
}
}



/**
```
{ 

    t_Grammar,

    c_Grammar,

    c_Version_6,

    preamble:$1,

    productions:$2.productions,

    ir_states:$2.ir,

    functions:$2.functions,

    imported_grammars:[t_Grammar],

    meta:{ 

        t_Meta,

        all_symbols:[c_Symbol],

        ignore_symbols:[c_TokenSymbol]
     },

    bodies:[t_Body],

    tok
 }
```*/
fn _fn0 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::NODES(mut r_0) = v0 { 
 if let HCO::NODE(r_1) = v1 { 
 let r_0 = (r_1).(Box<Productions>);
 if let HCO::NODE(r_2) = v1 { 
 let r_1 = (r_2).(Box<Productions>);
 if let HCO::NODE(r_3) = v1 { 
 let r_2 = (r_3).(Box<Productions>);
 let mut ref_0:Vec<HCO> = Vec::new();
 let mut ref_1:Vec<HCO> = Vec::new();
 let mut ref_2:Vec<HCO> = Vec::new();
 let mut ref_3 = ASTNode::Meta(Meta::new(
        ref_1,
        ref_2,
    ) 
);;
 if let ASTNode::Meta(r_4) = ref_3 { 
 let mut ref_4:Vec<HCO> = Vec::new();
 let mut ref_5 = ASTNode::Grammar(Grammar::new(
        r_0,
        r_0.productions,
        r_1.ir,
        r_2.functions,
        ref_0,
        r_4,
        ref_4,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE(ref_5)) } } } } }}
/**
```
{ 

    t_Grammar,

    c_Grammar,

    c_Version_6,

    preamble:$NULL,

    productions:$1.productions,

    ir_states:$1.ir,

    functions:$1.functions,

    imported_grammars:[t_Grammar],

    meta:{ 

        t_Meta,

        all_symbols:[c_Symbol],

        ignore_symbols:[c_TokenSymbol]
     },

    bodies:[t_Body],

    tok
 }
```*/
fn _fn1 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 if let HCO::NODE(r_0) = v0 { 
 let r_0 = (r_0).(Box<Productions>);
 if let HCO::NODE(r_1) = v0 { 
 let r_1 = (r_1).(Box<Productions>);
 if let HCO::NODE(r_2) = v0 { 
 let r_2 = (r_2).(Box<Productions>);
 let mut ref_0:Vec<HCO> = Vec::new();
 let mut ref_1:Vec<HCO> = Vec::new();
 let mut ref_2:Vec<HCO> = Vec::new();
 let mut ref_3 = ASTNode::Meta(Meta::new(
        ref_1,
        ref_2,
    ) 
);;
 if let ASTNode::Meta(r_3) = ref_3 { 
 let mut ref_4:Vec<HCO> = Vec::new();
 let mut ref_5 = ASTNode::Grammar(Grammar::new(
        Vec::new(),
        r_0.productions,
        r_1.ir,
        r_2.functions,
        ref_0,
        r_3,
        ref_4,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE(ref_5)) } } } }}
/**
```
{ 

    t_IR_STATE,

    c_IR,

    c_IrState,

    id:$1,

    instructions:$2,

    fail:$3,

    symbol_meta:$4
 }
```*/
fn _fn2 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3); 
 if let HCO::NODES(mut r_0) = v1 { 
 if let HCO::NODE(r_1) = v2 { 
 if let ASTNode::FailState(r_2) = r_1 { 
 if let HCO::NODE(r_3) = v3 { 
 if let ASTNode::Symbols(r_4) = r_3 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        /* AAA */v0.String(),
        r_0,
        Some(r_2),
        Some(r_4),
        ASTNode::NONE,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } } } } }}
/**
```
{ 

    t_IR_STATE,

    c_IR,

    c_IrState,

    id:$1,

    instructions:$2,

    fail:$NULL,

    symbol_meta:$3
 }
```*/
fn _fn3 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 if let HCO::NODES(mut r_0) = v1 { 
 if let HCO::NODE(r_1) = v2 { 
 if let ASTNode::Symbols(r_2) = r_1 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        /* AAA */v0.String(),
        r_0,
        None,
        Some(r_2),
        ASTNode::NONE,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } } }}
/**
```
{ 

    t_IR_STATE,

    c_IR,

    c_IrState,

    id:$1,

    instructions:$2,

    fail:$3,

    symbol_meta:$NULL
 }
```*/
fn _fn4 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 if let HCO::NODES(mut r_0) = v1 { 
 if let HCO::NODE(r_1) = v2 { 
 if let ASTNode::FailState(r_2) = r_1 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        /* AAA */v0.String(),
        r_0,
        Some(r_2),
        None,
        ASTNode::NONE,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } } }}
/**
```
{ 

    t_IR_STATE,

    c_IR,

    c_IrState,

    id:$1,

    instructions:$2,

    fail:$NULL,

    symbol_meta:$NULL
 }
```*/
fn _fn5 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::NODES(mut r_0) = v1 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        /* AAA */v0.String(),
        r_0,
        None,
        None,
        ASTNode::NONE,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ 

    t_ASSERT,

    c_IR,

    c_IR_Instruction,

    c_IR_Branch,

    mode:str($2),

    ids:$3,

    instructions:$5
 }
```*/
fn _fn6 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v5 = args.remove(i-0);
let mut v4 = args.remove(i-1);
let mut v3 = args.remove(i-2);
let mut v2 = args.remove(i-3);
let mut v1 = args.remove(i-4);
let mut v0 = args.remove(i-5); 
 if let HCO::TOKEN(r_0) = v1 { 
 if let HCO::NODES(mut r_1) = v2 { 
 if let HCO::NODES(mut r_2) = v4 { 
 let mut ref_0 = ASTNode::ASSERT(ASSERT::new(
        /* AAA */r_0.String(),
        r_1,
        r_2,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } } }}
/**
```
{ 

    t_PEEK,

    c_IR,

    c_IR_Instructio,

    c_IR_Branch,

    mode:str($2),

    ids:$3,

    instructions:$5
 }
```*/
fn _fn7 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v5 = args.remove(i-0);
let mut v4 = args.remove(i-1);
let mut v3 = args.remove(i-2);
let mut v2 = args.remove(i-3);
let mut v1 = args.remove(i-4);
let mut v0 = args.remove(i-5); 
 if let HCO::TOKEN(r_0) = v1 { 
 if let HCO::NODES(mut r_1) = v2 { 
 if let HCO::NODES(mut r_2) = v4 { 
 let mut ref_0 = ASTNode::PEEK(PEEK::new(
        /* AAA */r_0.String(),
        r_1,
        r_2,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } } }}
/**
```
{ 

    t_Production_Symbol,

    c_Symbol,

    name:str($1),

    production:c_Production,

    val:-1,

    annotation:t_Reference,

    tok
 }
```*/
fn _fn8 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 if let HCO::TOKEN(r_0) = v0 { 
 let mut ref_0 = ASTNode::Production_Symbol(Production_Symbol::new(
        /* AAA */r_0.String(),
        ASTNode::NONE,
        /* AAA */1.0,
        None,
        /* AAA */tok,
        0,
        false,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ 

    t_Production_Import_Symbol,

    c_Symbol,

    module:str($1),

    name:str($3),

    production:c_Production,

    annotation:t_Reference,

    tok
 }
```*/
fn _fn9 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 if let HCO::TOKEN(r_0) = v0 { 
 if let HCO::TOKEN(r_1) = v2 { 
 let mut ref_0 = ASTNode::Production_Import_Symbol(Production_Import_Symbol::new(
        /* AAA */r_0.String(),
        /* AAA */r_1.String(),
        ASTNode::NONE,
        None,
        /* AAA */tok,
        0,
        false,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } }}
/**
```
{ 

    t_Reduce,

    c_IR,

    c_IR_Instruction,

    len:i32($2),

    body_id:i32($3)
 }
```*/
fn _fn10 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 if let HCO::TOKEN(r_0) = v1 { 
 if let HCO::TOKEN(r_1) = v2 { 
 let mut ref_0 = ASTNode::Reduce(Reduce::new(
        /* AAA */r_0.to_i32(),
        /* AAA */r_1.to_i32(),
        ASTNode::NONE,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } }}
/**
```
{ 

    t_Reduce,

    c_IR,

    c_IR_Instruction,

    len:i32(-1),

    reduce_fn:$2
 }
```*/
fn _fn11 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::NODE(r_0) = v1 { 
 let mut ref_0 = ASTNode::Reduce(Reduce::new(
        /* AAA */1.0 as i32,
        None,
        r_0,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ t_TokenAssign, c_IR, c_IR_Instruction, ids:$3 }
```*/
fn _fn12 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 if let HCO::NODES(mut r_0) = v2 { 
 let mut ref_0 = ASTNode::TokenAssign(TokenAssign::new(
        r_0,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ t_SetProd, c_IR, c_IR_Instruction, id:$4 }
```*/
fn _fn13 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3); 
 if let HCO::NODE(r_0) = v3 { 
 let mut ref_0 = ASTNode::SetProd(SetProd::new(
        r_0,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ t_ForkTo, c_IR, c_IR_Instruction, states:$4 }
```*/
fn _fn14 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v4 = args.remove(i-0);
let mut v3 = args.remove(i-1);
let mut v2 = args.remove(i-2);
let mut v1 = args.remove(i-3);
let mut v0 = args.remove(i-4); 
 if let HCO::NODES(mut r_0) = v3 { 
 let mut ref_0 = ASTNode::ForkTo(ForkTo::new(
        r_0,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ 

    t_ScanUntil,

    c_IR,

    c_IR_Instruction,

    ids:$4,

    SCAN_BACKWARDS:bool($2)
 }
```*/
fn _fn15 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3); 
 if let HCO::NODES(mut r_0) = v3 { 
 if let HCO::TOKEN(r_1) = v1 { 
 let mut ref_0 = ASTNode::ScanUntil(ScanUntil::new(
        r_0,
        /* AAA */r_1.to_bool(),
    ) 
);;
 args.push(HCO::NODE(ref_0)) } }}
/**
```
{ t_TokenId, c_IR, c_IR_Instruction, id:$4 }
```*/
fn _fn16 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v4 = args.remove(i-0);
let mut v3 = args.remove(i-1);
let mut v2 = args.remove(i-2);
let mut v1 = args.remove(i-3);
let mut v0 = args.remove(i-4); 
 if let HCO::NODE(r_0) = v3 { 
 let mut ref_0 = ASTNode::TokenId(TokenId::new(
        r_0,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ t_Pass, c_IR, c_IR_Instruction }
```*/
fn _fn17 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 let mut ref_0 = ASTNode::Pass(Pass::new(
        
    ) 
);;
 args.push(HCO::NODE(ref_0))}
/**
```
{ t_Fail, c_IR, c_IR_Instruction }
```*/
fn _fn18 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 let mut ref_0 = ASTNode::Fail(Fail::new(
        
    ) 
);;
 args.push(HCO::NODE(ref_0))}
/**
```
{ t_NotInScope, c_IR, c_IR_Instruction, ids:$5 }
```*/
fn _fn19 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v5 = args.remove(i-0);
let mut v4 = args.remove(i-1);
let mut v3 = args.remove(i-2);
let mut v2 = args.remove(i-3);
let mut v1 = args.remove(i-4);
let mut v0 = args.remove(i-5); 
 if let HCO::NODES(mut r_0) = v4 { 
 let mut ref_0 = ASTNode::NotInScope(NotInScope::new(
        r_0,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ t_SetScope, c_IR, c_IR_Instruction, scope:$4 }
```*/
fn _fn20 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3); 
 let mut ref_0 = ASTNode::SetScope(SetScope::new(
        /* AAA */(v3.len() as i64),
    ) 
);;
 args.push(HCO::NODE(ref_0))}
/**
```
{ t_Consume, c_IR, c_IR_Instruction, EMPTY:bool($2) }
```*/
fn _fn21 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::TOKEN(r_0) = v1 { 
 let mut ref_0 = ASTNode::Consume(Consume::new(
        /* AAA */r_0.to_bool(),
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ 

    t_ScanUntil,

    c_IR,

    c_IR_Instruction,

    ids:$3,

    SCAN_BACKWARDS:bool($NULL)
 }
```*/
fn _fn22 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 if let HCO::NODES(mut r_0) = v2 { 
 let mut ref_0 = ASTNode::ScanUntil(ScanUntil::new(
        r_0,
        /* AAA */false,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ t_Consume, c_IR, c_IR_Instruction, EMPTY:bool($NULL) }
```*/
fn _fn23 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 let mut ref_0 = ASTNode::Consume(Consume::new(
        /* AAA */false,
    ) 
);;
 args.push(HCO::NODE(ref_0))}
/**
```
{ 

    t_Returned,

    c_Function,

    txt:str($4),

    name:"",

    env:false,

    IS_CONDITION:true
 }
```*/
fn _fn24 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v4 = args.remove(i-0);
let mut v3 = args.remove(i-1);
let mut v2 = args.remove(i-2);
let mut v1 = args.remove(i-3);
let mut v0 = args.remove(i-4); 
 if let HCO::TOKEN(r_0) = v3 { 
 let mut ref_0 = ASTNode::Returned(Returned::new(
        /* AAA */r_0.String(),
        /* AAA */String::from(""),
        /* AAA */false,
        /* AAA */true,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ t_Referenced, c_Function, reference:$3 }
```*/
fn _fn25 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 if let HCO::NODE(r_0) = v2 { 
 if let ASTNode::Reference(r_1) = r_0 { 
 let mut ref_0 = ASTNode::Referenced(Referenced::new(
        r_1,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } }}
/**
```
{ t_Reference, c_Symbol, val:str($1) }
```*/
fn _fn26 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 if let HCO::TOKEN(r_0) = v0 { 
 let mut ref_0 = ASTNode::Reference(Reference::new(
        /* AAA */r_0.String(),
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ 

    t_Generated,

    c_Symbol,

    c_Token,

    val:str($2),

    annotation:t_Reference,

    tok
 }
```*/
fn _fn27 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::TOKEN(r_0) = v1 { 
 let mut ref_0 = ASTNode::Generated(Generated::new(
        /* AAA */r_0.String(),
        None,
        /* AAA */tok,
        0,
        false,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ 

    t_Exclusive_Literal,

    c_Symbol,

    c_Token,

    val:str($2),

    annotation:t_Reference,

    tok
 }
```*/
fn _fn28 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 let mut ref_0 = ASTNode::Exclusive_Literal(Exclusive_Literal::new(
        /* AAA */v1.String(),
        None,
        /* AAA */tok,
        0,
        false,
    ) 
);;
 args.push(HCO::NODE(ref_0))}
/**
```
{ 

    t_Literal,

    c_Symbol,

    c_Token,

    val:str($1),

    annotation:t_Reference,

    tok
 }
```*/
fn _fn29 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 let mut ref_0 = ASTNode::Literal(Literal::new(
        /* AAA */v0.String(),
        None,
        /* AAA */tok,
        0,
        false,
    ) 
);;
 args.push(HCO::NODE(ref_0))}
/**
```
{ 

    t_Literal,

    c_Symbol,

    c_Token,

    val:str($2),

    annotation:t_Reference,

    tok
 }
```*/
fn _fn30 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 let mut ref_0 = ASTNode::Literal(Literal::new(
        /* AAA */v1.String(),
        None,
        /* AAA */tok,
        0,
        false,
    ) 
);;
 args.push(HCO::NODE(ref_0))}
/**
```
{ 

    t_End_Of_File,

    c_Symbol,

    c_Token,

    val:"END_OF_FILE",

    annotation:t_Reference,

    tok
 }
```*/
fn _fn31 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 let mut ref_0 = ASTNode::End_Of_File(End_Of_File::new(
        /* AAA */String::from("END_OF_FILE"),
        None,
        /* AAA */tok,
        0,
        false,
    ) 
);;
 args.push(HCO::NODE(ref_0))}
/**
```
{ t_Space, c_Meta, c_Format, position:i16(0) }
```*/
fn _fn32 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 let mut ref_0 = ASTNode::Space(Space::new(
        /* AAA */0.0 as i16,
        0,
        false,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_0))}
/**
```
{ t_NewLine, c_Meta, c_Format, position:i16(0) }
```*/
fn _fn33 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 let mut ref_0 = ASTNode::NewLine(NewLine::new(
        /* AAA */0.0 as i16,
        0,
        false,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_0))}
/**
```
{ t_IncreaseIndent, c_Meta, c_Format, position:i16(0) }
```*/
fn _fn34 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 let mut ref_0 = ASTNode::IncreaseIndent(IncreaseIndent::new(
        /* AAA */0.0 as i16,
        0,
        false,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_0))}
/**
```
{ t_DecreaseIndent, c_Meta, c_Format, position:i16(0) }
```*/
fn _fn35 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 let mut ref_0 = ASTNode::DecreaseIndent(DecreaseIndent::new(
        /* AAA */0.0 as i16,
        0,
        false,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_0))}
/**
```
{ 

    t_Production_Token,

    c_Symbol,

    c_Token,

    name:$2.name,

    production:$2,

    val:-1,

    annotation:t_Reference,

    tok
 }
```*/
fn _fn36 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::NODE(r_0) = v1 { 
 let r_0 = (r_0).(Box<Production_Symbol>);
 if let HCO::NODE(r_1) = v1 { 
 let mut ref_0 = ASTNode::Production_Token(Production_Token::new(
        /* AAA */r_0.name,
        r_1,
        /* AAA */1.0,
        None,
        /* AAA */tok,
        0,
        false,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } }}
/**
```
{ t_Goto, c_IR, c_IR_Instruction, state:$2 }
```*/
fn _fn37 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::NODE(r_0) = v1 { 
 let mut ref_0 = ASTNode::Goto(Goto::new(
        r_0,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ 

    t_FailState,

    c_IR,

    c_IR_State,

    id:$3,

    instructions:$4,

    symbol_meta:$6,

    fail:$5
 }
```*/
fn _fn38 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v5 = args.remove(i-0);
let mut v4 = args.remove(i-1);
let mut v3 = args.remove(i-2);
let mut v2 = args.remove(i-3);
let mut v1 = args.remove(i-4);
let mut v0 = args.remove(i-5); 
 if let HCO::NODES(mut r_0) = v3 { 
 if let HCO::NODE(r_1) = v5 { 
 if let ASTNode::Symbols(r_2) = r_1 { 
 if let HCO::NODE(r_3) = v4 { 
 if let ASTNode::FailState(r_4) = r_3 { 
 let mut ref_0 = ASTNode::FailState(FailState::new(
        /* AAA */v2.String(),
        r_0,
        Some(r_2),
        Some(r_4),
    ) 
);;
 args.push(HCO::NODE(ref_0)) } } } } }}
/**
```
{ 

    t_FailState,

    c_IR,

    c_IR_State,

    id:$3,

    instructions:$4,

    symbol_meta:$5,

    fail:$NULL
 }
```*/
fn _fn39 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v4 = args.remove(i-0);
let mut v3 = args.remove(i-1);
let mut v2 = args.remove(i-2);
let mut v1 = args.remove(i-3);
let mut v0 = args.remove(i-4); 
 if let HCO::NODES(mut r_0) = v3 { 
 if let HCO::NODE(r_1) = v4 { 
 if let ASTNode::Symbols(r_2) = r_1 { 
 let mut ref_0 = ASTNode::FailState(FailState::new(
        /* AAA */v2.String(),
        r_0,
        Some(r_2),
        None,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } } }}
/**
```
{ 

    t_FailState,

    c_IR,

    c_IR_State,

    id:$3,

    instructions:$4,

    symbol_meta:$NULL,

    fail:$5
 }
```*/
fn _fn40 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v4 = args.remove(i-0);
let mut v3 = args.remove(i-1);
let mut v2 = args.remove(i-2);
let mut v1 = args.remove(i-3);
let mut v0 = args.remove(i-4); 
 if let HCO::NODES(mut r_0) = v3 { 
 if let HCO::NODE(r_1) = v4 { 
 if let ASTNode::FailState(r_2) = r_1 { 
 let mut ref_0 = ASTNode::FailState(FailState::new(
        /* AAA */v2.String(),
        r_0,
        None,
        Some(r_2),
    ) 
);;
 args.push(HCO::NODE(ref_0)) } } }}
/**
```
{ 

    t_FailState,

    c_IR,

    c_IR_State,

    id:$3,

    instructions:$4,

    symbol_meta:$NULL,

    fail:$NULL
 }
```*/
fn _fn41 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3); 
 if let HCO::NODES(mut r_0) = v3 { 
 let mut ref_0 = ASTNode::FailState(FailState::new(
        /* AAA */v2.String(),
        r_0,
        None,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ t_Symbols, c_IR, expected:$3, skipped:$4 }
```*/
fn _fn42 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3); 
 if let HCO::NODES(mut r_0) = v2 { 
 if let HCO::NODES(mut r_1) = v3 { 
 let mut ref_0 = ASTNode::Symbols(Symbols::new(
        r_0,
        r_1,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } }}
/**
```
{ t_Symbols, c_IR, expected:$3, skipped:$NULL }
```*/
fn _fn43 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 if let HCO::NODES(mut r_0) = v2 { 
 let mut ref_0 = ASTNode::Symbols(Symbols::new(
        r_0,
        Vec::new(),
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ t_Not_Symbol, c_Symbol, val:$2.val, symbol:$2, tok }
```*/
fn _fn44 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::NODE(r_0) = v1 { 
 let r_0 = (r_0).(Box<Exclusive_Literal>);
 if let HCO::NODE(r_1) = v1 { 
 let mut ref_0 = ASTNode::Not_Symbol(Not_Symbol::new(
        /* AAA */r_0.val,
        r_1,
        /* AAA */tok,
        0,
        false,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } }}
/**
```
{ t_Look_Behind, c_Symbol, val:$2.val, symbol:$2, tok }
```*/
fn _fn45 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::NODE(r_0) = v1 { 
 let r_0 = (r_0).(Box<Generated>);
 if let HCO::NODE(r_1) = v1 { 
 let mut ref_0 = ASTNode::Look_Behind(Look_Behind::new(
        r_0.val,
        r_1,
        /* AAA */tok,
        0,
        false,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } }}
/**
```
{ 

    t_List_Production,

    c_Symbol,

    terminal_symbol:$3,

    IS_OPTIONAL:f64($2=="(*"),

    symbols:$1,

    annotation:t_Reference,

    tok
 }
```*/
fn _fn46 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3); 
 if let HCO::NODE(r_0) = v2 { 
 if let HCO::TOKEN(r_1) = v1 { 
 if let HCO::NODE(r_2) = v0 { 
 let mut ref_0 = ASTNode::List_Production(List_Production::new(
        r_0,
        /* AAA */r_1 == String::from("(*") as f64,
        r_2,
        None,
        /* AAA */tok,
        false,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } } }}
/**
```
{ 

    t_List_Production,

    c_Symbol,

    terminal_symbol:$NULL,

    IS_OPTIONAL:f64($2=="(*"),

    symbols:$1,

    annotation:t_Reference,

    tok
 }
```*/
fn _fn47 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 if let HCO::TOKEN(r_0) = v1 { 
 if let HCO::NODE(r_1) = v0 { 
 let mut ref_0 = ASTNode::List_Production(List_Production::new(
        ASTNode::NONE,
        /* AAA */r_0 == String::from("(*") as f64,
        r_1,
        None,
        /* AAA */tok,
        false,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } }}
/**
```
{ 

    t_Group_Production,

    c_Symbol,

    bodies:$2,

    annotation:t_Reference,

    tok
 }
```*/
fn _fn48 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 if let HCO::NODES(mut r_0) = v1 { 
 let mut ref_0 = ASTNode::Group_Production(Group_Production::new(
        r_0,
        None,
        /* AAA */tok,
        0,
        false,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ 

    t_Body,

    c_Production,

    priority:$1?1000:20,

    symbols:$3,

    reference:$2,

    reduce_function:$4,

    FORCE_FORK:false,

    id:-1,

    production:t_Production
 }
```*/
fn _fn49 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3); 
 if let HCO::TOKEN(r_0) = v0 { 
 let mut ref_0 = 1000.0;
if r_0 { ref_0 = 20.0 }
 if let HCO::NODES(mut r_1) = v2 { 
 if let HCO::NODE(r_2) = v1 { 
 if let ASTNode::Reference(r_3) = r_2 { 
 if let HCO::NODE(r_4) = v3 { 
 let mut ref_2 = ASTNode::Body(Body::new(
        ref_0,
        r_1,
        Some(r_3),
        r_4,
        /* AAA */false,
        /* AAA */1.0,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_2)) } } } } }}
/**
```
{ 

    t_Body,

    c_Production,

    priority:$NULL?1000:20,

    symbols:$2,

    reference:$1,

    reduce_function:$3,

    FORCE_FORK:false,

    id:-1,

    production:t_Production
 }
```*/
fn _fn50 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 let mut ref_0 = 1000.0;
if null { ref_0 = 20.0 }
 if let HCO::NODES(mut r_0) = v1 { 
 if let HCO::NODE(r_1) = v0 { 
 if let ASTNode::Reference(r_2) = r_1 { 
 if let HCO::NODE(r_3) = v2 { 
 let mut ref_2 = ASTNode::Body(Body::new(
        ref_0,
        r_0,
        Some(r_2),
        r_3,
        /* AAA */false,
        /* AAA */1.0,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_2)) } } } }}
/**
```
{ 

    t_Body,

    c_Production,

    priority:$1?1000:20,

    symbols:$2,

    reference:$NULL,

    reduce_function:$3,

    FORCE_FORK:false,

    id:-1,

    production:t_Production
 }
```*/
fn _fn51 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 if let HCO::TOKEN(r_0) = v0 { 
 let mut ref_0 = 1000.0;
if r_0 { ref_0 = 20.0 }
 if let HCO::NODES(mut r_1) = v1 { 
 if let HCO::NODE(r_2) = v2 { 
 let mut ref_2 = ASTNode::Body(Body::new(
        ref_0,
        r_1,
        None,
        r_2,
        /* AAA */false,
        /* AAA */1.0,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_2)) } } }}
/**
```
{ 

    t_Body,

    c_Production,

    priority:$1?1000:20,

    symbols:$3,

    reference:$2,

    reduce_function:$NULL,

    FORCE_FORK:false,

    id:-1,

    production:t_Production
 }
```*/
fn _fn52 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 if let HCO::TOKEN(r_0) = v0 { 
 let mut ref_0 = 1000.0;
if r_0 { ref_0 = 20.0 }
 if let HCO::NODES(mut r_1) = v2 { 
 if let HCO::NODE(r_2) = v1 { 
 if let ASTNode::Reference(r_3) = r_2 { 
 let mut ref_2 = ASTNode::Body(Body::new(
        ref_0,
        r_1,
        Some(r_3),
        ASTNode::NONE,
        /* AAA */false,
        /* AAA */1.0,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_2)) } } } }}
/**
```
{ 

    t_Body,

    c_Production,

    priority:$NULL?1000:20,

    symbols:$1,

    reference:$NULL,

    reduce_function:$2,

    FORCE_FORK:false,

    id:-1,

    production:t_Production
 }
```*/
fn _fn53 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 let mut ref_0 = 1000.0;
if null { ref_0 = 20.0 }
 if let HCO::NODES(mut r_0) = v0 { 
 if let HCO::NODE(r_1) = v1 { 
 let mut ref_2 = ASTNode::Body(Body::new(
        ref_0,
        r_0,
        None,
        r_1,
        /* AAA */false,
        /* AAA */1.0,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_2)) } }}
/**
```
{ 

    t_Body,

    c_Production,

    priority:$NULL?1000:20,

    symbols:$2,

    reference:$1,

    reduce_function:$NULL,

    FORCE_FORK:false,

    id:-1,

    production:t_Production
 }
```*/
fn _fn54 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 let mut ref_0 = 1000.0;
if null { ref_0 = 20.0 }
 if let HCO::NODES(mut r_0) = v1 { 
 if let HCO::NODE(r_1) = v0 { 
 if let ASTNode::Reference(r_2) = r_1 { 
 let mut ref_2 = ASTNode::Body(Body::new(
        ref_0,
        r_0,
        Some(r_2),
        ASTNode::NONE,
        /* AAA */false,
        /* AAA */1.0,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_2)) } } }}
/**
```
{ 

    t_Body,

    c_Production,

    priority:$1?1000:20,

    symbols:$2,

    reference:$NULL,

    reduce_function:$NULL,

    FORCE_FORK:false,

    id:-1,

    production:t_Production
 }
```*/
fn _fn55 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::TOKEN(r_0) = v0 { 
 let mut ref_0 = 1000.0;
if r_0 { ref_0 = 20.0 }
 if let HCO::NODES(mut r_1) = v1 { 
 let mut ref_2 = ASTNode::Body(Body::new(
        ref_0,
        r_1,
        None,
        ASTNode::NONE,
        /* AAA */false,
        /* AAA */1.0,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_2)) } }}
/**
```
{ 

    t_Body,

    c_Production,

    priority:$NULL?1000:20,

    symbols:$1,

    reference:$NULL,

    reduce_function:$NULL,

    FORCE_FORK:false,

    id:-1,

    production:t_Production
 }
```*/
fn _fn56 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 let mut ref_0 = 1000.0;
if null { ref_0 = 20.0 }
 if let HCO::NODES(mut r_0) = v0 { 
 let mut ref_2 = ASTNode::Body(Body::new(
        ref_0,
        r_0,
        None,
        ASTNode::NONE,
        /* AAA */false,
        /* AAA */1.0,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_2)) }}
/**
```
{ 

    t_Exclude,

    c_Symbol,

    c_Meta,

    sym:$2,

    index:-1,

    annotation:t_Reference,

    tok
 }
```*/
fn _fn57 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 if let HCO::NODES(mut r_0) = v1 { 
 let mut ref_0 = ASTNode::Exclude(Exclude::new(
        r_0,
        /* AAA */1.0,
        None,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ 

    t_Look_Ignore,

    c_Symbol,

    c_Meta,

    sym:$2,

    index:-1,

    annotation:t_Reference,

    tok
 }
```*/
fn _fn58 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 if let HCO::NODES(mut r_0) = v1 { 
 let mut ref_0 = ASTNode::Look_Ignore(Look_Ignore::new(
        r_0,
        /* AAA */1.0,
        None,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ 

    t_Empty,

    c_Symbol,

    val:"",

    annotation:t_Reference,

    tok
 }
```*/
fn _fn59 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 let mut ref_0 = ASTNode::Empty(Empty::new(
        /* AAA */String::from(""),
        None,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE(ref_0))}
/**
```
{ 

    t_Production,

    c_Production,

    priority:$3?1000:0,

    symbol:$s,

    bodies:$b,

    id:-1,

    LAZY:bool($l),

    entry_name:""
 }
```*/
fn _fn60 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v5 = args.remove(i-0);
let mut v4 = args.remove(i-1);
let mut v3 = args.remove(i-2);
let mut v2 = args.remove(i-3);
let mut v1 = args.remove(i-4);
let mut v0 = args.remove(i-5); 
 if let HCO::TOKEN(r_0) = v2 { 
 let mut ref_0 = 1000.0;
if r_0 { ref_0 = 0.0 }
 if let HCO::NODE(r_1) = v3 { 
 if let HCO::NODES(mut r_2) = v5 { 
 if let HCO::TOKEN(r_3) = v1 { 
 let mut ref_2 = ASTNode::Production(Production::new(
        ref_0,
        r_1,
        r_2,
        /* AAA */1.0,
        /* AAA */r_3.to_bool(),
        /* AAA */String::from(""),
    ) 
);;
 args.push(HCO::NODE(ref_2)) } } } }}
/**
```
{ 

    t_ProductionMerged,

    c_Production,

    symbol:$2,

    bodies:$4,

    id:-1
 }
```*/
fn _fn61 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3); 
 if let HCO::NODE(r_0) = v1 { 
 if let HCO::NODES(mut r_1) = v3 { 
 let mut ref_0 = ASTNode::ProductionMerged(ProductionMerged::new(
        r_0,
        r_1,
        /* AAA */1.0,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } }}
/**
```
{ 

    t_Production,

    c_Production,

    priority:$2?1000:0,

    symbol:$s,

    bodies:$b,

    id:-1,

    LAZY:bool($l),

    entry_name:""
 }
```*/
fn _fn62 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v4 = args.remove(i-0);
let mut v3 = args.remove(i-1);
let mut v2 = args.remove(i-2);
let mut v1 = args.remove(i-3);
let mut v0 = args.remove(i-4); 
 if let HCO::TOKEN(r_0) = v1 { 
 let mut ref_0 = 1000.0;
if r_0 { ref_0 = 0.0 }
 if let HCO::NODE(r_1) = v2 { 
 if let HCO::NODES(mut r_2) = v4 { 
 let mut ref_2 = ASTNode::Production(Production::new(
        ref_0,
        r_1,
        r_2,
        /* AAA */1.0,
        /* AAA */false,
        /* AAA */String::from(""),
    ) 
);;
 args.push(HCO::NODE(ref_2)) } } }}
/**
```
{ 

    t_Production,

    c_Production,

    priority:$NULL?1000:0,

    symbol:$s,

    bodies:$b,

    id:-1,

    LAZY:bool($l),

    entry_name:""
 }
```*/
fn _fn63 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v4 = args.remove(i-0);
let mut v3 = args.remove(i-1);
let mut v2 = args.remove(i-2);
let mut v1 = args.remove(i-3);
let mut v0 = args.remove(i-4); 
 let mut ref_0 = 1000.0;
if null { ref_0 = 0.0 }
 if let HCO::NODE(r_0) = v2 { 
 if let HCO::NODES(mut r_1) = v4 { 
 if let HCO::TOKEN(r_2) = v1 { 
 let mut ref_2 = ASTNode::Production(Production::new(
        ref_0,
        r_0,
        r_1,
        /* AAA */1.0,
        /* AAA */r_2.to_bool(),
        /* AAA */String::from(""),
    ) 
);;
 args.push(HCO::NODE(ref_2)) } } }}
/**
```
{ 

    t_Production,

    c_Production,

    priority:$NULL?1000:0,

    symbol:$s,

    bodies:$b,

    id:-1,

    LAZY:bool($l),

    entry_name:""
 }
```*/
fn _fn64 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3); 
 let mut ref_0 = 1000.0;
if null { ref_0 = 0.0 }
 if let HCO::NODE(r_0) = v1 { 
 if let HCO::NODES(mut r_1) = v3 { 
 let mut ref_2 = ASTNode::Production(Production::new(
        ref_0,
        r_0,
        r_1,
        /* AAA */1.0,
        /* AAA */false,
        /* AAA */String::from(""),
    ) 
);;
 args.push(HCO::NODE(ref_2)) } }}
/**
```
{ t_Ignore, c_Preamble, symbols:$2 }
```*/
fn _fn65 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 if let HCO::NODES(mut r_0) = v1 { 
 let mut ref_0 = ASTNode::Ignore(Ignore::new(
        r_0,
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ t_Import, c_Preamble, uri:$2, reference:$4 }
```*/
fn _fn66 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3); 
 let mut ref_0 = ASTNode::Import(Import::new(
        /* AAA */v1.String(),
        /* AAA */v3.Token(),
    ) 
);;
 args.push(HCO::NODE(ref_0))}
/**
```
{ t_Export, c_Preamble, production:$2, reference:$4 }
```*/
fn _fn67 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3); 
 if let HCO::NODE(r_0) = v1 { 
 if let HCO::TOKEN(r_1) = v3 { 
 let mut ref_0 = ASTNode::Export(Export::new(
        r_0,
        /* AAA */r_1,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } }}
/**
```
{ 

    t_Productions,

    functions:[],

    productions:[$1],

    ir:[],

    tok
 }
```*/
fn _fn68 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 let mut ref_0:Vec<ASTNode> =  Vec::new();
 let mut ref_1:Vec<ASTNode> =  Vec::new();
 if let HCO::NODE(r_0) = v0 { 
ref_1.push(r_0);
 let mut ref_3:Vec<ASTNode> =  Vec::new();
 let mut ref_4 = ASTNode::Productions(Productions::new(
        ref_0,
        ref_1,
        ref_3,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE(ref_4)) }}
/**
```
{ 

    t_Productions,

    functions:[$1],

    productions:[],

    ir:[],

    tok
 }
```*/
fn _fn69 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 let mut ref_0:Vec<ASTNode> =  Vec::new();
 if let HCO::NODE(r_0) = v0 { 
ref_0.push(r_0);
 let mut ref_2:Vec<ASTNode> =  Vec::new();
 let mut ref_3 = ASTNode::Productions(Productions::new(
        ref_0,
        ref_2,
        vec![],
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE(ref_3)) }}
/**
```
{ 

    t_Productions,

    functions:[],

    productions:[],

    ir:[$1],

    tok
 }
```*/
fn _fn70 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 let mut ref_0:Vec<ASTNode> =  Vec::new();
 let mut ref_1:Vec<ASTNode> =  Vec::new();
 let mut ref_2:Vec<ASTNode> =  Vec::new();
 if let HCO::NODE(r_0) = v0 { 
ref_2.push(r_0);
 let mut ref_4 = ASTNode::Productions(Productions::new(
        ref_0,
        ref_1,
        ref_2,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE(ref_4)) }}
/**
```
{ t_Out_Of_Band, c_Function, reference:$2, txt:$4 }
```*/
fn _fn71 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v4 = args.remove(i-0);
let mut v3 = args.remove(i-1);
let mut v2 = args.remove(i-2);
let mut v1 = args.remove(i-3);
let mut v0 = args.remove(i-4); 
 if let HCO::NODE(r_0) = v1 { 
 if let ASTNode::Reference(r_1) = r_0 { 
 if let HCO::TOKEN(r_2) = v3 { 
 let mut ref_0 = ASTNode::Out_Of_Band(Out_Of_Band::new(
        Some(r_1),
        r_2,
        ASTNode::NONE,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } } }}
/**
```
{ 

    t_Out_Of_Band,

    c_Function,

    production:$2,

    index:$3,

    txt:$5+""
 }
```*/
fn _fn72 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v5 = args.remove(i-0);
let mut v4 = args.remove(i-1);
let mut v3 = args.remove(i-2);
let mut v2 = args.remove(i-3);
let mut v1 = args.remove(i-4);
let mut v0 = args.remove(i-5); 
 if let HCO::TOKEN(r_0) = v4 { 
 if let HCO::NODE(r_1) = v1 { 
 let mut ref_0 = ASTNode::Out_Of_Band(Out_Of_Band::new(
        None,
        (r_0).String(),
        r_1,
        /* AAA */v2.Token(),
    ) 
);;
 args.push(HCO::NODE(ref_0)) } }}
/**
```
{ 

    t_Out_Of_Band,

    c_Function,

    production:$2,

    index:$3,

    reference:$4
 }
```*/
fn _fn73 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3); 
 if let HCO::NODE(r_0) = v3 { 
 if let ASTNode::Reference(r_1) = r_0 { 
 if let HCO::NODE(r_2) = v1 { 
 let mut ref_0 = ASTNode::Out_Of_Band(Out_Of_Band::new(
        Some(r_1),
        HCO::NONE,
        r_2,
        /* AAA */v2.Token(),
    ) 
);;
 args.push(HCO::NODE(ref_0)) } } }}
/**
```
{ 

    t_Out_Of_Band,

    c_Function,

    production:$2,

    index:$NULL,

    txt:$4+""
 }
```*/
fn _fn74 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v4 = args.remove(i-0);
let mut v3 = args.remove(i-1);
let mut v2 = args.remove(i-2);
let mut v1 = args.remove(i-3);
let mut v0 = args.remove(i-4); 
 if let HCO::TOKEN(r_0) = v3 { 
 if let HCO::NODE(r_1) = v1 { 
 let mut ref_0 = ASTNode::Out_Of_Band(Out_Of_Band::new(
        None,
        (r_0).String(),
        r_1,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } }}
/**
```
{ 

    t_Out_Of_Band,

    c_Function,

    production:$2,

    index:$NULL,

    reference:$3
 }
```*/
fn _fn75 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 if let HCO::NODE(r_0) = v2 { 
 if let ASTNode::Reference(r_1) = r_0 { 
 if let HCO::NODE(r_2) = v1 { 
 let mut ref_0 = ASTNode::Out_Of_Band(Out_Of_Band::new(
        Some(r_1),
        HCO::NONE,
        r_2,
        None,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } } }}
/**
```
{ 

    t_IR_STATE,

    c_IR,

    c_IrState,

    prod:$3,

    instructions:$5,

    fail:$6,

    symbol_meta:$7
 }
```*/
fn _fn76 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v7 = args.remove(i-0);
let mut v6 = args.remove(i-1);
let mut v5 = args.remove(i-2);
let mut v4 = args.remove(i-3);
let mut v3 = args.remove(i-4);
let mut v2 = args.remove(i-5);
let mut v1 = args.remove(i-6);
let mut v0 = args.remove(i-7); 
 if let HCO::NODES(mut r_0) = v4 { 
 if let HCO::NODE(r_1) = v5 { 
 if let ASTNode::FailState(r_2) = r_1 { 
 if let HCO::NODE(r_3) = v6 { 
 if let ASTNode::Symbols(r_4) = r_3 { 
 if let HCO::NODE(r_5) = v2 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        String::from(""),
        r_0,
        Some(r_2),
        Some(r_4),
        r_5,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } } } } } }}
/**
```
{ 

    t_IR_STATE,

    c_IR,

    c_IrState,

    prod:$3,

    instructions:$5,

    fail:$NULL,

    symbol_meta:$6
 }
```*/
fn _fn77 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v6 = args.remove(i-0);
let mut v5 = args.remove(i-1);
let mut v4 = args.remove(i-2);
let mut v3 = args.remove(i-3);
let mut v2 = args.remove(i-4);
let mut v1 = args.remove(i-5);
let mut v0 = args.remove(i-6); 
 if let HCO::NODES(mut r_0) = v4 { 
 if let HCO::NODE(r_1) = v5 { 
 if let ASTNode::Symbols(r_2) = r_1 { 
 if let HCO::NODE(r_3) = v2 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        String::from(""),
        r_0,
        None,
        Some(r_2),
        r_3,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } } } }}
/**
```
{ 

    t_IR_STATE,

    c_IR,

    c_IrState,

    prod:$3,

    instructions:$5,

    fail:$6,

    symbol_meta:$NULL
 }
```*/
fn _fn78 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v6 = args.remove(i-0);
let mut v5 = args.remove(i-1);
let mut v4 = args.remove(i-2);
let mut v3 = args.remove(i-3);
let mut v2 = args.remove(i-4);
let mut v1 = args.remove(i-5);
let mut v0 = args.remove(i-6); 
 if let HCO::NODES(mut r_0) = v4 { 
 if let HCO::NODE(r_1) = v5 { 
 if let ASTNode::FailState(r_2) = r_1 { 
 if let HCO::NODE(r_3) = v2 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        String::from(""),
        r_0,
        Some(r_2),
        None,
        r_3,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } } } }}
/**
```
{ 

    t_IR_STATE,

    c_IR,

    c_IrState,

    prod:$3,

    instructions:$5,

    fail:$NULL,

    symbol_meta:$NULL
 }
```*/
fn _fn79 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v5 = args.remove(i-0);
let mut v4 = args.remove(i-1);
let mut v3 = args.remove(i-2);
let mut v2 = args.remove(i-3);
let mut v1 = args.remove(i-4);
let mut v0 = args.remove(i-5); 
 if let HCO::NODES(mut r_0) = v4 { 
 if let HCO::NODE(r_1) = v2 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        String::from(""),
        r_0,
        None,
        None,
        r_1,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } }}
/**
```
{ t_Repeat, c_IR, c_IR_Instruction }
```*/
fn _fn80 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2); 
 let mut ref_0 = ASTNode::Repeat(Repeat::new(
        
    ) 
);;
 args.push(HCO::NODE(ref_0))}
/**
```
{ 

    t_Lazy,

    c_IR,

    c_IR_Instruction,

    cp_start:$3,

    cp_end:$4,

    state:$6
 }
```*/
fn _fn81 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v5 = args.remove(i-0);
let mut v4 = args.remove(i-1);
let mut v3 = args.remove(i-2);
let mut v2 = args.remove(i-3);
let mut v1 = args.remove(i-4);
let mut v0 = args.remove(i-5); 
 if let HCO::TOKEN(r_0) = v2 { 
 if let HCO::TOKEN(r_1) = v3 { 
 if let HCO::NODE(r_2) = v5 { 
 let mut ref_0 = ASTNode::Lazy(Lazy::new(
        /* AAA */r_0,
        /* AAA */r_1,
        r_2,
    ) 
);;
 args.push(HCO::NODE(ref_0)) } } }}
/**
```
{ t_Num, val:i64($1) }
```*/
fn _fn82 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 if let HCO::TOKEN(r_0) = v0 { 
 let mut ref_0 = ASTNode::Num(Num::new(
        r_0.to_i64(),
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ t_Num, val:i32($1) }
```*/
fn _fn83 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 if let HCO::TOKEN(r_0) = v0 { 
 let mut ref_0 = ASTNode::Num(Num::new(
        r_0.to_i32(),
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
{ t_HASH_NAME, val:str($1) }
```*/
fn _fn84 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 if let HCO::TOKEN(r_0) = v0 { 
 let mut ref_0 = ASTNode::HASH_NAME(HASH_NAME::new(
        /* AAA */r_0.String(),
    ) 
);;
 args.push(HCO::NODE(ref_0)) }}
/**
```
str($3)
```*/
fn _fn85 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3); 
 if let HCO::TOKEN(r_0) = v2 { 
 args.push(HCO::STRING(r_0.String())) }}
/**
```
$2
```*/
fn _fn86 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 if let HCO::NODES(mut r_0) = v1 { 

                                args.push(HCO::NODES(r_0)); }
                                 } 
/**
```
$1+$2
```*/
fn _fn87 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::TOKEN(r_0) = v1 { 
 args.push(HCO::STRING(v0.String() + &r_0.String())) }}
/**
```
$1+$3+[$4]
```*/
fn _fn88 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3);
                                
 let mut ref_0:Vec<ASTNode> =  Vec::new();
 if let HCO::NODE(r_0) = v3 { 
ref_0.push(r_0);
 if let HCO::NODES(mut r_1) = v0 { 
 if let HCO::NODES(mut r_2) = v2 { 
r_1.append(&mut r_2);
ref_0.append(&mut r_1);

                                args.push(HCO::NODES(ref_0)); } } }
                                 } 
/**
```
$1+[$2]
```*/
fn _fn89 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 let mut ref_0:Vec<ASTNode> =  Vec::new();
 if let HCO::NODE(r_0) = v1 { 
ref_0.push(r_0);
 if let HCO::NODES(mut r_1) = v0 { 
ref_0.append(&mut r_1);

                                args.push(HCO::NODES(ref_0)); } }
                                 } 
/**
```
[$1]
```*/
fn _fn90 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                                
 let mut ref_0:Vec<ASTNode> =  Vec::new();
 if let HCO::NODE(r_0) = v0 { 
ref_0.push(r_0);

                                args.push(HCO::NODES(ref_0)); }
                                 } 
/**
```
$1+$3+[$NULL]
```*/
fn _fn91 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 let mut ref_0:Vec<ASTNode> =  Vec::new();
 if let HCO::NODES(mut r_0) = v0 { 
 if let HCO::NODES(mut r_1) = v2 { 
r_0.append(&mut r_1);
ref_0.append(&mut r_0);

                                args.push(HCO::NODES(ref_0)); } }
                                 } 
/**
```
$1+[$NULL]
```*/
fn _fn92 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                                
 let mut ref_0:Vec<ASTNode> =  Vec::new();
 if let HCO::NODES(mut r_0) = v0 { 
ref_0.append(&mut r_0);

                                args.push(HCO::NODES(ref_0)); }
                                 } 
/**
```
$NULL+[$NULL]
```*/
fn _fn93 (args:&mut Vec<HCO>, tok: Token){
                            let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
                                

                                args.push(vec![]);
                            }
/**
```
$3
```*/
fn _fn94 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3); 
 if let HCO::NODE(r_0) = v2 { 
 args.push(HCO::NODE(r_0)) }}
/**
```
($1.annotation = $2, $1)
```*/
fn _fn95 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::NODE(r_0) = v0 { 
 if let HCO::NODE(r_1) = v1 { 
r_0.annotation = r_1
 if let HCO::NODE(r_2) = v0 { 
 args.push(HCO::NODE(r_2)) } } }}
/**
```
$1.IS_OPTIONAL = 1, $1
```*/
fn _fn96 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::NODE(r_0) = v0 { 
r_0.IS_OPTIONAL = 1.0
 if let HCO::NODE(r_1) = v0 { 
 args.push(HCO::NODE(r_1)) } }}
/**
```
$2.IS_NON_CAPTURE = true, $2
```*/
fn _fn97 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::NODE(r_0) = v1 { 
r_0.IS_NON_CAPTURE = true
 if let HCO::NODE(r_1) = v1 { 
 args.push(HCO::NODE(r_1)) } }}
/**
```
$__first__+$__last__
```*/
fn _fn98 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 if let HCO::NODES(mut r_0) = v0 { 
 if let HCO::NODE(r_1) = v2 { 
r_0.push(r_1);

                                args.push(HCO::NODES(r_0)); } }
                                 } 
/**
```
$1+$2
```*/
fn _fn99 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODES(mut r_0) = v0 { 
 if let HCO::NODES(mut r_1) = v1 { 
r_0.append(&mut r_1);

                                args.push(HCO::NODES(r_0)); } }
                                 } 
/**
```
$1
```*/
fn _fn100 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                                
 if let HCO::NODES(mut r_0) = v0 { 

                                args.push(HCO::NODES(r_0)); }
                                 } 
/**
```
$__first__+$__last__
```*/
fn _fn101 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODES(mut r_0) = v0 { 
 if let HCO::NODE(r_1) = v1 { 
r_0.push(r_1);

                                args.push(HCO::NODES(r_0)); } }
                                 } 
/**
```
$1.productions+$2, $1
```*/
fn _fn102 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::NODE(r_0) = v0 { 
 let r_0 = (r_0).(Box<Productions>);
 if let HCO::NODE(r_1) = v1 { 
r_0.productions.push(r_1);
r_0.productions
 if let HCO::NODE(r_2) = v0 { 
 args.push(HCO::NODE(r_2)) } } }}
/**
```
$1.functions+$2, $1
```*/
fn _fn103 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::NODE(r_0) = v0 { 
 let r_0 = (r_0).(Box<Productions>);
 if let HCO::NODE(r_1) = v1 { 
r_0.functions.push(r_1);
r_0.functions
 if let HCO::NODE(r_2) = v0 { 
 args.push(HCO::NODE(r_2)) } } }}
/**
```
$1.ir+$2, $1
```*/
fn _fn104 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::NODE(r_0) = v0 { 
 let r_0 = (r_0).(Box<Productions>);
 if let HCO::NODE(r_1) = v1 { 
r_0.ir.push(r_1);
r_0.ir
 if let HCO::NODE(r_2) = v0 { 
 args.push(HCO::NODE(r_2)) } } }}
/**
```
[$1]
```*/
fn _fn105 (args:&mut Vec<HCO>, tok: Token){ 
                            let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                            
 let mut ref_0:Vec<Token> = Vec::new();
ref_0.push(v0.Token());

                            args.push(HCO::TOKENS(ref_0));
                        }
/**
```
$__first__+$__last__
```*/
fn _fn106 (args:&mut Vec<HCO>, tok: Token){ 
                            let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                            
 if let HCO::TOKENS(mut r_0)= v0 { 
r_0.push(0)
r_0.push(groupMap)
r_0.push(setFilter)
r_0.push(group)

                            args.push(HCO::TOKENS(r_0)); }
                        }
/**
```
$__first__+$__last__
```*/
fn _fn107 (args:&mut Vec<HCO>, tok: Token){ 
                            let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                            
 if let HCO::TOKENS(mut r_0)= v0 { 
r_0.push(v1);

                            args.push(HCO::TOKENS(r_0)); }
                        }
/**
```
[$1]
```*/
fn _fn108 (args:&mut Vec<HCO>, tok: Token){ 
                            let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                            
 let mut ref_0:Vec<Token> = Vec::new();
 if let HCO::TOKEN(r_0) = v0 { 
ref_0.push(r_0);

                            args.push(HCO::TOKENS(ref_0)); }
                        }
/**
```
$__first__+$__last__
```*/
fn _fn109 (args:&mut Vec<HCO>, tok: Token){ 
                            let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                            
 if let HCO::TOKENS(mut r_0)= v0 { 
 if let HCO::TOKEN(r_1) = v1 { 
r_0.push(r_1);

                            args.push(HCO::TOKENS(r_0)); } }
                        }
/**
```
i64($1)
```*/
fn _fn110 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                                
 if let HCO::TOKEN(r_0) = v0 { 

                                args.push(r_0.to_i64()); }
                            }
/**
```
str($1)
```*/
fn _fn111 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 if let HCO::TOKEN(r_0) = v0 { 
 args.push(HCO::STRING(r_0.String())) }}
/**
```
$2
```*/
fn _fn112 (args:&mut Vec<HCO>, tok: Token){ let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
 if let HCO::NODE(r_0) = v1 { 
 args.push(HCO::NODE(r_0)) }}
/**
```
$2
```*/
fn _fn113 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODES(mut r_0) = v1 { 

                                args.push(HCO::NODES(r_0)); }
                                 } 
/**
```
[$2]
```*/
fn _fn114 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 let mut ref_0:Vec<ASTNode> =  Vec::new();
 if let HCO::NODE(r_0) = v1 { 
ref_0.push(r_0);

                                args.push(HCO::NODES(ref_0)); }
                                 } 
/**
```
$__first__+$__last__
```*/
fn _fn115 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 if let HCO::OBJECTS(mut r_0) = v0 { 
 if let HCO::NODE(r_1) = v2 { 
r_0.push(r_1);

                                args.push(HCO::NODES(r_0)); } }
                                 } 
/**
```
[$2]
```*/
fn _fn116 (args:&mut Vec<HCO>, tok: Token){
                            let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
                                
 let mut ref_0:Vec<f64> = Vec::new();
ref_0.push((v1.len() as f64));

                                args.push(ref_0);
                            }
/**
```
[$2]
```*/
fn _fn117 (args:&mut Vec<HCO>, tok: Token){ 
                            let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                            
 let mut ref_0:Vec<String> = Vec::new();
ref_0.push(v1.String());

                            args.push(HCO::STRINGS(ref_0)); 
                        }
/**
```
$__first__+$__last__
```*/
fn _fn118 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 if let HCO::OBJECTS(mut r_0) = v0 { 
r_0.push(v2);

                                args.push(HCO::NODES(r_0)); }
                                 } 
/**
```
f64($1)
```*/
fn _fn119 (args:&mut Vec<HCO>, tok: Token){let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
 if let HCO::TOKEN(r_0) = v0 { 
args.push(HCO::DOUBLE(r_0.to_f64())) }}
/**
```

```*/
fn _fn120 (args:&mut Vec<HCO>, tok: Token){}
/**
```

```*/
fn _fn121 (args:&mut Vec<HCO>, tok: Token){  let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
 args.push(v1); }
/**
```

```*/
fn _fn122 (args:&mut Vec<HCO>, tok: Token){  let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
 args.push(v2); }



pub const FunctionMaps:[RF; 269]= [
    _fn120,_fn0,_fn1,_fn120,_fn120,_fn120,_fn121,_fn120,_fn120,_fn120,_fn120,_fn120,_fn121,_fn120,_fn122,_fn2,_fn3,_fn4,_fn5,_fn85,_fn121,_fn120,_fn120,_fn120,_fn120,_fn121,_fn121,_fn121,_fn120,_fn120,_fn6,_fn7,_fn6,_fn6,_fn6,_fn6,_fn7,_fn7,_fn7,_fn86,_fn120,_fn120,_fn8,_fn87,_fn121,_fn87,_fn87,_fn120,_fn120,_fn120,_fn9,_fn88,_fn89,_fn90,_fn89,_fn91,_fn92,_fn92,_fn90,_fn93,_fn10,_fn11,_fn12,_fn13,_fn14,_fn15,_fn16,_fn17,_fn18,_fn19,_fn20,_fn21,_fn13,_fn16,_fn22,_fn23,_fn24,_fn25,_fn24,_fn25,_fn120,_fn120,_fn120,_fn121,_fn121,_fn120,_fn120,_fn120,_fn120,_fn120,_fn120,_fn120,_fn122,_fn26,_fn121,_fn120,_fn86,_fn120,_fn120,_fn120,_fn120,_fn120,_fn120,_fn27,_fn28,_fn29,_fn120,_fn120,_fn120,_fn30,_fn31,_fn120,_fn120,_fn120,_fn120,_fn32,_fn33,_fn34,_fn35,_fn36,_fn94,_fn94,_fn37,_fn38,_fn39,_fn40,_fn41,_fn42,_fn43,_fn120,_fn95,_fn96,_fn44,_fn45,_fn97,_fn120,_fn120,_fn120,_fn46,_fn46,_fn47,_fn47,_fn48,_fn90,_fn98,_fn49,_fn50,_fn51,_fn52,_fn53,_fn54,_fn55,_fn56,_fn99,_fn100,_fn93,_fn90,_fn90,_fn86,_fn57,_fn58,_fn58,_fn90,_fn101,_fn59,_fn60,_fn61,_fn62,_fn63,_fn64,_fn120,_fn95,_fn90,_fn101,_fn120,_fn120,_fn120,_fn65,_fn90,_fn101,_fn120,_fn66,_fn66,_fn67,_fn67,_fn68,_fn69,_fn70,_fn102,_fn103,_fn104,_fn71,_fn72,_fn73,_fn74,_fn75,_fn122,_fn76,_fn77,_fn78,_fn79,_fn120,_fn105,_fn106,_fn105,_fn106,_fn105,_fn107,_fn108,_fn109,_fn90,_fn101,_fn90,_fn101,_fn90,_fn101,_fn90,_fn98,_fn90,_fn98,_fn80,_fn81,_fn82,_fn90,_fn98,_fn83,_fn90,_fn101,_fn90,_fn101,_fn110,_fn90,_fn101,_fn90,_fn101,_fn111,_fn87,_fn111,_fn111,_fn87,_fn87,_fn111,_fn87,_fn111,_fn87,_fn111,_fn87,_fn111,_fn111,_fn87,_fn87,_fn84,_fn112,_fn113,_fn111,_fn87,_fn111,_fn87,_fn114,_fn115,_fn116,_fn117,_fn118,_fn118,_fn82,_fn82,_fn82,_fn119,_fn111,
];
