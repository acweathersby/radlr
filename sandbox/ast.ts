
/* **** DO NOT MODIFY **** DO NOT MODIFY **** DO NOT MODIFY ****
 * 
 * This code has been automatically generated by Hydrocarbon Toolkit
 * 
 * ###################################################################
 * 
 * Copyright 2022 Anthony C. Weathersby
 * 
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included 
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 */


import {
    ASTNode,
    ByteReader,
    ByteWriter,
    Token,
    Deserialize as InternalDeserialize,
    SerializeType,
    SerializeVector,
    SerializeStructVector
} from "@hctoolkit/runtime";

export type c_Grammar = Grammar;


export function isGrammar(s:ASTNode<ASTType>): s is c_Grammar{
    return (s.type & 2) ==  2;
}
        

export type c_Version_6 = Grammar;


export function isVersion_6(s:ASTNode<ASTType>): s is c_Version_6{
    return (s.type & 4) ==  4;
}
        

export type c_IR = IR_STATE
   | ASSERT
   | PEEK
   | Reduce
   | TokenAssign
   | SetProd
   | ForkTo
   | ScanUntil
   | TokenId
   | Pass
   | Fail
   | NotInScope
   | SetScope
   | Consume
   | Goto
   | FailState
   | Symbols
   | Repeat
   | Lazy;


export function isIR(s:ASTNode<ASTType>): s is c_IR{
    return (s.type & 8) ==  8;
}
        

export type c_IrState = IR_STATE;


export function isIrState(s:ASTNode<ASTType>): s is c_IrState{
    return (s.type & 16) ==  16;
}
        

export type c_IR_Instruction = ASSERT
   | Reduce
   | TokenAssign
   | SetProd
   | ForkTo
   | ScanUntil
   | TokenId
   | Pass
   | Fail
   | NotInScope
   | SetScope
   | Consume
   | Goto
   | Repeat
   | Lazy;


export function isIR_Instruction(s:ASTNode<ASTType>): s is c_IR_Instruction{
    return (s.type & 32) ==  32;
}
        

export type c_IR_Branch = ASSERT
   | PEEK;


export function isIR_Branch(s:ASTNode<ASTType>): s is c_IR_Branch{
    return (s.type & 64) ==  64;
}
        

export type c_IR_Instructio = PEEK;


export function isIR_Instructio(s:ASTNode<ASTType>): s is c_IR_Instructio{
    return (s.type & 128) ==  128;
}
        

export type c_Symbol = Production_Symbol
   | Production_Import_Symbol
   | Reference
   | Generated
   | Exclusive_Literal
   | Literal
   | End_Of_File
   | Production_Token
   | Not_Symbol
   | Look_Behind
   | List_Production
   | Group_Production
   | Exclude
   | Look_Ignore
   | Empty;


export function isSymbol(s:ASTNode<ASTType>): s is c_Symbol{
    return (s.type & 256) ==  256;
}
        

export type c_Function = Returned
   | Referenced
   | Out_Of_Band;


export function isFunction(s:ASTNode<ASTType>): s is c_Function{
    return (s.type & 512) ==  512;
}
        

export type c_Token = Generated
   | Exclusive_Literal
   | Literal
   | End_Of_File
   | Production_Token;


export function isToken(s:ASTNode<ASTType>): s is c_Token{
    return (s.type & 1024) ==  1024;
}
        

export type c_Meta = Space
   | NewLine
   | IncreaseIndent
   | DecreaseIndent
   | Exclude
   | Look_Ignore;


export function isMeta(s:ASTNode<ASTType>): s is c_Meta{
    return (s.type & 2048) ==  2048;
}
        

export type c_Format = Space
   | NewLine
   | IncreaseIndent
   | DecreaseIndent;


export function isFormat(s:ASTNode<ASTType>): s is c_Format{
    return (s.type & 4096) ==  4096;
}
        

export type c_IR_State = FailState;


export function isIR_State(s:ASTNode<ASTType>): s is c_IR_State{
    return (s.type & 8192) ==  8192;
}
        

export type c_Production = Body
   | Production
   | ProductionMerged;


export function isProduction(s:ASTNode<ASTType>): s is c_Production{
    return (s.type & 16384) ==  16384;
}
        

export type c_Preamble = Ignore
   | Import
   | Export;


export function isPreamble(s:ASTNode<ASTType>): s is c_Preamble{
    return (s.type & 32768) ==  32768;
}
        


export enum ASTClass {
Grammar = 2,
Version_6 = 4,
IR = 8,
IrState = 16,
IR_Instruction = 32,
IR_Branch = 64,
IR_Instructio = 128,
Symbol = 256,
Function = 512,
Token = 1024,
Meta = 2048,
Format = 4096,
IR_State = 8192,
Production = 16384,
Preamble = 32768
}



export enum ASTType {
Meta = 720896,
Grammar = 786438,
IR_STATE = 851992,
ASSERT = 917608,
PEEK = 983240,
Production_Symbol = 1048832,
Production_Import_Symbol = 1114368,
Reduce = 1179688,
TokenAssign = 1245224,
SetProd = 1310760,
ForkTo = 1376296,
ScanUntil = 1441832,
TokenId = 1507368,
Pass = 1572904,
Fail = 1638440,
NotInScope = 1703976,
SetScope = 1769512,
Consume = 1835048,
Returned = 1901056,
Referenced = 1966592,
Reference = 2031872,
Generated = 2098432,
Exclusive_Literal = 2163968,
Literal = 2229504,
End_Of_File = 2295040,
Space = 2365440,
NewLine = 2430976,
IncreaseIndent = 2496512,
DecreaseIndent = 2562048,
Production_Token = 2622720,
Goto = 2687016,
FailState = 2760712,
Symbols = 2818056,
Not_Symbol = 2883840,
Look_Behind = 2949376,
List_Production = 3014912,
Group_Production = 3080448,
Body = 3162112,
Exclude = 3213568,
Look_Ignore = 3279104,
Empty = 3342592,
Production = 3424256,
ProductionMerged = 3489792,
Ignore = 3571712,
Import = 3637248,
Export = 3702784,
Productions = 3735552,
Out_Of_Band = 3801600,
Repeat = 3866664,
Lazy = 3932200,
Num = 3997696,
HASH_NAME = 4063232
}



export function Deserialize(reader: ByteReader){
    return InternalDeserialize(reader, DeserializeStruct)
}

function DeserializeStruct(reader: ByteReader): ASTNode<ASTType>{
    switch(reader.peek_byte()){
        
        case 0: return Meta.Deserialize(reader);
        case 0: return Grammar.Deserialize(reader);
        case 0: return IR_STATE.Deserialize(reader);
        case 0: return ASSERT.Deserialize(reader);
        case 0: return PEEK.Deserialize(reader);
        case 0: return Production_Symbol.Deserialize(reader);
        case 0: return Production_Import_Symbol.Deserialize(reader);
        case 0: return Reduce.Deserialize(reader);
        case 0: return TokenAssign.Deserialize(reader);
        case 0: return SetProd.Deserialize(reader);
        case 0: return ForkTo.Deserialize(reader);
        case 0: return ScanUntil.Deserialize(reader);
        case 0: return TokenId.Deserialize(reader);
        case 0: return Pass.Deserialize(reader);
        case 0: return Fail.Deserialize(reader);
        case 0: return NotInScope.Deserialize(reader);
        case 0: return SetScope.Deserialize(reader);
        case 0: return Consume.Deserialize(reader);
        case 0: return Returned.Deserialize(reader);
        case 0: return Referenced.Deserialize(reader);
        case 0: return Reference.Deserialize(reader);
        case 0: return Generated.Deserialize(reader);
        case 0: return Exclusive_Literal.Deserialize(reader);
        case 0: return Literal.Deserialize(reader);
        case 0: return End_Of_File.Deserialize(reader);
        case 0: return Space.Deserialize(reader);
        case 0: return NewLine.Deserialize(reader);
        case 0: return IncreaseIndent.Deserialize(reader);
        case 0: return DecreaseIndent.Deserialize(reader);
        case 0: return Production_Token.Deserialize(reader);
        case 0: return Goto.Deserialize(reader);
        case 0: return FailState.Deserialize(reader);
        case 0: return Symbols.Deserialize(reader);
        case 0: return Not_Symbol.Deserialize(reader);
        case 0: return Look_Behind.Deserialize(reader);
        case 0: return List_Production.Deserialize(reader);
        case 0: return Group_Production.Deserialize(reader);
        case 0: return Body.Deserialize(reader);
        case 0: return Exclude.Deserialize(reader);
        case 0: return Look_Ignore.Deserialize(reader);
        case 0: return Empty.Deserialize(reader);
        case 0: return Production.Deserialize(reader);
        case 0: return ProductionMerged.Deserialize(reader);
        case 0: return Ignore.Deserialize(reader);
        case 0: return Import.Deserialize(reader);
        case 0: return Export.Deserialize(reader);
        case 0: return Productions.Deserialize(reader);
        case 0: return Out_Of_Band.Deserialize(reader);
        case 0: return Repeat.Deserialize(reader);
        case 0: return Lazy.Deserialize(reader);
        case 0: return Num.Deserialize(reader);
        case 0: return HASH_NAME.Deserialize(reader);
    }
    throw new Error("Could not deserialize");
}


export class Meta extends ASTNode<ASTType> {
    
    all_symbols:c_Symbol[];
ignore_symbols:( string | number | boolean | Token )[];

    constructor(
        _all_symbols:c_Symbol[],
        _ignore_symbols:( string | number | boolean | Token )[],) 
    {
        super();
            this.all_symbols = _all_symbols;
        this.ignore_symbols = _ignore_symbols;
        
    }
    replace_all_symbols(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.all_symbols.length && j >= 0){
                return this.all_symbols.splice(j, 1)[0];
            }
        }else if(isSymbol(child)){
            if(j < 0){
                this.all_symbols.unshift(child);
            }else if(j >= this.all_symbols.length){
                this.all_symbols.push(child);
            }else {
                return this.all_symbols.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.all_symbols.length; i++){
            this.all_symbols[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_all_symbols(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Meta {
        if(typeof s == "object")
            return s instanceof Meta;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Meta {
        return s.type == ASTType.Meta;
    }

    static Type(): ASTType.Meta {
        return ASTType.Meta;
    }

    get type(): ASTType.Meta {
        return ASTType.Meta;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        SerializeStructVector(this.all_symbols, writer)
    SerializeVector(this.ignore_symbols, writer)
    }

    static Deserialize(reader:ByteReader): Meta {

        reader.assert_byte(0);

        
        var _all_symbols = Deserialize(reader);
var _ignore_symbols = Deserialize(reader)

        return new Meta(_all_symbols, _ignore_symbols);
    }
}



export class Grammar extends ASTNode<ASTType> {
    
    preamble:c_Preamble[];
productions:(Production | ProductionMerged)[];
ir_states:c_IrState[];
functions:Out_Of_Band[];
imported_grammars:c_Grammar[];
meta:Meta;
bodies:Body[];
tok:Token;

    constructor(
        _preamble:c_Preamble[],
        _productions:(Production | ProductionMerged)[],
        _ir_states:c_IrState[],
        _functions:Out_Of_Band[],
        _imported_grammars:c_Grammar[],
        _meta:Meta,
        _bodies:Body[],
        _tok:Token,) 
    {
        super();
            this.preamble = _preamble;
        this.productions = _productions;
        this.ir_states = _ir_states;
        this.functions = _functions;
        this.imported_grammars = _imported_grammars;
        this.meta = _meta;
        this.bodies = _bodies;
        this.tok = _tok;
        
    }
    replace_preamble(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.preamble.length && j >= 0){
                return this.preamble.splice(j, 1)[0];
            }
        }else if(isPreamble(child)){
            if(j < 0){
                this.preamble.unshift(child);
            }else if(j >= this.preamble.length){
                this.preamble.push(child);
            }else {
                return this.preamble.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    replace_productions(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.productions.length && j >= 0){
                return this.productions.splice(j, 1)[0];
            }
        }else if(Production.nodeIs(child)
    || ProductionMerged.nodeIs(child)){
            if(j < 0){
                this.productions.unshift(child);
            }else if(j >= this.productions.length){
                this.productions.push(child);
            }else {
                return this.productions.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    replace_ir_states(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.ir_states.length && j >= 0){
                return this.ir_states.splice(j, 1)[0];
            }
        }else if(isIrState(child)){
            if(j < 0){
                this.ir_states.unshift(child);
            }else if(j >= this.ir_states.length){
                this.ir_states.push(child);
            }else {
                return this.ir_states.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    replace_functions(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.functions.length && j >= 0){
                return this.functions.splice(j, 1)[0];
            }
        }else if(Out_Of_Band.nodeIs(child)){
            if(j < 0){
                this.functions.unshift(child);
            }else if(j >= this.functions.length){
                this.functions.push(child);
            }else {
                return this.functions.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    replace_imported_grammars(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.imported_grammars.length && j >= 0){
                return this.imported_grammars.splice(j, 1)[0];
            }
        }else if(isGrammar(child)){
            if(j < 0){
                this.imported_grammars.unshift(child);
            }else if(j >= this.imported_grammars.length){
                this.imported_grammars.push(child);
            }else {
                return this.imported_grammars.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    replace_meta(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(Meta.nodeIs(child)){
            
            let old = this.meta;           

            this.meta = child;
            
            return old;
        }
        return null;
    }

    replace_bodies(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.bodies.length && j >= 0){
                return this.bodies.splice(j, 1)[0];
            }
        }else if(Body.nodeIs(child)){
            if(j < 0){
                this.bodies.unshift(child);
            }else if(j >= this.bodies.length){
                this.bodies.push(child);
            }else {
                return this.bodies.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.preamble.length; i++){
            this.preamble[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    
        for(let i = 0; i < this.productions.length; i++){
            this.productions[i].$$____Iterate_$_$_$(_yield, this, 1, i);
        } 
    
        for(let i = 0; i < this.ir_states.length; i++){
            this.ir_states[i].$$____Iterate_$_$_$(_yield, this, 2, i);
        } 
    
        for(let i = 0; i < this.functions.length; i++){
            this.functions[i].$$____Iterate_$_$_$(_yield, this, 3, i);
        } 
    
        for(let i = 0; i < this.imported_grammars.length; i++){
            this.imported_grammars[i].$$____Iterate_$_$_$(_yield, this, 4, i);
        } 
    
        this.meta.$$____Iterate_$_$_$( _yield, this, 5, 0);
    
        for(let i = 0; i < this.bodies.length; i++){
            this.bodies[i].$$____Iterate_$_$_$(_yield, this, 6, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_preamble(child, j);
    case 1: return this.replace_productions(child, j);
    case 2: return this.replace_ir_states(child, j);
    case 3: return this.replace_functions(child, j);
    case 4: return this.replace_imported_grammars(child, j);
    case 5: return this.replace_meta(child);
    case 6: return this.replace_bodies(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Grammar {
        if(typeof s == "object")
            return s instanceof Grammar;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Grammar {
        return s.type == ASTType.Grammar;
    }

    static Type(): ASTType.Grammar {
        return ASTType.Grammar;
    }

    get type(): ASTType.Grammar {
        return ASTType.Grammar;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        SerializeStructVector(this.preamble, writer)

        SerializeStructVector(this.productions, writer)

        SerializeStructVector(this.ir_states, writer)

        SerializeStructVector(this.functions, writer)

        SerializeStructVector(this.imported_grammars, writer)

        this.meta.serialize(writer);

        SerializeStructVector(this.bodies, writer)

        this.tok.serialize(writer);
    }

    static Deserialize(reader:ByteReader): Grammar {

        reader.assert_byte(0);

        
        var _preamble = Deserialize(reader);

        var _productions = Deserialize(reader);

        var _ir_states = Deserialize(reader);

        var _functions = Deserialize(reader);

        var _imported_grammars = Deserialize(reader);

        var _meta = Meta.Deserialize(reader);

        var _bodies = Deserialize(reader);

        var _tok = Token.Deserialize(reader);

        return new Grammar(_preamble, _productions, _ir_states, _functions, _imported_grammars, _meta, _bodies, _tok);
    }
}



export class IR_STATE extends ASTNode<ASTType> {
    
    id:string;
instructions:(c_IR_Instruction | c_IR_Instructio)[];
fail:c_IR_State| null;
symbol_meta:Symbols| null;
prod:(Production_Symbol | Production_Import_Symbol)| null;

    constructor(
        _id:string,
        _instructions:(c_IR_Instruction | c_IR_Instructio)[],
        _fail:c_IR_State| null,
        _symbol_meta:Symbols| null,
        _prod:(Production_Symbol | Production_Import_Symbol)| null,) 
    {
        super();
            this.id = _id;
        this.instructions = _instructions;
        this.fail = _fail;
        this.symbol_meta = _symbol_meta;
        this.prod = _prod;
        
    }
    replace_instructions(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.instructions.length && j >= 0){
                return this.instructions.splice(j, 1)[0];
            }
        }else if(isIR_Instruction(child)
    || isIR_Instructio(child)){
            if(j < 0){
                this.instructions.unshift(child);
            }else if(j >= this.instructions.length){
                this.instructions.push(child);
            }else {
                return this.instructions.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    replace_fail(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.fail;           

            this.fail = null;
            
            return old;
        }
                     else 
        if(isIR_State(child)){
            
            let old = this.fail;           

            this.fail = child;
            
            return old;
        }
        return null;
    }

    replace_symbol_meta(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.symbol_meta;           

            this.symbol_meta = null;
            
            return old;
        }
                     else 
        if(Symbols.nodeIs(child)){
            
            let old = this.symbol_meta;           

            this.symbol_meta = child;
            
            return old;
        }
        return null;
    }

    replace_prod(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.prod;           

            this.prod = null;
            
            return old;
        }
                     else 
        if(Production_Symbol.nodeIs(child)
    || Production_Import_Symbol.nodeIs(child)){
            
            let old = this.prod;           

            this.prod = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.instructions.length; i++){
            this.instructions[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    
        if(this.fail instanceof ASTNode)
            this.fail.$$____Iterate_$_$_$( _yield, this, 1, 0);
    
        if(this.symbol_meta instanceof ASTNode)
            this.symbol_meta.$$____Iterate_$_$_$( _yield, this, 2, 0);
    
        if(this.prod instanceof ASTNode)
            this.prod.$$____Iterate_$_$_$( _yield, this, 3, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_instructions(child, j);
    case 1: return this.replace_fail(child);
    case 2: return this.replace_symbol_meta(child);
    case 3: return this.replace_prod(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is IR_STATE {
        if(typeof s == "object")
            return s instanceof IR_STATE;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is IR_STATE {
        return s.type == ASTType.IR_STATE;
    }

    static Type(): ASTType.IR_STATE {
        return ASTType.IR_STATE;
    }

    get type(): ASTType.IR_STATE {
        return ASTType.IR_STATE;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.id)

        SerializeStructVector(this.instructions, writer)

        if(!this.fail)
            writer.write_null();
        else 
            this.fail.serialize(writer);
        

        if(!this.symbol_meta)
            writer.write_null();
        else 
            this.symbol_meta.serialize(writer);
        

        if(!this.prod)
            writer.write_null();
        else 
            this.prod.serialize(writer);
        
    }

    static Deserialize(reader:ByteReader): IR_STATE {

        reader.assert_byte(0);

                 var _id = reader.read_string()

        var _instructions = Deserialize(reader);

        var _fail = reader.assert_null() ? null : FailState.Deserialize(reader);

        var _symbol_meta = reader.assert_null() ? null : Symbols.Deserialize(reader);

        var _prod = reader.assert_null() ? null : Deserialize(reader)

        return new IR_STATE(_id, _instructions, _fail, _symbol_meta, _prod);
    }
}



export class ASSERT extends ASTNode<ASTType> {
    
    mode:string;
ids:(Production_Symbol | Production_Import_Symbol | Num)[];
instructions:(Repeat | Reduce | TokenAssign | SetProd | ForkTo | ScanUntil | TokenId | Pass | Fail | NotInScope | SetScope | Consume | Goto | Lazy)[];

    constructor(
        _mode:string,
        _ids:(Production_Symbol | Production_Import_Symbol | Num)[],
        _instructions:(Repeat | Reduce | TokenAssign | SetProd | ForkTo | ScanUntil | TokenId | Pass | Fail | NotInScope | SetScope | Consume | Goto | Lazy)[],) 
    {
        super();
            this.mode = _mode;
        this.ids = _ids;
        this.instructions = _instructions;
        
    }
    replace_ids(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.ids.length && j >= 0){
                return this.ids.splice(j, 1)[0];
            }
        }else if(Production_Symbol.nodeIs(child)
    || Production_Import_Symbol.nodeIs(child)
    || Num.nodeIs(child)){
            if(j < 0){
                this.ids.unshift(child);
            }else if(j >= this.ids.length){
                this.ids.push(child);
            }else {
                return this.ids.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    replace_instructions(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.instructions.length && j >= 0){
                return this.instructions.splice(j, 1)[0];
            }
        }else if(Repeat.nodeIs(child)
    || Reduce.nodeIs(child)
    || TokenAssign.nodeIs(child)
    || SetProd.nodeIs(child)
    || ForkTo.nodeIs(child)
    || ScanUntil.nodeIs(child)
    || TokenId.nodeIs(child)
    || Pass.nodeIs(child)
    || Fail.nodeIs(child)
    || NotInScope.nodeIs(child)
    || SetScope.nodeIs(child)
    || Consume.nodeIs(child)
    || Goto.nodeIs(child)
    || Lazy.nodeIs(child)){
            if(j < 0){
                this.instructions.unshift(child);
            }else if(j >= this.instructions.length){
                this.instructions.push(child);
            }else {
                return this.instructions.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.ids.length; i++){
            this.ids[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    
        for(let i = 0; i < this.instructions.length; i++){
            this.instructions[i].$$____Iterate_$_$_$(_yield, this, 1, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_ids(child, j);
    case 1: return this.replace_instructions(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is ASSERT {
        if(typeof s == "object")
            return s instanceof ASSERT;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is ASSERT {
        return s.type == ASTType.ASSERT;
    }

    static Type(): ASTType.ASSERT {
        return ASTType.ASSERT;
    }

    get type(): ASTType.ASSERT {
        return ASTType.ASSERT;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.mode)

        SerializeStructVector(this.ids, writer)

        SerializeStructVector(this.instructions, writer)
    }

    static Deserialize(reader:ByteReader): ASSERT {

        reader.assert_byte(0);

                 var _mode = reader.read_string()

        var _ids = Deserialize(reader);

        var _instructions = Deserialize(reader);

        return new ASSERT(_mode, _ids, _instructions);
    }
}



export class PEEK extends ASTNode<ASTType> {
    
    mode:string;
ids:(c_Token | c_Format | Num)[];
instructions:(Repeat | Reduce | TokenAssign | SetProd | ForkTo | ScanUntil | TokenId | Pass | Fail | NotInScope | SetScope | Consume | Goto | Lazy)[];

    constructor(
        _mode:string,
        _ids:(c_Token | c_Format | Num)[],
        _instructions:(Repeat | Reduce | TokenAssign | SetProd | ForkTo | ScanUntil | TokenId | Pass | Fail | NotInScope | SetScope | Consume | Goto | Lazy)[],) 
    {
        super();
            this.mode = _mode;
        this.ids = _ids;
        this.instructions = _instructions;
        
    }
    replace_ids(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.ids.length && j >= 0){
                return this.ids.splice(j, 1)[0];
            }
        }else if(isToken(child)
    || isFormat(child)
    || Num.nodeIs(child)){
            if(j < 0){
                this.ids.unshift(child);
            }else if(j >= this.ids.length){
                this.ids.push(child);
            }else {
                return this.ids.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    replace_instructions(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.instructions.length && j >= 0){
                return this.instructions.splice(j, 1)[0];
            }
        }else if(Repeat.nodeIs(child)
    || Reduce.nodeIs(child)
    || TokenAssign.nodeIs(child)
    || SetProd.nodeIs(child)
    || ForkTo.nodeIs(child)
    || ScanUntil.nodeIs(child)
    || TokenId.nodeIs(child)
    || Pass.nodeIs(child)
    || Fail.nodeIs(child)
    || NotInScope.nodeIs(child)
    || SetScope.nodeIs(child)
    || Consume.nodeIs(child)
    || Goto.nodeIs(child)
    || Lazy.nodeIs(child)){
            if(j < 0){
                this.instructions.unshift(child);
            }else if(j >= this.instructions.length){
                this.instructions.push(child);
            }else {
                return this.instructions.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.ids.length; i++){
            this.ids[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    
        for(let i = 0; i < this.instructions.length; i++){
            this.instructions[i].$$____Iterate_$_$_$(_yield, this, 1, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_ids(child, j);
    case 1: return this.replace_instructions(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is PEEK {
        if(typeof s == "object")
            return s instanceof PEEK;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is PEEK {
        return s.type == ASTType.PEEK;
    }

    static Type(): ASTType.PEEK {
        return ASTType.PEEK;
    }

    get type(): ASTType.PEEK {
        return ASTType.PEEK;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.mode)

        SerializeStructVector(this.ids, writer)

        SerializeStructVector(this.instructions, writer)
    }

    static Deserialize(reader:ByteReader): PEEK {

        reader.assert_byte(0);

                 var _mode = reader.read_string()

        var _ids = Deserialize(reader);

        var _instructions = Deserialize(reader);

        return new PEEK(_mode, _ids, _instructions);
    }
}



export class Production_Symbol extends ASTNode<ASTType> {
    
    name:string;
production:c_Production| null;
val:number;
annotation:Reference| null;
tok:Token;
IS_OPTIONAL:number;
IS_NON_CAPTURE:boolean;

    constructor(
        _name:string,
        _production:c_Production| null,
        _val:number,
        _annotation:Reference| null,
        _tok:Token,
        _IS_OPTIONAL:number,
        _IS_NON_CAPTURE:boolean,) 
    {
        super();
            this.name = _name;
        this.production = _production;
        this.val = _val;
        this.annotation = _annotation;
        this.tok = _tok;
        this.IS_OPTIONAL = _IS_OPTIONAL;
        this.IS_NON_CAPTURE = _IS_NON_CAPTURE;
        
    }
    replace_production(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.production;           

            this.production = null;
            
            return old;
        }
                     else 
        if(isProduction(child)){
            
            let old = this.production;           

            this.production = child;
            
            return old;
        }
        return null;
    }

    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.annotation;           

            this.annotation = null;
            
            return old;
        }
                     else 
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        if(this.production instanceof ASTNode)
            this.production.$$____Iterate_$_$_$( _yield, this, 0, 0);
    
        if(this.annotation instanceof ASTNode)
            this.annotation.$$____Iterate_$_$_$( _yield, this, 1, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_production(child);
    case 1: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Production_Symbol {
        if(typeof s == "object")
            return s instanceof Production_Symbol;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Production_Symbol {
        return s.type == ASTType.Production_Symbol;
    }

    static Type(): ASTType.Production_Symbol {
        return ASTType.Production_Symbol;
    }

    get type(): ASTType.Production_Symbol {
        return ASTType.Production_Symbol;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.name)

        if(!this.production)
            writer.write_null();
        else 
            this.production.serialize(writer);
        
            writer.write_double(this.val)

        if(!this.annotation)
            writer.write_null();
        else 
            this.annotation.serialize(writer);
        

        this.tok.serialize(writer);
            writer.write_double(this.IS_OPTIONAL)
           writer.write_byte(this.IS_NON_CAPTURE ==  true ? 1 : 0)
    }

    static Deserialize(reader:ByteReader): Production_Symbol {

        reader.assert_byte(0);

                 var _name = reader.read_string()

        var _production = reader.assert_null() ? null : Deserialize(reader)
            var _val = reader.read_double()

        var _annotation = reader.assert_null() ? null : Reference.Deserialize(reader);

        var _tok = Token.Deserialize(reader);
            var _IS_OPTIONAL = reader.read_double()
           var _IS_NON_CAPTURE = !!reader.read_byte()

        return new Production_Symbol(_name, _production, _val, _annotation, _tok, _IS_OPTIONAL, _IS_NON_CAPTURE);
    }
}



export class Production_Import_Symbol extends ASTNode<ASTType> {
    
    module:string;
name:string;
production:c_Production| null;
annotation:Reference| null;
tok:Token;
IS_OPTIONAL:number;
IS_NON_CAPTURE:boolean;

    constructor(
        _module:string,
        _name:string,
        _production:c_Production| null,
        _annotation:Reference| null,
        _tok:Token,
        _IS_OPTIONAL:number,
        _IS_NON_CAPTURE:boolean,) 
    {
        super();
            this.module = _module;
        this.name = _name;
        this.production = _production;
        this.annotation = _annotation;
        this.tok = _tok;
        this.IS_OPTIONAL = _IS_OPTIONAL;
        this.IS_NON_CAPTURE = _IS_NON_CAPTURE;
        
    }
    replace_production(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.production;           

            this.production = null;
            
            return old;
        }
                     else 
        if(isProduction(child)){
            
            let old = this.production;           

            this.production = child;
            
            return old;
        }
        return null;
    }

    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.annotation;           

            this.annotation = null;
            
            return old;
        }
                     else 
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        if(this.production instanceof ASTNode)
            this.production.$$____Iterate_$_$_$( _yield, this, 0, 0);
    
        if(this.annotation instanceof ASTNode)
            this.annotation.$$____Iterate_$_$_$( _yield, this, 1, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_production(child);
    case 1: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Production_Import_Symbol {
        if(typeof s == "object")
            return s instanceof Production_Import_Symbol;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Production_Import_Symbol {
        return s.type == ASTType.Production_Import_Symbol;
    }

    static Type(): ASTType.Production_Import_Symbol {
        return ASTType.Production_Import_Symbol;
    }

    get type(): ASTType.Production_Import_Symbol {
        return ASTType.Production_Import_Symbol;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.module)
         writer.write_string(this.name)

        if(!this.production)
            writer.write_null();
        else 
            this.production.serialize(writer);
        

        if(!this.annotation)
            writer.write_null();
        else 
            this.annotation.serialize(writer);
        

        this.tok.serialize(writer);
            writer.write_double(this.IS_OPTIONAL)
           writer.write_byte(this.IS_NON_CAPTURE ==  true ? 1 : 0)
    }

    static Deserialize(reader:ByteReader): Production_Import_Symbol {

        reader.assert_byte(0);

                 var _module = reader.read_string()
         var _name = reader.read_string()

        var _production = reader.assert_null() ? null : Deserialize(reader)

        var _annotation = reader.assert_null() ? null : Reference.Deserialize(reader);

        var _tok = Token.Deserialize(reader);
            var _IS_OPTIONAL = reader.read_double()
           var _IS_NON_CAPTURE = !!reader.read_byte()

        return new Production_Import_Symbol(_module, _name, _production, _annotation, _tok, _IS_OPTIONAL, _IS_NON_CAPTURE);
    }
}



export class Reduce extends ASTNode<ASTType> {
    
    len:number;
body_id:number;
reduce_fn:(Returned | Referenced)| null;

    constructor(
        _len:number,
        _body_id:number,
        _reduce_fn:(Returned | Referenced)| null,) 
    {
        super();
            this.len = _len;
        this.body_id = _body_id;
        this.reduce_fn = _reduce_fn;
        
    }
    replace_reduce_fn(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.reduce_fn;           

            this.reduce_fn = null;
            
            return old;
        }
                     else 
        if(Returned.nodeIs(child)
    || Referenced.nodeIs(child)){
            
            let old = this.reduce_fn;           

            this.reduce_fn = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        if(this.reduce_fn instanceof ASTNode)
            this.reduce_fn.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_reduce_fn(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Reduce {
        if(typeof s == "object")
            return s instanceof Reduce;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Reduce {
        return s.type == ASTType.Reduce;
    }

    static Type(): ASTType.Reduce {
        return ASTType.Reduce;
    }

    get type(): ASTType.Reduce {
        return ASTType.Reduce;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                    writer.write_word(this.len)
            writer.write_word(this.body_id)

        if(!this.reduce_fn)
            writer.write_null();
        else 
            this.reduce_fn.serialize(writer);
        
    }

    static Deserialize(reader:ByteReader): Reduce {

        reader.assert_byte(0);

                    var _len = reader.read_word()
            var _body_id = reader.read_word()

        var _reduce_fn = reader.assert_null() ? null : Deserialize(reader)

        return new Reduce(_len, _body_id, _reduce_fn);
    }
}



export class TokenAssign extends ASTNode<ASTType> {
    
    ids:(c_Token | c_Format | Num)[];

    constructor(
        _ids:(c_Token | c_Format | Num)[],) 
    {
        super();
            this.ids = _ids;
        
    }
    replace_ids(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.ids.length && j >= 0){
                return this.ids.splice(j, 1)[0];
            }
        }else if(isToken(child)
    || isFormat(child)
    || Num.nodeIs(child)){
            if(j < 0){
                this.ids.unshift(child);
            }else if(j >= this.ids.length){
                this.ids.push(child);
            }else {
                return this.ids.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.ids.length; i++){
            this.ids[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_ids(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is TokenAssign {
        if(typeof s == "object")
            return s instanceof TokenAssign;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is TokenAssign {
        return s.type == ASTType.TokenAssign;
    }

    static Type(): ASTType.TokenAssign {
        return ASTType.TokenAssign;
    }

    get type(): ASTType.TokenAssign {
        return ASTType.TokenAssign;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        SerializeStructVector(this.ids, writer)
    }

    static Deserialize(reader:ByteReader): TokenAssign {

        reader.assert_byte(0);

        
        var _ids = Deserialize(reader);

        return new TokenAssign(_ids);
    }
}



export class SetProd extends ASTNode<ASTType> {
    
    id:(Production_Symbol | Production_Import_Symbol | Num);

    constructor(
        _id:(Production_Symbol | Production_Import_Symbol | Num),) 
    {
        super();
            this.id = _id;
        
    }
    replace_id(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(Production_Symbol.nodeIs(child)
    || Production_Import_Symbol.nodeIs(child)
    || Num.nodeIs(child)){
            
            let old = this.id;           

            this.id = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.id.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_id(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is SetProd {
        if(typeof s == "object")
            return s instanceof SetProd;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is SetProd {
        return s.type == ASTType.SetProd;
    }

    static Type(): ASTType.SetProd {
        return ASTType.SetProd;
    }

    get type(): ASTType.SetProd {
        return ASTType.SetProd;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        this.id.serialize(writer);
    }

    static Deserialize(reader:ByteReader): SetProd {

        reader.assert_byte(0);

        
        var _id = Deserialize(reader)

        return new SetProd(_id);
    }
}



export class ForkTo extends ASTNode<ASTType> {
    
    states:(Production_Symbol | Production_Import_Symbol | HASH_NAME)[];

    constructor(
        _states:(Production_Symbol | Production_Import_Symbol | HASH_NAME)[],) 
    {
        super();
            this.states = _states;
        
    }
    replace_states(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.states.length && j >= 0){
                return this.states.splice(j, 1)[0];
            }
        }else if(Production_Symbol.nodeIs(child)
    || Production_Import_Symbol.nodeIs(child)
    || HASH_NAME.nodeIs(child)){
            if(j < 0){
                this.states.unshift(child);
            }else if(j >= this.states.length){
                this.states.push(child);
            }else {
                return this.states.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.states.length; i++){
            this.states[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_states(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is ForkTo {
        if(typeof s == "object")
            return s instanceof ForkTo;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is ForkTo {
        return s.type == ASTType.ForkTo;
    }

    static Type(): ASTType.ForkTo {
        return ASTType.ForkTo;
    }

    get type(): ASTType.ForkTo {
        return ASTType.ForkTo;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        SerializeStructVector(this.states, writer)
    }

    static Deserialize(reader:ByteReader): ForkTo {

        reader.assert_byte(0);

        
        var _states = Deserialize(reader);

        return new ForkTo(_states);
    }
}



export class ScanUntil extends ASTNode<ASTType> {
    
    ids:(c_Token | c_Format | Num)[];
SCAN_BACKWARDS:boolean;

    constructor(
        _ids:(c_Token | c_Format | Num)[],
        _SCAN_BACKWARDS:boolean,) 
    {
        super();
            this.ids = _ids;
        this.SCAN_BACKWARDS = _SCAN_BACKWARDS;
        
    }
    replace_ids(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.ids.length && j >= 0){
                return this.ids.splice(j, 1)[0];
            }
        }else if(isToken(child)
    || isFormat(child)
    || Num.nodeIs(child)){
            if(j < 0){
                this.ids.unshift(child);
            }else if(j >= this.ids.length){
                this.ids.push(child);
            }else {
                return this.ids.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.ids.length; i++){
            this.ids[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_ids(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is ScanUntil {
        if(typeof s == "object")
            return s instanceof ScanUntil;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is ScanUntil {
        return s.type == ASTType.ScanUntil;
    }

    static Type(): ASTType.ScanUntil {
        return ASTType.ScanUntil;
    }

    get type(): ASTType.ScanUntil {
        return ASTType.ScanUntil;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        SerializeStructVector(this.ids, writer)
           writer.write_byte(this.SCAN_BACKWARDS ==  true ? 1 : 0)
    }

    static Deserialize(reader:ByteReader): ScanUntil {

        reader.assert_byte(0);

        
        var _ids = Deserialize(reader);
           var _SCAN_BACKWARDS = !!reader.read_byte()

        return new ScanUntil(_ids, _SCAN_BACKWARDS);
    }
}



export class TokenId extends ASTNode<ASTType> {
    
    id:(c_Token | c_Format | Num);

    constructor(
        _id:(c_Token | c_Format | Num),) 
    {
        super();
            this.id = _id;
        
    }
    replace_id(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(isToken(child)
    || isFormat(child)
    || Num.nodeIs(child)){
            
            let old = this.id;           

            this.id = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.id.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_id(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is TokenId {
        if(typeof s == "object")
            return s instanceof TokenId;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is TokenId {
        return s.type == ASTType.TokenId;
    }

    static Type(): ASTType.TokenId {
        return ASTType.TokenId;
    }

    get type(): ASTType.TokenId {
        return ASTType.TokenId;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        this.id.serialize(writer);
    }

    static Deserialize(reader:ByteReader): TokenId {

        reader.assert_byte(0);

        
        var _id = Deserialize(reader)

        return new TokenId(_id);
    }
}



export class Pass extends ASTNode<ASTType> {
    
    

    constructor() 
    {
        super();
            
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Pass {
        if(typeof s == "object")
            return s instanceof Pass;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Pass {
        return s.type == ASTType.Pass;
    }

    static Type(): ASTType.Pass {
        return ASTType.Pass;
    }

    get type(): ASTType.Pass {
        return ASTType.Pass;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
    }

    static Deserialize(reader:ByteReader): Pass {

        reader.assert_byte(0);

        

        return new Pass();
    }
}



export class Fail extends ASTNode<ASTType> {
    
    

    constructor() 
    {
        super();
            
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Fail {
        if(typeof s == "object")
            return s instanceof Fail;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Fail {
        return s.type == ASTType.Fail;
    }

    static Type(): ASTType.Fail {
        return ASTType.Fail;
    }

    get type(): ASTType.Fail {
        return ASTType.Fail;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
    }

    static Deserialize(reader:ByteReader): Fail {

        reader.assert_byte(0);

        

        return new Fail();
    }
}



export class NotInScope extends ASTNode<ASTType> {
    
    ids:(Production_Symbol | Production_Import_Symbol | Num)[];

    constructor(
        _ids:(Production_Symbol | Production_Import_Symbol | Num)[],) 
    {
        super();
            this.ids = _ids;
        
    }
    replace_ids(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.ids.length && j >= 0){
                return this.ids.splice(j, 1)[0];
            }
        }else if(Production_Symbol.nodeIs(child)
    || Production_Import_Symbol.nodeIs(child)
    || Num.nodeIs(child)){
            if(j < 0){
                this.ids.unshift(child);
            }else if(j >= this.ids.length){
                this.ids.push(child);
            }else {
                return this.ids.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.ids.length; i++){
            this.ids[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_ids(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is NotInScope {
        if(typeof s == "object")
            return s instanceof NotInScope;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is NotInScope {
        return s.type == ASTType.NotInScope;
    }

    static Type(): ASTType.NotInScope {
        return ASTType.NotInScope;
    }

    get type(): ASTType.NotInScope {
        return ASTType.NotInScope;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        SerializeStructVector(this.ids, writer)
    }

    static Deserialize(reader:ByteReader): NotInScope {

        reader.assert_byte(0);

        
        var _ids = Deserialize(reader);

        return new NotInScope(_ids);
    }
}



export class SetScope extends ASTNode<ASTType> {
    
    scope:number;

    constructor(
        _scope:number,) 
    {
        super();
            this.scope = _scope;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is SetScope {
        if(typeof s == "object")
            return s instanceof SetScope;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is SetScope {
        return s.type == ASTType.SetScope;
    }

    static Type(): ASTType.SetScope {
        return ASTType.SetScope;
    }

    get type(): ASTType.SetScope {
        return ASTType.SetScope;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                    writer.write_double_word(this.scope)
    }

    static Deserialize(reader:ByteReader): SetScope {

        reader.assert_byte(0);

                    var _scope = reader.read_double_word()

        return new SetScope(_scope);
    }
}



export class Consume extends ASTNode<ASTType> {
    
    EMPTY:boolean;

    constructor(
        _EMPTY:boolean,) 
    {
        super();
            this.EMPTY = _EMPTY;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Consume {
        if(typeof s == "object")
            return s instanceof Consume;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Consume {
        return s.type == ASTType.Consume;
    }

    static Type(): ASTType.Consume {
        return ASTType.Consume;
    }

    get type(): ASTType.Consume {
        return ASTType.Consume;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                   writer.write_byte(this.EMPTY ==  true ? 1 : 0)
    }

    static Deserialize(reader:ByteReader): Consume {

        reader.assert_byte(0);

                   var _EMPTY = !!reader.read_byte()

        return new Consume(_EMPTY);
    }
}



export class Returned extends ASTNode<ASTType> {
    
    txt:string;
name:string;
env:boolean;
ref:string;
IS_CONDITION:boolean;

    constructor(
        _txt:string,
        _name:string,
        _env:boolean,
        _ref:string,
        _IS_CONDITION:boolean,) 
    {
        super();
            this.txt = _txt;
        this.name = _name;
        this.env = _env;
        this.ref = _ref;
        this.IS_CONDITION = _IS_CONDITION;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Returned {
        if(typeof s == "object")
            return s instanceof Returned;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Returned {
        return s.type == ASTType.Returned;
    }

    static Type(): ASTType.Returned {
        return ASTType.Returned;
    }

    get type(): ASTType.Returned {
        return ASTType.Returned;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.txt)
         writer.write_string(this.name)
           writer.write_byte(this.env ==  true ? 1 : 0)
         writer.write_string(this.ref)
           writer.write_byte(this.IS_CONDITION ==  true ? 1 : 0)
    }

    static Deserialize(reader:ByteReader): Returned {

        reader.assert_byte(0);

                 var _txt = reader.read_string()
         var _name = reader.read_string()
           var _env = !!reader.read_byte()
         var _ref = reader.read_string()
           var _IS_CONDITION = !!reader.read_byte()

        return new Returned(_txt, _name, _env, _ref, _IS_CONDITION);
    }
}



export class Referenced extends ASTNode<ASTType> {
    
    ref:Reference;

    constructor(
        _ref:Reference,) 
    {
        super();
            this.ref = _ref;
        
    }
    replace_ref(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(Reference.nodeIs(child)){
            
            let old = this.ref;           

            this.ref = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.ref.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_ref(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Referenced {
        if(typeof s == "object")
            return s instanceof Referenced;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Referenced {
        return s.type == ASTType.Referenced;
    }

    static Type(): ASTType.Referenced {
        return ASTType.Referenced;
    }

    get type(): ASTType.Referenced {
        return ASTType.Referenced;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        this.ref.serialize(writer);
    }

    static Deserialize(reader:ByteReader): Referenced {

        reader.assert_byte(0);

        
        var _ref = Reference.Deserialize(reader);

        return new Referenced(_ref);
    }
}



export class Reference extends ASTNode<ASTType> {
    
    val:string;

    constructor(
        _val:string,) 
    {
        super();
            this.val = _val;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Reference {
        if(typeof s == "object")
            return s instanceof Reference;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Reference {
        return s.type == ASTType.Reference;
    }

    static Type(): ASTType.Reference {
        return ASTType.Reference;
    }

    get type(): ASTType.Reference {
        return ASTType.Reference;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.val)
    }

    static Deserialize(reader:ByteReader): Reference {

        reader.assert_byte(0);

                 var _val = reader.read_string()

        return new Reference(_val);
    }
}



export class Generated extends ASTNode<ASTType> {
    
    val:string;
annotation:Reference| null;
tok:Token;
IS_OPTIONAL:number;
IS_NON_CAPTURE:boolean;

    constructor(
        _val:string,
        _annotation:Reference| null,
        _tok:Token,
        _IS_OPTIONAL:number,
        _IS_NON_CAPTURE:boolean,) 
    {
        super();
            this.val = _val;
        this.annotation = _annotation;
        this.tok = _tok;
        this.IS_OPTIONAL = _IS_OPTIONAL;
        this.IS_NON_CAPTURE = _IS_NON_CAPTURE;
        
    }
    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.annotation;           

            this.annotation = null;
            
            return old;
        }
                     else 
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        if(this.annotation instanceof ASTNode)
            this.annotation.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Generated {
        if(typeof s == "object")
            return s instanceof Generated;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Generated {
        return s.type == ASTType.Generated;
    }

    static Type(): ASTType.Generated {
        return ASTType.Generated;
    }

    get type(): ASTType.Generated {
        return ASTType.Generated;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.val)

        if(!this.annotation)
            writer.write_null();
        else 
            this.annotation.serialize(writer);
        

        this.tok.serialize(writer);
            writer.write_double(this.IS_OPTIONAL)
           writer.write_byte(this.IS_NON_CAPTURE ==  true ? 1 : 0)
    }

    static Deserialize(reader:ByteReader): Generated {

        reader.assert_byte(0);

                 var _val = reader.read_string()

        var _annotation = reader.assert_null() ? null : Reference.Deserialize(reader);

        var _tok = Token.Deserialize(reader);
            var _IS_OPTIONAL = reader.read_double()
           var _IS_NON_CAPTURE = !!reader.read_byte()

        return new Generated(_val, _annotation, _tok, _IS_OPTIONAL, _IS_NON_CAPTURE);
    }
}



export class Exclusive_Literal extends ASTNode<ASTType> {
    
    val:string;
annotation:Reference| null;
tok:Token;
IS_OPTIONAL:number;
IS_NON_CAPTURE:boolean;

    constructor(
        _val:string,
        _annotation:Reference| null,
        _tok:Token,
        _IS_OPTIONAL:number,
        _IS_NON_CAPTURE:boolean,) 
    {
        super();
            this.val = _val;
        this.annotation = _annotation;
        this.tok = _tok;
        this.IS_OPTIONAL = _IS_OPTIONAL;
        this.IS_NON_CAPTURE = _IS_NON_CAPTURE;
        
    }
    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.annotation;           

            this.annotation = null;
            
            return old;
        }
                     else 
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        if(this.annotation instanceof ASTNode)
            this.annotation.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Exclusive_Literal {
        if(typeof s == "object")
            return s instanceof Exclusive_Literal;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Exclusive_Literal {
        return s.type == ASTType.Exclusive_Literal;
    }

    static Type(): ASTType.Exclusive_Literal {
        return ASTType.Exclusive_Literal;
    }

    get type(): ASTType.Exclusive_Literal {
        return ASTType.Exclusive_Literal;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.val)

        if(!this.annotation)
            writer.write_null();
        else 
            this.annotation.serialize(writer);
        

        this.tok.serialize(writer);
            writer.write_double(this.IS_OPTIONAL)
           writer.write_byte(this.IS_NON_CAPTURE ==  true ? 1 : 0)
    }

    static Deserialize(reader:ByteReader): Exclusive_Literal {

        reader.assert_byte(0);

                 var _val = reader.read_string()

        var _annotation = reader.assert_null() ? null : Reference.Deserialize(reader);

        var _tok = Token.Deserialize(reader);
            var _IS_OPTIONAL = reader.read_double()
           var _IS_NON_CAPTURE = !!reader.read_byte()

        return new Exclusive_Literal(_val, _annotation, _tok, _IS_OPTIONAL, _IS_NON_CAPTURE);
    }
}



export class Literal extends ASTNode<ASTType> {
    
    val:string;
annotation:Reference| null;
tok:Token;
IS_OPTIONAL:number;
IS_NON_CAPTURE:boolean;

    constructor(
        _val:string,
        _annotation:Reference| null,
        _tok:Token,
        _IS_OPTIONAL:number,
        _IS_NON_CAPTURE:boolean,) 
    {
        super();
            this.val = _val;
        this.annotation = _annotation;
        this.tok = _tok;
        this.IS_OPTIONAL = _IS_OPTIONAL;
        this.IS_NON_CAPTURE = _IS_NON_CAPTURE;
        
    }
    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.annotation;           

            this.annotation = null;
            
            return old;
        }
                     else 
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        if(this.annotation instanceof ASTNode)
            this.annotation.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Literal {
        if(typeof s == "object")
            return s instanceof Literal;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Literal {
        return s.type == ASTType.Literal;
    }

    static Type(): ASTType.Literal {
        return ASTType.Literal;
    }

    get type(): ASTType.Literal {
        return ASTType.Literal;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.val)

        if(!this.annotation)
            writer.write_null();
        else 
            this.annotation.serialize(writer);
        

        this.tok.serialize(writer);
            writer.write_double(this.IS_OPTIONAL)
           writer.write_byte(this.IS_NON_CAPTURE ==  true ? 1 : 0)
    }

    static Deserialize(reader:ByteReader): Literal {

        reader.assert_byte(0);

                 var _val = reader.read_string()

        var _annotation = reader.assert_null() ? null : Reference.Deserialize(reader);

        var _tok = Token.Deserialize(reader);
            var _IS_OPTIONAL = reader.read_double()
           var _IS_NON_CAPTURE = !!reader.read_byte()

        return new Literal(_val, _annotation, _tok, _IS_OPTIONAL, _IS_NON_CAPTURE);
    }
}



export class End_Of_File extends ASTNode<ASTType> {
    
    val:string;
annotation:Reference| null;
tok:Token;
IS_OPTIONAL:number;
IS_NON_CAPTURE:boolean;

    constructor(
        _val:string,
        _annotation:Reference| null,
        _tok:Token,
        _IS_OPTIONAL:number,
        _IS_NON_CAPTURE:boolean,) 
    {
        super();
            this.val = _val;
        this.annotation = _annotation;
        this.tok = _tok;
        this.IS_OPTIONAL = _IS_OPTIONAL;
        this.IS_NON_CAPTURE = _IS_NON_CAPTURE;
        
    }
    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.annotation;           

            this.annotation = null;
            
            return old;
        }
                     else 
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        if(this.annotation instanceof ASTNode)
            this.annotation.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is End_Of_File {
        if(typeof s == "object")
            return s instanceof End_Of_File;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is End_Of_File {
        return s.type == ASTType.End_Of_File;
    }

    static Type(): ASTType.End_Of_File {
        return ASTType.End_Of_File;
    }

    get type(): ASTType.End_Of_File {
        return ASTType.End_Of_File;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.val)

        if(!this.annotation)
            writer.write_null();
        else 
            this.annotation.serialize(writer);
        

        this.tok.serialize(writer);
            writer.write_double(this.IS_OPTIONAL)
           writer.write_byte(this.IS_NON_CAPTURE ==  true ? 1 : 0)
    }

    static Deserialize(reader:ByteReader): End_Of_File {

        reader.assert_byte(0);

                 var _val = reader.read_string()

        var _annotation = reader.assert_null() ? null : Reference.Deserialize(reader);

        var _tok = Token.Deserialize(reader);
            var _IS_OPTIONAL = reader.read_double()
           var _IS_NON_CAPTURE = !!reader.read_byte()

        return new End_Of_File(_val, _annotation, _tok, _IS_OPTIONAL, _IS_NON_CAPTURE);
    }
}



export class Space extends ASTNode<ASTType> {
    
    position:number;
IS_OPTIONAL:number;
IS_NON_CAPTURE:boolean;
annotation:Reference;

    constructor(
        _position:number,
        _IS_OPTIONAL:number,
        _IS_NON_CAPTURE:boolean,
        _annotation:Reference,) 
    {
        super();
            this.position = _position;
        this.IS_OPTIONAL = _IS_OPTIONAL;
        this.IS_NON_CAPTURE = _IS_NON_CAPTURE;
        this.annotation = _annotation;
        
    }
    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.annotation.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Space {
        if(typeof s == "object")
            return s instanceof Space;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Space {
        return s.type == ASTType.Space;
    }

    static Type(): ASTType.Space {
        return ASTType.Space;
    }

    get type(): ASTType.Space {
        return ASTType.Space;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                    writer.write_short(this.position)
            writer.write_double(this.IS_OPTIONAL)
           writer.write_byte(this.IS_NON_CAPTURE ==  true ? 1 : 0)

        this.annotation.serialize(writer);
    }

    static Deserialize(reader:ByteReader): Space {

        reader.assert_byte(0);

                    var _position = reader.read_short()
            var _IS_OPTIONAL = reader.read_double()
           var _IS_NON_CAPTURE = !!reader.read_byte()

        var _annotation = Reference.Deserialize(reader);

        return new Space(_position, _IS_OPTIONAL, _IS_NON_CAPTURE, _annotation);
    }
}



export class NewLine extends ASTNode<ASTType> {
    
    position:number;
IS_OPTIONAL:number;
IS_NON_CAPTURE:boolean;
annotation:Reference;

    constructor(
        _position:number,
        _IS_OPTIONAL:number,
        _IS_NON_CAPTURE:boolean,
        _annotation:Reference,) 
    {
        super();
            this.position = _position;
        this.IS_OPTIONAL = _IS_OPTIONAL;
        this.IS_NON_CAPTURE = _IS_NON_CAPTURE;
        this.annotation = _annotation;
        
    }
    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.annotation.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is NewLine {
        if(typeof s == "object")
            return s instanceof NewLine;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is NewLine {
        return s.type == ASTType.NewLine;
    }

    static Type(): ASTType.NewLine {
        return ASTType.NewLine;
    }

    get type(): ASTType.NewLine {
        return ASTType.NewLine;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                    writer.write_short(this.position)
            writer.write_double(this.IS_OPTIONAL)
           writer.write_byte(this.IS_NON_CAPTURE ==  true ? 1 : 0)

        this.annotation.serialize(writer);
    }

    static Deserialize(reader:ByteReader): NewLine {

        reader.assert_byte(0);

                    var _position = reader.read_short()
            var _IS_OPTIONAL = reader.read_double()
           var _IS_NON_CAPTURE = !!reader.read_byte()

        var _annotation = Reference.Deserialize(reader);

        return new NewLine(_position, _IS_OPTIONAL, _IS_NON_CAPTURE, _annotation);
    }
}



export class IncreaseIndent extends ASTNode<ASTType> {
    
    position:number;
IS_OPTIONAL:number;
IS_NON_CAPTURE:boolean;
annotation:Reference;

    constructor(
        _position:number,
        _IS_OPTIONAL:number,
        _IS_NON_CAPTURE:boolean,
        _annotation:Reference,) 
    {
        super();
            this.position = _position;
        this.IS_OPTIONAL = _IS_OPTIONAL;
        this.IS_NON_CAPTURE = _IS_NON_CAPTURE;
        this.annotation = _annotation;
        
    }
    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.annotation.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is IncreaseIndent {
        if(typeof s == "object")
            return s instanceof IncreaseIndent;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is IncreaseIndent {
        return s.type == ASTType.IncreaseIndent;
    }

    static Type(): ASTType.IncreaseIndent {
        return ASTType.IncreaseIndent;
    }

    get type(): ASTType.IncreaseIndent {
        return ASTType.IncreaseIndent;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                    writer.write_short(this.position)
            writer.write_double(this.IS_OPTIONAL)
           writer.write_byte(this.IS_NON_CAPTURE ==  true ? 1 : 0)

        this.annotation.serialize(writer);
    }

    static Deserialize(reader:ByteReader): IncreaseIndent {

        reader.assert_byte(0);

                    var _position = reader.read_short()
            var _IS_OPTIONAL = reader.read_double()
           var _IS_NON_CAPTURE = !!reader.read_byte()

        var _annotation = Reference.Deserialize(reader);

        return new IncreaseIndent(_position, _IS_OPTIONAL, _IS_NON_CAPTURE, _annotation);
    }
}



export class DecreaseIndent extends ASTNode<ASTType> {
    
    position:number;
IS_OPTIONAL:number;
IS_NON_CAPTURE:boolean;
annotation:Reference;

    constructor(
        _position:number,
        _IS_OPTIONAL:number,
        _IS_NON_CAPTURE:boolean,
        _annotation:Reference,) 
    {
        super();
            this.position = _position;
        this.IS_OPTIONAL = _IS_OPTIONAL;
        this.IS_NON_CAPTURE = _IS_NON_CAPTURE;
        this.annotation = _annotation;
        
    }
    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.annotation.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is DecreaseIndent {
        if(typeof s == "object")
            return s instanceof DecreaseIndent;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is DecreaseIndent {
        return s.type == ASTType.DecreaseIndent;
    }

    static Type(): ASTType.DecreaseIndent {
        return ASTType.DecreaseIndent;
    }

    get type(): ASTType.DecreaseIndent {
        return ASTType.DecreaseIndent;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                    writer.write_short(this.position)
            writer.write_double(this.IS_OPTIONAL)
           writer.write_byte(this.IS_NON_CAPTURE ==  true ? 1 : 0)

        this.annotation.serialize(writer);
    }

    static Deserialize(reader:ByteReader): DecreaseIndent {

        reader.assert_byte(0);

                    var _position = reader.read_short()
            var _IS_OPTIONAL = reader.read_double()
           var _IS_NON_CAPTURE = !!reader.read_byte()

        var _annotation = Reference.Deserialize(reader);

        return new DecreaseIndent(_position, _IS_OPTIONAL, _IS_NON_CAPTURE, _annotation);
    }
}



export class Production_Token extends ASTNode<ASTType> {
    
    name:string;
production:(Production_Symbol | Production_Import_Symbol);
val:number;
annotation:Reference| null;
tok:Token;
IS_OPTIONAL:number;
IS_NON_CAPTURE:boolean;

    constructor(
        _name:string,
        _production:(Production_Symbol | Production_Import_Symbol),
        _val:number,
        _annotation:Reference| null,
        _tok:Token,
        _IS_OPTIONAL:number,
        _IS_NON_CAPTURE:boolean,) 
    {
        super();
            this.name = _name;
        this.production = _production;
        this.val = _val;
        this.annotation = _annotation;
        this.tok = _tok;
        this.IS_OPTIONAL = _IS_OPTIONAL;
        this.IS_NON_CAPTURE = _IS_NON_CAPTURE;
        
    }
    replace_production(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(Production_Symbol.nodeIs(child)
    || Production_Import_Symbol.nodeIs(child)){
            
            let old = this.production;           

            this.production = child;
            
            return old;
        }
        return null;
    }

    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.annotation;           

            this.annotation = null;
            
            return old;
        }
                     else 
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.production.$$____Iterate_$_$_$( _yield, this, 0, 0);
    
        if(this.annotation instanceof ASTNode)
            this.annotation.$$____Iterate_$_$_$( _yield, this, 1, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_production(child);
    case 1: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Production_Token {
        if(typeof s == "object")
            return s instanceof Production_Token;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Production_Token {
        return s.type == ASTType.Production_Token;
    }

    static Type(): ASTType.Production_Token {
        return ASTType.Production_Token;
    }

    get type(): ASTType.Production_Token {
        return ASTType.Production_Token;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.name)

        this.production.serialize(writer);
            writer.write_double(this.val)

        if(!this.annotation)
            writer.write_null();
        else 
            this.annotation.serialize(writer);
        

        this.tok.serialize(writer);
            writer.write_double(this.IS_OPTIONAL)
           writer.write_byte(this.IS_NON_CAPTURE ==  true ? 1 : 0)
    }

    static Deserialize(reader:ByteReader): Production_Token {

        reader.assert_byte(0);

                 var _name = reader.read_string()

        var _production = Deserialize(reader)
            var _val = reader.read_double()

        var _annotation = reader.assert_null() ? null : Reference.Deserialize(reader);

        var _tok = Token.Deserialize(reader);
            var _IS_OPTIONAL = reader.read_double()
           var _IS_NON_CAPTURE = !!reader.read_byte()

        return new Production_Token(_name, _production, _val, _annotation, _tok, _IS_OPTIONAL, _IS_NON_CAPTURE);
    }
}



export class Goto extends ASTNode<ASTType> {
    
    state:(Production_Symbol | Production_Import_Symbol | HASH_NAME);

    constructor(
        _state:(Production_Symbol | Production_Import_Symbol | HASH_NAME),) 
    {
        super();
            this.state = _state;
        
    }
    replace_state(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(Production_Symbol.nodeIs(child)
    || Production_Import_Symbol.nodeIs(child)
    || HASH_NAME.nodeIs(child)){
            
            let old = this.state;           

            this.state = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.state.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_state(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Goto {
        if(typeof s == "object")
            return s instanceof Goto;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Goto {
        return s.type == ASTType.Goto;
    }

    static Type(): ASTType.Goto {
        return ASTType.Goto;
    }

    get type(): ASTType.Goto {
        return ASTType.Goto;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        this.state.serialize(writer);
    }

    static Deserialize(reader:ByteReader): Goto {

        reader.assert_byte(0);

        
        var _state = Deserialize(reader)

        return new Goto(_state);
    }
}



export class FailState extends ASTNode<ASTType> {
    
    id:string;
instructions:(c_IR_Instruction | c_IR_Instructio)[];
symbol_meta:Symbols| null;
fail:c_IR_State| null;

    constructor(
        _id:string,
        _instructions:(c_IR_Instruction | c_IR_Instructio)[],
        _symbol_meta:Symbols| null,
        _fail:c_IR_State| null,) 
    {
        super();
            this.id = _id;
        this.instructions = _instructions;
        this.symbol_meta = _symbol_meta;
        this.fail = _fail;
        
    }
    replace_instructions(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.instructions.length && j >= 0){
                return this.instructions.splice(j, 1)[0];
            }
        }else if(isIR_Instruction(child)
    || isIR_Instructio(child)){
            if(j < 0){
                this.instructions.unshift(child);
            }else if(j >= this.instructions.length){
                this.instructions.push(child);
            }else {
                return this.instructions.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    replace_symbol_meta(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.symbol_meta;           

            this.symbol_meta = null;
            
            return old;
        }
                     else 
        if(Symbols.nodeIs(child)){
            
            let old = this.symbol_meta;           

            this.symbol_meta = child;
            
            return old;
        }
        return null;
    }

    replace_fail(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.fail;           

            this.fail = null;
            
            return old;
        }
                     else 
        if(isIR_State(child)){
            
            let old = this.fail;           

            this.fail = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.instructions.length; i++){
            this.instructions[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    
        if(this.symbol_meta instanceof ASTNode)
            this.symbol_meta.$$____Iterate_$_$_$( _yield, this, 1, 0);
    
        if(this.fail instanceof ASTNode)
            this.fail.$$____Iterate_$_$_$( _yield, this, 2, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_instructions(child, j);
    case 1: return this.replace_symbol_meta(child);
    case 2: return this.replace_fail(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is FailState {
        if(typeof s == "object")
            return s instanceof FailState;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is FailState {
        return s.type == ASTType.FailState;
    }

    static Type(): ASTType.FailState {
        return ASTType.FailState;
    }

    get type(): ASTType.FailState {
        return ASTType.FailState;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.id)

        SerializeStructVector(this.instructions, writer)

        if(!this.symbol_meta)
            writer.write_null();
        else 
            this.symbol_meta.serialize(writer);
        

        if(!this.fail)
            writer.write_null();
        else 
            this.fail.serialize(writer);
        
    }

    static Deserialize(reader:ByteReader): FailState {

        reader.assert_byte(0);

                 var _id = reader.read_string()

        var _instructions = Deserialize(reader);

        var _symbol_meta = reader.assert_null() ? null : Symbols.Deserialize(reader);

        var _fail = reader.assert_null() ? null : FailState.Deserialize(reader);

        return new FailState(_id, _instructions, _symbol_meta, _fail);
    }
}



export class Symbols extends ASTNode<ASTType> {
    
    expected:(c_Token | c_Format | Num)[];
skipped:(c_Token | c_Format | Num)[];

    constructor(
        _expected:(c_Token | c_Format | Num)[],
        _skipped:(c_Token | c_Format | Num)[],) 
    {
        super();
            this.expected = _expected;
        this.skipped = _skipped;
        
    }
    replace_expected(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.expected.length && j >= 0){
                return this.expected.splice(j, 1)[0];
            }
        }else if(isToken(child)
    || isFormat(child)
    || Num.nodeIs(child)){
            if(j < 0){
                this.expected.unshift(child);
            }else if(j >= this.expected.length){
                this.expected.push(child);
            }else {
                return this.expected.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    replace_skipped(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.skipped.length && j >= 0){
                return this.skipped.splice(j, 1)[0];
            }
        }else if(isToken(child)
    || isFormat(child)
    || Num.nodeIs(child)){
            if(j < 0){
                this.skipped.unshift(child);
            }else if(j >= this.skipped.length){
                this.skipped.push(child);
            }else {
                return this.skipped.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.expected.length; i++){
            this.expected[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    
        for(let i = 0; i < this.skipped.length; i++){
            this.skipped[i].$$____Iterate_$_$_$(_yield, this, 1, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_expected(child, j);
    case 1: return this.replace_skipped(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Symbols {
        if(typeof s == "object")
            return s instanceof Symbols;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Symbols {
        return s.type == ASTType.Symbols;
    }

    static Type(): ASTType.Symbols {
        return ASTType.Symbols;
    }

    get type(): ASTType.Symbols {
        return ASTType.Symbols;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        SerializeStructVector(this.expected, writer)

        SerializeStructVector(this.skipped, writer)
    }

    static Deserialize(reader:ByteReader): Symbols {

        reader.assert_byte(0);

        
        var _expected = Deserialize(reader);

        var _skipped = Deserialize(reader);

        return new Symbols(_expected, _skipped);
    }
}



export class Not_Symbol extends ASTNode<ASTType> {
    
    val:string;
symbol:(Exclusive_Literal | Literal);
tok:Token;
IS_OPTIONAL:number;
IS_NON_CAPTURE:boolean;
annotation:Reference;

    constructor(
        _val:string,
        _symbol:(Exclusive_Literal | Literal),
        _tok:Token,
        _IS_OPTIONAL:number,
        _IS_NON_CAPTURE:boolean,
        _annotation:Reference,) 
    {
        super();
            this.val = _val;
        this.symbol = _symbol;
        this.tok = _tok;
        this.IS_OPTIONAL = _IS_OPTIONAL;
        this.IS_NON_CAPTURE = _IS_NON_CAPTURE;
        this.annotation = _annotation;
        
    }
    replace_symbol(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(Exclusive_Literal.nodeIs(child)
    || Literal.nodeIs(child)){
            
            let old = this.symbol;           

            this.symbol = child;
            
            return old;
        }
        return null;
    }

    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.symbol.$$____Iterate_$_$_$( _yield, this, 0, 0);
    
        this.annotation.$$____Iterate_$_$_$( _yield, this, 1, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_symbol(child);
    case 1: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Not_Symbol {
        if(typeof s == "object")
            return s instanceof Not_Symbol;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Not_Symbol {
        return s.type == ASTType.Not_Symbol;
    }

    static Type(): ASTType.Not_Symbol {
        return ASTType.Not_Symbol;
    }

    get type(): ASTType.Not_Symbol {
        return ASTType.Not_Symbol;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.val)

        this.symbol.serialize(writer);

        this.tok.serialize(writer);
            writer.write_double(this.IS_OPTIONAL)
           writer.write_byte(this.IS_NON_CAPTURE ==  true ? 1 : 0)

        this.annotation.serialize(writer);
    }

    static Deserialize(reader:ByteReader): Not_Symbol {

        reader.assert_byte(0);

                 var _val = reader.read_string()

        var _symbol = Deserialize(reader)

        var _tok = Token.Deserialize(reader);
            var _IS_OPTIONAL = reader.read_double()
           var _IS_NON_CAPTURE = !!reader.read_byte()

        var _annotation = Reference.Deserialize(reader);

        return new Not_Symbol(_val, _symbol, _tok, _IS_OPTIONAL, _IS_NON_CAPTURE, _annotation);
    }
}



export class Look_Behind extends ASTNode<ASTType> {
    
    val:(string | string | number);
symbol:(c_Token | c_Format);
tok:Token;
IS_OPTIONAL:number;
IS_NON_CAPTURE:boolean;
annotation:Reference;

    constructor(
        _val:(string | string | number),
        _symbol:(c_Token | c_Format),
        _tok:Token,
        _IS_OPTIONAL:number,
        _IS_NON_CAPTURE:boolean,
        _annotation:Reference,) 
    {
        super();
            this.val = _val;
        this.symbol = _symbol;
        this.tok = _tok;
        this.IS_OPTIONAL = _IS_OPTIONAL;
        this.IS_NON_CAPTURE = _IS_NON_CAPTURE;
        this.annotation = _annotation;
        
    }
    replace_symbol(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(isToken(child)
    || isFormat(child)){
            
            let old = this.symbol;           

            this.symbol = child;
            
            return old;
        }
        return null;
    }

    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.symbol.$$____Iterate_$_$_$( _yield, this, 0, 0);
    
        this.annotation.$$____Iterate_$_$_$( _yield, this, 1, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_symbol(child);
    case 1: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Look_Behind {
        if(typeof s == "object")
            return s instanceof Look_Behind;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Look_Behind {
        return s.type == ASTType.Look_Behind;
    }

    static Type(): ASTType.Look_Behind {
        return ASTType.Look_Behind;
    }

    get type(): ASTType.Look_Behind {
        return ASTType.Look_Behind;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
            SerializeType(this.val, writer)

        this.symbol.serialize(writer);

        this.tok.serialize(writer);
            writer.write_double(this.IS_OPTIONAL)
           writer.write_byte(this.IS_NON_CAPTURE ==  true ? 1 : 0)

        this.annotation.serialize(writer);
    }

    static Deserialize(reader:ByteReader): Look_Behind {

        reader.assert_byte(0);

        var _val = Deserialize(reader)

        var _symbol = Deserialize(reader)

        var _tok = Token.Deserialize(reader);
            var _IS_OPTIONAL = reader.read_double()
           var _IS_NON_CAPTURE = !!reader.read_byte()

        var _annotation = Reference.Deserialize(reader);

        return new Look_Behind(_val, _symbol, _tok, _IS_OPTIONAL, _IS_NON_CAPTURE, _annotation);
    }
}



export class List_Production extends ASTNode<ASTType> {
    
    terminal_symbol:(c_Token | c_Format)| null;
IS_OPTIONAL:number;
symbols:(c_Token | c_Format | Not_Symbol | Look_Behind | List_Production | Group_Production | Production_Symbol | Production_Import_Symbol);
annotation:Reference| null;
tok:Token;
IS_NON_CAPTURE:boolean;

    constructor(
        _terminal_symbol:(c_Token | c_Format)| null,
        _IS_OPTIONAL:number,
        _symbols:(c_Token | c_Format | Not_Symbol | Look_Behind | List_Production | Group_Production | Production_Symbol | Production_Import_Symbol),
        _annotation:Reference| null,
        _tok:Token,
        _IS_NON_CAPTURE:boolean,) 
    {
        super();
            this.terminal_symbol = _terminal_symbol;
        this.IS_OPTIONAL = _IS_OPTIONAL;
        this.symbols = _symbols;
        this.annotation = _annotation;
        this.tok = _tok;
        this.IS_NON_CAPTURE = _IS_NON_CAPTURE;
        
    }
    replace_terminal_symbol(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.terminal_symbol;           

            this.terminal_symbol = null;
            
            return old;
        }
                     else 
        if(isToken(child)
    || isFormat(child)){
            
            let old = this.terminal_symbol;           

            this.terminal_symbol = child;
            
            return old;
        }
        return null;
    }

    replace_symbols(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(isToken(child)
    || isFormat(child)
    || Not_Symbol.nodeIs(child)
    || Look_Behind.nodeIs(child)
    || List_Production.nodeIs(child)
    || Group_Production.nodeIs(child)
    || Production_Symbol.nodeIs(child)
    || Production_Import_Symbol.nodeIs(child)){
            
            let old = this.symbols;           

            this.symbols = child;
            
            return old;
        }
        return null;
    }

    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.annotation;           

            this.annotation = null;
            
            return old;
        }
                     else 
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        if(this.terminal_symbol instanceof ASTNode)
            this.terminal_symbol.$$____Iterate_$_$_$( _yield, this, 0, 0);
    
        this.symbols.$$____Iterate_$_$_$( _yield, this, 1, 0);
    
        if(this.annotation instanceof ASTNode)
            this.annotation.$$____Iterate_$_$_$( _yield, this, 2, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_terminal_symbol(child);
    case 1: return this.replace_symbols(child);
    case 2: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is List_Production {
        if(typeof s == "object")
            return s instanceof List_Production;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is List_Production {
        return s.type == ASTType.List_Production;
    }

    static Type(): ASTType.List_Production {
        return ASTType.List_Production;
    }

    get type(): ASTType.List_Production {
        return ASTType.List_Production;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        if(!this.terminal_symbol)
            writer.write_null();
        else 
            this.terminal_symbol.serialize(writer);
        
            writer.write_double(this.IS_OPTIONAL)

        this.symbols.serialize(writer);

        if(!this.annotation)
            writer.write_null();
        else 
            this.annotation.serialize(writer);
        

        this.tok.serialize(writer);
           writer.write_byte(this.IS_NON_CAPTURE ==  true ? 1 : 0)
    }

    static Deserialize(reader:ByteReader): List_Production {

        reader.assert_byte(0);

        
        var _terminal_symbol = reader.assert_null() ? null : Deserialize(reader)
            var _IS_OPTIONAL = reader.read_double()

        var _symbols = Deserialize(reader)

        var _annotation = reader.assert_null() ? null : Reference.Deserialize(reader);

        var _tok = Token.Deserialize(reader);
           var _IS_NON_CAPTURE = !!reader.read_byte()

        return new List_Production(_terminal_symbol, _IS_OPTIONAL, _symbols, _annotation, _tok, _IS_NON_CAPTURE);
    }
}



export class Group_Production extends ASTNode<ASTType> {
    
    bodies:Body[];
annotation:Reference| null;
tok:Token;
IS_OPTIONAL:number;
IS_NON_CAPTURE:boolean;

    constructor(
        _bodies:Body[],
        _annotation:Reference| null,
        _tok:Token,
        _IS_OPTIONAL:number,
        _IS_NON_CAPTURE:boolean,) 
    {
        super();
            this.bodies = _bodies;
        this.annotation = _annotation;
        this.tok = _tok;
        this.IS_OPTIONAL = _IS_OPTIONAL;
        this.IS_NON_CAPTURE = _IS_NON_CAPTURE;
        
    }
    replace_bodies(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.bodies.length && j >= 0){
                return this.bodies.splice(j, 1)[0];
            }
        }else if(Body.nodeIs(child)){
            if(j < 0){
                this.bodies.unshift(child);
            }else if(j >= this.bodies.length){
                this.bodies.push(child);
            }else {
                return this.bodies.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.annotation;           

            this.annotation = null;
            
            return old;
        }
                     else 
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.bodies.length; i++){
            this.bodies[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    
        if(this.annotation instanceof ASTNode)
            this.annotation.$$____Iterate_$_$_$( _yield, this, 1, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_bodies(child, j);
    case 1: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Group_Production {
        if(typeof s == "object")
            return s instanceof Group_Production;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Group_Production {
        return s.type == ASTType.Group_Production;
    }

    static Type(): ASTType.Group_Production {
        return ASTType.Group_Production;
    }

    get type(): ASTType.Group_Production {
        return ASTType.Group_Production;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        SerializeStructVector(this.bodies, writer)

        if(!this.annotation)
            writer.write_null();
        else 
            this.annotation.serialize(writer);
        

        this.tok.serialize(writer);
            writer.write_double(this.IS_OPTIONAL)
           writer.write_byte(this.IS_NON_CAPTURE ==  true ? 1 : 0)
    }

    static Deserialize(reader:ByteReader): Group_Production {

        reader.assert_byte(0);

        
        var _bodies = Deserialize(reader);

        var _annotation = reader.assert_null() ? null : Reference.Deserialize(reader);

        var _tok = Token.Deserialize(reader);
            var _IS_OPTIONAL = reader.read_double()
           var _IS_NON_CAPTURE = !!reader.read_byte()

        return new Group_Production(_bodies, _annotation, _tok, _IS_OPTIONAL, _IS_NON_CAPTURE);
    }
}



export class Body extends ASTNode<ASTType> {
    
    priority:number;
symbols:(c_Meta | c_Token | Not_Symbol | Look_Behind | List_Production | Group_Production | Production_Symbol | Production_Import_Symbol)[];
ref:Reference| null;
reduce_function:(Returned | Referenced)| null;
FORCE_FORK:boolean;
id:number;
production:Production| null;

    constructor(
        _priority:number,
        _symbols:(c_Meta | c_Token | Not_Symbol | Look_Behind | List_Production | Group_Production | Production_Symbol | Production_Import_Symbol)[],
        _ref:Reference| null,
        _reduce_function:(Returned | Referenced)| null,
        _FORCE_FORK:boolean,
        _id:number,
        _production:Production| null,) 
    {
        super();
            this.priority = _priority;
        this.symbols = _symbols;
        this.ref = _ref;
        this.reduce_function = _reduce_function;
        this.FORCE_FORK = _FORCE_FORK;
        this.id = _id;
        this.production = _production;
        
    }
    replace_symbols(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.symbols.length && j >= 0){
                return this.symbols.splice(j, 1)[0];
            }
        }else if(isMeta(child)
    || isToken(child)
    || Not_Symbol.nodeIs(child)
    || Look_Behind.nodeIs(child)
    || List_Production.nodeIs(child)
    || Group_Production.nodeIs(child)
    || Production_Symbol.nodeIs(child)
    || Production_Import_Symbol.nodeIs(child)){
            if(j < 0){
                this.symbols.unshift(child);
            }else if(j >= this.symbols.length){
                this.symbols.push(child);
            }else {
                return this.symbols.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    replace_ref(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.ref;           

            this.ref = null;
            
            return old;
        }
                     else 
        if(Reference.nodeIs(child)){
            
            let old = this.ref;           

            this.ref = child;
            
            return old;
        }
        return null;
    }

    replace_reduce_function(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.reduce_function;           

            this.reduce_function = null;
            
            return old;
        }
                     else 
        if(Returned.nodeIs(child)
    || Referenced.nodeIs(child)){
            
            let old = this.reduce_function;           

            this.reduce_function = child;
            
            return old;
        }
        return null;
    }

    replace_production(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.production;           

            this.production = null;
            
            return old;
        }
                     else 
        if(Production.nodeIs(child)){
            
            let old = this.production;           

            this.production = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.symbols.length; i++){
            this.symbols[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    
        if(this.ref instanceof ASTNode)
            this.ref.$$____Iterate_$_$_$( _yield, this, 1, 0);
    
        if(this.reduce_function instanceof ASTNode)
            this.reduce_function.$$____Iterate_$_$_$( _yield, this, 2, 0);
    
        if(this.production instanceof ASTNode)
            this.production.$$____Iterate_$_$_$( _yield, this, 3, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_symbols(child, j);
    case 1: return this.replace_ref(child);
    case 2: return this.replace_reduce_function(child);
    case 3: return this.replace_production(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Body {
        if(typeof s == "object")
            return s instanceof Body;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Body {
        return s.type == ASTType.Body;
    }

    static Type(): ASTType.Body {
        return ASTType.Body;
    }

    get type(): ASTType.Body {
        return ASTType.Body;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                    writer.write_double(this.priority)

        SerializeStructVector(this.symbols, writer)

        if(!this.ref)
            writer.write_null();
        else 
            this.ref.serialize(writer);
        

        if(!this.reduce_function)
            writer.write_null();
        else 
            this.reduce_function.serialize(writer);
        
           writer.write_byte(this.FORCE_FORK ==  true ? 1 : 0)
            writer.write_double(this.id)

        if(!this.production)
            writer.write_null();
        else 
            this.production.serialize(writer);
        
    }

    static Deserialize(reader:ByteReader): Body {

        reader.assert_byte(0);

                    var _priority = reader.read_double()

        var _symbols = Deserialize(reader);

        var _ref = reader.assert_null() ? null : Reference.Deserialize(reader);

        var _reduce_function = reader.assert_null() ? null : Deserialize(reader)
           var _FORCE_FORK = !!reader.read_byte()
            var _id = reader.read_double()

        var _production = reader.assert_null() ? null : Production.Deserialize(reader);

        return new Body(_priority, _symbols, _ref, _reduce_function, _FORCE_FORK, _id, _production);
    }
}



export class Exclude extends ASTNode<ASTType> {
    
    sym:(c_Token | c_Format)[];
index:number;
annotation:Reference| null;
tok:Token;

    constructor(
        _sym:(c_Token | c_Format)[],
        _index:number,
        _annotation:Reference| null,
        _tok:Token,) 
    {
        super();
            this.sym = _sym;
        this.index = _index;
        this.annotation = _annotation;
        this.tok = _tok;
        
    }
    replace_sym(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.sym.length && j >= 0){
                return this.sym.splice(j, 1)[0];
            }
        }else if(isToken(child)
    || isFormat(child)){
            if(j < 0){
                this.sym.unshift(child);
            }else if(j >= this.sym.length){
                this.sym.push(child);
            }else {
                return this.sym.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.annotation;           

            this.annotation = null;
            
            return old;
        }
                     else 
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.sym.length; i++){
            this.sym[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    
        if(this.annotation instanceof ASTNode)
            this.annotation.$$____Iterate_$_$_$( _yield, this, 1, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_sym(child, j);
    case 1: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Exclude {
        if(typeof s == "object")
            return s instanceof Exclude;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Exclude {
        return s.type == ASTType.Exclude;
    }

    static Type(): ASTType.Exclude {
        return ASTType.Exclude;
    }

    get type(): ASTType.Exclude {
        return ASTType.Exclude;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        SerializeStructVector(this.sym, writer)
            writer.write_double(this.index)

        if(!this.annotation)
            writer.write_null();
        else 
            this.annotation.serialize(writer);
        

        this.tok.serialize(writer);
    }

    static Deserialize(reader:ByteReader): Exclude {

        reader.assert_byte(0);

        
        var _sym = Deserialize(reader);
            var _index = reader.read_double()

        var _annotation = reader.assert_null() ? null : Reference.Deserialize(reader);

        var _tok = Token.Deserialize(reader);

        return new Exclude(_sym, _index, _annotation, _tok);
    }
}



export class Look_Ignore extends ASTNode<ASTType> {
    
    sym:(c_Token | c_Format)[];
index:number;
annotation:Reference| null;
tok:Token;

    constructor(
        _sym:(c_Token | c_Format)[],
        _index:number,
        _annotation:Reference| null,
        _tok:Token,) 
    {
        super();
            this.sym = _sym;
        this.index = _index;
        this.annotation = _annotation;
        this.tok = _tok;
        
    }
    replace_sym(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.sym.length && j >= 0){
                return this.sym.splice(j, 1)[0];
            }
        }else if(isToken(child)
    || isFormat(child)){
            if(j < 0){
                this.sym.unshift(child);
            }else if(j >= this.sym.length){
                this.sym.push(child);
            }else {
                return this.sym.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.annotation;           

            this.annotation = null;
            
            return old;
        }
                     else 
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.sym.length; i++){
            this.sym[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    
        if(this.annotation instanceof ASTNode)
            this.annotation.$$____Iterate_$_$_$( _yield, this, 1, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_sym(child, j);
    case 1: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Look_Ignore {
        if(typeof s == "object")
            return s instanceof Look_Ignore;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Look_Ignore {
        return s.type == ASTType.Look_Ignore;
    }

    static Type(): ASTType.Look_Ignore {
        return ASTType.Look_Ignore;
    }

    get type(): ASTType.Look_Ignore {
        return ASTType.Look_Ignore;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        SerializeStructVector(this.sym, writer)
            writer.write_double(this.index)

        if(!this.annotation)
            writer.write_null();
        else 
            this.annotation.serialize(writer);
        

        this.tok.serialize(writer);
    }

    static Deserialize(reader:ByteReader): Look_Ignore {

        reader.assert_byte(0);

        
        var _sym = Deserialize(reader);
            var _index = reader.read_double()

        var _annotation = reader.assert_null() ? null : Reference.Deserialize(reader);

        var _tok = Token.Deserialize(reader);

        return new Look_Ignore(_sym, _index, _annotation, _tok);
    }
}



export class Empty extends ASTNode<ASTType> {
    
    val:string;
annotation:Reference| null;
tok:Token;

    constructor(
        _val:string,
        _annotation:Reference| null,
        _tok:Token,) 
    {
        super();
            this.val = _val;
        this.annotation = _annotation;
        this.tok = _tok;
        
    }
    replace_annotation(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.annotation;           

            this.annotation = null;
            
            return old;
        }
                     else 
        if(Reference.nodeIs(child)){
            
            let old = this.annotation;           

            this.annotation = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        if(this.annotation instanceof ASTNode)
            this.annotation.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_annotation(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Empty {
        if(typeof s == "object")
            return s instanceof Empty;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Empty {
        return s.type == ASTType.Empty;
    }

    static Type(): ASTType.Empty {
        return ASTType.Empty;
    }

    get type(): ASTType.Empty {
        return ASTType.Empty;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.val)

        if(!this.annotation)
            writer.write_null();
        else 
            this.annotation.serialize(writer);
        

        this.tok.serialize(writer);
    }

    static Deserialize(reader:ByteReader): Empty {

        reader.assert_byte(0);

                 var _val = reader.read_string()

        var _annotation = reader.assert_null() ? null : Reference.Deserialize(reader);

        var _tok = Token.Deserialize(reader);

        return new Empty(_val, _annotation, _tok);
    }
}



export class Production extends ASTNode<ASTType> {
    
    priority:number;
symbol:(Production_Symbol | Production_Import_Symbol);
bodies:Body[];
id:number;
LAZY:boolean;
entry_name:string;

    constructor(
        _priority:number,
        _symbol:(Production_Symbol | Production_Import_Symbol),
        _bodies:Body[],
        _id:number,
        _LAZY:boolean,
        _entry_name:string,) 
    {
        super();
            this.priority = _priority;
        this.symbol = _symbol;
        this.bodies = _bodies;
        this.id = _id;
        this.LAZY = _LAZY;
        this.entry_name = _entry_name;
        
    }
    replace_symbol(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(Production_Symbol.nodeIs(child)
    || Production_Import_Symbol.nodeIs(child)){
            
            let old = this.symbol;           

            this.symbol = child;
            
            return old;
        }
        return null;
    }

    replace_bodies(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.bodies.length && j >= 0){
                return this.bodies.splice(j, 1)[0];
            }
        }else if(Body.nodeIs(child)){
            if(j < 0){
                this.bodies.unshift(child);
            }else if(j >= this.bodies.length){
                this.bodies.push(child);
            }else {
                return this.bodies.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.symbol.$$____Iterate_$_$_$( _yield, this, 0, 0);
    
        for(let i = 0; i < this.bodies.length; i++){
            this.bodies[i].$$____Iterate_$_$_$(_yield, this, 1, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_symbol(child);
    case 1: return this.replace_bodies(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Production {
        if(typeof s == "object")
            return s instanceof Production;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Production {
        return s.type == ASTType.Production;
    }

    static Type(): ASTType.Production {
        return ASTType.Production;
    }

    get type(): ASTType.Production {
        return ASTType.Production;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                    writer.write_double(this.priority)

        this.symbol.serialize(writer);

        SerializeStructVector(this.bodies, writer)
            writer.write_double(this.id)
           writer.write_byte(this.LAZY ==  true ? 1 : 0)
         writer.write_string(this.entry_name)
    }

    static Deserialize(reader:ByteReader): Production {

        reader.assert_byte(0);

                    var _priority = reader.read_double()

        var _symbol = Deserialize(reader)

        var _bodies = Deserialize(reader);
            var _id = reader.read_double()
           var _LAZY = !!reader.read_byte()
         var _entry_name = reader.read_string()

        return new Production(_priority, _symbol, _bodies, _id, _LAZY, _entry_name);
    }
}



export class ProductionMerged extends ASTNode<ASTType> {
    
    symbol:(Production_Symbol | Production_Import_Symbol);
bodies:Body[];
id:number;

    constructor(
        _symbol:(Production_Symbol | Production_Import_Symbol),
        _bodies:Body[],
        _id:number,) 
    {
        super();
            this.symbol = _symbol;
        this.bodies = _bodies;
        this.id = _id;
        
    }
    replace_symbol(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(Production_Symbol.nodeIs(child)
    || Production_Import_Symbol.nodeIs(child)){
            
            let old = this.symbol;           

            this.symbol = child;
            
            return old;
        }
        return null;
    }

    replace_bodies(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.bodies.length && j >= 0){
                return this.bodies.splice(j, 1)[0];
            }
        }else if(Body.nodeIs(child)){
            if(j < 0){
                this.bodies.unshift(child);
            }else if(j >= this.bodies.length){
                this.bodies.push(child);
            }else {
                return this.bodies.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.symbol.$$____Iterate_$_$_$( _yield, this, 0, 0);
    
        for(let i = 0; i < this.bodies.length; i++){
            this.bodies[i].$$____Iterate_$_$_$(_yield, this, 1, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_symbol(child);
    case 1: return this.replace_bodies(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is ProductionMerged {
        if(typeof s == "object")
            return s instanceof ProductionMerged;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is ProductionMerged {
        return s.type == ASTType.ProductionMerged;
    }

    static Type(): ASTType.ProductionMerged {
        return ASTType.ProductionMerged;
    }

    get type(): ASTType.ProductionMerged {
        return ASTType.ProductionMerged;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        this.symbol.serialize(writer);

        SerializeStructVector(this.bodies, writer)
            writer.write_double(this.id)
    }

    static Deserialize(reader:ByteReader): ProductionMerged {

        reader.assert_byte(0);

        
        var _symbol = Deserialize(reader)

        var _bodies = Deserialize(reader);
            var _id = reader.read_double()

        return new ProductionMerged(_symbol, _bodies, _id);
    }
}



export class Ignore extends ASTNode<ASTType> {
    
    symbols:(c_Token | c_Format)[];

    constructor(
        _symbols:(c_Token | c_Format)[],) 
    {
        super();
            this.symbols = _symbols;
        
    }
    replace_symbols(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.symbols.length && j >= 0){
                return this.symbols.splice(j, 1)[0];
            }
        }else if(isToken(child)
    || isFormat(child)){
            if(j < 0){
                this.symbols.unshift(child);
            }else if(j >= this.symbols.length){
                this.symbols.push(child);
            }else {
                return this.symbols.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.symbols.length; i++){
            this.symbols[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_symbols(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Ignore {
        if(typeof s == "object")
            return s instanceof Ignore;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Ignore {
        return s.type == ASTType.Ignore;
    }

    static Type(): ASTType.Ignore {
        return ASTType.Ignore;
    }

    get type(): ASTType.Ignore {
        return ASTType.Ignore;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        SerializeStructVector(this.symbols, writer)
    }

    static Deserialize(reader:ByteReader): Ignore {

        reader.assert_byte(0);

        
        var _symbols = Deserialize(reader);

        return new Ignore(_symbols);
    }
}



export class Import extends ASTNode<ASTType> {
    
    uri:string;
reference:Token;

    constructor(
        _uri:string,
        _reference:Token,) 
    {
        super();
            this.uri = _uri;
        this.reference = _reference;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Import {
        if(typeof s == "object")
            return s instanceof Import;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Import {
        return s.type == ASTType.Import;
    }

    static Type(): ASTType.Import {
        return ASTType.Import;
    }

    get type(): ASTType.Import {
        return ASTType.Import;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.uri)

        this.reference.serialize(writer);
    }

    static Deserialize(reader:ByteReader): Import {

        reader.assert_byte(0);

                 var _uri = reader.read_string()

        var _reference = Token.Deserialize(reader);

        return new Import(_uri, _reference);
    }
}



export class Export extends ASTNode<ASTType> {
    
    production:(Production_Symbol | Production_Import_Symbol);
reference:Token;

    constructor(
        _production:(Production_Symbol | Production_Import_Symbol),
        _reference:Token,) 
    {
        super();
            this.production = _production;
        this.reference = _reference;
        
    }
    replace_production(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(Production_Symbol.nodeIs(child)
    || Production_Import_Symbol.nodeIs(child)){
            
            let old = this.production;           

            this.production = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.production.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_production(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Export {
        if(typeof s == "object")
            return s instanceof Export;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Export {
        return s.type == ASTType.Export;
    }

    static Type(): ASTType.Export {
        return ASTType.Export;
    }

    get type(): ASTType.Export {
        return ASTType.Export;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        this.production.serialize(writer);

        this.reference.serialize(writer);
    }

    static Deserialize(reader:ByteReader): Export {

        reader.assert_byte(0);

        
        var _production = Deserialize(reader)

        var _reference = Token.Deserialize(reader);

        return new Export(_production, _reference);
    }
}



export class Productions extends ASTNode<ASTType> {
    
    functions:Out_Of_Band[];
productions:(Production | ProductionMerged)[];
ir:c_IrState[];
tok:Token;

    constructor(
        _functions:Out_Of_Band[],
        _productions:(Production | ProductionMerged)[],
        _ir:c_IrState[],
        _tok:Token,) 
    {
        super();
            this.functions = _functions;
        this.productions = _productions;
        this.ir = _ir;
        this.tok = _tok;
        
    }
    replace_functions(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.functions.length && j >= 0){
                return this.functions.splice(j, 1)[0];
            }
        }else if(Out_Of_Band.nodeIs(child)){
            if(j < 0){
                this.functions.unshift(child);
            }else if(j >= this.functions.length){
                this.functions.push(child);
            }else {
                return this.functions.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    replace_productions(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.productions.length && j >= 0){
                return this.productions.splice(j, 1)[0];
            }
        }else if(Production.nodeIs(child)
    || ProductionMerged.nodeIs(child)){
            if(j < 0){
                this.productions.unshift(child);
            }else if(j >= this.productions.length){
                this.productions.push(child);
            }else {
                return this.productions.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    replace_ir(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.ir.length && j >= 0){
                return this.ir.splice(j, 1)[0];
            }
        }else if(isIrState(child)){
            if(j < 0){
                this.ir.unshift(child);
            }else if(j >= this.ir.length){
                this.ir.push(child);
            }else {
                return this.ir.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.functions.length; i++){
            this.functions[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    
        for(let i = 0; i < this.productions.length; i++){
            this.productions[i].$$____Iterate_$_$_$(_yield, this, 1, i);
        } 
    
        for(let i = 0; i < this.ir.length; i++){
            this.ir[i].$$____Iterate_$_$_$(_yield, this, 2, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_functions(child, j);
    case 1: return this.replace_productions(child, j);
    case 2: return this.replace_ir(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Productions {
        if(typeof s == "object")
            return s instanceof Productions;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Productions {
        return s.type == ASTType.Productions;
    }

    static Type(): ASTType.Productions {
        return ASTType.Productions;
    }

    get type(): ASTType.Productions {
        return ASTType.Productions;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        SerializeStructVector(this.functions, writer)

        SerializeStructVector(this.productions, writer)

        SerializeStructVector(this.ir, writer)

        this.tok.serialize(writer);
    }

    static Deserialize(reader:ByteReader): Productions {

        reader.assert_byte(0);

        
        var _functions = Deserialize(reader);

        var _productions = Deserialize(reader);

        var _ir = Deserialize(reader);

        var _tok = Token.Deserialize(reader);

        return new Productions(_functions, _productions, _ir, _tok);
    }
}



export class Out_Of_Band extends ASTNode<ASTType> {
    
    reference:Reference| null;
txt:(Token | string)| null;
production:(Production_Symbol | Production_Import_Symbol)| null;
index:Token| null;

    constructor(
        _reference:Reference| null,
        _txt:(Token | string)| null,
        _production:(Production_Symbol | Production_Import_Symbol)| null,
        _index:Token| null,) 
    {
        super();
            this.reference = _reference;
        this.txt = _txt;
        this.production = _production;
        this.index = _index;
        
    }
    replace_reference(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.reference;           

            this.reference = null;
            
            return old;
        }
                     else 
        if(Reference.nodeIs(child)){
            
            let old = this.reference;           

            this.reference = child;
            
            return old;
        }
        return null;
    }

    replace_production(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.production;           

            this.production = null;
            
            return old;
        }
                     else 
        if(Production_Symbol.nodeIs(child)
    || Production_Import_Symbol.nodeIs(child)){
            
            let old = this.production;           

            this.production = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        if(this.reference instanceof ASTNode)
            this.reference.$$____Iterate_$_$_$( _yield, this, 0, 0);
    
        if(this.production instanceof ASTNode)
            this.production.$$____Iterate_$_$_$( _yield, this, 1, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_reference(child);
    case 1: return this.replace_production(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Out_Of_Band {
        if(typeof s == "object")
            return s instanceof Out_Of_Band;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Out_Of_Band {
        return s.type == ASTType.Out_Of_Band;
    }

    static Type(): ASTType.Out_Of_Band {
        return ASTType.Out_Of_Band;
    }

    get type(): ASTType.Out_Of_Band {
        return ASTType.Out_Of_Band;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        if(!this.reference)
            writer.write_null();
        else 
            this.reference.serialize(writer);
        
    SerializeType(this.txt, writer)

        if(!this.production)
            writer.write_null();
        else 
            this.production.serialize(writer);
        

        if(!this.index)
            writer.write_null();
        else 
            this.index.serialize(writer);
        
    }

    static Deserialize(reader:ByteReader): Out_Of_Band {

        reader.assert_byte(0);

        
        var _reference = reader.assert_null() ? null : Reference.Deserialize(reader);
var _txt = Deserialize(reader)

        var _production = reader.assert_null() ? null : Deserialize(reader)

        var _index = reader.assert_null() ? null : Token.Deserialize(reader);

        return new Out_Of_Band(_reference, _txt, _production, _index);
    }
}



export class Repeat extends ASTNode<ASTType> {
    
    

    constructor() 
    {
        super();
            
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Repeat {
        if(typeof s == "object")
            return s instanceof Repeat;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Repeat {
        return s.type == ASTType.Repeat;
    }

    static Type(): ASTType.Repeat {
        return ASTType.Repeat;
    }

    get type(): ASTType.Repeat {
        return ASTType.Repeat;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
    }

    static Deserialize(reader:ByteReader): Repeat {

        reader.assert_byte(0);

        

        return new Repeat();
    }
}



export class Lazy extends ASTNode<ASTType> {
    
    cp_start:Token;
cp_end:Token;
state:(Production_Symbol | Production_Import_Symbol | HASH_NAME);

    constructor(
        _cp_start:Token,
        _cp_end:Token,
        _state:(Production_Symbol | Production_Import_Symbol | HASH_NAME),) 
    {
        super();
            this.cp_start = _cp_start;
        this.cp_end = _cp_end;
        this.state = _state;
        
    }
    replace_state(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(Production_Symbol.nodeIs(child)
    || Production_Import_Symbol.nodeIs(child)
    || HASH_NAME.nodeIs(child)){
            
            let old = this.state;           

            this.state = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.state.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_state(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Lazy {
        if(typeof s == "object")
            return s instanceof Lazy;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Lazy {
        return s.type == ASTType.Lazy;
    }

    static Type(): ASTType.Lazy {
        return ASTType.Lazy;
    }

    get type(): ASTType.Lazy {
        return ASTType.Lazy;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        this.cp_start.serialize(writer);

        this.cp_end.serialize(writer);

        this.state.serialize(writer);
    }

    static Deserialize(reader:ByteReader): Lazy {

        reader.assert_byte(0);

        
        var _cp_start = Token.Deserialize(reader);

        var _cp_end = Token.Deserialize(reader);

        var _state = Deserialize(reader)

        return new Lazy(_cp_start, _cp_end, _state);
    }
}



export class Num extends ASTNode<ASTType> {
    
    val:(number | number);

    constructor(
        _val:(number | number),) 
    {
        super();
            this.val = _val;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Num {
        if(typeof s == "object")
            return s instanceof Num;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Num {
        return s.type == ASTType.Num;
    }

    static Type(): ASTType.Num {
        return ASTType.Num;
    }

    get type(): ASTType.Num {
        return ASTType.Num;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
            SerializeType(this.val, writer)
    }

    static Deserialize(reader:ByteReader): Num {

        reader.assert_byte(0);

        var _val = Deserialize(reader)

        return new Num(_val);
    }
}



export class HASH_NAME extends ASTNode<ASTType> {
    
    val:string;

    constructor(
        _val:string,) 
    {
        super();
            this.val = _val;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is HASH_NAME {
        if(typeof s == "object")
            return s instanceof HASH_NAME;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is HASH_NAME {
        return s.type == ASTType.HASH_NAME;
    }

    static Type(): ASTType.HASH_NAME {
        return ASTType.HASH_NAME;
    }

    get type(): ASTType.HASH_NAME {
        return ASTType.HASH_NAME;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.val)
    }

    static Deserialize(reader:ByteReader): HASH_NAME {

        reader.assert_byte(0);

                 var _val = reader.read_string()

        return new HASH_NAME(_val);
    }
}



/**
```
{ 

    t_Grammar,

    c_Grammar,

    c_Version_6,

    preamble:$1,

    productions:$2.productions,

    ir_states:$2.ir,

    functions:$2.functions,

    imported_grammars:[t_Grammar],

    meta:{ 

        t_Meta,

        all_symbols:[c_Symbol],

        ignore_symbols:[c_TokenSymbol]
     },

    bodies:[t_Body],

    tok
 }
```*/
function _FN0_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:( string | number | boolean | Token )[] = [];
 let ref_1:( string | number | boolean | Token )[] = [];
 let ref_2:null[] = [];
 let ref_3:Meta = new Meta(
        ref_1,
        ref_2,
   );;
 let ref_4:( string | number | boolean | Token )[] = [];
 let ref_5:Grammar = new Grammar(
        v0,
        v1.productions,
        v1.ir,
        v1.functions,
        ref_0,
        ref_3,
        ref_4,
        tok,
   );;

                                args.push(ref_5) 
                            }
/**
```
{ 

    t_Grammar,

    c_Grammar,

    c_Version_6,

    preamble:$NULL,

    productions:$1.productions,

    ir_states:$1.ir,

    functions:$1.functions,

    imported_grammars:[t_Grammar],

    meta:{ 

        t_Meta,

        all_symbols:[c_Symbol],

        ignore_symbols:[c_TokenSymbol]
     },

    bodies:[t_Body],

    tok
 }
```*/
function _FN1_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:( string | number | boolean | Token )[] = [];
 let ref_1:( string | number | boolean | Token )[] = [];
 let ref_2:null[] = [];
 let ref_3:Meta = new Meta(
        ref_1,
        ref_2,
   );;
 let ref_4:( string | number | boolean | Token )[] = [];
 let ref_5:Grammar = new Grammar(
        [],
        v0.productions,
        v0.ir,
        v0.functions,
        ref_0,
        ref_3,
        ref_4,
        tok,
   );;

                                args.push(ref_5) 
                            }
/**
```
{ 

    t_IR_STATE,

    c_IR,

    c_IrState,

    id:$1,

    instructions:$2,

    fail:$3,

    symbol_meta:$4
 }
```*/
function _FN2_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:IR_STATE = new IR_STATE(
        v0,
        v1,
        v2,
        v3,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_IR_STATE,

    c_IR,

    c_IrState,

    id:$1,

    instructions:$2,

    fail:$NULL,

    symbol_meta:$3
 }
```*/
function _FN3_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:IR_STATE = new IR_STATE(
        v0,
        v1,
        null,
        v2,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_IR_STATE,

    c_IR,

    c_IrState,

    id:$1,

    instructions:$2,

    fail:$3,

    symbol_meta:$NULL
 }
```*/
function _FN4_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:IR_STATE = new IR_STATE(
        v0,
        v1,
        v2,
        null,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_IR_STATE,

    c_IR,

    c_IrState,

    id:$1,

    instructions:$2,

    fail:$NULL,

    symbol_meta:$NULL
 }
```*/
function _FN5_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:IR_STATE = new IR_STATE(
        v0,
        v1,
        null,
        null,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_ASSERT,

    c_IR,

    c_IR_Instruction,

    c_IR_Branch,

    mode:str($2),

    ids:$3,

    instructions:$5
 }
```*/
function _FN6_ (args: any[], tok: Token) : any { 
                        let v5 = args.pop();
let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:ASSERT = new ASSERT(
        v1.toString(),
        v2,
        v4,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_PEEK,

    c_IR,

    c_IR_Instructio,

    c_IR_Branch,

    mode:str($2),

    ids:$3,

    instructions:$5
 }
```*/
function _FN7_ (args: any[], tok: Token) : any { 
                        let v5 = args.pop();
let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:PEEK = new PEEK(
        v1.toString(),
        v2,
        v4,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Production_Symbol,

    c_Symbol,

    name:str($1),

    production:c_Production,

    val:-1,

    annotation:t_Reference,

    tok
 }
```*/
function _FN8_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:Production_Symbol = new Production_Symbol(
        v0.toString(),
        null,
        1.0,
        null,
        tok,
        0,
        false,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Production_Import_Symbol,

    c_Symbol,

    module:str($1),

    name:str($3),

    production:c_Production,

    annotation:t_Reference,

    tok
 }
```*/
function _FN9_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Production_Import_Symbol = new Production_Import_Symbol(
        v0.toString(),
        v2.toString(),
        null,
        null,
        tok,
        0,
        false,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Reduce,

    c_IR,

    c_IR_Instruction,

    len:i32($2),

    body_id:i32($3)
 }
```*/
function _FN10_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Reduce = new Reduce(
        parseInt(v1.toString()),
        parseInt(v2.toString()),
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Reduce,

    c_IR,

    c_IR_Instruction,

    len:i32(-1),

    reduce_fn:$2
 }
```*/
function _FN11_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Reduce = new Reduce(
        1.0 ,
        0,
        v1,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_TokenAssign, c_IR, c_IR_Instruction, ids:$3 }
```*/
function _FN12_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:TokenAssign = new TokenAssign(
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_SetProd, c_IR, c_IR_Instruction, id:$4 }
```*/
function _FN13_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:SetProd = new SetProd(
        v3,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_ForkTo, c_IR, c_IR_Instruction, states:$4 }
```*/
function _FN14_ (args: any[], tok: Token) : any { 
                        let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:ForkTo = new ForkTo(
        v3,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_ScanUntil,

    c_IR,

    c_IR_Instruction,

    ids:$4,

    SCAN_BACKWARDS:bool($2)
 }
```*/
function _FN15_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:ScanUntil = new ScanUntil(
        v3,
        !!(v1),
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_TokenId, c_IR, c_IR_Instruction, id:$4 }
```*/
function _FN16_ (args: any[], tok: Token) : any { 
                        let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:TokenId = new TokenId(
        v3,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Pass, c_IR, c_IR_Instruction }
```*/
function _FN17_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:Pass = new Pass(
        
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Fail, c_IR, c_IR_Instruction }
```*/
function _FN18_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:Fail = new Fail(
        
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_NotInScope, c_IR, c_IR_Instruction, ids:$5 }
```*/
function _FN19_ (args: any[], tok: Token) : any { 
                        let v5 = args.pop();
let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:NotInScope = new NotInScope(
        v4,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_SetScope, c_IR, c_IR_Instruction, scope:$4 }
```*/
function _FN20_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:SetScope = new SetScope(
        v3,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Consume, c_IR, c_IR_Instruction, EMPTY:bool($2) }
```*/
function _FN21_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Consume = new Consume(
        !!(v1),
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_ScanUntil,

    c_IR,

    c_IR_Instruction,

    ids:$3,

    SCAN_BACKWARDS:bool($NULL)
 }
```*/
function _FN22_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:ScanUntil = new ScanUntil(
        v2,
        false,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Consume, c_IR, c_IR_Instruction, EMPTY:bool($NULL) }
```*/
function _FN23_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:Consume = new Consume(
        false,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Returned,

    c_Function,

    txt:str($4),

    name:"",

    env:false,

    ref:"",

    IS_CONDITION:true
 }
```*/
function _FN24_ (args: any[], tok: Token) : any { 
                        let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Returned = new Returned(
        v3.toString(),
        "",
        false,
        "",
        true,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Referenced, c_Function, ref:$3 }
```*/
function _FN25_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Referenced = new Referenced(
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Reference, c_Symbol, val:str($1) }
```*/
function _FN26_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:Reference = new Reference(
        v0.toString(),
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Generated,

    c_Symbol,

    c_Token,

    val:str($2),

    annotation:t_Reference,

    tok
 }
```*/
function _FN27_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Generated = new Generated(
        v1.toString(),
        null,
        tok,
        0,
        false,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Exclusive_Literal,

    c_Symbol,

    c_Token,

    val:str($2),

    annotation:t_Reference,

    tok
 }
```*/
function _FN28_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Exclusive_Literal = new Exclusive_Literal(
        v1,
        null,
        tok,
        0,
        false,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Literal,

    c_Symbol,

    c_Token,

    val:str($1),

    annotation:t_Reference,

    tok
 }
```*/
function _FN29_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:Literal = new Literal(
        v0,
        null,
        tok,
        0,
        false,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Literal,

    c_Symbol,

    c_Token,

    val:str($2),

    annotation:t_Reference,

    tok
 }
```*/
function _FN30_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Literal = new Literal(
        v1,
        null,
        tok,
        0,
        false,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_End_Of_File,

    c_Symbol,

    c_Token,

    val:"END_OF_FILE",

    annotation:t_Reference,

    tok
 }
```*/
function _FN31_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:End_Of_File = new End_Of_File(
        "END_OF_FILE",
        null,
        tok,
        0,
        false,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Space, c_Meta, c_Format, position:i16(0) }
```*/
function _FN32_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:Space = new Space(
        0.0 ,
        0,
        false,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_NewLine, c_Meta, c_Format, position:i16(0) }
```*/
function _FN33_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:NewLine = new NewLine(
        0.0 ,
        0,
        false,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_IncreaseIndent, c_Meta, c_Format, position:i16(0) }
```*/
function _FN34_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:IncreaseIndent = new IncreaseIndent(
        0.0 ,
        0,
        false,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_DecreaseIndent, c_Meta, c_Format, position:i16(0) }
```*/
function _FN35_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:DecreaseIndent = new DecreaseIndent(
        0.0 ,
        0,
        false,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Production_Token,

    c_Symbol,

    c_Token,

    name:$2.name,

    production:$2,

    val:-1,

    annotation:t_Reference,

    tok
 }
```*/
function _FN36_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Production_Token = new Production_Token(
        v1.name,
        v1,
        1.0,
        null,
        tok,
        0,
        false,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Goto, c_IR, c_IR_Instruction, state:$2 }
```*/
function _FN37_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Goto = new Goto(
        v1,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_FailState,

    c_IR,

    c_IR_State,

    id:$3,

    instructions:$4,

    symbol_meta:$6,

    fail:$5
 }
```*/
function _FN38_ (args: any[], tok: Token) : any { 
                        let v5 = args.pop();
let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:FailState = new FailState(
        v2,
        v3,
        v5,
        v4,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_FailState,

    c_IR,

    c_IR_State,

    id:$3,

    instructions:$4,

    symbol_meta:$5,

    fail:$NULL
 }
```*/
function _FN39_ (args: any[], tok: Token) : any { 
                        let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:FailState = new FailState(
        v2,
        v3,
        v4,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_FailState,

    c_IR,

    c_IR_State,

    id:$3,

    instructions:$4,

    symbol_meta:$NULL,

    fail:$5
 }
```*/
function _FN40_ (args: any[], tok: Token) : any { 
                        let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:FailState = new FailState(
        v2,
        v3,
        null,
        v4,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_FailState,

    c_IR,

    c_IR_State,

    id:$3,

    instructions:$4,

    symbol_meta:$NULL,

    fail:$NULL
 }
```*/
function _FN41_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:FailState = new FailState(
        v2,
        v3,
        null,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Symbols, c_IR, expected:$3, skipped:$4 }
```*/
function _FN42_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Symbols = new Symbols(
        v2,
        v3,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Symbols, c_IR, expected:$3, skipped:$NULL }
```*/
function _FN43_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Symbols = new Symbols(
        v2,
        [],
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Not_Symbol, c_Symbol, val:$2.val, symbol:$2, tok }
```*/
function _FN44_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Not_Symbol = new Not_Symbol(
        v1.val,
        v1,
        tok,
        0,
        false,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Look_Behind, c_Symbol, val:$2.val, symbol:$2, tok }
```*/
function _FN45_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Look_Behind = new Look_Behind(
        v1.val,
        v1,
        tok,
        0,
        false,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_List_Production,

    c_Symbol,

    terminal_symbol:$3,

    IS_OPTIONAL:f64($2=="(*"),

    symbols:$1,

    annotation:t_Reference,

    tok
 }
```*/
function _FN46_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:List_Production = new List_Production(
        v2,
        +(v1 == "(*"),
        v0,
        null,
        tok,
        false,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_List_Production,

    c_Symbol,

    terminal_symbol:$NULL,

    IS_OPTIONAL:f64($2=="(*"),

    symbols:$1,

    annotation:t_Reference,

    tok
 }
```*/
function _FN47_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:List_Production = new List_Production(
        null,
        +(v1 == "(*"),
        v0,
        null,
        tok,
        false,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Group_Production,

    c_Symbol,

    bodies:$2,

    annotation:t_Reference,

    tok
 }
```*/
function _FN48_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Group_Production = new Group_Production(
        v1,
        null,
        tok,
        0,
        false,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Body,

    c_Production,

    priority:$1?1000:20,

    symbols:$3,

    ref:$2,

    reduce_function:$4,

    FORCE_FORK:false,

    id:-1,

    production:t_Production
 }
```*/
function _FN49_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0 = 1000.0;
if( v0 ){ ref_0 = 20.0 }
 let ref_2:Body = new Body(
        ref_0,
        v2,
        v1,
        v3,
        false,
        1.0,
        null,
   );;

                                args.push(ref_2) 
                            }
/**
```
{ 

    t_Body,

    c_Production,

    priority:$NULL?1000:20,

    symbols:$2,

    ref:$1,

    reduce_function:$3,

    FORCE_FORK:false,

    id:-1,

    production:t_Production
 }
```*/
function _FN50_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Body = new Body(
        20.0,
        v1,
        v0,
        v2,
        false,
        1.0,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Body,

    c_Production,

    priority:$1?1000:20,

    symbols:$2,

    ref:$NULL,

    reduce_function:$3,

    FORCE_FORK:false,

    id:-1,

    production:t_Production
 }
```*/
function _FN51_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0 = 1000.0;
if( v0 ){ ref_0 = 20.0 }
 let ref_2:Body = new Body(
        ref_0,
        v1,
        null,
        v2,
        false,
        1.0,
        null,
   );;

                                args.push(ref_2) 
                            }
/**
```
{ 

    t_Body,

    c_Production,

    priority:$1?1000:20,

    symbols:$3,

    ref:$2,

    reduce_function:$NULL,

    FORCE_FORK:false,

    id:-1,

    production:t_Production
 }
```*/
function _FN52_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0 = 1000.0;
if( v0 ){ ref_0 = 20.0 }
 let ref_2:Body = new Body(
        ref_0,
        v2,
        v1,
        null,
        false,
        1.0,
        null,
   );;

                                args.push(ref_2) 
                            }
/**
```
{ 

    t_Body,

    c_Production,

    priority:$NULL?1000:20,

    symbols:$1,

    ref:$NULL,

    reduce_function:$2,

    FORCE_FORK:false,

    id:-1,

    production:t_Production
 }
```*/
function _FN53_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Body = new Body(
        20.0,
        v0,
        null,
        v1,
        false,
        1.0,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Body,

    c_Production,

    priority:$NULL?1000:20,

    symbols:$2,

    ref:$1,

    reduce_function:$NULL,

    FORCE_FORK:false,

    id:-1,

    production:t_Production
 }
```*/
function _FN54_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Body = new Body(
        20.0,
        v1,
        v0,
        null,
        false,
        1.0,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Body,

    c_Production,

    priority:$1?1000:20,

    symbols:$2,

    ref:$NULL,

    reduce_function:$NULL,

    FORCE_FORK:false,

    id:-1,

    production:t_Production
 }
```*/
function _FN55_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0 = 1000.0;
if( v0 ){ ref_0 = 20.0 }
 let ref_2:Body = new Body(
        ref_0,
        v1,
        null,
        null,
        false,
        1.0,
        null,
   );;

                                args.push(ref_2) 
                            }
/**
```
{ 

    t_Body,

    c_Production,

    priority:$NULL?1000:20,

    symbols:$1,

    ref:$NULL,

    reduce_function:$NULL,

    FORCE_FORK:false,

    id:-1,

    production:t_Production
 }
```*/
function _FN56_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:Body = new Body(
        20.0,
        v0,
        null,
        null,
        false,
        1.0,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Exclude,

    c_Symbol,

    c_Meta,

    sym:$2,

    index:-1,

    annotation:t_Reference,

    tok
 }
```*/
function _FN57_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Exclude = new Exclude(
        v1,
        1.0,
        null,
        tok,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Look_Ignore,

    c_Symbol,

    c_Meta,

    sym:$2,

    index:-1,

    annotation:t_Reference,

    tok
 }
```*/
function _FN58_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Look_Ignore = new Look_Ignore(
        v1,
        1.0,
        null,
        tok,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Empty,

    c_Symbol,

    val:"",

    annotation:t_Reference,

    tok
 }
```*/
function _FN59_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:Empty = new Empty(
        "",
        null,
        tok,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Production,

    c_Production,

    priority:$3?1000:0,

    symbol:$s,

    bodies:$b,

    id:-1,

    LAZY:bool($l),

    entry_name:""
 }
```*/
function _FN60_ (args: any[], tok: Token) : any { 
                        let v5 = args.pop();
let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0 = 1000.0;
if( v2 ){ ref_0 = 0.0 }
 let ref_2:Production = new Production(
        ref_0,
        v3,
        v5,
        1.0,
        !!(v1),
        "",
   );;

                                args.push(ref_2) 
                            }
/**
```
{ 

    t_ProductionMerged,

    c_Production,

    symbol:$2,

    bodies:$4,

    id:-1
 }
```*/
function _FN61_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:ProductionMerged = new ProductionMerged(
        v1,
        v3,
        1.0,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Production,

    c_Production,

    priority:$2?1000:0,

    symbol:$s,

    bodies:$b,

    id:-1,

    LAZY:bool($l),

    entry_name:""
 }
```*/
function _FN62_ (args: any[], tok: Token) : any { 
                        let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0 = 1000.0;
if( v1 ){ ref_0 = 0.0 }
 let ref_2:Production = new Production(
        ref_0,
        v2,
        v4,
        1.0,
        false,
        "",
   );;

                                args.push(ref_2) 
                            }
/**
```
{ 

    t_Production,

    c_Production,

    priority:$NULL?1000:0,

    symbol:$s,

    bodies:$b,

    id:-1,

    LAZY:bool($l),

    entry_name:""
 }
```*/
function _FN63_ (args: any[], tok: Token) : any { 
                        let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Production = new Production(
        0.0,
        v2,
        v4,
        1.0,
        !!(v1),
        "",
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Production,

    c_Production,

    priority:$NULL?1000:0,

    symbol:$s,

    bodies:$b,

    id:-1,

    LAZY:bool($l),

    entry_name:""
 }
```*/
function _FN64_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Production = new Production(
        0.0,
        v1,
        v3,
        1.0,
        false,
        "",
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Ignore, c_Preamble, symbols:$2 }
```*/
function _FN65_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Ignore = new Ignore(
        v1,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Import, c_Preamble, uri:$2, reference:$4 }
```*/
function _FN66_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Import = new Import(
        v1,
        v3,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Export, c_Preamble, production:$2, reference:$4 }
```*/
function _FN67_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Export = new Export(
        v1,
        v3,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Productions,

    functions:[],

    productions:[$1],

    ir:[],

    tok
 }
```*/
function _FN68_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:Out_Of_Band = [];
 let ref_1:(Production | ProductionMerged)[] = [v0];
 let ref_2:IR_STATE = [];
 let ref_3:Productions = new Productions(
        ref_0,
        ref_1,
        ref_2,
        tok,
   );;

                                args.push(ref_3) 
                            }
/**
```
{ 

    t_Productions,

    functions:[$1],

    productions:[],

    ir:[],

    tok
 }
```*/
function _FN69_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:(Out_Of_Band)[] = [v0];
 let ref_1:Production = [];
 let ref_2:( string | number | boolean | Token )[] = [];
 let ref_3:Productions = new Productions(
        ref_0,
        ref_1,
        ref_2,
        tok,
   );;

                                args.push(ref_3) 
                            }
/**
```
{ 

    t_Productions,

    functions:[],

    productions:[],

    ir:[$1],

    tok
 }
```*/
function _FN70_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:Out_Of_Band = [];
 let ref_1:Production = [];
 let ref_2:(IR_STATE)[] = [v0];
 let ref_3:Productions = new Productions(
        ref_0,
        ref_1,
        ref_2,
        tok,
   );;

                                args.push(ref_3) 
                            }
/**
```
{ t_Out_Of_Band, c_Function, reference:$2, txt:$4 }
```*/
function _FN71_ (args: any[], tok: Token) : any { 
                        let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Out_Of_Band = new Out_Of_Band(
        v1,
        v3,
        null,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Out_Of_Band,

    c_Function,

    production:$2,

    index:$3,

    txt:$5+""
 }
```*/
function _FN72_ (args: any[], tok: Token) : any { 
                        let v5 = args.pop();
let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Out_Of_Band = new Out_Of_Band(
        null,
        (v4).toString1(),
        v1,
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Out_Of_Band,

    c_Function,

    production:$2,

    index:$3,

    reference:$4
 }
```*/
function _FN73_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Out_Of_Band = new Out_Of_Band(
        v3,
        null,
        v1,
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Out_Of_Band,

    c_Function,

    production:$2,

    index:$NULL,

    txt:$4+""
 }
```*/
function _FN74_ (args: any[], tok: Token) : any { 
                        let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Out_Of_Band = new Out_Of_Band(
        null,
        (v3).toString1(),
        v1,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Out_Of_Band,

    c_Function,

    production:$2,

    index:$NULL,

    reference:$3
 }
```*/
function _FN75_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Out_Of_Band = new Out_Of_Band(
        v2,
        null,
        v1,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_IR_STATE,

    c_IR,

    c_IrState,

    prod:$3,

    instructions:$5,

    fail:$6,

    symbol_meta:$7
 }
```*/
function _FN76_ (args: any[], tok: Token) : any { 
                        let v7 = args.pop();
let v6 = args.pop();
let v5 = args.pop();
let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:IR_STATE = new IR_STATE(
        '',
        v4,
        v5,
        v6,
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_IR_STATE,

    c_IR,

    c_IrState,

    prod:$3,

    instructions:$5,

    fail:$NULL,

    symbol_meta:$6
 }
```*/
function _FN77_ (args: any[], tok: Token) : any { 
                        let v6 = args.pop();
let v5 = args.pop();
let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:IR_STATE = new IR_STATE(
        '',
        v4,
        null,
        v5,
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_IR_STATE,

    c_IR,

    c_IrState,

    prod:$3,

    instructions:$5,

    fail:$6,

    symbol_meta:$NULL
 }
```*/
function _FN78_ (args: any[], tok: Token) : any { 
                        let v6 = args.pop();
let v5 = args.pop();
let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:IR_STATE = new IR_STATE(
        '',
        v4,
        v5,
        null,
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_IR_STATE,

    c_IR,

    c_IrState,

    prod:$3,

    instructions:$5,

    fail:$NULL,

    symbol_meta:$NULL
 }
```*/
function _FN79_ (args: any[], tok: Token) : any { 
                        let v5 = args.pop();
let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:IR_STATE = new IR_STATE(
        '',
        v4,
        null,
        null,
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Repeat, c_IR, c_IR_Instruction }
```*/
function _FN80_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Repeat = new Repeat(
        
   );;

                                args.push(ref_0) 
                            }
/**
```
{ 

    t_Lazy,

    c_IR,

    c_IR_Instruction,

    cp_start:$3,

    cp_end:$4,

    state:$6
 }
```*/
function _FN81_ (args: any[], tok: Token) : any { 
                        let v5 = args.pop();
let v4 = args.pop();
let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Lazy = new Lazy(
        v2,
        v3,
        v5,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Num, val:i64($1) }
```*/
function _FN82_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:Num = new Num(
        parseInt(v0.toString()),
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_HASH_NAME, val:str($1) }
```*/
function _FN83_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:HASH_NAME = new HASH_NAME(
        v0.toString(),
   );;

                                args.push(ref_0) 
                            }
/**
```
str($3)
```*/
function _FN84_ (args: any[], tok: Token) : any { let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop(); 
 args.push(v2.toString())}
/**
```
$2
```*/
function _FN85_ (args: any[], tok: Token) : any { 
                                let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 
                                args.push(v1) } 
/**
```
$1+$2
```*/
function _FN86_ (args: any[], tok: Token) : any { let v1 = args.pop();
let v0 = args.pop(); 
 args.push(v0 + (v1).toString())}
/**
```
$1+$3+[$4]
```*/
function _FN87_ (args: any[], tok: Token) : any { 
                                let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:(Repeat | Repeat | Reduce | TokenAssign | SetProd | ForkTo | ScanUntil | TokenId | Pass | Fail | NotInScope | SetScope | Consume | Goto)[] = [v3];
v0.push(...v2);
ref_0.unshift(...v0);
 
                                args.push(ref_0) } 
/**
```
$1+[$2]
```*/
function _FN88_ (args: any[], tok: Token) : any { 
                                let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:(Repeat | Repeat | Goto)[] = [v1];
ref_0.unshift(...v0);
 
                                args.push(ref_0) } 
/**
```
[$1]
```*/
function _FN89_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(Lazy)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
$1+$NULL+[$2]
```*/
function _FN90_ (args: any[], tok: Token) : any { 
                                let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:(Repeat | Repeat | Reduce | TokenAssign | SetProd | ForkTo | ScanUntil | TokenId | Pass | Fail | NotInScope | SetScope | Consume)[] = [v1];
ref_0.unshift(...v0);
 
                                args.push(ref_0) } 
/**
```
$1+$3+[$NULL]
```*/
function _FN91_ (args: any[], tok: Token) : any { 
                                let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:(Reduce | TokenAssign | SetProd | ForkTo | ScanUntil | TokenId | Pass | Fail | NotInScope | SetScope | Consume | Goto)[] = [];
v0.push(...v2);
ref_0.unshift(...v0);
 
                                args.push(ref_0) } 
/**
```
$1+[$NULL]
```*/
function _FN92_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(Goto)[] = [];
ref_0.unshift(...v0);
 
                                args.push(ref_0) } 
/**
```
$1+$NULL+[$NULL]
```*/
function _FN93_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(Reduce | TokenAssign | SetProd | ForkTo | ScanUntil | TokenId | Pass | Fail | NotInScope | SetScope | Consume)[] = [];
ref_0.unshift(...v0);
 
                                args.push(ref_0) } 
/**
```
$NULL+[$1]
```*/
function _FN94_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(Repeat | Repeat)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
$NULL+[$NULL]
```*/
function _FN95_ (args: any[], tok: Token) : any {
                            let v0 = args.pop(); 
                                
 let ref_0:( string | number | boolean | Token )[] = [];
ref_0.push(null);

                                args.push(ref_0) 
                            }
/**
```
$3
```*/
function _FN96_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                

                                args.push(v2) 
                            }
/**
```
($1.annotation = $2, $1)
```*/
function _FN97_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
v0.annotation = v1

                                args.push(v0) 
                            }
/**
```
$1.IS_OPTIONAL = 1, $1
```*/
function _FN98_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
v0.IS_OPTIONAL = 1.0

                                args.push(v0) 
                            }
/**
```
$2.IS_NON_CAPTURE = true, $2
```*/
function _FN99_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
v1.IS_NON_CAPTURE = true

                                args.push(v1) 
                            }
/**
```
[$1]
```*/
function _FN100_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(Body)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
$__first__+$__last__
```*/
function _FN101_ (args: any[], tok: Token) : any { 
                                let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
v0.push(v2);
 
                                args.push(v0) } 
/**
```
$1+$2
```*/
function _FN102_ (args: any[], tok: Token) : any { 
                                let v1 = args.pop();
let v0 = args.pop();
                                
v0.push(...v1);
 
                                args.push(v0) } 
/**
```
$1
```*/
function _FN103_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 
                                args.push(v0) } 
/**
```
[]
```*/
function _FN104_ (args: any[], tok: Token) : any {
                            let v0 = args.pop(); 
                                
 let ref_0:( string | number | boolean | Token )[] = [];

                                args.push(ref_0) 
                            }
/**
```
[$1]
```*/
function _FN105_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(Not_Symbol | Look_Behind | List_Production | Generated | Exclusive_Literal | Literal | End_Of_File | Space | NewLine | IncreaseIndent | DecreaseIndent | Production_Token | Group_Production | Production_Symbol | Production_Import_Symbol)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
[$1]
```*/
function _FN106_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(Exclude | Look_Ignore)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
[$1]
```*/
function _FN107_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(Generated | Exclusive_Literal | Literal | End_Of_File | Space | NewLine | IncreaseIndent | DecreaseIndent | Production_Token)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
$__first__+$__last__
```*/
function _FN108_ (args: any[], tok: Token) : any { 
                                let v1 = args.pop();
let v0 = args.pop();
                                
v0.push(v1);
 
                                args.push(v0) } 
/**
```
[$1]
```*/
function _FN109_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(Ignore | Import | Export)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
$1.productions+$2, $1
```*/
function _FN110_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
v0.productions.push(v1);
v0.productions

                                args.push(v0) 
                            }
/**
```
$1.functions+$2, $1
```*/
function _FN111_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
v0.functions.push(v1);
v0.functions

                                args.push(v0) 
                            }
/**
```
$1.ir+$2, $1
```*/
function _FN112_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
v0.ir.push(v1);
v0.ir

                                args.push(v0) 
                            }
/**
```
[$1]
```*/
function _FN113_ (args: any[], tok: Token) : any {
                            let v0 = args.pop(); 
                                
 let ref_0:Token[] = [v0];

                                args.push(ref_0) 
                            }
/**
```
$__first__+$__last__
```*/
function _FN114_ (args: any[], tok: Token) : any {
                            let v1 = args.pop();
let v0 = args.pop(); 
                                
v0.push(v1)

                                args.push(v0) 
                            }
/**
```
[$1]
```*/
function _FN115_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(ASSERT | PEEK)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
[$1]
```*/
function _FN116_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(Production_Symbol | Production_Import_Symbol)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
[$1]
```*/
function _FN117_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(Num)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
[$1]
```*/
function _FN118_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(Reduce | TokenAssign | SetProd | ForkTo | ScanUntil | TokenId | Pass | Fail | NotInScope | SetScope | Consume)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
[$1]
```*/
function _FN119_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(Goto)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
[$1]
```*/
function _FN120_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(Production_Symbol | Production_Import_Symbol | HASH_NAME)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
i64($1)
```*/
function _FN121_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                

                                args.push(parseInt(v0.toString())) 
                            }
/**
```
str($1)
```*/
function _FN122_ (args: any[], tok: Token) : any { let v0 = args.pop(); 
 args.push(v0.toString())}
/**
```
str($__first__)+str($__last__)
```*/
function _FN123_ (args: any[], tok: Token) : any { let v1 = args.pop();
let v0 = args.pop(); 
 args.push(v0 + v1.toString())}
/**
```
$2
```*/
function _FN124_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                

                                args.push(v1) 
                            }
/**
```
[$2]
```*/
function _FN125_ (args: any[], tok: Token) : any { 
                                let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:(Reference)[] = [v1];
 
                                args.push(ref_0) } 
/**
```
$__first__+$__last__
```*/
function _FN126_ (args: any[], tok: Token) : any { 
                                let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
v0.push(v2);

                                args.push(v0); 
                            }
/**
```
[$2]
```*/
function _FN127_ (args: any[], tok: Token) : any {
                            let v1 = args.pop();
let v0 = args.pop(); 
                                
 let ref_0:number[] = [v1];

                                args.push(ref_0) 
                            }
/**
```
[$2]
```*/
function _FN128_ (args: any[], tok: Token) : any {
                            let v1 = args.pop();
let v0 = args.pop(); 
                                
 let ref_0:string[] = [v1];

                                args.push(ref_0) 
                            }
/**
```
f64($1)
```*/
function _FN129_ (args: any[], tok: Token) : any {let v0 = args.pop(); 
args.push(parseFloat(v0.toString()))}
/**
```

```*/
function _FN130_ (args: any[], tok: Token) : any {}
/**
```

```*/
function _FN131_ (args: any[], tok: Token) : any {  let v1 = args.pop();
let v0 = args.pop();
 args.push(v1); }
/**
```

```*/
function _FN132_ (args: any[], tok: Token) : any {  let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
 args.push(v2); }



export  const FunctionMaps = [
    _FN130_,
_FN0_,
_FN1_,
_FN130_,
_FN130_,
_FN130_,
_FN131_,
_FN130_,
_FN130_,
_FN130_,
_FN130_,
_FN130_,
_FN131_,
_FN130_,
_FN132_,
_FN2_,
_FN3_,
_FN4_,
_FN5_,
_FN84_,
_FN131_,
_FN130_,
_FN130_,
_FN130_,
_FN130_,
_FN131_,
_FN131_,
_FN131_,
_FN130_,
_FN130_,
_FN6_,
_FN7_,
_FN6_,
_FN6_,
_FN6_,
_FN6_,
_FN7_,
_FN7_,
_FN7_,
_FN85_,
_FN130_,
_FN130_,
_FN8_,
_FN86_,
_FN131_,
_FN86_,
_FN86_,
_FN130_,
_FN130_,
_FN130_,
_FN9_,
_FN87_,
_FN88_,
_FN89_,
_FN90_,
_FN91_,
_FN92_,
_FN93_,
_FN94_,
_FN95_,
_FN10_,
_FN11_,
_FN12_,
_FN13_,
_FN14_,
_FN15_,
_FN16_,
_FN17_,
_FN18_,
_FN19_,
_FN20_,
_FN21_,
_FN13_,
_FN16_,
_FN22_,
_FN23_,
_FN24_,
_FN25_,
_FN24_,
_FN25_,
_FN130_,
_FN130_,
_FN130_,
_FN131_,
_FN131_,
_FN130_,
_FN130_,
_FN130_,
_FN130_,
_FN130_,
_FN130_,
_FN130_,
_FN132_,
_FN26_,
_FN131_,
_FN130_,
_FN85_,
_FN130_,
_FN130_,
_FN130_,
_FN130_,
_FN130_,
_FN130_,
_FN27_,
_FN28_,
_FN29_,
_FN130_,
_FN130_,
_FN130_,
_FN30_,
_FN31_,
_FN130_,
_FN130_,
_FN130_,
_FN130_,
_FN32_,
_FN33_,
_FN34_,
_FN35_,
_FN36_,
_FN96_,
_FN96_,
_FN37_,
_FN38_,
_FN39_,
_FN40_,
_FN41_,
_FN42_,
_FN43_,
_FN130_,
_FN97_,
_FN98_,
_FN44_,
_FN45_,
_FN99_,
_FN130_,
_FN130_,
_FN130_,
_FN46_,
_FN46_,
_FN47_,
_FN47_,
_FN48_,
_FN100_,
_FN101_,
_FN49_,
_FN50_,
_FN51_,
_FN52_,
_FN53_,
_FN54_,
_FN55_,
_FN56_,
_FN102_,
_FN103_,
_FN104_,
_FN105_,
_FN106_,
_FN85_,
_FN57_,
_FN58_,
_FN58_,
_FN107_,
_FN108_,
_FN59_,
_FN60_,
_FN61_,
_FN62_,
_FN63_,
_FN64_,
_FN130_,
_FN97_,
_FN109_,
_FN108_,
_FN130_,
_FN130_,
_FN130_,
_FN65_,
_FN107_,
_FN108_,
_FN130_,
_FN66_,
_FN66_,
_FN67_,
_FN67_,
_FN68_,
_FN69_,
_FN70_,
_FN110_,
_FN111_,
_FN112_,
_FN71_,
_FN72_,
_FN73_,
_FN74_,
_FN75_,
_FN132_,
_FN76_,
_FN77_,
_FN78_,
_FN79_,
_FN130_,
_FN113_,
_FN114_,
_FN113_,
_FN114_,
_FN113_,
_FN108_,
_FN113_,
_FN108_,
_FN115_,
_FN108_,
_FN116_,
_FN108_,
_FN117_,
_FN108_,
_FN118_,
_FN101_,
_FN119_,
_FN101_,
_FN80_,
_FN81_,
_FN82_,
_FN120_,
_FN101_,
_FN82_,
_FN116_,
_FN108_,
_FN117_,
_FN108_,
_FN121_,
_FN107_,
_FN108_,
_FN117_,
_FN108_,
_FN122_,
_FN123_,
_FN122_,
_FN122_,
_FN123_,
_FN123_,
_FN122_,
_FN123_,
_FN122_,
_FN123_,
_FN122_,
_FN123_,
_FN122_,
_FN122_,
_FN123_,
_FN123_,
_FN83_,
_FN124_,
_FN124_,
_FN122_,
_FN123_,
_FN122_,
_FN123_,
_FN125_,
_FN126_,
_FN127_,
_FN128_,
_FN126_,
_FN126_,
_FN82_,
_FN82_,
_FN82_,
_FN129_,
_FN122_,
];
