@NAME ascript

@IGNORE g:sp g:nl

<> body >  

    struct 
    
    | expression(+\, )
        f:ast { { t_AST_Statements, statements:$1, tok } }

<> expression > 
    
    member

    | string_convert

    | numeric_convert

    | bool_convert

    | literal

    | vector

    | token


<> struct > 

    \{ struct_prop(+\, ) \}
        f:ast { { t_AST_Struct, props:$2, tok } }


<> struct_prop >  
    
    identifier \: expression
        f:ast { { t_AST_Property, id:str($1), value:$3, tok } }
    
    |  identifier \: struct
        f:ast { { t_AST_Property, id:str($1), value:$3, tok } }
    
    |  identifier
        f:ast { { t_AST_Property, id:str($1), named_reference: str($1), tok } }
    
    | type_identifier
        f:ast { { t_AST_TypeId,  value:str($1), tok } }
    
    | class_identifier
        f:ast { { t_AST_ClassId, value:str($1), tok } }

    | token


<> type_identifier > 

    t:t_ identifier


<> class_identifier >

    t:c_ identifier


<> vector >

    \[ expression(*\, ) \]
        f:ast { { t_AST_Vector, initializer: $2, tok  } }


<> add > 
    
    member \+ expression
    
        f:ast { { t_AST_Add, left: $1, right: $3, tok } }


<> member > 
    
    reference

    | reference \. identifier
        f:ast { { t_AST_Member, reference:$1, property:$3 } }


<> string_convert > 
    
    t:str convert_initializer?
        f:ast { { t_AST_STRING, value: $2, tok  } }


<> bool_convert > 
    
    t:bool convert_initializer?
        f:ast { { t_AST_BOOL,  initializer: $2, tok  } }


<> numeric_convert > 
    
    t:u8  convert_initializer?
        f:ast { { t_AST_U8,  initializer: $2, tok  } }

    | t:u16 convert_initializer?
        f:ast { { t_AST_U16, initializer: $2, tok  } }

    | t:u32 convert_initializer?
        f:ast { { t_AST_U32, initializer: $2, tok  } }

    | t:u64 convert_initializer?
        f:ast { { t_AST_U64, initializer: $2, tok  } }

    | t:i8  convert_initializer?
        f:ast { { t_AST_I8,  initializer: $2, tok  } }

    | t:i16 convert_initializer?
        f:ast { { t_AST_I16, initializer: $2, tok  } }

    | t:i32 convert_initializer?
        f:ast { { t_AST_I32, initializer: $2, tok  } }

    | t:i64 convert_initializer?
        f:ast { { t_AST_I64, initializer: $2, tok  } }

    | t:f32 convert_initializer?
        f:ast { { t_AST_F32, initializer: $2, tok  } }

    | t:f64 convert_initializer?
        f:ast { { t_AST_F64, initializer: $2, tok  } }


<> convert_initializer > 

    t:( init_objects t:)       
        f:ast { { t_Init, expression: $2 } }

<> init_objects > member | token 


<> literal > 
    
    t:true 
        f:ast { { t_AST_BOOL, value: true } }

    | t:false
        f:ast { { t_AST_BOOL, value: false } }

    | tk:integer
        f:ast { { t_AST_NUMBER, value:f64($1) } }



<> reference > 
    
    t:$ tk:identifier 
        f:ast { { t_AST_NamedReference, value: str($2), tok } }

    | t:$ tk:integer         
        f:ast { { t_AST_IndexReference, value: i64($2), tok } }


<> integer > 
    
    g:num(+)


<> identifier > 

    tk:identifier_syms 


<> identifier_syms >  

    identifier_syms g:id

    | identifier_syms \_

    | identifier_syms \-

    | identifier_syms g:num      

    | \_ 

    | \- 

    | g:id


<> token > 

    t:tok 
        f:ast { { t_AST_Token } }

    | t:token 
        f:ast { { t_AST_Token } }