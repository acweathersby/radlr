//! A CST implementation, heavily inspired by rowan, suitable for
//! handling ambiguous and error corrected trees (technically a shared packed
//! parser forest)

use super::super::*;
use std::{
  collections::hash_map::DefaultHasher,
  fmt::Debug,
  hash::{Hash, Hasher},
  rc::Rc,
};

/// A hash of the node that only takes into account non-spacial values.
pub trait CSTHashes: Hash {
  fn canonical_hash<H: std::hash::Hasher>(&self, state: &mut H);
  fn dedup_hash<H: std::hash::Hasher>(&self, state: &mut H);
}

#[derive(Clone)]
#[cfg_attr(debug_assertions, derive(Debug))]
pub enum CSTErrorNodeType {
  MissingToken(u16),
  ErroneousInput,
}

#[derive(Clone, Hash)]
pub enum CSTNode {
  /// A Token that is ignored in the grammar
  Skipped(TokenNode),
  /// A general Token recognized from the input
  Token(ParserState, TokenNode),
  /// A token that was generated by the parser to overcome
  /// an error caused by the absence of the token
  MissingToken(u32, ParserState, TokenNode),
  /// A sequence of erroneous characters found within the
  /// input.
  Errata(TokenNode),
  /// A non-terminal node produce from the reduction of a rule.
  NonTerm(NonTermNode),
  /// A series of alternative interpretations of a sequence of
  /// characters
  Alts(Alts),
}

impl CSTHashes for CSTNode {
  fn canonical_hash<H: std::hash::Hasher>(&self, state: &mut H) {
    use CSTNode::*;
    match self {
      Errata(..) | Skipped(..) => {}
      Token(_, tok) | MissingToken(.., tok) => tok.canonical_hash(state),
      NonTerm(nt) => nt.canonical_hash(state),
      Alts(m) => m.canonical_hash(state),
    }
  }

  fn dedup_hash<H: std::hash::Hasher>(&self, state: &mut H) {
    use CSTNode::*;
    match self {
      Errata(tok) | Skipped(tok) | Token(_, tok) | MissingToken(.., tok) => tok.dedup_hash(state),
      NonTerm(nt) => nt.dedup_hash(state),
      Alts(m) => m.dedup_hash(state),
    }
  }
}

impl CSTNode {
  pub fn offset(&self) -> u32 {
    use CSTNode::*;
    match self {
      Errata(tok) | Skipped(tok) | Token(_, tok) | MissingToken(.., tok) => tok.offset,
      NonTerm(nt) => nt.offset,
      Alts(m) => m.offset,
    }
  }

  pub fn length(&self) -> u32 {
    use CSTNode::*;
    match self {
      Errata(tok) | Skipped(tok) | Token(_, tok) | MissingToken(.., tok) => tok.val.len() as u32,
      NonTerm(nt) => nt.length,
      Alts(m) => m.length,
    }
  }
}

impl Debug for CSTNode {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    match self {
      Self::Skipped(node) => {
        node.fmt(f)?;
        f.write_str(" [skipped]")
      }
      Self::MissingToken(.., node) => {
        node.fmt(f)?;
        f.write_str(" [missing]")
      }
      Self::Errata(node) => {
        node.fmt(f)?;
        f.write_str(" [errata]")
      }
      Self::Token(_, node) => node.fmt(f),
      Self::Alts(multi) => multi.fmt(f),
      Self::NonTerm(nt) => nt.fmt(f),
    }
  }
}

#[derive(Clone, Hash)]
pub struct NonTermNode {
  pub id:      u16,
  pub rule:    u16,
  pub offset:  u32,
  pub length:  u32,
  pub symbols: Vec<Rc<CSTNode>>,
}

impl CSTHashes for NonTermNode {
  fn canonical_hash<H: std::hash::Hasher>(&self, state: &mut H) {
    self.id.hash(state);
  }

  fn dedup_hash<H: std::hash::Hasher>(&self, state: &mut H) {
    self.id.hash(state);
    self.symbols.iter().for_each(|s| s.dedup_hash(state))
  }
}

impl Debug for NonTermNode {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut hasher = DefaultHasher::new();
    self.canonical_hash(&mut hasher);

    let mut dedup = DefaultHasher::new();
    self.dedup_hash(&mut dedup);

    f.write_fmt(format_args!(
      "[nonterm: {} @ {} : {} : {}]",
      self.id,
      self as *const _ as usize,
      hasher.finish(),
      dedup.finish()
    ))?;
    let mut list = f.debug_list();
    for obj in &self.symbols {
      list.entry(obj);
    }
    list.finish()
  }
}

impl NonTermNode {
  pub fn new(id: u16, rule: u16, symbols: Vec<Rc<CSTNode>>, offset: u32, length: u32) -> Self {
    Self { id, rule, symbols, offset, length }
  }

  pub fn typed(id: u16, rule: u16, symbols: Vec<Rc<CSTNode>>, offset: u32, length: u32) -> CSTNode {
    CSTNode::NonTerm(Self::new(id, rule, symbols, offset, length))
  }
}

#[derive(Clone, Hash)]
pub struct Alts {
  pub length:       u32,
  pub offset:       u32,
  pub alternatives: Vec<Rc<Alternative>>,
  #[cfg(debug_assertions)]
  pub meta_label:   &'static str,
}

impl Alts {
  pub fn new(alternatives: Vec<Rc<Alternative>>, meta_label: &'static str) -> Self {
    let length = alternatives[0].length;
    let offset = alternatives[0].offset;

    #[cfg(debug_assertions)]
    {
      Self { alternatives, length, offset, meta_label }
    }
    #[cfg(not(debug_assertions))]
    Self { alternatives, length, offset }
  }

  pub fn typed(alternatives: Vec<Rc<Alternative>>, meta_label: &'static str) -> CSTNode {
    CSTNode::Alts(Self::new(alternatives, meta_label))
  }
}

impl CSTHashes for Alts {
  fn canonical_hash<H: std::hash::Hasher>(&self, state: &mut H) {
    self.alternatives[0].canonical_hash(state)
  }

  fn dedup_hash<H: std::hash::Hasher>(&self, state: &mut H) {
    self.alternatives.iter().for_each(|s| s.dedup_hash(state))
  }
}

impl Debug for Alts {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    #[cfg(debug_assertions)]
    f.write_fmt(format_args!("[multi: {}]", self.meta_label))?;
    #[cfg(not(debug_assertions))]
    f.write_fmt(format_args!("[multi]"))?;
    let mut list = f.debug_list();
    for obj in &self.alternatives {
      list.entry(obj);
    }
    list.finish()
  }
}

#[derive(Clone, Hash)]
pub struct Alternative {
  pub length:  u32,
  pub offset:  u32,
  pub entropy: isize,
  pub symbols: Vec<Rc<CSTNode>>,
}

impl CSTHashes for Alternative {
  fn canonical_hash<H: std::hash::Hasher>(&self, state: &mut H) {
    self.symbols.iter().for_each(|s| s.canonical_hash(state))
  }

  fn dedup_hash<H: std::hash::Hasher>(&self, state: &mut H) {
    self.symbols.iter().for_each(|s| s.dedup_hash(state))
  }
}

impl Debug for Alternative {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut hasher = DefaultHasher::new();
    self.symbols.iter().for_each(|s| s.dedup_hash(&mut hasher));
    f.write_fmt(format_args!("[alternative [{}] : {}]", self.entropy, hasher.finish()))?;
    let mut list = f.debug_list();
    for obj in &self.symbols {
      list.entry(obj);
    }
    list.finish()
  }
}

pub trait CSTtoASTProducer<I: ParserInput, ASTNode>: ASTProducer<I, ASTNode> {
  fn cst_to_ast(&self, node: &CSTNode) -> Option<ASTBaseNode<ASTNode>> {
    use CSTNode::*;
    match node {
      Skipped(..) | Errata { .. } => None,
      Token(.., token) | MissingToken(.., token) => Some(ASTBaseNode::Token(Rc::new(token.clone()))),
      NonTerm(non_term) => {
        let reduce_fn = self.get_reduce_functions()[non_term.rule as usize];

        let mut symbols = non_term.symbols.iter().filter_map(|n| self.cst_to_ast(n));

        Some(reduce_fn(&mut symbols))
      }
      Alts(multi) => {
        if let Some(first) = multi.alternatives.first() {
          first.symbols.iter().filter_map(|n| self.cst_to_ast(n)).next()
        } else {
          None
        }
      }
    }
  }
}

struct TokenCache {
  cache: std::collections::HashMap<Token, ()>,
}

#[derive(Clone)]
enum Token_ {
  LargeToken(Rc<LargeToken>),
  SmallToken { len: u8, tok_id: u16, data: [u8; 12] },
}

impl Token_ {
  pub fn str(&self) -> &str {
    match self {
      Self::LargeToken(tk) => tk.val.as_str(),
      Self::SmallToken { len, tok_id, data } => unsafe { std::str::from_utf8_unchecked(&data[0..*len as usize]) },
    }
  }
}

struct LargeToken {
  pub val: String,
}

#[derive(Clone, Hash)]
pub struct TokenNode {
  pub tok_id: u32,
  pub offset: u32,
  pub val:    String,
}

impl TokenNode {
  pub fn new(tok_id: u32, offset: u32, val: String) -> Self {
    Self { tok_id, offset, val }
  }

  pub fn skipped_type(tok_id: u32, offset: u32, val: String) -> CSTNode {
    CSTNode::Skipped(Self::new(tok_id, offset, val))
  }

  pub fn token_type(state: ParserState, tok_id: u32, offset: u32, val: String) -> CSTNode {
    CSTNode::Token(state, Self::new(tok_id, offset, val))
  }

  pub fn missing_type(state: ParserState, tok_id: u32, offset: u32, val: String, entropy: u32) -> CSTNode {
    CSTNode::MissingToken(entropy, state, Self::new(tok_id, offset, val))
  }

  pub fn error_type(tok_id: u32, offset: u32, val: String) -> CSTNode {
    CSTNode::Errata(Self::new(tok_id, offset, val))
  }

  pub fn length(&self) -> u32 {
    self.val.len() as u32
  }
}

impl CSTHashes for TokenNode {
  fn canonical_hash<H: std::hash::Hasher>(&self, state: &mut H) {
    self.tok_id.hash(state);
  }

  fn dedup_hash<H: std::hash::Hasher>(&self, state: &mut H) {
    self.tok_id.hash(state);
    self.val.hash(state);
  }
}

impl Debug for TokenNode {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    f.write_fmt(format_args!("┊{}┊", self.val))
  }
}
