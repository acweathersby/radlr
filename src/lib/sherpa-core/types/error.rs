use crate::proxy::Array;
use sherpa_rust_runtime::{
  deprecate::SherpaParseError,
  types::{BlameColor, ParserError, Token},
};
use std::{
  hash::Hash,
  path::PathBuf,
  string::{FromUtf16Error, FromUtf8Error},
  sync::PoisonError,
};

use SherpaError::*;

/// All classes of errors that can be generated by sherpa
#[derive(Clone, Copy, Hash)]
#[repr(u8)]
pub enum ErrorClass {
  Exports,
  Imports,
  Grammar,
  Parsing,
  ForbiddenLR,
  ForbiddenLL,
  ForbiddenPeek,
  ForbiddenFork,
  GraphConstruction,
  Extended(u32),
}

#[derive(Clone, Hash)]
pub struct ErrorId(pub ErrorClass, pub usize, pub &'static str);

impl ErrorId {
  pub fn to_string(&self) -> String {
    let ErrorId(class, case, friendly_title) = self;
    let id = class.discriminant() * 100 + case;
    let id_string_base = "[".to_string() + &id.to_string() + "]";
    let friendly_title = if friendly_title.len() > 1 { "-".to_string() + friendly_title } else { Default::default() };
    id_string_base + &friendly_title
  }
}

impl ErrorClass {
  fn discriminant(&self) -> usize {
    // SAFETY: Because `Self` is marked `repr(u8)`, its layout is a `repr(C)`
    // `union` between `repr(C)` structs, each of which has the `u8`
    // discriminant as its first field, so we can read the discriminant without
    // offsetting the pointer.
    let des = unsafe { *<*const _>::from(self).cast::<u8>() } as usize;

    if let ErrorClass::Extended(extension) = self {
      des + *extension as usize
    } else {
      des
    }
  }
}

impl From<(ErrorClass, usize, &'static str)> for ErrorId {
  fn from(value: (ErrorClass, usize, &'static str)) -> Self {
    Self(value.0, value.1, value.2)
  }
}

impl From<(ErrorClass, usize)> for ErrorId {
  fn from(value: (ErrorClass, usize)) -> Self {
    Self(value.0, value.1, "")
  }
}

pub(crate) mod severity {

  /// Severity types of SherpaErrors
  #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
  #[cfg_attr(any(debug_assertions, feature = "auto_print_errors"), derive(std::fmt::Debug))]
  pub enum SherpaErrorSeverity {
    /// No error at all
    None,
    /// A hint that can be communicated to the user to improve some
    /// aspect of the grammar or parser.
    Hint,
    /// A warning that can be ignored but would yield better results
    /// if heeded.
    Warning,
    /// An error that compromises the integrate of the compile process
    /// and halts progression.
    #[default]
    Critical,
  }
}

pub use severity::SherpaErrorSeverity;

/// Stores every error type that can be generated by a sherpa function. Also
/// wraps common error types.
#[derive(Clone, Hash)]
pub enum SherpaError {
  /// A general structure for reporting an error that has occurred
  /// within a source file.
  SourceError {
    /// Location of the error within a source file.
    loc:        Token,
    /// Path to the source file containing the error.
    path:       PathBuf,
    /// A unique identifier for this class of error, in the form `g:id(+)(\-
    /// g:id(+))(*)`
    id:         ErrorId,
    /// The description of the error
    msg:        String,
    /// An optional message that appears inline
    /// within the error location diagram. Set to an empty string
    /// to prevents its display.
    inline_msg: String,
    /// An optional message that appears after the source diagram.
    ps_msg:     String,
    /// The severity of the error.
    severity:   SherpaErrorSeverity,
  },
  /// A general structure for reporting an error that has occurred
  /// within an external source file.
  SourcesError {
    /// A vector of source tuples, comprised of the source
    /// token, the path to source file that generated the token,
    /// and an inline string message which can be an empty string:
    /// An optional inline message that appears inline
    /// within the error location diagram. Set to an empty string
    /// to prevents its display.
    sources:  Vec<(Token, PathBuf, String)>,
    /// A unique identifier for this class of error, in the form `g:id(+)(\-
    /// g:id(+))(*)`
    id:       ErrorId,
    /// The description of the error
    msg:      String,
    /// An optional message that appears after the source diagram.
    ps_msg:   String,
    /// The severity of the error.
    severity: SherpaErrorSeverity,
  },
  //---------------------------------------------------------------------------
  // ----------------- Generic Error Types
  // ------------------------------------
  //---------------------------------------------------------------------------
  /// Error from a poisoned pointer.
  PoisonError(String),
  /// Error from an IO operation
  IOError(String),
  /// Generic error
  Error(std::fmt::Error),
  /// Plaintext error message
  Text(String),

  /// Plaintext error message
  StaticText(&'static str),

  /// Multiple Errors
  Multi(Vec<SherpaError>),
}

impl IntoIterator for SherpaError {
  type IntoIter = std::vec::IntoIter<Self::Item>;
  type Item = SherpaError;

  fn into_iter(self) -> Self::IntoIter {
    match self {
      Multi(errors) => errors.into_iter(),
      err => vec![err].into_iter(),
    }
  }
}

impl SherpaError {
  /// Return the Errors severity
  pub fn get_severity(&self) -> SherpaErrorSeverity {
    match self {
      _ => SherpaErrorSeverity::Critical,
    }
  }

  /// Convert SherpaParseError into SherpaError
  pub fn from_parse_error(err: SherpaParseError, path: PathBuf) -> SherpaError {
    Self::SourceError {
      loc: err.loc,
      path,
      id: (ErrorClass::Parsing, 99, "parse-error").into(),
      msg: err.message,
      inline_msg: err.inline_message,
      ps_msg: Default::default(),
      severity: SherpaErrorSeverity::Critical,
    }
  }

  /// Compares the friendly name of an error with a string,
  /// returning `true` if the two match.
  pub fn is(&self, _friendly_name: &str) -> bool {
    match self {
      _ => false,
    }
  }

  /// Todo
  pub fn is_critical(&self) -> bool {
    matches!(self.get_severity(), _Critical)
  }

  /// Todo
  pub fn is_hint(&self) -> bool {
    matches!(self.get_severity(), _Hint)
  }

  /// Todo
  pub fn is_warning(&self) -> bool {
    matches!(self.get_severity(), _Warning)
  }

  pub fn flatten(self) -> Array<SherpaError> {
    match self {
      Multi(errors) => errors.into_iter().flat_map(|e| e.flatten()).collect(),
      err => vec![err],
    }
  }
}

impl<T> From<PoisonError<T>> for SherpaError {
  fn from(err: PoisonError<T>) -> Self {
    PoisonError(err.to_string())
  }
}

impl From<std::io::Error> for SherpaError {
  fn from(err: std::io::Error) -> Self {
    IOError(err.to_string())
  }
}

impl From<std::fmt::Error> for SherpaError {
  fn from(err: std::fmt::Error) -> Self {
    Self::Error(err)
  }
}

impl From<()> for SherpaError {
  fn from(_: ()) -> Self {
    "UNDEFINED".into()
  }
}

impl From<&str> for SherpaError {
  fn from(err: &str) -> Self {
    Text(err.to_string())
  }
}

impl From<String> for SherpaError {
  fn from(err: String) -> Self {
    Text(err)
  }
}

impl From<FromUtf8Error> for SherpaError {
  fn from(err: FromUtf8Error) -> Self {
    Text(err.to_string())
  }
}

impl From<FromUtf16Error> for SherpaError {
  fn from(err: FromUtf16Error) -> Self {
    Text(err.to_string())
  }
}

impl From<SherpaParseError> for SherpaError {
  fn from(err: SherpaParseError) -> Self {
    Self::from_parse_error(err, Default::default())
  }
}

impl From<ParserError> for SherpaError {
  #[track_caller]
  fn from(err: ParserError) -> Self {
    match err {
      ParserError::InputError { message, inline_message, loc, last_nonterminal } => Self::SourceError {
        loc:        loc,
        path:       Default::default(),
        id:         (ErrorClass::Parsing, 99, "parse-error").into(),
        msg:        message,
        inline_msg: inline_message,
        ps_msg:     Default::default(),
        severity:   SherpaErrorSeverity::Critical,
      },
      ParserError::InvalidNonTerminal => Self::Text("Invalid non-terminal".into()),
      ParserError::Unexpected | _ => Self::Text("Unexpected error".into()),
    }
  }
}

impl std::fmt::Display for SherpaError {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    std::fmt::Debug::fmt(&self, f)
  }
}

impl std::fmt::Debug for SherpaError {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    match self {
      SourceError { msg, id, inline_msg, loc, path, ps_msg, .. } => f.write_fmt(format_args!(
        "\n{} [{}:{}]\n{}\n\n{}\n\n{}\n",
        id.to_string(),
        path.to_str().unwrap(),
        loc.loc_stub(),
        msg.trim(),
        loc.blame(1, 1, &inline_msg.trim(), BlameColor::RED),
        ps_msg.trim()
      )),
      SourcesError { msg, id, sources, ps_msg, .. } => f.write_fmt(format_args!(
        "\n{}\n{}\n{}\n\n{}\n",
        id.to_string(),
        msg.trim(),
        sources
          .iter()
          .map(|(tok, path, inline_message)| format!(
            "-- in [{}:{}]\n    {}",
            path.to_str().unwrap(),
            tok.loc_stub(),
            tok.blame(1, 1, inline_message, BlameColor::RED).replace("\n", "\n    ")
          ))
          .collect::<Vec<_>>()
          .join("\n"),
        ps_msg.trim()
      )),
      PoisonError(err_string) => f.write_fmt(format_args!("\nPoison Error: {}", err_string)),
      IOError(err_string) => f.write_fmt(format_args!("\nIO Error: {}", err_string)),
      Text(err_string) => f.write_str(&err_string),
      StaticText(err_string) => f.write_str(err_string),
      Self::Error(error) => std::fmt::Debug::fmt(error, f),
      Multi(errors) => {
        let f = f;
        for error in errors {
          std::fmt::Debug::fmt(error, f)?;
        }
        std::fmt::Result::Ok(())
      }
    }
  }
}

#[derive(Default)]
#[cfg_attr(any(debug_assertions, auto_print_errors), derive(std::fmt::Debug))]
pub struct ErrorGroups {
  pub hints:    Vec<SherpaError>,
  pub warnings: Vec<SherpaError>,
  pub critical: Vec<SherpaError>,
}

pub trait ErrorContainerIter: Iterator<Item = SherpaError> + Sized + Clone {
  fn _debug_print_(&self) {
    for error in self.clone() {
      eprintln!("{:?}", error);
    }
  }

  fn stderr_print(&self) {
    for error in self.clone() {
      eprintln!("{:?}", error);
    }
  }

  fn have_errors(&self) -> bool {
    self.clone().count() == 0
  }

  fn have_critical(&self) -> bool {
    self.clone().any(|e| e.is_critical())
  }

  fn have_hints(&self) -> bool {
    self.clone().any(|e| e.is_hint())
  }

  fn have_warnings(&self) -> bool {
    self.clone().any(|e| e.is_warning())
  }

  fn get_errors_types(self) -> ErrorGroups {
    let mut groups = ErrorGroups { ..Default::default() };
    for error in self {
      match error.get_severity() {
        SherpaErrorSeverity::Critical => groups.critical.push(error.clone()),
        SherpaErrorSeverity::Warning => groups.warnings.push(error.clone()),
        SherpaErrorSeverity::Hint => groups.critical.push(error.clone()),
        _ => {}
      }
    }
    groups
  }

  fn flatten(self) -> Array<SherpaError> {
    let mut out = Array::default();
    for err in self {
      out.extend(err.flatten());
    }

    out
  }

  fn into_multi(self) -> SherpaError {
    SherpaError::Multi(Array::from_iter(self))
  }
}

impl<T: Iterator<Item = SherpaError> + Sized + Clone> ErrorContainerIter for T {}
