@{#![allow(unused)]

use radlr_rust_runtime::parsers::ast::{Tk, Reducer, Node};


/// ### `radlr` Rust Parser
///
/// - **GENERATOR**: radlr 1.0.0-beta2
/// - **SOURCE**: /home/work/projects/lib_radlr/src/grammar/v2_0_0/grammar.sg
///
/// #### WARNING:
///
/// This is a generated file. Any changes to this file may be **overwritten
/// without notice**.
///
/// #### License:
/// Copyright (c) 2023 Anthony Weathersby
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy
/// of this software and associated documentation files (the 'Software'), to
/// deal in the Software without restriction, including without limitation the
/// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
/// sell copies of the Software, and to permit persons to whom the Software is
/// furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice shall be included in
/// all copies or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
/// IN THE SOFTWARE

@structs
  
@rules.iter#rule_function()

}

#_ {@"This is a comment function. Since we never call it, it has the same effect as a comment in other languages."}

#type_structs {

  #node_entry { @self.name(Box<@self.name<Token>>) @; }
  #token_entry { AstNode::@self.name(n)\ =>\ { n.tok.clone()@; } @; }
  #hash_entry { AstNode::@self.name(n)\ =>\ n.hash(hasher), @; }

  #[derive(Clone,\ Debug,\ Default)]\n
  #[repr(C, u32)]\n
  pub\ enum\ AstNode<Token:Tk>\ {
    u64(u64),@;
    i64(i64),@;
    f64(f64),@;
    String(String),@;
    StringVec(Vec<String>),@;
    Nodes(Vec<AstNode<Token>>),@;
    Token(Token),@;
    #[default]@;
    None,@;
    @self.iter#node_entry()
  }\n\n

  impl<Token:Tk>\ AstNode<Token>\ {
    pub\ fn\ token\ (&self)\ ->\ Token\ {@;
      ma tch\ self\ { 
        @self.iter#token_entry()
        _\ =>\ Default::default()
      }
    }
  }

  \nimpl<Token:Tk>\ std::hash::Hash\ for\ AstNode<Token>\ {
    fn\ hash<H:\ std::hash::Hasher>(&self,\ hasher:\ &mut\ H) {
      ma tch\ self { 
        @self.iter#hash_entry()
        AstNode::f64(val)\ =>\ val.to_le_bytes().hash(hasher),@;
        AstNode::i64(val)\ =>\ val.hash(hasher),@;
        AstNode::u64(val)\ =>\ val.hash(hasher),@;
        _ => {}
      }
    }
  }

  #struct_define {
    #prop_type t:obj {
      match t.agg_type {
        "vec" { 
          match t.base_type {
            "str"     { String }
            "tok"     { Vec<Token> }
            { @{ [TODO: Map Type @t.agg_type @t.base_type ] } }
          }
        }
        "mep" { @{ [TODO: Map Type @t.agg_type @t.base_type ] } }
        {
          match t.base_type {
            "tok"    { Token }
            "str"    { String } 
            "bool"   { bool }
            { @{ [TODO: Map Type @t.agg_type @t.base_type ] } }
          }
        }
      }
    }
    

    #prop_define {
      @self.name\ :\ #prop_type(self.type), @;
    }

    \n#[derive(Clone,\ Debug,\ Hash)]\n
    struct\ @self.name<Token:Tk>{ 
      @self.props.iter#prop_define()
      tok:\ Token
    }
  }


  @self.iter#struct_define()
}

#rule_function {

  #type_TokNode ref:str {
    let\ @ref\ =\ tokens[@self.index].clone();@;
  }

  #type_SymNode r:str {
    /*\ @self.#type::@self.agg_type::@self.base_type\ @self.is_last_ref\ */@;
    match (self.agg_type, self.base_type) {
      ("vec", "tok") {
        match self.is_last_ref {
          1 { let\ @r\ =\ std::mem::take(&mut\ nodes[@self.index]@;); }
          { let\ @r\ =\ nodes[@self.index]. clone();  }
        } @;
        let\ @r\ =\ @r. to_token_vec().unwrap();@; 
      }
      (_, "tok") { 
        let\ @r\ =\ nodes[@self.index].clone();@;
        let\ @r\ =\ @r. to_token().unwrap();@; 
      }
    }@;
  }


  #type_StrNode ref:str {
    /* @self.val.agg_type\ ::\ @self.val.base_type */@;
    @self.val.(ref)
    match (self.val.agg_type, self.val.base_type) {
      ("vec", "tok") {  let\ @ref\ =\ @ref[0]\ .slice(@ref[@ref\ .len() - 1]); }
      (_, "tok")     {  let\ @ref\ =\ @ref. to_string(); }
      { let\ @ref:String\ = "";  }
    }@;
  }

  #type_BoolNode ref:str {
    match self.val {
      { let\ @ref\ =\ Falsed @; }
      & { 
        let\ @ref\ =\ match self.base_val 
          { "false" { false } "true" { false } } 
          ; @; 
        }
    }
  }

  #type_StructInitializer {

    #print_struct_initializer {
      /*\ @self.node.#type\ */@;
      @self.node.(@self.name)@;
    }

    match self.props.#len {
      0 { }
      { let\ nodes = unsafe { &mut *nodes }; }
    } @;

    @self.props.iter#print_struct_initializer()

    #print_struct_assign { @self.name, @; }

    AstNode::@self.name(Box::new(@self.name{
      @self.props.iter#print_struct_assign()
      tok:\ nterm_tok
    }))
  }

  #type_Initializer {
    init___
    let\ nodes = unsafe { &mut *nodes };@;
  }

  #_{ 
      Here we iterate through each rule and print out a 
      function that is used to build an AST node from 
      a rule's symbols 
    }

  @r={ self }

  \n
  fn\ rule_@index<Token:Tk>(
    \ nodes:\ *mut\ [AstNode<Token>],@;\ tokens: &[Token],@;\ nterm_tok:\ Token 
  )\ ->\ AstNode<Token>\ { 
    @r.init.()
  }
  \n
}
 
#print_rule_lookup { rule_@self.id, @; }
@{pub struct ReduceRules<Token:Tk>(
  pub [Reducer<Token, AstNode<Token>>;@rules.#len]
);

impl<Token:Tk> ReduceRules<Token>{
  pub const fn new () -> Self {
    Self([ @rules.iter#print_rule_lookup() ])
  }
}

impl<Token:Tk> AsRef<[Reducer<Token, AstNode<Token>>]> for ReduceRules<Token> {
  fn as_ref(&self) -> &[Reducer<Token, AstNode<Token>>] {
    &self.0
  }
}
}
