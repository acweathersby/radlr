@{#![allow(unused)]

/// ### `radlr` Rust Parser
///
/// - **GENERATOR**: radlr 1.0.0-beta2
/// - **SOURCE**: /home/work/projects/lib_radlr/src/grammar/v2_0_0/grammar.sg
///
/// #### WARNING:
///
/// This is a generated file. Any changes to this file may be **overwritten
/// without notice**.
///
/// #### License:
/// Copyright (c) 2020-2024 Anthony Weathersby
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy
/// of this software and associated documentation files (the 'Software'), to
/// deal in the Software without restriction, including without limitation the
/// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
/// sell copies of the Software, and to permit persons to whom the Software is
/// furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice shall be included in
/// all copies or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
/// IN THE SOFTWARE

use radlr_rust_runtime::parsers::ast::{Tk, Reducer, Node};

@structs
  
@rules.iter#rule_function()

}

#_ {@"This is a comment function. Since we never call it, it has the same effect as a comment in other languages."}

#convert_type_name type_name:str {
  match type_name {
    "tok"    { Token }
    "str"    { String } 
    "bool"   { bool }
    "i8"     { i8 }
    "i16"    { i6 }
    "i32"    { i2 }
    "i64"    { i4 }
    "u8"     { u8 }
    "u16"    { u16 }
    "u32"    { u32 }
    "u64"    { u64 }
    "f32"    { f32 }
    "f64"    { f64 }
    { @{ [TODO: ScalarType @type_name ] } }
  }
}

#prop_name ts:str {
  match ts {
    "type" { r# @[ts] }
    "enum" { r# @[ts] }
    { @[ts] }
  }
}

#type_structs {



  #node_entry { @self.name(Box<@self.name<Token>>) @; }
  #token_entry { AstNode::@self.name(n)\ =>\ { n.tok.clone()@; } @; }
  #hash_entry { AstNode::@self.name(n)\ =>\ n.hash(hasher), @; }

  #[derive(Clone,\ Debug,\ Default)]\n
  #[repr(C, u32)]\n
  pub\ enum\ AstNode<Token:Tk>\ {
    u64(u64),@;
    i64(i64),@;
    f64(f64),@;
    String(String),@;
    StringVec(Vec<String>),@;
    Nodes(Vec<AstNode<Token>>),@;
    Token(Token),@;
    #[default]@;
    None,@;
    @self.iter#node_entry()
  }\n\n

  impl<Token:Tk>\ AstNode<Token>\ {
    pub\ fn\ token\ (&self)\ ->\ Token\ {@;
      ma tch\ self\ { 
        @self.iter#token_entry()
        _\ =>\ Default::default()
      }
    }
  }

  \nimpl<Token:Tk>\ std::hash::Hash\ for\ AstNode<Token>\ {
    fn\ hash<H:\ std::hash::Hasher>(&self,\ hasher:\ &mut\ H) {
      ma tch\ self { 
        @self.iter#hash_entry()
        AstNode::f64(val)\ =>\ val.to_le_bytes().hash(hasher),@;
        AstNode::i64(val)\ =>\ val.hash(hasher),@;
        AstNode::u64(val)\ =>\ val.hash(hasher),@;
        _ => {}
      }
    }
  }

  #struct_define {
    #prop_type t:obj {
      match t.agg_type {
        "vec" { 
          match t.base_type {
            "str"     { String }
            "tok"     { Vec<Token> }
            { @{ [TODO: Vec Type @t.agg_type @t.base_type ] } }
          }
        }
        "map" { @{ [TODO: Map Type @t.agg_type @t.base_type ] } }
        { #convert_type_name(t.base_type) }
      }
    }
    
    #prop_define {
      #prop_name(@self.name):\ #prop_type(self.type), @;
    }

    \n#[derive(Clone,\ Debug,\ Hash)]\n
    struct\ @self.name<Token:Tk>{ 
      @self.props.iter#prop_define()
      tok:\ Token
    }
  }


  @self.iter#struct_define()
}

#rule_function {

  #type_NumNode ref:str {
    match self.init {
      & { 
        @self.init.(ref)

        match (self.init.agg_type, self.init.base_type) {
          ("vec", _)  { let\ @ref\ =\ @ref. len()\ as\ #convert_type_name(@self.base_type); @; }
          ("map", _)  { let\ @ref\ =\ @ref. len()\ as\ #convert_type_name(@self.base_type); @; }
          (_, "tok")  {  let\ @ref\ =\ @ref. to_string(); }
          { let\ @ref:String\ = "";  }
        }@;
      }
      { let\ @ref\ =\ @self.base_val;@; }
    }
  }

  #type_TokNode ref:str {
    let\ @ref\ =\ tokens[@self.index].clone();@;
  }

  #type_SymNode r:str {
    /*\ @self.#type::@self.agg_type::@self.base_type\ @self.is_last_ref\ */@;
    match (self.agg_type, self.base_type) {
      ("vec", "tok") {
        match self.is_last_ref {
          1 { let\ @r\ =\ std::mem::take(&mut\ nodes[@self.index]@;); }
          { let\ @r\ =\ nodes[@self.index]. clone();  }
        } @;
        let\ @r\ =\ @r. to_token_vec().unwrap();@; 
      }
      (_, "tok") { 
        let\ @r\ =\ nodes[@self.index].clone();@;
        let\ @r\ =\ @r. to_token().unwrap();@; 
      }
    }@;
  }

  #type_AddNode ref:str {
    
    @ref_l={ @ref + "_l" }
    @ref_r={ @ref + "_r" }

    @self.right.(@ref_r)
    @self.left.(@ref_l)

    match (self.left.agg_type, self.right.agg_type) {
      ("vec",  "vec") {
        vec_vec
      }

      ("vec",  "map") {
        vec_map
      }

      ("map",  "vec") {
        map_vec
      }

      ("map",  "map") {
        map_map
      }

      ("vec",  _) {
        
        match self.right.base_type {
          "tok" { 
            let\ mut\ @ref\ =\ @ref_l; @;
            @ref . push ( @ref_r ) ; @;
          }
        }
        
      }

      (_,  "vec") {
        add_vec
      }

      ("map",  _) {
        map_add
      }

      (_,  "map") {
        add_map
      }

      (_, _) {
        scalar_add
      }
    } @;
  }

  #type_VecNode ref:str {

    #vec_elements_initializers ref:str {
      @ref={ ref + "_" + index }
      @self.(ref)@;
    }

    #vec_elements_names ref:str {
      @ref={ ref + "_" + index }
      @ref match iter_last { & { } { "," } }@;
    }
    /* @self.init */@;
    @self.init.iter#vec_elements_initializers(ref) 

    let\ @ref\ =\ vec![\ @self.init.iter#vec_elements_names(ref)\ ];@;
  }

  #type_StrNode ref:str {
    /* @self.init.agg_type\ ::\ @self.init.base_type */@;
    @self.init.(ref)
    match (self.init.agg_type, self.init.base_type) {
      ("vec", "tok") {  let\ @ref\ =\ @ref[0]\ .slice(@ref[@ref\ .len() - 1]); }
      (_, "tok")     {  let\ @ref\ =\ @ref. to_string(); }
      { let\ @ref:String\ = "";  }
    }@;
  }

  #type_BoolNode ref:str {
    match self.init {
      { let\ @ref\ =\ false ; @; }
      & { 
        let\ @ref\ =\ match self.base_val 
          { "false" { false } "true" { false } } 
          ; @; 
        }
    }
  }

  #type_StructInitializer {

    #print_struct_initializer {
      /*\ @self.node.#type\ */@;
      @self.node.(@self.name)@;
    }

    match self.props.#len {
      0 { }
      { let\ nodes = unsafe { &mut *nodes }; }
    } @;

    @self.props.iter#print_struct_initializer()

    #print_struct_assign { #prop_name(@self.name), @; }

    AstNode::@self.name(Box::new(@self.name{
      @self.props.iter#print_struct_assign()
      tok:\ nterm_tok
    }))
  }

  #type_Initializer {
    @out={ "out" }

    let\ nodes = unsafe { &mut *nodes };@;
    /*\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ */
    /*\ @self.node.#type\ */@;
    @self.node.(@out)@;

    /*\ @self.node.ast_type.agg_type\ @self.node.ast_type.base_type\ */@;
    match (@self.node.ast_type.agg_type, @self.node.ast_type.base_type) {
      ("vec", "tok") { 
        AstNode::Tokens(@out) @;
      }
    }
  }

  #_{ 
      Here we iterate through each rule and print out a 
      function that is used to build an AST node from 
      a rule's symbols 
    }

  @r={ self }

  \n
  fn\ rule_@index<Token:Tk>(
    \ nodes:\ *mut\ [AstNode<Token>],@;\ tokens: &[Token],@;\ nterm_tok:\ Token 
  )\ ->\ AstNode<Token>\ { 
    @r.init.()
  }
  \n
}
 
#print_rule_lookup { rule_@self.id, @; }
@{pub struct ReduceRules<Token:Tk>(
  pub [Reducer<Token, AstNode<Token>>;@rules.#len]
);

impl<Token:Tk> ReduceRules<Token>{
  pub const fn new () -> Self {
    Self([ @rules.iter#print_rule_lookup() ])
  }
}

impl<Token:Tk> AsRef<[Reducer<Token, AstNode<Token>>]> for ReduceRules<Token> {
  fn as_ref(&self) -> &[Reducer<Token, AstNode<Token>>] {
    &self.0
  }
}
}
