---
title: "Ascript"
description: "Sherpa Documentation"
draft: false
weight: 3
---



AScripT is the moniker givin to the automatic AST generation process provided by Hydrocarbon. It is
a lazy conglomeration of *AST* and *Script*. Laziness aside, AScripT provides a way of creating a rich cross-language AST
code that supports iteration, transformation, serialization, lazy evaluation. 



## Parse Actions
By default, Hydrocarbon converts recognized terminal symbols into Tokens, and nothing else. Custom parse actions may be utilized to 
define more useful behavior. The language with which parse actions are defined in is JavaScript.

Parse actions take on new meaning within the AScripT context. AScripT parse actions use a strict subset of JavaScript syntax to define an abstraction of strictly typed AST node structure and transformation actions. This abstraction is then used to generate concrete code comprised of classes, structs, or objects and functions to manipulate ASTs generated by the Hydrocarbon parser in a target language. 

# Core Types

## Struct

An AScripT struct is the primary type of an AScripT defined AST. It declare specific nodes that can be present within a tree. A struct 
is defined using `{ ... }` brackets within a [parse action](./api.parse_action.index.md). Within the those brackets, any number of property fields, of the form `<prop_name>:<prop_value>`, may be defined. AScripT will automatically determine what type a givin property field should be, based on the expression used to define the 
property value.

##### example

```sherpa { lab=true }
/* A simple struct definition */ 

<> expr > expr^l "+" expr^r :ast { t_Add, l, r  }

```

> If you are more familiar with JSON or JavaScript, then you will recognize the Struct definition being the same as an [Object Literal](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#object_literals), with
> the exceptions that keys may not be computed, prototypical inheritance has no meaning in the AScripT context, and values are restricted to the types defined within this document. 

### Struct Type

The property name `type` is a special field that determines the name of the property and any classes it belongs to. It
or its shorthand must be specified in any struct definition. In the above example, AScripT will generate a code definition for an `Add` class, structure, or object,
depending on the target language. That definition will contain the property fields `l` and `r`, initialized with whatever values `expr` and `term` resolve to. 

Every struct MUST be defined with a `type` key. The value of the key must be specified with a *type label* of the form `t_<identifier>`, such as
`type: t_Term` or `type: t_If_Statement`. The *type label* serves as the name of the compiled struct type. Different struct definitions with matching *type labels* will be merged into one struct. A struct can only be defined with one *type label*. An error will be formed if  multiple type labels are defined on a single struct 
```
:ast { { type: t_Sub, type: t_Add } } /* Causes an error */
```

#### Type Shorthand

A shorthand form for the type definition may be used.


### Struct Class
The *type label* can be augmented with *class descriptors*, of the form `c_<identifier>`. They are combined with the type labels using the join operator `|`, as in `type: t_Term | c_Statement` or `type: t_If_Statement | c_Block`. Think of *Class descriptors* as tags that provide more information on the use and 
classification of a particular struct type. A struct can be defined with multiple *class descriptors*:
```
:ast { { type: t_Sub | c_Expression | c_Binary | c_Additive_Operator } }
```

If different struct definitions a have matching *type labels* but a different set of of class descriptors, the struct definitions will still be merged, and 
the union of the class descriptors will define the class descriptor set used in the compiled struct:

```
/* A single struct definition somewhere in the grammar */
... :ast { { type: t_Mult | c_Binary | c_Multiplicative_Operator } } 

/* Another struct definition elsewhere in the grammar */
... :ast { { type: t_Mult | c_Expression | c_Binary } } 

/* The generated representation of the struct will look like */
/* :ast { { type: t_Mult | c_Expression | c_Binary | c_Multiplicative_Operator } } */

```

### Struct Properties

Other than the `type` property a struct can contain any number of properties defined 




They can be used in conjuction with the iteration system to filter iterated results, returning struct instances that
match a givin *class descriptor*:

```typescript
import { Class } from "./ast.ts";

const my_ast = parse(...);

for (const {node} of my_ast.iterate().filter(Class.Block)){
    /* 
        Only structs that have been defined with the 
        *c_Block* class descriptor will be yielded.
    */
}
```
### Token

Similar to string, can store source file information and 
directly references the source data instead of copying a section of
data to a new String buffer.

### Vector


## Numerical Types

### I8

```Javascript
:ast { i8($1) }
```

8bit Integer. May be interpreted as signed or unsigned. 

### I16

```Javascript
:ast { i16($1) }
```

16bit Integer. May be interpreted as signed or unsigned. 

### I32

```Javascript
:ast { i32($1) }
```

32bit Integer. May be interpreted as signed or unsigned. 

### I64

```Javascript
:ast { i64($1) }
```

64bit Integer. May be interpreted as signed or unsigned. 

### F32
```Javascript
:ast { f32($1) }
```

32bit Floating Point value

### F64
```Javascript
:ast { f64($1) }
```

64bit Floating Point value. Only true numeric type available in JavaScript.

## Other

### Boolean
```Javascript
:ast { bool($1) }
```

Boolean `true` or `false` value.

### String
```Javascript
:ast { str($1) } or :ast { "" + ($1) } or :ast { ($1) + "" }
```

A target language native string container type. 



### Null

```Javascript
:ast { null }
```




## Errors

Mixed structs and non-struct types

Mixed vector of structs and non-struct types

