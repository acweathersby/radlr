NAME ir

IMPORT ./symbol as sym
IMPORT ./token as tok
IMPORT ../v1_0_0/comment as cmt

IGNORE { c:sp c:nl tk:cmt::line tk:cmt::block }

<> state > 

    sym::production_symbol^id "=>" statement

        :ast { t_State, id, statement, tok }

    | sym::production_symbol^id "=!>" statement

        :ast { t_State, catches:true, id, statement, tok }

<> statement > [ 
    transitive_statement?^transitive 
    non_branch_statement(*)^non_branch
    ( match | goto_sequence | terminal_statement )?^branch
]

     :ast { t_Statement, transitive, non_branch, branch }


<> transitive_statement >

    "peek"          :ast { t_Peek }

    | "shift"       :ast { t_Shift }

    | "skip"        :ast { t_Skip }

    | "pop"         :ast { t_Pop }

    | "scan"        :ast { t_Scan }


<> terminal_statement >

    "fail"          :ast { t_Fail }

    | "pass"        :ast { t_Pass }

    | "accept"      :ast { t_Accept }


<> non_branch_statement > 

    "reduce" tok::int ( "symbols" "to" )? tok::int ( "with" "rule" )? tok::int
        
        :ast { t_Reduce, len: u32($2), rule_id: u32($6), prod_id: u32($4) }

    | "set-tok" tok::int

        :ast { t_SetTokenId, id: u32($2) }

    | "set" tok::id tok::int
    
        :ast { t_SetVal, id: str($2), val:u32($3)  }

    | "assert"      
    
        :ast { t_Assert  }


<> goto_sequence > goto_push(*) goto

    :ast { t_Gotos, pushes: $1, goto:$2  }


<> goto_push > "push" sym::non_terminal

    :ast { t_Push, prod: $2 }

<> goto > "goto" sym::non_terminal

    :ast { t_Goto, prod: $2 }

<> match > generic_match_block | production_match_block | terminal_match_block

<> generic_match_block >

    "match" ":" tok::id^id ( int_match :ast [$1] | "{" (int_match | default_match | hint)(+) "}" :ast $2  )^m

        :ast { t_Match, mode: str($id), matches:$m }


<> production_match_block >

    "match" ":" "PRODUCTION" ( non_terminal_match :ast [$1] | "{" ( non_terminal_match | hint | default_match )(+) "}" :ast $2 )^m

        :ast { t_Match, mode: str($3), matches:$m }


<> terminal_match_block >

    "match" ":" "TERMINAL" ( terminal_match :ast [$1] | "{" ( terminal_match | hint | default_match )(+) "}" :ast $2 )^m

        :ast { t_Match, mode: str($3), matches:$m }


<> non_terminal_match > "(" sym::non_terminal^sym ")" "{" statement "}"

    :ast { t_NonTermMatch, sym, statement }


<> terminal_match > "(" sym::terminal^sym ")" "{" statement "}"

    :ast { t_TermMatch, sym, statement }


<> int_match > "(" ( c:num :ast u64($1) )(+"|")^vals ")" "{" statement "}"

    :ast { t_TermMatch, vals, statement }


<> default_match > "default"? "{" statement "}"

    :ast { t_DefaultMatch, statement }


<> hint > "fail-hint" "{" tok::string^message "}"

    :ast { t_FailHint, message: str($message) }

