NAME sherpa

IMPORT ./ir as ir
IMPORT ./symbol as sym
IMPORT ./token as tok
IMPORT ./ascript as ast
IMPORT ../v_one/comment as cmt
IMPORT ../v_one/defined_type_eval as dt

IGNORE { c:sp c:nl tk:cmt::line tk:cmt::block }

EXPORT grammar as grammar
EXPORT ast::struct as ast_struct
EXPORT ast::expression as ast_expression
EXPORT ir::state as ir
EXPORT dt::def_type as type_eval
EXPORT dt::escaped_string as escaped


<> grammar >

    preamble(*) ( cf_production | pratt_production | peg_production | append_production | ir::state )(+)

        :ast { t_Grammar, preamble:$1, productions:$2, tok }


<> preamble >

    export_clause

    | import_clause

    | name_clause

    | ignore_clause


<> export_clause >

    "EXPORT" sym::non_terminal (( "AS" | "as" ) tok::id)?

        :ast { t_Export, production:$2, reference:str($3) } 


<> import_clause >

    "IMPORT" ( c:id | c:sym )(+) c:sp ( "AS" | "as" ) tok::id

        :ast { t_Import, uri: str($2), reference:str($5), tok }

<> ignore_clause >

    "IGNORE" "{"  sym::terminal(+) "}"

        :ast { t_Ignore, symbols: $3 }


<> name_clause >

    "NAME" tok::id

        :ast { t_Name, name: str($2) }


<> cf_production > 

    "<>" sym::production_symbol^n ">" rules^r

        :ast { t_CFProduction, name_sym:$n, rules: $r, tok }


<> peg_production >

    ":>" sym::production_symbol^n ">" rules^r

        :ast { t_PegProduction, name_sym:$n, rules: $r, tok }


<> pratt_production >

    "#>" sym::production_symbol^n ">" rules^r

        :ast { t_PrattProduction, name_sym:$n, rules: $r, tok }


<> append_production >

    "+>" sym::non_terminal^n ">" rules^r

        :ast { t_AppendProduction,  name_sym:$n, rules: $r, tok }

<> rules >  rule(+"|")


<> pratt_rule > sym::annotated_symbol(+)^s ast_definition?^a

    :ast { t_PrattRule, symbols:$s, ast:$a }


<> rule >

    (( sym::annotated_symbol | not_empty )(+)^s sym::end_of_input?^eoi :ast [$s, $eoi])^s 
    
    ast_definition?^a

        :ast { t_Rule, symbols:$s, ast:$a, tok }


<> ast_definition >

        ":ast" ast::body^ast

            :ast  { t_Ascript, ast:$ast, tok }


+> sym::non_terminal >

    "(" rules ")"{1}

        :ast { t_GroupProduction, rules:$2,  tok }


+> sym::terminal >

    "tk:(" rules ")"{1}

        :ast { t_TokenGroupProduction, rules:$2,  tok }


<> not_empty >

    "[" sym::annotated_symbol(+)^s ']' "!"?^o

        :ast { t_NotEmptySet, unordered: bool($o), symbols:$s, tok }
