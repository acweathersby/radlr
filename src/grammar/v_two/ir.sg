NAME ir

IMPORT ./symbol as sym
IMPORT ./token as tok
IMPORT ./ascript as ast
IMPORT ../v_one/comment as cmt

IGNORE { c:sp c:nl tk:cmt::line tk:cmt::block }

<> state > 

    sym::production_symbol^id "=>" statement

        :ast { t_State, id, statement, tok }

    | sym::production_symbol^id "=!>" statement

        :ast { t_State, catches:true, id, statement, tok }

<> statement >

    transitive_statement^transitive 
     ( "then" non_branch_statement(+"then")^non_branch )?
     ( "then" branch_statement^branch )?

     :ast { t_Statement, transitive, non_branch, branch }

     |

     non_branch_statement(+"then")^non_branch
     ( "then" branch_statement^branch )?

     :ast { t_Statement, non_branch, branch }

    | branch_statement^branch 

     :ast { t_Statement, branch }

<> branch_statement > match | goto_sequence | terminal_statement

<> transitive_statement >

    "peek"          :ast { t_Peek, tok }

    | "peek-skip"   :ast { t_PeekSkip, tok }

    | "shift"       :ast { t_Shift, tok }

    | "skip"        :ast { t_Skip, tok }

    | "pop"         :ast { t_Pop, tok }

    | "scan"        :ast { t_Scan, tok }

    | "reset"       :ast { t_Reset, tok }


<> terminal_statement >

    "fail"          :ast { t_Fail, tok }

    | "pass"        :ast { t_Pass, tok }

    | "accept"      :ast { t_Accept, tok }


<> non_branch_statement > 

    "reduce" tok::int ( "symbols" "to" )? tok::int ( "with" "rule" )? tok::int^int
        
        :ast { t_ReduceRaw, len: u32($2), rule_id: u32($int), prod_id: u32($4), tok }

    | "reduce" tok::int ( "symbols" "to" )? sym::non_terminal^prod ( ":ast" ast::body^ast )?
        
        :ast { t_Reduce, len: u32($2), ast,  prod, tok }

    | "set-tok" tok::int

        :ast { t_SetTokenId, id: u32($2), tok }

    | "set-tok-len" tok::int

        :ast { t_SetTokenLen, id: u32($2) }

    | "set-line"        :ast { t_SetLine, tok }


<> goto_sequence >

        goto_push(+"then") "then" goto

            :ast { t_Gotos, pushes: $1, goto }
    |  goto

            :ast { t_Gotos, goto }

<> goto_push > "push" sym::non_terminal

    :ast { t_Push, prod: $2, name:str($2), tok }

<> goto > "goto" sym::non_terminal

    :ast { t_Goto, prod: $2, name:str($2), tok }

<> match > generic_match_block | production_match_block | terminal_match_block

<> generic_match_block >

    "match" ":" tok::id^id ( ":" tok::id :ast str($2) )?^scanner ( int_match :ast [$1] | "{" ( int_match | default_match | hint )(+) "}" :ast $2  )^m

        :ast { t_Matches, mode: str($id), matches:$m, scanner, tok }


<> production_match_block >

    "match" ":" "PRODUCTION" ( non_terminal_match :ast [$1] | "{" ( non_terminal_match | hint | default_match )(+) "}" :ast $2 )^m

        :ast { t_ProductionMatches, matches:$m }


<> terminal_match_block >

    "match" ":" "TERMINAL" ( terminal_match :ast [$1] | "{" ( terminal_match | hint | default_match )(+) "}" :ast $2 )^m

        :ast { t_TerminalMatches, matches:$m }


<> non_terminal_match > "(" sym::non_terminal^sym ")" "{" statement "}"

    :ast { t_NonTermMatch, sym, statement }


<> terminal_match > "(" sym::terminal^sym ")" "{" statement "}"

    :ast { t_TermMatch, sym, statement }


<> int_match > "(" ( tok::int :ast u64($1) )(+"|")^vals ")" "{" statement "}"

    :ast { t_IntMatch, vals, statement }


<> default_match > "default"? "{" statement "}"

    :ast { t_DefaultMatch, statement }


<> hint > "fail-hint" "{" tok::string^message "}"

    :ast { t_FailHint, message: str($message) }

