// ns-hugo:/home/runner/work/sherpa/sherpa/src/web/doc/assets/js/sherpa/sherpa_wasm.js
var wasm;
var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder.decode();
}
var cachedUint8Memory0 = null;
function getUint8Memory0() {
  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
var heap = new Array(128).fill(void 0);
heap.push(void 0, null, true, false);
var heap_next = heap.length;
function addHeapObject(obj) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
function getObject(idx) {
  return heap[idx];
}
function dropObject(idx) {
  if (idx < 132)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
function debugString(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name2 = val.name;
    if (typeof name2 == "string" && name2.length > 0) {
      return `Function(${name2})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length = val.length;
    let debug = "[";
    if (length > 0) {
      debug += debugString(val[0]);
    }
    for (let i = 1; i < length; i++) {
      debug += ", " + debugString(val[i]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} };
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
var cachedInt32Memory0 = null;
function getInt32Memory0() {
  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachedInt32Memory0;
}
function create_soup() {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.create_soup(retptr);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    if (r2) {
      throw takeObject(r1);
    }
    return JSSoup.__wrap(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function _assertClass(instance, klass) {
  if (!(instance instanceof klass)) {
    throw new Error(`expected instance of ${klass.name}`);
  }
  return instance.ptr;
}
function create_parse_db(grammar_id, soup) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(grammar_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    _assertClass(soup, JSSoup);
    wasm.create_parse_db(retptr, ptr0, len0, soup.__wbg_ptr);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    if (r2) {
      throw takeObject(r1);
    }
    return JSParserDB.__wrap(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function create_rust_ast_output(js_db) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    _assertClass(js_db, JSParserDB);
    wasm.create_rust_ast_output(retptr, js_db.__wbg_ptr);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0;
      len1 = 0;
      throw takeObject(r2);
    }
    deferred2_0 = ptr1;
    deferred2_1 = len1;
    return getStringFromWasm0(ptr1, len1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
  }
}
function create_parser_states(js_db, optimize_states) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    _assertClass(js_db, JSParserDB);
    wasm.create_parser_states(retptr, js_db.__wbg_ptr, optimize_states);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    if (r2) {
      throw takeObject(r1);
    }
    return JSParseStates.__wrap(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function create_bytecode(js_db, states) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    _assertClass(js_db, JSParserDB);
    _assertClass(states, JSParseStates);
    wasm.create_bytecode(retptr, js_db.__wbg_ptr, states.__wbg_ptr);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    if (r2) {
      throw takeObject(r1);
    }
    return JSBytecode.__wrap(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function create_bytecode_disassembly(bytecode) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    _assertClass(bytecode, JSBytecode);
    wasm.create_bytecode_disassembly(retptr, bytecode.__wbg_ptr);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0;
      len1 = 0;
      throw takeObject(r2);
    }
    deferred2_0 = ptr1;
    deferred2_1 = len1;
    return getStringFromWasm0(ptr1, len1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
  }
}
function create_instruction_disassembly(address, bytecode) {
  let deferred1_0;
  let deferred1_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    _assertClass(bytecode, JSBytecode);
    wasm.create_instruction_disassembly(retptr, address, bytecode.__wbg_ptr);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    deferred1_0 = r0;
    deferred1_1 = r1;
    return getStringFromWasm0(r0, r1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
  }
}
function get_debug_symbol_ids(address, bytecode) {
  _assertClass(bytecode, JSBytecode);
  const ret = wasm.get_debug_symbol_ids(address, bytecode.__wbg_ptr);
  return takeObject(ret);
}
function get_debug_state_name(address, bytecode) {
  _assertClass(bytecode, JSBytecode);
  const ret = wasm.get_debug_state_name(address, bytecode.__wbg_ptr);
  return takeObject(ret);
}
function get_debug_tok_offsets(address, bytecode) {
  _assertClass(bytecode, JSBytecode);
  const ret = wasm.get_debug_tok_offsets(address, bytecode.__wbg_ptr);
  return takeObject(ret);
}
function get_state_source_string(name2, states, db) {
  const ptr0 = passStringToWasm0(name2, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  _assertClass(states, JSParseStates);
  _assertClass(db, JSParserDB);
  const ret = wasm.get_state_source_string(ptr0, len0, states.__wbg_ptr, db.__wbg_ptr);
  return takeObject(ret);
}
function get_symbol_name_from_id(id, db) {
  _assertClass(db, JSParserDB);
  const ret = wasm.get_symbol_name_from_id(id, db.__wbg_ptr);
  return takeObject(ret);
}
function get_entry_names(db) {
  _assertClass(db, JSParserDB);
  const ret = wasm.get_entry_names(db.__wbg_ptr);
  return takeObject(ret);
}
function get_codemirror_parse_tree(input) {
  const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.get_codemirror_parse_tree(ptr0, len0);
  return takeObject(ret);
}
function get_production_names() {
  const ret = wasm.get_production_names();
  return takeObject(ret);
}
var JSByteCodeParser = class _JSByteCodeParser {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_JSByteCodeParser.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_jsbytecodeparser_free(ptr);
  }
  /**
  * @param {string} input
  * @param {JSBytecode} bytecode
  * @returns {JSByteCodeParser}
  */
  static new(input, bytecode) {
    const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    _assertClass(bytecode, JSBytecode);
    const ret = wasm.jsbytecodeparser_new(ptr0, len0, bytecode.__wbg_ptr);
    return _JSByteCodeParser.__wrap(ret);
  }
  /**
  * @param {string} entry_name
  * @param {JSBytecode} bytecode
  * @param {JSParserDB} db
  */
  init(entry_name, bytecode, db) {
    const ptr0 = passStringToWasm0(entry_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    _assertClass(bytecode, JSBytecode);
    _assertClass(db, JSParserDB);
    wasm.jsbytecodeparser_init(this.__wbg_ptr, ptr0, len0, bytecode.__wbg_ptr, db.__wbg_ptr);
  }
  /**
  * @returns {any}
  */
  next() {
    const ret = wasm.jsbytecodeparser_next(this.__wbg_ptr);
    return takeObject(ret);
  }
};
var JSBytecode = class _JSBytecode {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_JSBytecode.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_jsbytecode_free(ptr);
  }
};
var JSGrammarIdentities = class _JSGrammarIdentities {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_JSGrammarIdentities.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_jsgrammaridentities_free(ptr);
  }
};
var JSGrammarParser = class _JSGrammarParser {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_JSGrammarParser.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_jsgrammarparser_free(ptr);
  }
  /**
  * @param {string} input
  * @returns {JSGrammarParser}
  */
  static new(input) {
    const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.jsgrammarparser_new(ptr0, len0);
    return _JSGrammarParser.__wrap(ret);
  }
  /**
  */
  init() {
    wasm.jsgrammarparser_init(this.__wbg_ptr);
  }
  /**
  * @returns {any}
  */
  next() {
    const ret = wasm.jsgrammarparser_next(this.__wbg_ptr);
    return takeObject(ret);
  }
};
var JSParseStates = class _JSParseStates {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_JSParseStates.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_jsparsestates_free(ptr);
  }
  /**
  * @returns {number}
  */
  get num_of_states() {
    const ret = wasm.__wbg_get_jsparsestates_num_of_states(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
  * @param {number} arg0
  */
  set num_of_states(arg0) {
    wasm.__wbg_set_jsparsestates_num_of_states(this.__wbg_ptr, arg0);
  }
};
var JSParserDB = class _JSParserDB {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_JSParserDB.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_jsparserdb_free(ptr);
  }
};
var JSSherpaSourceError = class _JSSherpaSourceError {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_JSSherpaSourceError.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_jssherpasourceerror_free(ptr);
  }
  /**
  * @returns {number}
  */
  get line() {
    const ret = wasm.__wbg_get_jssherpasourceerror_line(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
  * @param {number} arg0
  */
  set line(arg0) {
    wasm.__wbg_set_jssherpasourceerror_line(this.__wbg_ptr, arg0);
  }
  /**
  * @returns {number}
  */
  get col() {
    const ret = wasm.__wbg_get_jssherpasourceerror_col(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
  * @param {number} arg0
  */
  set col(arg0) {
    wasm.__wbg_set_jssherpasourceerror_col(this.__wbg_ptr, arg0);
  }
  /**
  * @returns {number}
  */
  get len() {
    const ret = wasm.__wbg_get_jssherpasourceerror_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
  * @param {number} arg0
  */
  set len(arg0) {
    wasm.__wbg_set_jssherpasourceerror_len(this.__wbg_ptr, arg0);
  }
  /**
  * @returns {number}
  */
  get start_offset() {
    const ret = wasm.__wbg_get_jssherpasourceerror_start_offset(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
  * @param {number} arg0
  */
  set start_offset(arg0) {
    wasm.__wbg_set_jssherpasourceerror_start_offset(this.__wbg_ptr, arg0);
  }
  /**
  * @returns {number}
  */
  get end_offset() {
    const ret = wasm.__wbg_get_jssherpasourceerror_end_offset(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
  * @param {number} arg0
  */
  set end_offset(arg0) {
    wasm.__wbg_set_jssherpasourceerror_end_offset(this.__wbg_ptr, arg0);
  }
  /**
  * @returns {string}
  */
  get message() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.jssherpasourceerror_message(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
};
var JSSoup = class _JSSoup {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_JSSoup.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_jssoup_free(ptr);
  }
  /**
  * Adds or replaces grammar in the soup, or throws an error
  * if the grammar is invalid. Returns the grammar
  * id if successful.
  * @param {string} grammar
  * @param {string} path
  * @returns {JSGrammarIdentities}
  */
  add_grammar(grammar, path) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(grammar, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      const ptr1 = passStringToWasm0(path, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len1 = WASM_VECTOR_LEN;
      wasm.jssoup_add_grammar(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return JSGrammarIdentities.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * Adds a production targeting a specific grammar
  * @param {string} grammar_name
  */
  add_production(grammar_name) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(grammar_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      wasm.jssoup_add_production(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
var PositionedErrors = class _PositionedErrors {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_PositionedErrors.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_positionederrors_free(ptr);
  }
  /**
  * @returns {number}
  */
  get length() {
    const ret = wasm.positionederrors_length(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
  * @param {number} index
  * @returns {JSSherpaSourceError | undefined}
  */
  get_error_at(index) {
    const ret = wasm.positionederrors_get_error_at(this.__wbg_ptr, index);
    return ret === 0 ? void 0 : JSSherpaSourceError.__wrap(ret);
  }
};
var TokenOffsets = class _TokenOffsets {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_TokenOffsets.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_tokenoffsets_free(ptr);
  }
  /**
  * @returns {number}
  */
  get start() {
    const ret = wasm.__wbg_get_tokenoffsets_start(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
  * @param {number} arg0
  */
  set start(arg0) {
    wasm.__wbg_set_tokenoffsets_start(this.__wbg_ptr, arg0);
  }
  /**
  * @returns {number}
  */
  get end() {
    const ret = wasm.__wbg_get_jsparsestates_num_of_states(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
  * @param {number} arg0
  */
  set end(arg0) {
    wasm.__wbg_set_jsparsestates_num_of_states(this.__wbg_ptr, arg0);
  }
};
async function __wbg_load(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module, imports);
      } catch (e) {
        if (module.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_number_new = function(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_positionederrors_new = function(arg0) {
    const ret = PositionedErrors.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_tokenoffsets_new = function(arg0) {
    const ret = TokenOffsets.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {
    const ret = BigInt.asUintN(64, arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_set_841ac57cff3d672b = function(arg0, arg1, arg2) {
    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);
  };
  imports.wbg.__wbg_new_898a68150f225f2e = function() {
    const ret = new Array();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_b51585de1b234aff = function() {
    const ret = new Object();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_set_502d29070ea18557 = function(arg0, arg1, arg2) {
    getObject(arg0)[arg1 >>> 0] = takeObject(arg2);
  };
  imports.wbg.__wbg_push_ca1c26067ef907ac = function(arg0, arg1) {
    const ret = getObject(arg0).push(getObject(arg1));
    return ret;
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString(getObject(arg1));
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  return imports;
}
function __wbg_init_memory(imports, maybe_memory) {
}
function __wbg_finalize_init(instance, module) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module;
  cachedInt32Memory0 = null;
  cachedUint8Memory0 = null;
  return wasm;
}
async function __wbg_init(input) {
  if (wasm !== void 0)
    return wasm;
  if (typeof input === "undefined") {
    input = new URL("sherpa_wasm_bg.wasm", import.meta.url);
  }
  const imports = __wbg_get_imports();
  if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
    input = fetch(input);
  }
  __wbg_init_memory(imports);
  const { instance, module } = await __wbg_load(await input, imports);
  return __wbg_finalize_init(instance, module);
}
var sherpa_wasm_default = __wbg_init;

// node_modules/@codemirror/state/dist/index.js
var Text = class _Text {
  /**
  @internal
  */
  constructor() {
  }
  /**
  Get the line description around the given position.
  */
  lineAt(pos) {
    if (pos < 0 || pos > this.length)
      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(n) {
    if (n < 1 || n > this.lines)
      throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
    return this.lineInner(n, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(from, to, text) {
    let parts = [];
    this.decompose(
      0,
      from,
      parts,
      2
      /* Open.To */
    );
    if (text.length)
      text.decompose(
        0,
        text.length,
        parts,
        1 | 2
        /* Open.To */
      );
    this.decompose(
      to,
      this.length,
      parts,
      1
      /* Open.From */
    );
    return TextNode.from(parts, this.length - (to - from) + text.length);
  }
  /**
  Append another document to this one.
  */
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(from, to = this.length) {
    let parts = [];
    this.decompose(from, to, parts, 0);
    return TextNode.from(parts, to - from);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(other) {
    if (other == this)
      return true;
    if (other.length != this.length || other.lines != this.lines)
      return false;
    let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
    let a = new RawTextCursor(this), b = new RawTextCursor(other);
    for (let skip = start, pos = start; ; ) {
      a.next(skip);
      b.next(skip);
      skip = 0;
      if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
        return false;
      pos += a.value.length;
      if (a.done || pos >= end)
        return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(from, to = this.length) {
    return new PartialTextCursor(this, from, to);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(from, to) {
    let inner;
    if (from == null) {
      inner = this.iter();
    } else {
      if (to == null)
        to = this.lines + 1;
      let start = this.line(from).from;
      inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
    }
    return new LineCursor(inner);
  }
  /**
  @internal
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(text) {
    if (text.length == 0)
      throw new RangeError("A document must have at least one line");
    if (text.length == 1 && !text[0])
      return _Text.empty;
    return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
  }
};
var TextLeaf = class _TextLeaf extends Text {
  constructor(text, length = textLength(text)) {
    super();
    this.text = text;
    this.length = length;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let string2 = this.text[i], end = offset + string2.length;
      if ((isLine ? line : end) >= target)
        return new Line(offset, end, line, string2);
      offset = end + 1;
      line++;
    }
  }
  decompose(from, to, target, open) {
    let text = from <= 0 && to >= this.length ? this : new _TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
    if (open & 1) {
      let prev = target.pop();
      let joined = appendText(text.text, prev.text.slice(), 0, text.length);
      if (joined.length <= 32) {
        target.push(new _TextLeaf(joined, prev.length + text.length));
      } else {
        let mid = joined.length >> 1;
        target.push(new _TextLeaf(joined.slice(0, mid)), new _TextLeaf(joined.slice(mid)));
      }
    } else {
      target.push(text);
    }
  }
  replace(from, to, text) {
    if (!(text instanceof _TextLeaf))
      return super.replace(from, to, text);
    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
    let newLen = this.length + text.length - (to - from);
    if (lines.length <= 32)
      return new _TextLeaf(lines, newLen);
    return TextNode.from(_TextLeaf.split(lines, []), newLen);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    let result = "";
    for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
      let line = this.text[i], end = pos + line.length;
      if (pos > from && i)
        result += lineSep;
      if (from < end && to > pos)
        result += line.slice(Math.max(0, from - pos), to - pos);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let line of this.text)
      target.push(line);
  }
  scanIdentical() {
    return 0;
  }
  static split(text, target) {
    let part = [], len = -1;
    for (let line of text) {
      part.push(line);
      len += line.length + 1;
      if (part.length == 32) {
        target.push(new _TextLeaf(part, len));
        part = [];
        len = -1;
      }
    }
    if (len > -1)
      target.push(new _TextLeaf(part, len));
    return target;
  }
};
var TextNode = class _TextNode extends Text {
  constructor(children, length) {
    super();
    this.children = children;
    this.length = length;
    this.lines = 0;
    for (let child of children)
      this.lines += child.lines;
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
      if ((isLine ? endLine : end) >= target)
        return child.lineInner(target, isLine, line, offset);
      offset = end + 1;
      line = endLine + 1;
    }
  }
  decompose(from, to, target, open) {
    for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (from <= end && to >= pos) {
        let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
        if (pos >= from && end <= to && !childOpen)
          target.push(child);
        else
          child.decompose(from - pos, to - pos, target, childOpen);
      }
      pos = end + 1;
    }
  }
  replace(from, to, text) {
    if (text.lines < this.lines)
      for (let i = 0, pos = 0; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (from >= pos && to <= end) {
          let updated = child.replace(from - pos, to - pos, text);
          let totalLines = this.lines - child.lines + updated.lines;
          if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
            let copy = this.children.slice();
            copy[i] = updated;
            return new _TextNode(copy, this.length - (to - from) + text.length);
          }
          return super.replace(pos, end, updated);
        }
        pos = end + 1;
      }
    return super.replace(from, to, text);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    let result = "";
    for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
      let child = this.children[i], end = pos + child.length;
      if (pos > from && i)
        result += lineSep;
      if (from < end && to > pos)
        result += child.sliceString(from - pos, to - pos, lineSep);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let child of this.children)
      child.flatten(target);
  }
  scanIdentical(other, dir) {
    if (!(other instanceof _TextNode))
      return 0;
    let length = 0;
    let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
    for (; ; iA += dir, iB += dir) {
      if (iA == eA || iB == eB)
        return length;
      let chA = this.children[iA], chB = other.children[iB];
      if (chA != chB)
        return length + chA.scanIdentical(chB, dir);
      length += chA.length + 1;
    }
  }
  static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
    let lines = 0;
    for (let ch of children)
      lines += ch.lines;
    if (lines < 32) {
      let flat = [];
      for (let ch of children)
        ch.flatten(flat);
      return new TextLeaf(flat, length);
    }
    let chunk = Math.max(
      32,
      lines >> 5
      /* Tree.BranchShift */
    ), maxChunk = chunk << 1, minChunk = chunk >> 1;
    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
    function add2(child) {
      let last;
      if (child.lines > maxChunk && child instanceof _TextNode) {
        for (let node of child.children)
          add2(node);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk)
          flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0)
        return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : _TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (let child of children)
      add2(child);
    flush();
    return chunked.length == 1 ? chunked[0] : new _TextNode(chunked, length);
  }
};
Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
function textLength(text) {
  let length = -1;
  for (let line of text)
    length += line.length + 1;
  return length;
}
function appendText(text, target, from = 0, to = 1e9) {
  for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
    let line = text[i], end = pos + line.length;
    if (end >= from) {
      if (end > to)
        line = line.slice(0, to - pos);
      if (pos < from)
        line = line.slice(from - pos);
      if (first) {
        target[target.length - 1] += line;
        first = false;
      } else
        target.push(line);
    }
    pos = end + 1;
  }
  return target;
}
function sliceText(text, from, to) {
  return appendText(text, [""], from, to);
}
var RawTextCursor = class {
  constructor(text, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text];
    this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false;
    for (; ; ) {
      let last = this.nodes.length - 1;
      let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
      let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
      if (offset == (dir > 0 ? size : 0)) {
        if (last == 0) {
          this.done = true;
          this.value = "";
          return this;
        }
        if (dir > 0)
          this.offsets[last - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last] += dir;
        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top2 instanceof TextLeaf) {
        let next = top2.text[offset + (dir < 0 ? -1 : 0)];
        this.offsets[last] += dir;
        if (next.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
          return this;
        }
        skip -= next.length;
      } else {
        let next = top2.children[offset + (dir < 0 ? -1 : 0)];
        if (skip > next.length) {
          skip -= next.length;
          this.offsets[last] += dir;
        } else {
          if (dir < 0)
            this.offsets[last]--;
          this.nodes.push(next);
          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
        }
      }
    }
  }
  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }
    return this.nextInner(skip, this.dir);
  }
};
var PartialTextCursor = class {
  constructor(text, start, end) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
    this.pos = start > end ? text.length : 0;
    this.from = Math.min(start, end);
    this.to = Math.max(start, end);
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit)
      skip = limit;
    limit -= skip;
    let { value } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
    this.done = !this.value;
    return this;
  }
  next(skip = 0) {
    if (skip < 0)
      skip = Math.max(skip, this.from - this.pos);
    else if (skip > 0)
      skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
};
var LineCursor = class {
  constructor(inner) {
    this.inner = inner;
    this.afterBreak = true;
    this.value = "";
    this.done = false;
  }
  next(skip = 0) {
    let { done, lineBreak, value } = this.inner.next(skip);
    if (done) {
      this.done = true;
      this.value = "";
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = "";
      } else {
        this.afterBreak = true;
        this.next();
      }
    } else {
      this.value = value;
      this.afterBreak = false;
    }
    return this;
  }
  get lineBreak() {
    return false;
  }
};
if (typeof Symbol != "undefined") {
  Text.prototype[Symbol.iterator] = function() {
    return this.iter();
  };
  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
var Line = class {
  /**
  @internal
  */
  constructor(from, to, number2, text) {
    this.from = from;
    this.to = to;
    this.number = number2;
    this.text = text;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
var extend = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
for (let i = 1; i < extend.length; i++)
  extend[i] += extend[i - 1];
function isExtendingChar(code) {
  for (let i = 1; i < extend.length; i += 2)
    if (extend[i] > code)
      return extend[i - 1] <= code;
  return false;
}
function isRegionalIndicator(code) {
  return code >= 127462 && code <= 127487;
}
var ZWJ = 8205;
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length)
    return pos;
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
    pos--;
  let prev = codePointAt(str, pos);
  pos += codePointSize(prev);
  while (pos < str.length) {
    let next = codePointAt(str, pos);
    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
      pos += codePointSize(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0, i = pos - 2;
      while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
        countBefore++;
        i -= 2;
      }
      if (countBefore % 2 == 0)
        break;
      else
        pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending);
    if (found < pos)
      return found;
    pos--;
  }
  return 0;
}
function surrogateLow(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length)
    return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1))
    return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function fromCodePoint(code) {
  if (code <= 65535)
    return String.fromCharCode(code);
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
function codePointSize(code) {
  return code < 65536 ? 1 : 2;
}
var DefaultSplit = /\r\n?|\n/;
var MapMode = /* @__PURE__ */ function(MapMode2) {
  MapMode2[MapMode2["Simple"] = 0] = "Simple";
  MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
  MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
  MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
  return MapMode2;
}(MapMode || (MapMode = {}));
var ChangeDesc = class _ChangeDesc {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(sections) {
    this.sections = sections;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2)
      result += this.sections[i];
    return result;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2) {
      let ins = this.sections[i + 1];
      result += ins < 0 ? this.sections[i] : ins;
    }
    return result;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(f) {
    for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0) {
        f(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let sections = [];
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0)
        sections.push(len, ins);
      else
        sections.push(ins, len);
    }
    return new _ChangeDesc(sections);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(other, before = false) {
    return other.empty ? this : mapSet(this, other, before);
  }
  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0, posB = 0;
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
      if (ins < 0) {
        if (endA > pos)
          return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
          return null;
        if (endA > pos || endA == pos && assoc < 0 && !len)
          return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA)
      throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(from, to = from) {
    for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
      let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
      if (ins >= 0 && pos <= to && end >= from)
        return pos < from && end > to ? "cover" : true;
      pos = end;
    }
    return false;
  }
  /**
  @internal
  */
  toString() {
    let result = "";
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(json) {
    if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new _ChangeDesc(json);
  }
  /**
  @internal
  */
  static create(sections) {
    return new _ChangeDesc(sections);
  }
};
var ChangeSet = class _ChangeSet extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections);
    this.inserted = inserted;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(doc2) {
    if (this.length != doc2.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
    return doc2;
  }
  mapDesc(other, before = false) {
    return mapSet(this, other, before, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(doc2) {
    let sections = this.sections.slice(), inserted = [];
    for (let i = 0, pos = 0; i < sections.length; i += 2) {
      let len = sections[i], ins = sections[i + 1];
      if (ins >= 0) {
        sections[i] = ins;
        sections[i + 1] = len;
        let index = i >> 1;
        while (inserted.length < index)
          inserted.push(Text.empty);
        inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
      }
      pos += len;
    }
    return new _ChangeSet(sections, inserted);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(other, before = false) {
    return other.empty ? this : mapSet(this, other, before, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ChangeDesc.create(this.sections);
  }
  /**
  @internal
  */
  filter(ranges) {
    let resultSections = [], resultInserted = [], filteredSections = [];
    let iter = new SectionIter(this);
    done:
      for (let i = 0, pos = 0; ; ) {
        let next = i == ranges.length ? 1e9 : ranges[i++];
        while (pos < next || pos == next && iter.len == 0) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, next - pos);
          addSection(filteredSections, len, -1);
          let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
          addSection(resultSections, len, ins);
          if (ins > 0)
            addInsert(resultInserted, resultSections, iter.text);
          iter.forward(len);
          pos += len;
        }
        let end = ranges[i++];
        while (pos < end) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, end - pos);
          addSection(resultSections, len, -1);
          addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
          iter.forward(len);
          pos += len;
        }
      }
    return {
      changes: new _ChangeSet(resultSections, resultInserted),
      filtered: ChangeDesc.create(filteredSections)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let parts = [];
    for (let i = 0; i < this.sections.length; i += 2) {
      let len = this.sections[i], ins = this.sections[i + 1];
      if (ins < 0)
        parts.push(len);
      else if (ins == 0)
        parts.push([len]);
      else
        parts.push([len].concat(this.inserted[i >> 1].toJSON()));
    }
    return parts;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(changes, length, lineSep) {
    let sections = [], inserted = [], pos = 0;
    let total = null;
    function flush(force = false) {
      if (!force && !sections.length)
        return;
      if (pos < length)
        addSection(sections, length - pos, -1);
      let set = new _ChangeSet(sections, inserted);
      total = total ? total.compose(set.map(total)) : set;
      sections = [];
      inserted = [];
      pos = 0;
    }
    function process(spec) {
      if (Array.isArray(spec)) {
        for (let sub of spec)
          process(sub);
      } else if (spec instanceof _ChangeSet) {
        if (spec.length != length)
          throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let { from, to = from, insert: insert2 } = spec;
        if (from > to || from < 0 || to > length)
          throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
        let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
        let insLen = insText.length;
        if (from == to && insLen == 0)
          return;
        if (from < pos)
          flush();
        if (from > pos)
          addSection(sections, from - pos, -1);
        addSection(sections, to - from, insLen);
        addInsert(inserted, sections, insText);
        pos = to;
      }
    }
    process(changes);
    flush(!total);
    return total;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(length) {
    return new _ChangeSet(length ? [length, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(json) {
    if (!Array.isArray(json))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [], inserted = [];
    for (let i = 0; i < json.length; i++) {
      let part = json[i];
      if (typeof part == "number") {
        sections.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections.push(part[0], 0);
      } else {
        while (inserted.length < i)
          inserted.push(Text.empty);
        inserted[i] = Text.of(part.slice(1));
        sections.push(part[0], inserted[i].length);
      }
    }
    return new _ChangeSet(sections, inserted);
  }
  /**
  @internal
  */
  static createSet(sections, inserted) {
    return new _ChangeSet(sections, inserted);
  }
};
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0)
    return;
  let last = sections.length - 2;
  if (last >= 0 && ins <= 0 && ins == sections[last + 1])
    sections[last] += len;
  else if (len == 0 && sections[last] == 0)
    sections[last + 1] += ins;
  else if (forceJoin) {
    sections[last] += len;
    sections[last + 1] += ins;
  } else
    sections.push(len, ins);
}
function addInsert(values, sections, value) {
  if (value.length == 0)
    return;
  let index = sections.length - 2 >> 1;
  if (index < values.length) {
    values[values.length - 1] = values[values.length - 1].append(value);
  } else {
    while (values.length < index)
      values.push(Text.empty);
    values.push(value);
  }
}
function iterChanges(desc, f, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
    let len = desc.sections[i++], ins = desc.sections[i++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text = Text.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted)
          text = text.append(inserted[i - 2 >> 1]);
        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
          break;
        len = desc.sections[i++];
        ins = desc.sections[i++];
      }
      f(posA, endA, posB, endB, text);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before, mkSet = false) {
  let sections = [], insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let inserted = -1; ; ) {
    if (a.ins == -1 && b.ins == -1) {
      let len = Math.min(a.len, b.len);
      addSection(sections, len, -1);
      a.forward(len);
      b.forward(len);
    } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
      let len = b.len;
      addSection(sections, b.ins, -1);
      while (len) {
        let piece = Math.min(a.len, len);
        if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
          addSection(sections, 0, a.ins);
          if (insert2)
            addInsert(insert2, sections, a.text);
          inserted = a.i;
        }
        a.forward(piece);
        len -= piece;
      }
      b.next();
    } else if (a.ins >= 0) {
      let len = 0, left = a.len;
      while (left) {
        if (b.ins == -1) {
          let piece = Math.min(left, b.len);
          len += piece;
          left -= piece;
          b.forward(piece);
        } else if (b.ins == 0 && b.len < left) {
          left -= b.len;
          b.next();
        } else {
          break;
        }
      }
      addSection(sections, len, inserted < a.i ? a.ins : 0);
      if (insert2 && inserted < a.i)
        addInsert(insert2, sections, a.text);
      inserted = a.i;
      a.forward(a.len - left);
    } else if (a.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else if (a.ins == 0) {
      addSection(sections, a.len, 0, open);
      a.next();
    } else if (b.len == 0 && !b.done) {
      addSection(sections, 0, b.ins, open);
      if (insert2)
        addInsert(insert2, sections, b.text);
      b.next();
    } else if (a.done || b.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a.len2, b.len), sectionLen = sections.length;
      if (a.ins == -1) {
        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
        addSection(sections, len, insB, open);
        if (insert2 && insB)
          addInsert(insert2, sections, b.text);
      } else if (b.ins == -1) {
        addSection(sections, a.off ? 0 : a.len, len, open);
        if (insert2)
          addInsert(insert2, sections, a.textBit(len));
      } else {
        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
        if (insert2 && !b.off)
          addInsert(insert2, sections, b.text);
      }
      open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
      a.forward2(len);
      b.forward(len);
    }
  }
}
var SectionIter = class {
  constructor(set) {
    this.set = set;
    this.i = 0;
    this.next();
  }
  next() {
    let { sections } = this.set;
    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted } = this.set, index = this.i - 2 >> 1;
    return index >= inserted.length ? Text.empty : inserted[index];
  }
  textBit(len) {
    let { inserted } = this.set, index = this.i - 2 >> 1;
    return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
  }
  forward(len) {
    if (len == this.len)
      this.next();
    else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1)
      this.forward(len);
    else if (len == this.ins)
      this.next();
    else {
      this.ins -= len;
      this.off += len;
    }
  }
};
var SelectionRange = class _SelectionRange {
  constructor(from, to, flags) {
    this.from = from;
    this.to = to;
    this.flags = flags;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let level = this.flags & 3;
    return level == 3 ? null : level;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let value = this.flags >> 5;
    return value == 33554431 ? void 0 : value;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(change, assoc = -1) {
    let from, to;
    if (this.empty) {
      from = to = change.mapPos(this.from, assoc);
    } else {
      from = change.mapPos(this.from, 1);
      to = change.mapPos(this.to, -1);
    }
    return from == this.from && to == this.to ? this : new _SelectionRange(from, to, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(from, to = from) {
    if (from <= this.anchor && to >= this.anchor)
      return EditorSelection.range(from, to);
    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
    return EditorSelection.range(this.anchor, head);
  }
  /**
  Compare this range to another range.
  */
  eq(other) {
    return this.anchor == other.anchor && this.head == other.head;
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(json) {
    if (!json || typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json.anchor, json.head);
  }
  /**
  @internal
  */
  static create(from, to, flags) {
    return new _SelectionRange(from, to, flags);
  }
};
var EditorSelection = class _EditorSelection {
  constructor(ranges, mainIndex) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(change, assoc = -1) {
    if (change.empty)
      return this;
    return _EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
  }
  /**
  Compare this selection to another selection.
  */
  eq(other) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
      return false;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(other.ranges[i]))
        return false;
    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new _EditorSelection([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(range, main = true) {
    return _EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(range, which = this.mainIndex) {
    let ranges = this.ranges.slice();
    ranges[which] = range;
    return _EditorSelection.create(ranges, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(json) {
    if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new _EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(anchor, head = anchor) {
    return new _EditorSelection([_EditorSelection.range(anchor, head)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i = 0; i < ranges.length; i++) {
      let range = ranges[i];
      if (range.empty ? range.from <= pos : range.from < pos)
        return _EditorSelection.normalized(ranges.slice(), mainIndex);
      pos = range.to;
    }
    return new _EditorSelection(ranges, mainIndex);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5);
  }
  /**
  Create a selection range.
  */
  static range(anchor, head, goalColumn, bidiLevel) {
    let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5 | (bidiLevel == null ? 3 : Math.min(2, bidiLevel));
    return head < anchor ? SelectionRange.create(head, anchor, 16 | 8 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 4 : 0) | flags);
  }
  /**
  @internal
  */
  static normalized(ranges, mainIndex = 0) {
    let main = ranges[mainIndex];
    ranges.sort((a, b) => a.from - b.from);
    mainIndex = ranges.indexOf(main);
    for (let i = 1; i < ranges.length; i++) {
      let range = ranges[i], prev = ranges[i - 1];
      if (range.empty ? range.from <= prev.to : range.from < prev.to) {
        let from = prev.from, to = Math.max(range.to, prev.to);
        if (i <= mainIndex)
          mainIndex--;
        ranges.splice(--i, 2, range.anchor > range.head ? _EditorSelection.range(to, from) : _EditorSelection.range(from, to));
      }
    }
    return new _EditorSelection(ranges, mainIndex);
  }
};
function checkSelection(selection, docLength) {
  for (let range of selection.ranges)
    if (range.to > docLength)
      throw new RangeError("Selection points outside of document");
}
var nextID = 0;
var Facet = class _Facet {
  constructor(combine, compareInput, compare2, isStatic, enables) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare2;
    this.isStatic = isStatic;
    this.id = nextID++;
    this.default = combine([]);
    this.extensions = typeof enables == "function" ? enables(this) : enables;
  }
  /**
  Define a new facet.
  */
  static define(config2 = {}) {
    return new _Facet(config2.combine || ((a) => a), config2.compareInput || ((a, b) => a === b), config2.compare || (!config2.combine ? sameArray : (a, b) => a === b), !!config2.static, config2.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get);
  }
  from(field, get) {
    if (!get)
      get = (x) => x;
    return this.compute([field], (state) => get(state.field(field)));
  }
};
function sameArray(a, b) {
  return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
var FacetProvider = class {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies;
    this.facet = facet;
    this.type = type;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a2;
    let getter = this.value;
    let compare2 = this.facet.compareInput;
    let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2;
    let depDoc = false, depSel = false, depAddrs = [];
    for (let dep of this.dependencies) {
      if (dep == "doc")
        depDoc = true;
      else if (dep == "selection")
        depSel = true;
      else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
        depAddrs.push(addresses[dep.id]);
    }
    return {
      create(state) {
        state.values[idx] = getter(state);
        return 1;
      },
      update(state, tr) {
        if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
          let newVal = getter(state);
          if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
            state.values[idx] = newVal;
            return 1;
          }
        }
        return 0;
      },
      reconfigure: (state, oldState) => {
        let newVal, oldAddr = oldState.config.address[id];
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (this.dependencies.every((dep) => {
            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
          }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
            state.values[idx] = oldVal;
            return 0;
          }
        } else {
          newVal = getter(state);
        }
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
};
function compareArray(a, b, compare2) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!compare2(a[i], b[i]))
      return false;
  return true;
}
function ensureAll(state, addrs) {
  let changed = false;
  for (let addr of addrs)
    if (ensureAddr(state, addr) & 1)
      changed = true;
  return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p) => addresses[p.id]);
  let providerTypes = providers.map((p) => p.type);
  let dynamic = providerAddrs.filter((p) => !(p & 1));
  let idx = addresses[facet.id] >> 1;
  function get(state) {
    let values = [];
    for (let i = 0; i < providerAddrs.length; i++) {
      let value = getAddr(state, providerAddrs[i]);
      if (providerTypes[i] == 2)
        for (let val of value)
          values.push(val);
      else
        values.push(value);
    }
    return facet.combine(values);
  }
  return {
    create(state) {
      for (let addr of providerAddrs)
        ensureAddr(state, addr);
      state.values[idx] = get(state);
      return 1;
    },
    update(state, tr) {
      if (!ensureAll(state, dynamic))
        return 0;
      let value = get(state);
      if (facet.compare(value, state.values[idx]))
        return 0;
      state.values[idx] = value;
      return 1;
    },
    reconfigure(state, oldState) {
      let depChanged = ensureAll(state, providerAddrs);
      let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
      if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
        state.values[idx] = oldValue;
        return 0;
      }
      let value = get(state);
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue;
        return 0;
      }
      state.values[idx] = value;
      return 1;
    }
  };
}
var initField = /* @__PURE__ */ Facet.define({ static: true });
var StateField = class _StateField {
  constructor(id, createF, updateF, compareF, spec) {
    this.id = id;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(config2) {
    let field = new _StateField(nextID++, config2.create, config2.update, config2.compare || ((a, b) => a === b), config2);
    if (config2.provide)
      field.provides = config2.provide(field);
    return field;
  }
  create(state) {
    let init = state.facet(initField).find((i) => i.field == this);
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
  }
  /**
  @internal
  */
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return {
      create: (state) => {
        state.values[idx] = this.create(state);
        return 1;
      },
      update: (state, tr) => {
        let oldVal = state.values[idx];
        let value = this.updateF(oldVal, tr);
        if (this.compareF(oldVal, value))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure: (state, oldState) => {
        if (oldState.config.address[this.id] != null) {
          state.values[idx] = oldState.field(this);
          return 0;
        }
        state.values[idx] = this.create(state);
        return 1;
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(create) {
    return [this, initField.of({ field: this, create })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
};
var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
var Prec = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ prec(Prec_.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ prec(Prec_.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ prec(Prec_.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ prec(Prec_.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ prec(Prec_.lowest)
};
var PrecExtension = class {
  constructor(inner, prec2) {
    this.inner = inner;
    this.prec = prec2;
  }
};
var Compartment = class _Compartment {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(content2) {
    return _Compartment.reconfigure.of({ compartment: this, extension: content2 });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(state) {
    return state.config.compartments.get(this);
  }
};
var CompartmentInstance = class {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
};
var Configuration = class _Configuration {
  constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
    this.base = base2;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.facets = facets;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length)
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base2, compartments, oldState) {
    let fields = [];
    let facets = /* @__PURE__ */ Object.create(null);
    let newCompartments = /* @__PURE__ */ new Map();
    for (let ext of flatten(base2, compartments, newCompartments)) {
      if (ext instanceof StateField)
        fields.push(ext);
      else
        (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = /* @__PURE__ */ Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push((a) => field.slot(a));
    }
    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
    for (let id in facets) {
      let providers = facets[id], facet = providers[0].facet;
      let oldProviders = oldFacets && oldFacets[id] || [];
      if (providers.every(
        (p) => p.type == 0
        /* Provider.Static */
      )) {
        address[facet.id] = staticValues.length << 1 | 1;
        if (sameArray(oldProviders, providers)) {
          staticValues.push(oldState.facet(facet));
        } else {
          let value = facet.combine(providers.map((p) => p.value));
          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
        }
      } else {
        for (let p of providers) {
          if (p.type == 0) {
            address[p.id] = staticValues.length << 1 | 1;
            staticValues.push(p.value);
          } else {
            address[p.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a) => p.dynamicSlot(a));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
      }
    }
    let dynamic = dynamicSlots.map((f) => f(address));
    return new _Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
  }
};
function flatten(extension, compartments, newCompartments) {
  let result = [[], [], [], [], []];
  let seen = /* @__PURE__ */ new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known <= prec2)
        return;
      let found = result[known].indexOf(ext);
      if (found > -1)
        result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance)
        newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e of ext)
        inner(e, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`);
      let content2 = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content2);
      inner(content2, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec2].push(ext);
      if (ext.provides)
        inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result[prec2].push(ext);
      if (ext.facet.extensions)
        inner(ext.facet.extensions, Prec_.default);
    } else {
      let content2 = ext.extension;
      if (!content2)
        throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content2, prec2);
    }
  }
  inner(extension, Prec_.default);
  return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
  if (addr & 1)
    return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2)
    return status;
  state.status[idx] = 4;
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
var languageData = /* @__PURE__ */ Facet.define();
var allowMultipleSelections = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((v) => v),
  static: true
});
var lineSeparator = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : void 0,
  static: true
});
var changeFilter = /* @__PURE__ */ Facet.define();
var transactionFilter = /* @__PURE__ */ Facet.define();
var transactionExtender = /* @__PURE__ */ Facet.define();
var readOnly = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : false
});
var Annotation = class {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new AnnotationType();
  }
};
var AnnotationType = class {
  /**
  Create an instance of this annotation.
  */
  of(value) {
    return new Annotation(this, value);
  }
};
var StateEffectType = class {
  /**
  @internal
  */
  constructor(map) {
    this.map = map;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(value) {
    return new StateEffect(this, value);
  }
};
var StateEffect = class _StateEffect {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === void 0 ? void 0 : mapped == this.value ? this : new _StateEffect(this.type, mapped);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(type) {
    return this.type == type;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds.
  */
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v) => v));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(effects, mapping) {
    if (!effects.length)
      return effects;
    let result = [];
    for (let effect of effects) {
      let mapped = effect.map(mapping);
      if (mapped)
        result.push(mapped);
    }
    return result;
  }
};
StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
var Transaction = class _Transaction {
  constructor(startState, changes, selection, effects, annotations, scrollIntoView3) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView3;
    this._doc = null;
    this._state = null;
    if (selection)
      checkSelection(selection, changes.newLength);
    if (!annotations.some((a) => a.type == _Transaction.time))
      this.annotations = annotations.concat(_Transaction.time.of(Date.now()));
  }
  /**
  @internal
  */
  static create(startState, changes, selection, effects, annotations, scrollIntoView3) {
    return new _Transaction(startState, changes, selection, effects, annotations, scrollIntoView3);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    if (!this._state)
      this.startState.applyTransaction(this);
    return this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(type) {
    for (let ann of this.annotations)
      if (ann.type == type)
        return ann.value;
    return void 0;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(event) {
    let e = this.annotation(_Transaction.userEvent);
    return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
  }
};
Transaction.time = /* @__PURE__ */ Annotation.define();
Transaction.userEvent = /* @__PURE__ */ Annotation.define();
Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
Transaction.remote = /* @__PURE__ */ Annotation.define();
function joinRanges(a, b) {
  let result = [];
  for (let iA = 0, iB = 0; ; ) {
    let from, to;
    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
      from = a[iA++];
      to = a[iA++];
    } else if (iB < b.length) {
      from = b[iB++];
      to = b[iB++];
    } else
      return result;
    if (!result.length || result[result.length - 1] < from)
      result.push(from, to);
    else if (result[result.length - 1] < to)
      result[result.length - 1] = to;
  }
}
function mergeTransaction(a, b, sequential) {
  var _a2;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b.changes;
    mapForB = ChangeSet.empty(b.changes.length);
    changes = a.changes.compose(b.changes);
  } else {
    mapForA = b.changes.map(a.changes);
    mapForB = a.changes.mapDesc(b.changes, true);
    changes = a.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b.selection ? b.selection.map(mapForB) : (_a2 = a.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
    effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
    scrollIntoView: a.scrollIntoView || b.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection, annotations = asArray(spec.annotations);
  if (spec.userEvent)
    annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter) {
  let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false)
    filter = false;
  for (let i = 1; i < specs.length; i++) {
    if (specs[i].filter === false)
      filter = false;
    let seq = !!specs[i].sequential;
    s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
  }
  let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
  return extendTransaction(filter ? filterTransaction(tr) : tr);
}
function filterTransaction(tr) {
  let state = tr.startState;
  let result = true;
  for (let filter of state.facet(changeFilter)) {
    let value = filter(tr);
    if (value === false) {
      result = false;
      break;
    }
    if (Array.isArray(value))
      result = result === true ? value : joinRanges(result, value);
  }
  if (result !== true) {
    let changes, back;
    if (result === false) {
      back = tr.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
    }
    tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i = filters.length - 1; i >= 0; i--) {
    let filtered = filters[i](tr);
    if (filtered instanceof Transaction)
      tr = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr = filtered[0];
    else
      tr = resolveTransaction(state, asArray(filtered), false);
  }
  return tr;
}
function extendTransaction(tr) {
  let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
  for (let i = extenders.length - 1; i >= 0; i--) {
    let extension = extenders[i](tr);
    if (extension && Object.keys(extension).length)
      spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
  }
  return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
var none = [];
function asArray(value) {
  return value == null ? none : Array.isArray(value) ? value : [value];
}
var CharCategory = /* @__PURE__ */ function(CharCategory2) {
  CharCategory2[CharCategory2["Word"] = 0] = "Word";
  CharCategory2[CharCategory2["Space"] = 1] = "Space";
  CharCategory2[CharCategory2["Other"] = 2] = "Other";
  return CharCategory2;
}(CharCategory || (CharCategory = {}));
var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
var wordChar;
try {
  wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_) {
}
function hasWordChar(str) {
  if (wordChar)
    return wordChar.test(str);
  for (let i = 0; i < str.length; i++) {
    let ch = str[i];
    if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
      return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char) => {
    if (!/\S/.test(char))
      return CharCategory.Space;
    if (hasWordChar(char))
      return CharCategory.Word;
    for (let i = 0; i < wordChars.length; i++)
      if (char.indexOf(wordChars[i]) > -1)
        return CharCategory.Word;
    return CharCategory.Other;
  };
}
var EditorState = class _EditorState {
  constructor(config2, doc2, selection, values, computeSlot, tr) {
    this.config = config2;
    this.doc = doc2;
    this.selection = selection;
    this.values = values;
    this.status = config2.statusTemplate.slice();
    this.computeSlot = computeSlot;
    if (tr)
      tr._state = this;
    for (let i = 0; i < this.config.dynamicSlots.length; i++)
      ensureAddr(this, i << 1);
    this.computeSlot = null;
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require2)
        throw new RangeError("Field is not present in this state");
      return void 0;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  /**
  @internal
  */
  applyTransaction(tr) {
    let conf = this.config, { base: base2, compartments } = conf;
    for (let effect of tr.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = /* @__PURE__ */ new Map();
          conf.compartments.forEach((val, key) => compartments.set(key, val));
          conf = null;
        }
        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null;
        base2 = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null;
        base2 = asArray(base2).concat(effect.value);
      }
    }
    let startValues;
    if (!conf) {
      conf = Configuration.resolve(base2, compartments, this);
      let intermediateState = new _EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
      startValues = intermediateState.values;
    } else {
      startValues = tr.startState.values.slice();
    }
    new _EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state, slot) => slot.update(state, tr), tr);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(text) {
    if (typeof text == "string")
      text = this.toText(text);
    return this.changeByRange((range) => ({
      changes: { from: range.from, to: range.to, insert: text },
      range: EditorSelection.cursor(range.from + text.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(f) {
    let sel = this.selection;
    let result1 = f(sel.ranges[0]);
    let changes = this.changes(result1.changes), ranges = [result1.range];
    let effects = asArray(result1.effects);
    for (let i = 1; i < sel.ranges.length; i++) {
      let result = f(sel.ranges[i]);
      let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
      for (let j = 0; j < i; j++)
        ranges[j] = ranges[j].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(spec = []) {
    if (spec instanceof ChangeSet)
      return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(_EditorState.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(string2) {
    return Text.of(string2.split(this.facet(_EditorState.lineSeparator) || DefaultSplit));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(from = 0, to = this.doc.length) {
    return this.doc.sliceString(from, to, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null)
      return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields)
      for (let prop in fields) {
        let value = fields[prop];
        if (value instanceof StateField && this.config.address[value.id] != null)
          result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
      }
    return result;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(json, config2 = {}, fields) {
    if (!json || typeof json.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields)
      for (let prop in fields) {
        if (Object.prototype.hasOwnProperty.call(json, prop)) {
          let field = fields[prop], value = json[prop];
          fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
        }
      }
    return _EditorState.create({
      doc: json.doc,
      selection: EditorSelection.fromJSON(json.selection),
      extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(config2 = {}) {
    let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
    let doc2 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(_EditorState.lineSeparator) || DefaultSplit));
    let selection = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
    checkSelection(selection, doc2.length);
    if (!configuration.staticFacet(allowMultipleSelections))
      selection = selection.asSingle();
    return new _EditorState(configuration, doc2, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(_EditorState.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(_EditorState.lineSeparator) || "\n";
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(readOnly);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(phrase2, ...insert2) {
    for (let map of this.facet(_EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(map, phrase2)) {
        phrase2 = map[phrase2];
        break;
      }
    if (insert2.length)
      phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m, i) => {
        if (i == "$")
          return "$";
        let n = +(i || 1);
        return !n || n > insert2.length ? m : insert2[n - 1];
      });
    return phrase2;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(name2, pos, side = -1) {
    let values = [];
    for (let provider of this.facet(languageData)) {
      for (let result of provider(this, pos, side)) {
        if (Object.prototype.hasOwnProperty.call(result, name2))
          values.push(result[name2]);
      }
    }
    return values;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(at) {
    return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(pos) {
    let { text, from, length } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start = pos - from, end = pos - from;
    while (start > 0) {
      let prev = findClusterBreak(text, start, false);
      if (cat(text.slice(prev, start)) != CharCategory.Word)
        break;
      start = prev;
    }
    while (end < length) {
      let next = findClusterBreak(text, end);
      if (cat(text.slice(end, next)) != CharCategory.Word)
        break;
      end = next;
    }
    return start == end ? null : EditorSelection.range(start + from, end + from);
  }
};
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = /* @__PURE__ */ Facet.define({
  compare(a, b) {
    let kA = Object.keys(a), kB = Object.keys(b);
    return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
  }
});
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
function combineConfig(configs, defaults3, combine = {}) {
  let result = {};
  for (let config2 of configs)
    for (let key of Object.keys(config2)) {
      let value = config2[key], current = result[key];
      if (current === void 0)
        result[key] = value;
      else if (current === value || value === void 0)
        ;
      else if (Object.hasOwnProperty.call(combine, key))
        result[key] = combine[key](current, value);
      else
        throw new Error("Config merge conflict for field " + key);
    }
  for (let key in defaults3)
    if (result[key] === void 0)
      result[key] = defaults3[key];
  return result;
}
var RangeValue = class {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(other) {
    return this == other;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(from, to = from) {
    return Range.create(from, to, this);
  }
};
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
var Range = class _Range {
  constructor(from, to, value) {
    this.from = from;
    this.to = to;
    this.value = value;
  }
  /**
  @internal
  */
  static create(from, to, value) {
    return new _Range(from, to, value);
  }
};
function cmpRange(a, b) {
  return a.from - b.from || a.value.startSide - b.value.startSide;
}
var Chunk = class _Chunk {
  constructor(from, to, value, maxPoint) {
    this.from = from;
    this.to = to;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(pos, side, end, startAt = 0) {
    let arr = end ? this.to : this.from;
    for (let lo = startAt, hi = arr.length; ; ) {
      if (lo == hi)
        return lo;
      let mid = lo + hi >> 1;
      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
      if (mid == lo)
        return diff >= 0 ? lo : hi;
      if (diff >= 0)
        hi = mid;
      else
        lo = mid + 1;
    }
  }
  between(offset, from, to, f) {
    for (let i = this.findIndex(from, -1e9, true), e = this.findIndex(to, 1e9, false, i); i < e; i++)
      if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
        return false;
  }
  map(offset, changes) {
    let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
    for (let i = 0; i < this.value.length; i++) {
      let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null)
          continue;
        newFrom = newTo = mapped;
        if (val.startSide != val.endSide) {
          newTo = changes.mapPos(curFrom, val.endSide);
          if (newTo < newFrom)
            continue;
        }
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
          continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0)
        continue;
      if (newPos < 0)
        newPos = newFrom;
      if (val.point)
        maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from.push(newFrom - newPos);
      to.push(newTo - newPos);
    }
    return { mapped: value.length ? new _Chunk(from, to, value, maxPoint) : null, pos: newPos };
  }
};
var RangeSet = class _RangeSet {
  constructor(chunkPos, chunk, nextLayer, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  /**
  @internal
  */
  static create(chunkPos, chunk, nextLayer, maxPoint) {
    return new _RangeSet(chunkPos, chunk, nextLayer, maxPoint);
  }
  /**
  @internal
  */
  get length() {
    let last = this.chunk.length - 1;
    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let size = this.nextLayer.size;
    for (let chunk of this.chunk)
      size += chunk.value.length;
    return size;
  }
  /**
  @internal
  */
  chunkEnd(index) {
    return this.chunkPos[index] + this.chunk[index].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(updateSpec) {
    let { add: add2 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
    let filter = updateSpec.filter;
    if (add2.length == 0 && !filter)
      return this;
    if (sort)
      add2 = add2.slice().sort(cmpRange);
    if (this.isEmpty)
      return add2.length ? _RangeSet.of(add2) : this;
    let cur2 = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
    let builder = new RangeSetBuilder();
    while (cur2.value || i < add2.length) {
      if (i < add2.length && (cur2.from - add2[i].from || cur2.startSide - add2[i].value.startSide) >= 0) {
        let range = add2[i++];
        if (!builder.addInner(range.from, range.to, range.value))
          spill.push(range);
      } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i == add2.length || this.chunkEnd(cur2.chunkIndex) < add2[i].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
        cur2.nextChunk();
      } else {
        if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
          if (!builder.addInner(cur2.from, cur2.to, cur2.value))
            spill.push(Range.create(cur2.from, cur2.to, cur2.value));
        }
        cur2.next();
      }
    }
    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? _RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(changes) {
    if (changes.empty || this.isEmpty)
      return this;
    let chunks = [], chunkPos = [], maxPoint = -1;
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i], chunk = this.chunk[i];
      let touch = changes.touchesRange(start, start + chunk.length);
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start));
      } else if (touch === true) {
        let { mapped, pos } = chunk.map(start, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next = this.nextLayer.map(changes);
    return chunks.length == 0 ? next : new _RangeSet(chunkPos, chunks, next || _RangeSet.empty, maxPoint);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(from, to, f) {
    if (this.isEmpty)
      return;
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i], chunk = this.chunk[i];
      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false)
        return;
    }
    this.nextLayer.between(from, to, f);
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(from = 0) {
    return HeapCursor.from([this]).goto(from);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(sets, from = 0) {
    return HeapCursor.from(sets).goto(from);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a = oldSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let b = newSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a, b, textDiff);
    let sideA = new SpanCursor(a, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
    if (textDiff.empty && textDiff.length == 0)
      compare(sideA, 0, sideB, 0, 0, comparator);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(oldSets, newSets, from = 0, to) {
    if (to == null)
      to = 1e9 - 1;
    let a = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
    let b = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
    if (a.length != b.length)
      return false;
    if (!a.length)
      return true;
    let sharedChunks = findSharedChunks(a, b);
    let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
    for (; ; ) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
        return false;
      if (sideA.to > to)
        return true;
      sideA.next();
      sideB.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(sets, from, to, iterator, minPointSize = -1) {
    let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
    let openRanges = cursor.openStart;
    for (; ; ) {
      let curTo = Math.min(cursor.to, to);
      if (cursor.point) {
        let active = cursor.activeForPoint(cursor.to);
        let openCount = cursor.pointFrom < from ? active.length + 1 : Math.min(active.length, openRanges);
        iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
        openRanges = Math.min(cursor.openEnd(curTo), active.length);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor.active, openRanges);
        openRanges = cursor.openEnd(curTo);
      }
      if (cursor.to > to)
        return openRanges + (cursor.point && cursor.to > to ? 1 : 0);
      pos = cursor.to;
      cursor.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(ranges, sort = false) {
    let build = new RangeSetBuilder();
    for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
      build.add(range.from, range.to, range.value);
    return build.finish();
  }
};
RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
function lazySort(ranges) {
  if (ranges.length > 1)
    for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
      let cur2 = ranges[i];
      if (cmpRange(prev, cur2) > 0)
        return ranges.slice().sort(cmpRange);
      prev = cur2;
    }
  return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
var RangeSetBuilder = class _RangeSetBuilder {
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1e9;
    this.lastTo = -1e9;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(from, to, value) {
    if (!this.addInner(from, to, value))
      (this.nextLayer || (this.nextLayer = new _RangeSetBuilder())).add(from, to, value);
  }
  /**
  @internal
  */
  addInner(from, to, value) {
    let diff = from - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0)
      return false;
    if (this.from.length == 250)
      this.finishChunk(true);
    if (this.chunkStart < 0)
      this.chunkStart = from;
    this.from.push(from - this.chunkStart);
    this.to.push(to - this.chunkStart);
    this.last = value;
    this.lastFrom = from;
    this.lastTo = to;
    this.value.push(value);
    if (value.point)
      this.maxPoint = Math.max(this.maxPoint, to - from);
    return true;
  }
  /**
  @internal
  */
  addChunk(from, chunk) {
    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
      return false;
    if (this.from.length)
      this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from);
    let last = chunk.value.length - 1;
    this.last = chunk.value[last];
    this.lastFrom = chunk.from[last] + from;
    this.lastTo = chunk.to[last] + from;
    return true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  /**
  @internal
  */
  finishInner(next) {
    if (this.from.length)
      this.finishChunk(false);
    if (this.chunks.length == 0)
      return next;
    let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
    this.from = null;
    return result;
  }
};
function findSharedChunks(a, b, textDiff) {
  let inA = /* @__PURE__ */ new Map();
  for (let set of a)
    for (let i = 0; i < set.chunk.length; i++)
      if (set.chunk[i].maxPoint <= 0)
        inA.set(set.chunk[i], set.chunkPos[i]);
  let shared = /* @__PURE__ */ new Set();
  for (let set of b)
    for (let i = 0; i < set.chunk.length; i++) {
      let known = inA.get(set.chunk[i]);
      if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
        shared.add(set.chunk[i]);
    }
  return shared;
}
var LayerCursor = class {
  constructor(layer2, skip, minPoint, rank = 0) {
    this.layer = layer2;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
        break;
      this.chunkIndex++;
      forward = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
      if (!forward || this.rangeIndex < rangeIndex)
        this.setRangeIndex(rangeIndex);
    }
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0)
      this.gotoInner(pos, side, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
        let from = chunkPos + chunk.from[this.rangeIndex];
        this.from = from;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        this.setRangeIndex(this.rangeIndex + 1);
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
    }
  }
  setRangeIndex(index) {
    if (index == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++;
      if (this.skip) {
        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
          this.chunkIndex++;
      }
      this.rangeIndex = 0;
    } else {
      this.rangeIndex = index;
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
  }
};
var HeapCursor = class _HeapCursor {
  constructor(heap2) {
    this.heap = heap2;
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap2 = [];
    for (let i = 0; i < sets.length; i++) {
      for (let cur2 = sets[i]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
        if (cur2.maxPoint >= minPoint)
          heap2.push(new LayerCursor(cur2, skip, minPoint, i));
      }
    }
    return heap2.length == 1 ? heap2[0] : new _HeapCursor(heap2);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side = -1e9) {
    for (let cur2 of this.heap)
      cur2.goto(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (let cur2 of this.heap)
      cur2.forward(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    if ((this.to - pos || this.value.endSide - side) < 0)
      this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9;
      this.value = null;
      this.rank = -1;
    } else {
      let top2 = this.heap[0];
      this.from = top2.from;
      this.to = top2.to;
      this.value = top2.value;
      this.rank = top2.rank;
      if (top2.value)
        top2.next();
      heapBubble(this.heap, 0);
    }
  }
};
function heapBubble(heap2, index) {
  for (let cur2 = heap2[index]; ; ) {
    let childIndex = (index << 1) + 1;
    if (childIndex >= heap2.length)
      break;
    let child = heap2[childIndex];
    if (childIndex + 1 < heap2.length && child.compare(heap2[childIndex + 1]) >= 0) {
      child = heap2[childIndex + 1];
      childIndex++;
    }
    if (cur2.compare(child) < 0)
      break;
    heap2[childIndex] = cur2;
    heap2[index] = child;
    index = childIndex;
  }
}
var SpanCursor = class {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1e9;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
      this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index) {
    remove(this.active, index);
    remove(this.activeTo, index);
    remove(this.activeRank, index);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i = 0, { value, to, rank } = this.cursor;
    while (i < this.activeRank.length && this.activeRank[i] <= rank)
      i++;
    insert(this.active, i, value);
    insert(this.activeTo, i, to);
    insert(this.activeRank, i, rank);
    if (trackOpen)
      insert(trackOpen, i, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let from = this.to, wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let a = this.minActive;
      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a] > from) {
          this.to = this.activeTo[a];
          this.endSide = this.active[a].endSide;
          break;
        }
        this.removeActive(a);
        if (trackOpen)
          remove(trackOpen, a);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9;
        break;
      } else if (this.cursor.from > from) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          this.cursor.next();
          this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      this.openStart = 0;
      for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)
        this.openStart++;
    }
  }
  activeForPoint(to) {
    if (!this.active.length)
      return this.active;
    let active = [];
    for (let i = this.active.length - 1; i >= 0; i--) {
      if (this.activeRank[i] < this.pointRank)
        break;
      if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
        active.push(this.active[i]);
    }
    return active.reverse();
  }
  openEnd(to) {
    let open = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
      open++;
    return open;
  }
};
function compare(a, startA, b, startB, length, comparator) {
  a.goto(startA);
  b.goto(startB);
  let endB = startB + length;
  let pos = startB, dPos = startB - startA;
  for (; ; ) {
    let diff = a.to + dPos - b.to || a.endSide - b.endSide;
    let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
    if (a.point || b.point) {
      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to))))
        comparator.comparePoint(pos, clipEnd, a.point, b.point);
    } else {
      if (clipEnd > pos && !sameValues(a.active, b.active))
        comparator.compareRange(pos, clipEnd, a.active, b.active);
    }
    if (end > endB)
      break;
    pos = end;
    if (diff <= 0)
      a.next();
    if (diff >= 0)
      b.next();
  }
}
function sameValues(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (a[i] != b[i] && !a[i].eq(b[i]))
      return false;
  return true;
}
function remove(array, index) {
  for (let i = index, e = array.length - 1; i < e; i++)
    array[i] = array[i + 1];
  array.pop();
}
function insert(array, index, value) {
  for (let i = array.length - 1; i >= index; i--)
    array[i + 1] = array[i];
  array[index] = value;
}
function findMinIndex(value, array) {
  let found = -1, foundPos = 1e9;
  for (let i = 0; i < array.length; i++)
    if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
      found = i;
      foundPos = array[i];
    }
  return found;
}
function countColumn(string2, tabSize, to = string2.length) {
  let n = 0;
  for (let i = 0; i < to; ) {
    if (string2.charCodeAt(i) == 9) {
      n += tabSize - n % tabSize;
      i++;
    } else {
      n++;
      i = findClusterBreak(string2, i);
    }
  }
  return n;
}
function findColumn(string2, col, tabSize, strict) {
  for (let i = 0, n = 0; ; ) {
    if (n >= col)
      return i;
    if (i == string2.length)
      break;
    n += string2.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
    i = findClusterBreak(string2, i);
  }
  return strict === true ? -1 : string2.length;
}

// node_modules/style-mod/src/style-mod.js
var C = "\u037C";
var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
var StyleModule = class {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(spec, options) {
    this.rules = [];
    let { finish } = options || {};
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }
    function render(selectors, spec2, target, isKeyframes) {
      let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
      if (isAt && spec2 == null)
        return target.push(selectors[0] + ";");
      for (let prop in spec2) {
        let value = spec2[prop];
        if (/&/.test(prop)) {
          render(
            prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),
            value,
            target
          );
        } else if (value && typeof value == "object") {
          if (!isAt)
            throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render(splitSelector(prop), value, local, keyframes);
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
        }
      }
      if (local.length || keyframes) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }
    for (let prop in spec)
      render(splitSelector(prop), spec[prop], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join("\n");
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let id = top[COUNT] || 1;
    top[COUNT] = id + 1;
    return C + id.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  static mount(root, modules) {
    (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);
  }
};
var adoptedSet = null;
var StyleSet = class {
  constructor(root) {
    if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
      if (adoptedSet) {
        root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);
        return root[SET] = adoptedSet;
      }
      this.sheet = new CSSStyleSheet();
      root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);
      adoptedSet = this;
    } else {
      this.styleTag = (root.ownerDocument || root).createElement("style");
      let target = root.head || root;
      target.insertBefore(this.styleTag, target.firstChild);
    }
    this.modules = [];
    root[SET] = this;
  }
  mount(modules) {
    let sheet = this.sheet;
    let pos = 0, j = 0;
    for (let i = 0; i < modules.length; i++) {
      let mod = modules[i], index = this.modules.indexOf(mod);
      if (index < j && index > -1) {
        this.modules.splice(index, 1);
        j--;
        index = -1;
      }
      if (index == -1) {
        this.modules.splice(j++, 0, mod);
        if (sheet)
          for (let k = 0; k < mod.rules.length; k++)
            sheet.insertRule(mod.rules[k], pos++);
      } else {
        while (j < index)
          pos += this.modules[j++].rules.length;
        pos += mod.rules.length;
        j++;
      }
    }
    if (!sheet) {
      let text = "";
      for (let i = 0; i < this.modules.length; i++)
        text += this.modules[i].getRules() + "\n";
      this.styleTag.textContent = text;
    }
  }
};

// node_modules/w3c-keyname/index.es.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = mac || chrome && +chrome[1] < 57;
for (i = 0; i < 10; i++)
  base[48 + i] = base[96 + i] = String(i);
var i;
for (i = 1; i <= 24; i++)
  base[i + 111] = "F" + i;
var i;
for (i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
var i;
for (code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];
var code;
function keyName(event) {
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name2 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name2 == "Esc")
    name2 = "Escape";
  if (name2 == "Del")
    name2 = "Delete";
  if (name2 == "Left")
    name2 = "ArrowLeft";
  if (name2 == "Up")
    name2 = "ArrowUp";
  if (name2 == "Right")
    name2 = "ArrowRight";
  if (name2 == "Down")
    name2 = "ArrowDown";
  return name2;
}

// node_modules/@codemirror/view/dist/index.js
function getSelection(root) {
  let target;
  if (root.nodeType == 11) {
    target = root.getSelection ? root : root.ownerDocument;
  } else {
    target = root;
  }
  return target.getSelection();
}
function contains(dom, node) {
  return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function deepActiveElement(doc2) {
  let elt = doc2.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function hasSelection(dom, selection) {
  if (!selection.anchorNode)
    return false;
  try {
    return contains(dom, selection.anchorNode);
  } catch (_) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3)
    return textRange(dom, 0, dom.nodeValue.length).getClientRects();
  else if (dom.nodeType == 1)
    return dom.getClientRects();
  else
    return [];
}
function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
}
function domIndex(node) {
  for (var index = 0; ; index++) {
    node = node.previousSibling;
    if (!node)
      return index;
  }
}
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : maxOffset(node))) {
      if (node.nodeName == "DIV")
        return false;
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1)
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.nodeType == 1 && node.contentEditable == "false")
        return false;
      off = dir < 0 ? maxOffset(node) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
var Rect0 = { left: 0, right: 0, top: 0, bottom: 0 };
function flattenRect(rect, left) {
  let x = left ? rect.left : rect.right;
  return { left: x, right: x, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  for (let cur2 = dom; cur2; ) {
    if (cur2.nodeType == 1) {
      let bounding, top2 = cur2 == doc2.body;
      if (top2) {
        bounding = windowRect(win);
      } else {
        if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
          cur2 = cur2.assignedSlot || cur2.parentNode;
          continue;
        }
        let rect2 = cur2.getBoundingClientRect();
        bounding = {
          left: rect2.left,
          right: rect2.left + cur2.clientWidth,
          top: rect2.top,
          bottom: rect2.top + cur2.clientHeight
        };
      }
      let moveX = 0, moveY = 0;
      if (y == "nearest") {
        if (rect.top < bounding.top) {
          moveY = -(bounding.top - rect.top + yMargin);
          if (side > 0 && rect.bottom > bounding.bottom + moveY)
            moveY = rect.bottom - bounding.bottom + moveY + yMargin;
        } else if (rect.bottom > bounding.bottom) {
          moveY = rect.bottom - bounding.bottom + yMargin;
          if (side < 0 && rect.top - moveY < bounding.top)
            moveY = -(bounding.top + moveY - rect.top + yMargin);
        }
      } else {
        let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
        let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
        moveY = targetTop - bounding.top;
      }
      if (x == "nearest") {
        if (rect.left < bounding.left) {
          moveX = -(bounding.left - rect.left + xMargin);
          if (side > 0 && rect.right > bounding.right + moveX)
            moveX = rect.right - bounding.right + moveX + xMargin;
        } else if (rect.right > bounding.right) {
          moveX = rect.right - bounding.right + xMargin;
          if (side < 0 && rect.left < bounding.left + moveX)
            moveX = -(bounding.left + moveX - rect.left + xMargin);
        }
      } else {
        let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
        moveX = targetLeft - bounding.left;
      }
      if (moveX || moveY) {
        if (top2) {
          win.scrollBy(moveX, moveY);
        } else {
          let movedX = 0, movedY = 0;
          if (moveY) {
            let start = cur2.scrollTop;
            cur2.scrollTop += moveY;
            movedY = cur2.scrollTop - start;
          }
          if (moveX) {
            let start = cur2.scrollLeft;
            cur2.scrollLeft += moveX;
            movedX = cur2.scrollLeft - start;
          }
          rect = {
            left: rect.left - movedX,
            top: rect.top - movedY,
            right: rect.right - movedX,
            bottom: rect.bottom - movedY
          };
          if (movedX && Math.abs(movedX - moveX) < 1)
            x = "nearest";
          if (movedY && Math.abs(movedY - moveY) < 1)
            y = "nearest";
        }
      }
      if (top2)
        break;
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
}
function scrollableParent(dom) {
  let doc2 = dom.ownerDocument;
  for (let cur2 = dom.parentNode; cur2; ) {
    if (cur2 == doc2.body) {
      break;
    } else if (cur2.nodeType == 1) {
      if (cur2.scrollHeight > cur2.clientHeight || cur2.scrollWidth > cur2.clientWidth)
        return cur2;
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
  return null;
}
var DOMSelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }
  setRange(range) {
    this.set(range.anchorNode, range.anchorOffset, range.focusNode, range.focusOffset);
  }
  set(anchorNode, anchorOffset, focusNode, focusOffset) {
    this.anchorNode = anchorNode;
    this.anchorOffset = anchorOffset;
    this.focusNode = focusNode;
    this.focusOffset = focusOffset;
  }
};
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stack = [];
  for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
    stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
    if (cur2 == cur2.ownerDocument)
      break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i = 0; i < stack.length; ) {
      let elt = stack[i++], top2 = stack[i++], left = stack[i++];
      if (elt.scrollTop != top2)
        elt.scrollTop = top2;
      if (elt.scrollLeft != left)
        elt.scrollLeft = left;
    }
  }
}
var scratchRange;
function textRange(node, from, to = from) {
  let range = scratchRange || (scratchRange = document.createRange());
  range.setEnd(node, to);
  range.setStart(node, from);
  return range;
}
function dispatchKey(elt, name2, code) {
  let options = { key: name2, code: name2, keyCode: code, which: code, cancelable: true };
  let down = new KeyboardEvent("keydown", options);
  down.synthetic = true;
  elt.dispatchEvent(down);
  let up = new KeyboardEvent("keyup", options);
  up.synthetic = true;
  elt.dispatchEvent(up);
  return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node) {
  while (node) {
    if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
      return node;
    node = node.assignedSlot || node.parentNode;
  }
  return null;
}
function clearAttributes(node) {
  while (node.attributes.length)
    node.removeAttributeNode(node.attributes[0]);
}
function atElementStart(doc2, selection) {
  let node = selection.focusNode, offset = selection.focusOffset;
  if (!node || selection.anchorNode != node || selection.anchorOffset != offset)
    return false;
  for (; ; ) {
    if (offset) {
      if (node.nodeType != 1)
        return false;
      let prev = node.childNodes[offset - 1];
      if (prev.contentEditable == "false")
        offset--;
      else {
        node = prev;
        offset = maxOffset(node);
      }
    } else if (node == doc2) {
      return true;
    } else {
      offset = domIndex(node);
      node = node.parentNode;
    }
  }
}
var DOMPos = class _DOMPos {
  constructor(node, offset, precise = true) {
    this.node = node;
    this.offset = offset;
    this.precise = precise;
  }
  static before(dom, precise) {
    return new _DOMPos(dom.parentNode, domIndex(dom), precise);
  }
  static after(dom, precise) {
    return new _DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }
};
var noChildren = [];
var ContentView = class _ContentView {
  constructor() {
    this.parent = null;
    this.dom = null;
    this.dirty = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(view) {
    let pos = this.posAtStart;
    for (let child of this.children) {
      if (child == view)
        return pos;
      pos += child.length + child.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(view) {
    return this.posBefore(view) + view.length;
  }
  // Will return a rectangle directly before (when side < 0), after
  // (side > 0) or directly on (when the browser supports it) the
  // given position.
  coordsAt(_pos, _side) {
    return null;
  }
  sync(view, track) {
    if (this.dirty & 2) {
      let parent = this.dom;
      let prev = null, next;
      for (let child of this.children) {
        if (child.dirty) {
          if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
            let contentView = _ContentView.get(next);
            if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
              child.reuseDOM(next);
          }
          child.sync(view, track);
          child.dirty = 0;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (track && !track.written && track.node == parent && next != child.dom)
          track.written = true;
        if (child.dom.parentNode == parent) {
          while (next && next != child.dom)
            next = rm$1(next);
        } else {
          parent.insertBefore(child.dom, next);
        }
        prev = child.dom;
      }
      next = prev ? prev.nextSibling : parent.firstChild;
      if (next && track && track.node == parent)
        track.written = true;
      while (next)
        next = rm$1(next);
    } else if (this.dirty & 1) {
      for (let child of this.children)
        if (child.dirty) {
          child.sync(view, track);
          child.dirty = 0;
        }
    }
  }
  reuseDOM(_dom) {
  }
  localPosFromDOM(node, offset) {
    let after;
    if (node == this.dom) {
      after = this.dom.childNodes[offset];
    } else {
      let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
      for (; ; ) {
        let parent = node.parentNode;
        if (parent == this.dom)
          break;
        if (bias == 0 && parent.firstChild != parent.lastChild) {
          if (node == parent.firstChild)
            bias = -1;
          else
            bias = 1;
        }
        node = parent;
      }
      if (bias < 0)
        after = node;
      else
        after = node.nextSibling;
    }
    if (after == this.dom.firstChild)
      return 0;
    while (after && !_ContentView.get(after))
      after = after.nextSibling;
    if (!after)
      return this.length;
    for (let i = 0, pos = 0; ; i++) {
      let child = this.children[i];
      if (child.dom == after)
        return pos;
      pos += child.length + child.breakAfter;
    }
  }
  domBoundsAround(from, to, offset = 0) {
    let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
    for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (pos < from && end > to)
        return child.domBoundsAround(from, to, pos);
      if (end >= from && fromI == -1) {
        fromI = i;
        fromStart = pos;
      }
      if (pos > to && child.dom.parentNode == this.dom) {
        toI = i;
        toEnd = prevEnd;
        break;
      }
      prevEnd = end;
      pos = end + child.breakAfter;
    }
    return {
      from: fromStart,
      to: toEnd < 0 ? offset + this.length : toEnd,
      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
    };
  }
  markDirty(andParent = false) {
    this.dirty |= 2;
    this.markParentsDirty(andParent);
  }
  markParentsDirty(childList) {
    for (let parent = this.parent; parent; parent = parent.parent) {
      if (childList)
        parent.dirty |= 2;
      if (parent.dirty & 1)
        return;
      parent.dirty |= 1;
      childList = false;
    }
  }
  setParent(parent) {
    if (this.parent != parent) {
      this.parent = parent;
      if (this.dirty)
        this.markParentsDirty(true);
    }
  }
  setDOM(dom) {
    if (this.dom)
      this.dom.cmView = null;
    this.dom = dom;
    dom.cmView = this;
  }
  get rootView() {
    for (let v = this; ; ) {
      let parent = v.parent;
      if (!parent)
        return v;
      v = parent;
    }
  }
  replaceChildren(from, to, children = noChildren) {
    this.markDirty();
    for (let i = from; i < to; i++) {
      let child = this.children[i];
      if (child.parent == this)
        child.destroy();
    }
    this.children.splice(from, to - from, ...children);
    for (let i = 0; i < children.length; i++)
      children[i].setParent(this);
  }
  ignoreMutation(_rec) {
    return false;
  }
  ignoreEvent(_event) {
    return false;
  }
  childCursor(pos = this.length) {
    return new ChildCursor(this.children, pos, this.children.length);
  }
  childPos(pos, bias = 1) {
    return this.childCursor().findPos(pos, bias);
  }
  toString() {
    let name2 = this.constructor.name.replace("View", "");
    return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(node) {
    return node.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  merge(from, to, source, hasStart, openStart, openEnd) {
    return false;
  }
  become(other) {
    return false;
  }
  canReuseDOM(other) {
    return other.constructor == this.constructor;
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
};
ContentView.prototype.breakAfter = 0;
function rm$1(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ChildCursor = class {
  constructor(children, pos, i) {
    this.children = children;
    this.pos = pos;
    this.i = i;
    this.off = 0;
  }
  findPos(pos, bias = 1) {
    for (; ; ) {
      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
        this.off = pos - this.pos;
        return this;
      }
      let next = this.children[--this.i];
      this.pos -= next.length + next.breakAfter;
    }
  }
};
function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
  let { children } = parent;
  let before = children.length ? children[fromI] : null;
  let last = insert2.length ? insert2[insert2.length - 1] : null;
  let breakAtEnd = last ? last.breakAfter : breakAtStart;
  if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last : null, fromOff == 0, openStart, openEnd))
    return;
  if (toI < children.length) {
    let after = children[toI];
    if (after && toOff < after.length) {
      if (fromI == toI) {
        after = after.split(toOff);
        toOff = 0;
      }
      if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
        insert2[insert2.length - 1] = after;
      } else {
        if (toOff)
          after.merge(0, toOff, null, false, 0, openEnd);
        insert2.push(after);
      }
    } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
      if (last)
        last.breakAfter = 1;
      else
        breakAtStart = 1;
    }
    toI++;
  }
  if (before) {
    before.breakAfter = breakAtStart;
    if (fromOff > 0) {
      if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
        before.breakAfter = insert2.shift().breakAfter;
      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
        before.merge(fromOff, before.length, null, false, openStart, 0);
      }
      fromI++;
    }
  }
  while (fromI < toI && insert2.length) {
    if (children[toI - 1].become(insert2[insert2.length - 1])) {
      toI--;
      insert2.pop();
      openEnd = insert2.length ? 0 : openStart;
    } else if (children[fromI].become(insert2[0])) {
      fromI++;
      insert2.shift();
      openStart = insert2.length ? 0 : openEnd;
    } else {
      break;
    }
  }
  if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
    fromI--;
  if (fromI < toI || insert2.length)
    parent.replaceChildren(fromI, toI, insert2);
}
function mergeChildrenInto(parent, from, to, insert2, openStart, openEnd) {
  let cur2 = parent.childCursor();
  let { i: toI, off: toOff } = cur2.findPos(to, 1);
  let { i: fromI, off: fromOff } = cur2.findPos(from, -1);
  let dLen = from - to;
  for (let view of insert2)
    dLen += view.length;
  parent.length += dLen;
  replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
}
var nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
var gecko2 = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
var chrome2 = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
var webkit = "webkitFontSmoothing" in doc.documentElement.style;
var safari = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
var ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
  mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
  windows: /* @__PURE__ */ /Win/.test(nav.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
  ie: ie2,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko: gecko2,
  gecko_version: gecko2 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome2,
  chrome_version: chrome2 ? +chrome2[1] : 0,
  ios,
  android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
  webkit,
  safari,
  webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
var MaxJoinLen = 256;
var TextView = class _TextView extends ContentView {
  constructor(text) {
    super();
    this.text = text;
  }
  get length() {
    return this.text.length;
  }
  createDOM(textDOM) {
    this.setDOM(textDOM || document.createTextNode(this.text));
  }
  sync(view, track) {
    if (!this.dom)
      this.createDOM();
    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom)
        track.written = true;
      this.dom.nodeValue = this.text;
    }
  }
  reuseDOM(dom) {
    if (dom.nodeType == 3)
      this.createDOM(dom);
  }
  merge(from, to, source) {
    if (source && (!(source instanceof _TextView) || this.length - (to - from) + source.length > MaxJoinLen))
      return false;
    this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
    this.markDirty();
    return true;
  }
  split(from) {
    let result = new _TextView(this.text.slice(from));
    this.text = this.text.slice(0, from);
    this.markDirty();
    return result;
  }
  localPosFromDOM(node, offset) {
    return node == this.dom ? offset : offset ? this.text.length : 0;
  }
  domAtPos(pos) {
    return new DOMPos(this.dom, pos);
  }
  domBoundsAround(_from, _to, offset) {
    return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(pos, side) {
    return textCoords(this.dom, pos, side);
  }
};
var MarkView = class _MarkView extends ContentView {
  constructor(mark, children = [], length = 0) {
    super();
    this.mark = mark;
    this.children = children;
    this.length = length;
    for (let ch of children)
      ch.setParent(this);
  }
  setAttrs(dom) {
    clearAttributes(dom);
    if (this.mark.class)
      dom.className = this.mark.class;
    if (this.mark.attrs)
      for (let name2 in this.mark.attrs)
        dom.setAttribute(name2, this.mark.attrs[name2]);
    return dom;
  }
  reuseDOM(node) {
    if (node.nodeName == this.mark.tagName.toUpperCase()) {
      this.setDOM(node);
      this.dirty |= 4 | 2;
    }
  }
  sync(view, track) {
    if (!this.dom)
      this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
    else if (this.dirty & 4)
      this.setAttrs(this.dom);
    super.sync(view, track);
  }
  merge(from, to, source, _hasStart, openStart, openEnd) {
    if (source && (!(source instanceof _MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    mergeChildrenInto(this, from, to, source ? source.children : [], openStart - 1, openEnd - 1);
    this.markDirty();
    return true;
  }
  split(from) {
    let result = [], off = 0, detachFrom = -1, i = 0;
    for (let elt of this.children) {
      let end = off + elt.length;
      if (end > from)
        result.push(off < from ? elt.split(from - off) : elt);
      if (detachFrom < 0 && off >= from)
        detachFrom = i;
      off = end;
      i++;
    }
    let length = this.length - from;
    this.length = from;
    if (detachFrom > -1) {
      this.children.length = detachFrom;
      this.markDirty();
    }
    return new _MarkView(this.mark, result, length);
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
};
function textCoords(text, pos, side) {
  let length = text.nodeValue.length;
  if (pos > length)
    pos = length;
  let from = pos, to = pos, flatten2 = 0;
  if (pos == 0 && side < 0 || pos == length && side >= 0) {
    if (!(browser.chrome || browser.gecko)) {
      if (pos) {
        from--;
        flatten2 = 1;
      } else if (to < length) {
        to++;
        flatten2 = -1;
      }
    }
  } else {
    if (side < 0)
      from--;
    else if (to < length)
      to++;
  }
  let rects = textRange(text, from, to).getClientRects();
  if (!rects.length)
    return Rect0;
  let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
  if (browser.safari && !flatten2 && rect.width == 0)
    rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
  return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
}
var WidgetView = class _WidgetView extends ContentView {
  constructor(widget, length, side) {
    super();
    this.widget = widget;
    this.length = length;
    this.side = side;
    this.prevWidget = null;
  }
  static create(widget, length, side) {
    return new (widget.customView || _WidgetView)(widget, length, side);
  }
  split(from) {
    let result = _WidgetView.create(this.widget, this.length - from, this.side);
    this.length -= from;
    return result;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget)
        this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      this.dom.contentEditable = "false";
    }
  }
  getSide() {
    return this.side;
  }
  merge(from, to, source, hasStart, openStart, openEnd) {
    if (source && (!(source instanceof _WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    this.length = from + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  become(other) {
    if (other.length == this.length && other instanceof _WidgetView && other.side == this.side) {
      if (this.widget.constructor == other.widget.constructor) {
        if (!this.widget.eq(other.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other.widget;
        return true;
      }
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Text.empty;
    let top2 = this;
    while (top2.parent)
      top2 = top2.parent;
    let { view } = top2, text = view && view.state.doc, start = this.posAtStart;
    return text ? text.slice(start, start + this.length) : Text.empty;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos, side) {
    let rects = this.dom.getClientRects(), rect = null;
    if (!rects.length)
      return Rect0;
    for (let i = pos > 0 ? rects.length - 1 : 0; ; i += pos > 0 ? -1 : 1) {
      rect = rects[i];
      if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
        break;
    }
    return this.length ? rect : flattenRect(rect, this.side > 0);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
};
var CompositionView = class extends WidgetView {
  domAtPos(pos) {
    let { topView, text } = this.widget;
    if (!topView)
      return new DOMPos(text, Math.min(pos, text.nodeValue.length));
    return scanCompositionTree(pos, 0, topView, text, (v, p) => v.domAtPos(p), (p) => new DOMPos(text, Math.min(p, text.nodeValue.length)));
  }
  sync() {
    this.setDOM(this.widget.toDOM());
  }
  localPosFromDOM(node, offset) {
    let { topView, text } = this.widget;
    if (!topView)
      return Math.min(offset, this.length);
    return posFromDOMInCompositionTree(node, offset, topView, text);
  }
  ignoreMutation() {
    return false;
  }
  get overrideDOMText() {
    return null;
  }
  coordsAt(pos, side) {
    let { topView, text } = this.widget;
    if (!topView)
      return textCoords(text, pos, side);
    return scanCompositionTree(pos, side, topView, text, (v, pos2, side2) => v.coordsAt(pos2, side2), (pos2, side2) => textCoords(text, pos2, side2));
  }
  destroy() {
    var _a2;
    super.destroy();
    (_a2 = this.widget.topView) === null || _a2 === void 0 ? void 0 : _a2.destroy();
  }
  get isEditable() {
    return true;
  }
  canReuseDOM() {
    return true;
  }
};
function scanCompositionTree(pos, side, view, text, enterView, fromText) {
  if (view instanceof MarkView) {
    for (let child = view.dom.firstChild; child; child = child.nextSibling) {
      let desc = ContentView.get(child);
      if (!desc)
        return fromText(pos, side);
      let hasComp = contains(child, text);
      let len = desc.length + (hasComp ? text.nodeValue.length : 0);
      if (pos < len || pos == len && desc.getSide() <= 0)
        return hasComp ? scanCompositionTree(pos, side, desc, text, enterView, fromText) : enterView(desc, pos, side);
      pos -= len;
    }
    return enterView(view, view.length, -1);
  } else if (view.dom == text) {
    return fromText(pos, side);
  } else {
    return enterView(view, pos, side);
  }
}
function posFromDOMInCompositionTree(node, offset, view, text) {
  if (view instanceof MarkView) {
    for (let child of view.children) {
      let pos = 0, hasComp = contains(child.dom, text);
      if (contains(child.dom, node))
        return pos + (hasComp ? posFromDOMInCompositionTree(node, offset, child, text) : child.localPosFromDOM(node, offset));
      pos += hasComp ? text.nodeValue.length : child.length;
    }
  } else if (view.dom == text) {
    return Math.min(offset, text.nodeValue.length);
  }
  return view.localPosFromDOM(node, offset);
}
var WidgetBufferView = class _WidgetBufferView extends ContentView {
  constructor(side) {
    super();
    this.side = side;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(other) {
    return other instanceof _WidgetBufferView && other.side == this.side;
  }
  split() {
    return new _WidgetBufferView(this.side);
  }
  sync() {
    if (!this.dom) {
      let dom = document.createElement("img");
      dom.className = "cm-widgetBuffer";
      dom.setAttribute("aria-hidden", "true");
      this.setDOM(dom);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(pos) {
    return DOMPos.before(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos) {
    let imgRect = this.dom.getBoundingClientRect();
    let siblingRect = inlineSiblingRect(this, this.side > 0 ? -1 : 1);
    return siblingRect && siblingRect.top < imgRect.bottom && siblingRect.bottom > imgRect.top ? { left: imgRect.left, right: imgRect.right, top: siblingRect.top, bottom: siblingRect.bottom } : imgRect;
  }
  get overrideDOMText() {
    return Text.empty;
  }
};
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineSiblingRect(view, side) {
  let parent = view.parent, index = parent ? parent.children.indexOf(view) : -1;
  while (parent && index >= 0) {
    if (side < 0 ? index > 0 : index < parent.children.length) {
      let next = parent.children[index + side];
      if (next instanceof TextView) {
        let nextRect = next.coordsAt(side < 0 ? next.length : 0, side);
        if (nextRect)
          return nextRect;
      }
      index += side;
    } else if (parent instanceof MarkView && parent.parent) {
      index = parent.parent.children.indexOf(parent) + (side < 0 ? 0 : 1);
      parent = parent.parent;
    } else {
      let last = parent.dom.lastChild;
      if (last && last.nodeName == "BR")
        return last.getClientRects()[0];
      break;
    }
  }
  return void 0;
}
function inlineDOMAtPos(parent, pos) {
  let dom = parent.dom, { children } = parent, i = 0;
  for (let off = 0; i < children.length; i++) {
    let child = children[i], end = off + child.length;
    if (end == off && child.getSide() <= 0)
      continue;
    if (pos > off && pos < end && child.dom.parentNode == dom)
      return child.domAtPos(pos - off);
    if (pos <= off)
      break;
    off = end;
  }
  for (let j = i; j > 0; j--) {
    let prev = children[j - 1];
    if (prev.dom.parentNode == dom)
      return prev.domAtPos(prev.length);
  }
  for (let j = i; j < children.length; j++) {
    let next = children[j];
    if (next.dom.parentNode == dom)
      return next.domAtPos(0);
  }
  return new DOMPos(dom, 0);
}
function joinInlineInto(parent, view, open) {
  let last, { children } = parent;
  if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
    joinInlineInto(last, view.children[0], open - 1);
  } else {
    children.push(view);
    view.setParent(parent);
  }
  parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
  let before = null, beforePos = -1, after = null, afterPos = -1;
  function scan(view2, pos2) {
    for (let i = 0, off = 0; i < view2.children.length && off <= pos2; i++) {
      let child = view2.children[i], end = off + child.length;
      if (end >= pos2) {
        if (child.children.length) {
          scan(child, pos2 - off);
        } else if (!after && (end > pos2 || off == end && child.getSide() > 0)) {
          after = child;
          afterPos = pos2 - off;
        } else if (off < pos2 || off == end && child.getSide() < 0) {
          before = child;
          beforePos = pos2 - off;
        }
      }
      off = end;
    }
  }
  scan(view, pos);
  let target = (side < 0 ? before : after) || before || after;
  if (target)
    return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
  return fallbackRect(view);
}
function fallbackRect(view) {
  let last = view.dom.lastChild;
  if (!last)
    return view.dom.getBoundingClientRect();
  let rects = clientRectsFor(last);
  return rects[rects.length - 1] || null;
}
function combineAttrs(source, target) {
  for (let name2 in source) {
    if (name2 == "class" && target.class)
      target.class += " " + source.class;
    else if (name2 == "style" && target.style)
      target.style += ";" + source.style;
    else
      target[name2] = source[name2];
  }
  return target;
}
function attrsEq(a, b) {
  if (a == b)
    return true;
  if (!a || !b)
    return false;
  let keysA = Object.keys(a), keysB = Object.keys(b);
  if (keysA.length != keysB.length)
    return false;
  for (let key of keysA) {
    if (keysB.indexOf(key) == -1 || a[key] !== b[key])
      return false;
  }
  return true;
}
function updateAttrs(dom, prev, attrs) {
  let changed = null;
  if (prev) {
    for (let name2 in prev)
      if (!(attrs && name2 in attrs))
        dom.removeAttribute(changed = name2);
  }
  if (attrs) {
    for (let name2 in attrs)
      if (!(prev && prev[name2] == attrs[name2]))
        dom.setAttribute(changed = name2, attrs[name2]);
  }
  return !!changed;
}
var WidgetType = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(widget) {
    return false;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(dom, view) {
    return false;
  }
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(event) {
    return true;
  }
  /**
  @internal
  */
  get customView() {
    return null;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(dom) {
  }
};
var BlockType = /* @__PURE__ */ function(BlockType2) {
  BlockType2[BlockType2["Text"] = 0] = "Text";
  BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
  BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
  BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
  return BlockType2;
}(BlockType || (BlockType = {}));
var Decoration = class extends RangeValue {
  constructor(startSide, endSide, widget, spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget;
    this.spec = spec;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return false;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(spec) {
    return new MarkDecoration(spec);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(spec) {
    let side = spec.side || 0, block = !!spec.block;
    side += block ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
    return new PointDecoration(spec, side, side, block, spec.widget || null, false);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(spec) {
    let block = !!spec.block, startSide, endSide;
    if (spec.isBlockGap) {
      startSide = -5e8;
      endSide = 4e8;
    } else {
      let { start, end } = getInclusive(spec, block);
      startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
      endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
    }
    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(spec) {
    return new LineDecoration(spec);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(of, sort = false) {
    return RangeSet.of(of, sort);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
};
Decoration.none = RangeSet.empty;
var MarkDecoration = class _MarkDecoration extends Decoration {
  constructor(spec) {
    let { start, end } = getInclusive(spec);
    super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
    this.tagName = spec.tagName || "span";
    this.class = spec.class || "";
    this.attrs = spec.attributes || null;
  }
  eq(other) {
    return this == other || other instanceof _MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);
  }
  range(from, to = from) {
    if (from >= to)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(from, to);
  }
};
MarkDecoration.prototype.point = false;
var LineDecoration = class _LineDecoration extends Decoration {
  constructor(spec) {
    super(-2e8, -2e8, null, spec);
  }
  eq(other) {
    return other instanceof _LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
  }
  range(from, to = from) {
    if (to != from)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from, to);
  }
};
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
var PointDecoration = class _PointDecoration extends Decoration {
  constructor(spec, startSide, endSide, block, widget, isReplace) {
    super(startSide, endSide, widget, spec);
    this.block = block;
    this.isReplace = isReplace;
    this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
  }
  eq(other) {
    return other instanceof _PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }
  range(from, to = from) {
    if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to != from)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from, to);
  }
};
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
  let { inclusiveStart: start, inclusiveEnd: end } = spec;
  if (start == null)
    start = spec.inclusive;
  if (end == null)
    end = spec.inclusive;
  return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
}
function widgetsEq(a, b) {
  return a == b || !!(a && b && a.compare(b));
}
function addRange(from, to, ranges, margin = 0) {
  let last = ranges.length - 1;
  if (last >= 0 && ranges[last] + margin >= from)
    ranges[last] = Math.max(ranges[last], to);
  else
    ranges.push(from, to);
}
var LineView = class _LineView extends ContentView {
  constructor() {
    super(...arguments);
    this.children = [];
    this.length = 0;
    this.prevAttrs = void 0;
    this.attrs = null;
    this.breakAfter = 0;
  }
  // Consumes source
  merge(from, to, source, hasStart, openStart, openEnd) {
    if (source) {
      if (!(source instanceof _LineView))
        return false;
      if (!this.dom)
        source.transferDOM(this);
    }
    if (hasStart)
      this.setDeco(source ? source.attrs : null);
    mergeChildrenInto(this, from, to, source ? source.children : [], openStart, openEnd);
    return true;
  }
  split(at) {
    let end = new _LineView();
    end.breakAfter = this.breakAfter;
    if (this.length == 0)
      return end;
    let { i, off } = this.childPos(at);
    if (off) {
      end.append(this.children[i].split(off), 0);
      this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
      i++;
    }
    for (let j = i; j < this.children.length; j++)
      end.append(this.children[j], 0);
    while (i > 0 && this.children[i - 1].length == 0)
      this.children[--i].destroy();
    this.children.length = i;
    this.markDirty();
    this.length = at;
    return end;
  }
  transferDOM(other) {
    if (!this.dom)
      return;
    this.markDirty();
    other.setDOM(this.dom);
    other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
    this.prevAttrs = void 0;
    this.dom = null;
  }
  setDeco(attrs) {
    if (!attrsEq(this.attrs, attrs)) {
      if (this.dom) {
        this.prevAttrs = this.attrs;
        this.markDirty();
      }
      this.attrs = attrs;
    }
  }
  append(child, openStart) {
    joinInlineInto(this, child, openStart);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(deco) {
    let attrs = deco.spec.attributes, cls = deco.spec.class;
    if (attrs)
      this.attrs = combineAttrs(attrs, this.attrs || {});
    if (cls)
      this.attrs = combineAttrs({ class: cls }, this.attrs || {});
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  reuseDOM(node) {
    if (node.nodeName == "DIV") {
      this.setDOM(node);
      this.dirty |= 4 | 2;
    }
  }
  sync(view, track) {
    var _a2;
    if (!this.dom) {
      this.setDOM(document.createElement("div"));
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    } else if (this.dirty & 4) {
      clearAttributes(this.dom);
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    }
    if (this.prevAttrs !== void 0) {
      updateAttrs(this.dom, this.prevAttrs, this.attrs);
      this.dom.classList.add("cm-line");
      this.prevAttrs = void 0;
    }
    super.sync(view, track);
    let last = this.dom.lastChild;
    while (last && ContentView.get(last) instanceof MarkView)
      last = last.lastChild;
    if (!last || !this.length || last.nodeName != "BR" && ((_a2 = ContentView.get(last)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
      let hack = document.createElement("BR");
      hack.cmIgnore = true;
      this.dom.appendChild(hack);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let totalWidth = 0;
    for (let child of this.children) {
      if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
        return null;
      let rects = clientRectsFor(child.dom);
      if (rects.length != 1)
        return null;
      totalWidth += rects[0].width;
    }
    return !totalWidth ? null : {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: totalWidth / this.length
    };
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
  become(_other) {
    return false;
  }
  get type() {
    return BlockType.Text;
  }
  static find(docView, pos) {
    for (let i = 0, off = 0; i < docView.children.length; i++) {
      let block = docView.children[i], end = off + block.length;
      if (end >= pos) {
        if (block instanceof _LineView)
          return block;
        if (end > pos)
          break;
      }
      off = end + block.breakAfter;
    }
    return null;
  }
};
var BlockWidgetView = class _BlockWidgetView extends ContentView {
  constructor(widget, length, type) {
    super();
    this.widget = widget;
    this.length = length;
    this.type = type;
    this.breakAfter = 0;
    this.prevWidget = null;
  }
  merge(from, to, source, _takeDeco, openStart, openEnd) {
    if (source && (!(source instanceof _BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    this.length = from + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  split(at) {
    let len = this.length - at;
    this.length = at;
    let end = new _BlockWidgetView(this.widget, len, this.type);
    end.breakAfter = this.breakAfter;
    return end;
  }
  get children() {
    return noChildren;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget)
        this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      this.dom.contentEditable = "false";
    }
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(other) {
    if (other instanceof _BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
      if (!other.widget.eq(this.widget))
        this.markDirty(true);
      if (this.dom && !this.prevWidget)
        this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      this.breakAfter = other.breakAfter;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
};
var ContentBuilder = class _ContentBuilder {
  constructor(doc2, pos, end, disallowBlockEffectsFor) {
    this.doc = doc2;
    this.pos = pos;
    this.end = end;
    this.disallowBlockEffectsFor = disallowBlockEffectsFor;
    this.content = [];
    this.curLine = null;
    this.breakAtStart = 0;
    this.pendingBuffer = 0;
    this.bufferMarks = [];
    this.atCursorPos = true;
    this.openStart = -1;
    this.openEnd = -1;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc2.iter();
    this.skip = pos;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let last = this.content[this.content.length - 1];
    return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);
  }
  getLine() {
    if (!this.curLine) {
      this.content.push(this.curLine = new LineView());
      this.atCursorPos = true;
    }
    return this.curLine;
  }
  flushBuffer(active = this.bufferMarks) {
    if (this.pendingBuffer) {
      this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
      this.pendingBuffer = 0;
    }
  }
  addBlockWidget(view) {
    this.flushBuffer();
    this.curLine = null;
    this.content.push(view);
  }
  finish(openEnd) {
    if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
      this.flushBuffer();
    else
      this.pendingBuffer = 0;
    if (!this.posCovered())
      this.getLine();
  }
  buildText(length, active, openStart) {
    while (length > 0) {
      if (this.textOff == this.text.length) {
        let { value, lineBreak, done } = this.cursor.next(this.skip);
        this.skip = 0;
        if (done)
          throw new Error("Ran out of text content when drawing inline views");
        if (lineBreak) {
          if (!this.posCovered())
            this.getLine();
          if (this.content.length)
            this.content[this.content.length - 1].breakAfter = 1;
          else
            this.breakAtStart = 1;
          this.flushBuffer();
          this.curLine = null;
          this.atCursorPos = true;
          length--;
          continue;
        } else {
          this.text = value;
          this.textOff = 0;
        }
      }
      let take = Math.min(
        this.text.length - this.textOff,
        length,
        512
        /* T.Chunk */
      );
      this.flushBuffer(active.slice(active.length - openStart));
      this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
      this.atCursorPos = true;
      this.textOff += take;
      length -= take;
      openStart = 0;
    }
  }
  span(from, to, active, openStart) {
    this.buildText(to - from, active, openStart);
    this.pos = to;
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  point(from, to, deco, active, openStart, index) {
    if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
      if (deco.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (to > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let len = to - from;
    if (deco instanceof PointDecoration) {
      if (deco.block) {
        let { type } = deco;
        if (type == BlockType.WidgetAfter && !this.posCovered())
          this.getLine();
        this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
      } else {
        let view = WidgetView.create(deco.widget || new NullWidget("span"), len, len ? 0 : deco.startSide);
        let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
        let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
        let line = this.getLine();
        if (this.pendingBuffer == 2 && !cursorBefore)
          this.pendingBuffer = 0;
        this.flushBuffer(active);
        if (cursorBefore) {
          line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
          openStart = active.length + Math.max(0, openStart - active.length);
        }
        line.append(wrapMarks(view, active), openStart);
        this.atCursorPos = cursorAfter;
        this.pendingBuffer = !cursorAfter ? 0 : from < to || openStart > active.length ? 1 : 2;
        if (this.pendingBuffer)
          this.bufferMarks = active.slice();
      }
    } else if (this.doc.lineAt(this.pos).from == this.pos) {
      this.getLine().addLineDeco(deco);
    }
    if (len) {
      if (this.textOff + len <= this.text.length) {
        this.textOff += len;
      } else {
        this.skip += len - (this.text.length - this.textOff);
        this.text = "";
        this.textOff = 0;
      }
      this.pos = to;
    }
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  static build(text, from, to, decorations2, dynamicDecorationMap) {
    let builder = new _ContentBuilder(text, from, to, dynamicDecorationMap);
    builder.openEnd = RangeSet.spans(decorations2, from, to, builder);
    if (builder.openStart < 0)
      builder.openStart = builder.openEnd;
    builder.finish(builder.openEnd);
    return builder;
  }
};
function wrapMarks(view, active) {
  for (let mark of active)
    view = new MarkView(mark, [view], view.length);
  return view;
}
var NullWidget = class extends WidgetType {
  constructor(tag) {
    super();
    this.tag = tag;
  }
  eq(other) {
    return other.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(elt) {
    return elt.nodeName.toLowerCase() == this.tag;
  }
};
var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
var exceptionSink = /* @__PURE__ */ Facet.define();
var updateListener = /* @__PURE__ */ Facet.define();
var inputHandler = /* @__PURE__ */ Facet.define();
var focusChangeEffect = /* @__PURE__ */ Facet.define();
var perLineTextDirection = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x) => x)
});
var nativeSelectionHidden = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x) => x)
});
var ScrollTarget = class _ScrollTarget {
  constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5) {
    this.range = range;
    this.y = y;
    this.x = x;
    this.yMargin = yMargin;
    this.xMargin = xMargin;
  }
  map(changes) {
    return changes.empty ? this : new _ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
  }
};
var scrollIntoView = /* @__PURE__ */ StateEffect.define({ map: (t2, ch) => t2.map(ch) });
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length)
    handler[0](exception);
  else if (window.onerror)
    window.onerror(String(exception), context, void 0, void 0, exception);
  else if (context)
    console.error(context + ":", exception);
  else
    console.error(exception);
}
var editable = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : true });
var nextPluginID = 0;
var viewPlugin = /* @__PURE__ */ Facet.define();
var ViewPlugin = class _ViewPlugin {
  constructor(id, create, domEventHandlers, buildExtensions) {
    this.id = id;
    this.create = create;
    this.domEventHandlers = domEventHandlers;
    this.extension = buildExtensions(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(create, spec) {
    const { eventHandlers, provide, decorations: deco } = spec || {};
    return new _ViewPlugin(nextPluginID++, create, eventHandlers, (plugin) => {
      let ext = [viewPlugin.of(plugin)];
      if (deco)
        ext.push(decorations.of((view) => {
          let pluginInst = view.plugin(plugin);
          return pluginInst ? deco(pluginInst) : Decoration.none;
        }));
      if (provide)
        ext.push(provide(plugin));
      return ext;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(cls, spec) {
    return _ViewPlugin.define((view) => new cls(view), spec);
  }
};
var PluginInstance = class {
  constructor(spec) {
    this.spec = spec;
    this.mustUpdate = null;
    this.value = null;
  }
  update(view) {
    if (!this.value) {
      if (this.spec) {
        try {
          this.value = this.spec.create(view);
        } catch (e) {
          logException(view.state, e, "CodeMirror plugin crashed");
          this.deactivate();
        }
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate;
      this.mustUpdate = null;
      if (this.value.update) {
        try {
          this.value.update(update);
        } catch (e) {
          logException(update.state, e, "CodeMirror plugin crashed");
          if (this.value.destroy)
            try {
              this.value.destroy();
            } catch (_) {
            }
          this.deactivate();
        }
      }
    }
    return this;
  }
  destroy(view) {
    var _a2;
    if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
      try {
        this.value.destroy();
      } catch (e) {
        logException(view.state, e, "CodeMirror plugin crashed");
      }
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
};
var editorAttributes = /* @__PURE__ */ Facet.define();
var contentAttributes = /* @__PURE__ */ Facet.define();
var decorations = /* @__PURE__ */ Facet.define();
var atomicRanges = /* @__PURE__ */ Facet.define();
var scrollMargins = /* @__PURE__ */ Facet.define();
var styleModule = /* @__PURE__ */ Facet.define();
var ChangedRange = class _ChangedRange {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  join(other) {
    return new _ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }
  addToSet(set) {
    let i = set.length, me = this;
    for (; i > 0; i--) {
      let range = set[i - 1];
      if (range.fromA > me.toA)
        continue;
      if (range.toA < me.fromA)
        break;
      me = me.join(range);
      set.splice(i - 1, 1);
    }
    set.splice(i, 0, me);
    return set;
  }
  static extendWithRanges(diff, ranges) {
    if (ranges.length == 0)
      return diff;
    let result = [];
    for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
      let next = dI == diff.length ? null : diff[dI], off = posA - posB;
      let end = next ? next.fromB : 1e9;
      while (rI < ranges.length && ranges[rI] < end) {
        let from = ranges[rI], to = ranges[rI + 1];
        let fromB = Math.max(posB, from), toB = Math.min(end, to);
        if (fromB <= toB)
          new _ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
        if (to > end)
          break;
        else
          rI += 2;
      }
      if (!next)
        return result;
      new _ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
      posA = next.toA;
      posB = next.toB;
    }
  }
};
var ViewUpdate = class _ViewUpdate {
  constructor(view, state, transactions) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    this.flags = 0;
    this.startState = view.state;
    this.changes = ChangeSet.empty(this.startState.doc.length);
    for (let tr of transactions)
      this.changes = this.changes.compose(tr.changes);
    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
  }
  /**
  @internal
  */
  static create(view, state, transactions) {
    return new _ViewUpdate(view, state, transactions);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & (8 | 2)) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((tr) => tr.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
};
var Direction = /* @__PURE__ */ function(Direction2) {
  Direction2[Direction2["LTR"] = 0] = "LTR";
  Direction2[Direction2["RTL"] = 1] = "RTL";
  return Direction2;
}(Direction || (Direction = {}));
var LTR = Direction.LTR;
var RTL = Direction.RTL;
function dec(str) {
  let result = [];
  for (let i = 0; i < str.length; i++)
    result.push(1 << +str[i]);
  return result;
}
var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
var Brackets = /* @__PURE__ */ Object.create(null);
var BracketStack = [];
for (let p of ["()", "[]", "{}"]) {
  let l = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
  Brackets[l] = r;
  Brackets[r] = -l;
}
function charType(ch) {
  return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8203 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : ch == 8204 ? 256 : 1;
}
var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
var BidiSpan = class {
  /**
  @internal
  */
  constructor(from, to, level) {
    this.from = from;
    this.to = to;
    this.level = level;
  }
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  /**
  @internal
  */
  side(end, dir) {
    return this.dir == dir == end ? this.to : this.from;
  }
  /**
  @internal
  */
  static find(order, index, level, assoc) {
    let maybe = -1;
    for (let i = 0; i < order.length; i++) {
      let span = order[i];
      if (span.from <= index && span.to >= index) {
        if (span.level == level)
          return i;
        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level))
          maybe = i;
      }
    }
    if (maybe < 0)
      throw new RangeError("Index out of range");
    return maybe;
  }
};
var types = [];
function computeOrder(line, direction) {
  let len = line.length, outerType = direction == LTR ? 1 : 2, oppositeType = direction == LTR ? 2 : 1;
  if (!line || outerType == 1 && !BidiRE.test(line))
    return trivialOrder(len);
  for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
    let type = charType(line.charCodeAt(i));
    if (type == 512)
      type = prev;
    else if (type == 8 && prevStrong == 4)
      type = 16;
    types[i] = type == 4 ? 2 : type;
    if (type & 7)
      prevStrong = type;
    prev = type;
  }
  for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
    let type = types[i];
    if (type == 128) {
      if (i < len - 1 && prev == types[i + 1] && prev & 24)
        type = types[i] = prev;
      else
        types[i] = 256;
    } else if (type == 64) {
      let end = i + 1;
      while (end < len && types[end] == 64)
        end++;
      let replace = i && prev == 8 || end < len && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
      for (let j = i; j < end; j++)
        types[j] = replace;
      i = end - 1;
    } else if (type == 8 && prevStrong == 1) {
      types[i] = 1;
    }
    prev = type;
    if (type & 7)
      prevStrong = type;
  }
  for (let i = 0, sI = 0, context = 0, ch, br, type; i < len; i++) {
    if (br = Brackets[ch = line.charCodeAt(i)]) {
      if (br < 0) {
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          if (BracketStack[sJ + 1] == -br) {
            let flags = BracketStack[sJ + 2];
            let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
            if (type2)
              types[i] = types[BracketStack[sJ]] = type2;
            sI = sJ;
            break;
          }
        }
      } else if (BracketStack.length == 189) {
        break;
      } else {
        BracketStack[sI++] = i;
        BracketStack[sI++] = ch;
        BracketStack[sI++] = context;
      }
    } else if ((type = types[i]) == 2 || type == 1) {
      let embed = type == outerType;
      context = embed ? 0 : 1;
      for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
        let cur2 = BracketStack[sJ + 2];
        if (cur2 & 2)
          break;
        if (embed) {
          BracketStack[sJ + 2] |= 2;
        } else {
          if (cur2 & 4)
            break;
          BracketStack[sJ + 2] |= 4;
        }
      }
    }
  }
  for (let i = 0; i < len; i++) {
    if (types[i] == 256) {
      let end = i + 1;
      while (end < len && types[end] == 256)
        end++;
      let beforeL = (i ? types[i - 1] : outerType) == 1;
      let afterL = (end < len ? types[end] : outerType) == 1;
      let replace = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
      for (let j = i; j < end; j++)
        types[j] = replace;
      i = end - 1;
    }
  }
  let order = [];
  if (outerType == 1) {
    for (let i = 0; i < len; ) {
      let start = i, rtl = types[i++] != 1;
      while (i < len && rtl == (types[i] != 1))
        i++;
      if (rtl) {
        for (let j = i; j > start; ) {
          let end = j, l = types[--j] != 2;
          while (j > start && l == (types[j - 1] != 2))
            j--;
          order.push(new BidiSpan(j, end, l ? 2 : 1));
        }
      } else {
        order.push(new BidiSpan(start, i, 0));
      }
    }
  } else {
    for (let i = 0; i < len; ) {
      let start = i, rtl = types[i++] == 2;
      while (i < len && rtl == (types[i] == 2))
        i++;
      order.push(new BidiSpan(start, i, rtl ? 1 : 2));
    }
  }
  return order;
}
function trivialOrder(length) {
  return [new BidiSpan(0, length, 0)];
}
var movedOver = "";
function moveVisually(line, order, dir, start, forward) {
  var _a2;
  let startIndex = start.head - line.from, spanI = -1;
  if (startIndex == 0) {
    if (!forward || !line.length)
      return null;
    if (order[0].level != dir) {
      startIndex = order[0].side(false, dir);
      spanI = 0;
    }
  } else if (startIndex == line.length) {
    if (forward)
      return null;
    let last = order[order.length - 1];
    if (last.level != dir) {
      startIndex = last.side(true, dir);
      spanI = order.length - 1;
    }
  }
  if (spanI < 0)
    spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
  let span = order[spanI];
  if (startIndex == span.side(forward, dir)) {
    span = order[spanI += forward ? 1 : -1];
    startIndex = span.side(!forward, dir);
  }
  let indexForward = forward == (span.dir == dir);
  let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  if (nextIndex != span.side(forward, dir))
    return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
  if (!nextSpan && span.level != dir)
    return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
  if (nextSpan && nextSpan.level < span.level)
    return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
  return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
}
var LineBreakPlaceholder = "\uFFFF";
var DOMReader = class {
  constructor(points, state) {
    this.points = points;
    this.text = "";
    this.lineSeparator = state.facet(EditorState.lineSeparator);
  }
  append(text) {
    this.text += text;
  }
  lineBreak() {
    this.text += LineBreakPlaceholder;
  }
  readRange(start, end) {
    if (!start)
      return this;
    let parent = start.parentNode;
    for (let cur2 = start; ; ) {
      this.findPointBefore(parent, cur2);
      this.readNode(cur2);
      let next = cur2.nextSibling;
      if (next == end)
        break;
      let view = ContentView.get(cur2), nextView = ContentView.get(next);
      if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || cur2.cmIgnore))
        this.lineBreak();
      cur2 = next;
    }
    this.findPointBefore(parent, end);
    return this;
  }
  readTextNode(node) {
    let text = node.nodeValue;
    for (let point of this.points)
      if (point.node == node)
        point.pos = this.text.length + Math.min(point.offset, text.length);
    for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let nextBreak = -1, breakSize = 1, m;
      if (this.lineSeparator) {
        nextBreak = text.indexOf(this.lineSeparator, off);
        breakSize = this.lineSeparator.length;
      } else if (m = re.exec(text)) {
        nextBreak = m.index;
        breakSize = m[0].length;
      }
      this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
      if (nextBreak < 0)
        break;
      this.lineBreak();
      if (breakSize > 1) {
        for (let point of this.points)
          if (point.node == node && point.pos > this.text.length)
            point.pos -= breakSize - 1;
      }
      off = nextBreak + breakSize;
    }
  }
  readNode(node) {
    if (node.cmIgnore)
      return;
    let view = ContentView.get(node);
    let fromView = view && view.overrideDOMText;
    if (fromView != null) {
      this.findPointInside(node, fromView.length);
      for (let i = fromView.iter(); !i.next().done; ) {
        if (i.lineBreak)
          this.lineBreak();
        else
          this.append(i.value);
      }
    } else if (node.nodeType == 3) {
      this.readTextNode(node);
    } else if (node.nodeName == "BR") {
      if (node.nextSibling)
        this.lineBreak();
    } else if (node.nodeType == 1) {
      this.readRange(node.firstChild, null);
    }
  }
  findPointBefore(node, next) {
    for (let point of this.points)
      if (point.node == node && node.childNodes[point.offset] == next)
        point.pos = this.text.length;
  }
  findPointInside(node, maxLen) {
    for (let point of this.points)
      if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
        point.pos = this.text.length + Math.min(maxLen, point.offset);
  }
};
function isBlockElement(node) {
  return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
var DOMPoint = class {
  constructor(node, offset) {
    this.node = node;
    this.offset = offset;
    this.pos = -1;
  }
};
var DocView = class extends ContentView {
  constructor(view) {
    super();
    this.view = view;
    this.compositionDeco = Decoration.none;
    this.decorations = [];
    this.dynamicDecorationMap = [];
    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0;
    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.forceSelection = false;
    this.lastUpdate = Date.now();
    this.setDOM(view.contentDOM);
    this.children = [new LineView()];
    this.children[0].setParent(this);
    this.updateDeco();
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0);
  }
  get length() {
    return this.view.state.doc.length;
  }
  // Update the document view to a given state. scrollIntoView can be
  // used as a hint to compute a new viewport that includes that
  // position, if we know the editor is going to scroll that position
  // into view.
  update(update) {
    let changedRanges = update.changedRanges;
    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
        this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
      }
    }
    if (this.view.inputState.composing < 0)
      this.compositionDeco = Decoration.none;
    else if (update.transactions.length || this.dirty)
      this.compositionDeco = computeCompositionDeco(this.view, update.changes);
    if ((browser.ie || browser.chrome) && !this.compositionDeco.size && update && update.state.doc.lines != update.startState.doc.lines)
      this.forceSelection = true;
    let prevDeco = this.decorations, deco = this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    if (this.dirty == 0 && changedRanges.length == 0) {
      return false;
    } else {
      this.updateInner(changedRanges, update.startState.doc.length);
      if (update.transactions.length)
        this.lastUpdate = Date.now();
      return true;
    }
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(changes, oldLength) {
    this.view.viewState.mustMeasureContent = true;
    this.updateChildren(changes, oldLength);
    let { observer } = this.view;
    observer.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight + "px";
      this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
      this.sync(this.view, track);
      this.dirty = 0;
      if (track && (track.written || observer.selectionRange.focusNode != track.node))
        this.forceSelection = true;
      this.dom.style.height = "";
    });
    let gaps = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
      for (let child of this.children)
        if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
          gaps.push(child.dom);
    }
    observer.updateGaps(gaps);
  }
  updateChildren(changes, oldLength) {
    let cursor = this.childCursor(oldLength);
    for (let i = changes.length - 1; ; i--) {
      let next = i >= 0 ? changes[i] : null;
      if (!next)
        break;
      let { fromA, toA, fromB, toB } = next;
      let { content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap);
      let { i: toI, off: toOff } = cursor.findPos(toA, 1);
      let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
      replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
    }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(mustRead = false, fromPointer = false) {
    if (mustRead || !this.view.observer.selectionRange.focusNode)
      this.view.observer.readSelectionRange();
    if (!(fromPointer || this.mayControlSelection()))
      return;
    let force = this.forceSelection;
    this.forceSelection = false;
    let main = this.view.state.selection.main;
    let anchor = this.domAtPos(main.anchor);
    let head = main.empty ? anchor : this.domAtPos(main.head);
    if (browser.gecko && main.empty && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head = new DOMPos(dummy, 0);
      force = true;
    }
    let domSel = this.view.observer.selectionRange;
    if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
      this.view.observer.ignore(() => {
        if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
          this.dom.blur();
          this.dom.focus({ preventScroll: true });
        }
        let rawSel = getSelection(this.view.root);
        if (!rawSel)
          ;
        else if (main.empty) {
          if (browser.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);
            if (nextTo && nextTo != (1 | 2)) {
              let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
              if (text)
                anchor = new DOMPos(text, nextTo == 1 ? 0 : text.nodeValue.length);
            }
          }
          rawSel.collapse(anchor.node, anchor.offset);
          if (main.bidiLevel != null && domSel.cursorBidiLevel != null)
            domSel.cursorBidiLevel = main.bidiLevel;
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset);
          try {
            rawSel.extend(head.node, head.offset);
          } catch (_) {
          }
        } else {
          let range = document.createRange();
          if (main.anchor > main.head)
            [anchor, head] = [head, anchor];
          range.setEnd(head.node, head.offset);
          range.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range);
        }
      });
      this.view.observer.setSelectionRange(anchor, head);
    }
    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.compositionDeco.size)
      return;
    let { view } = this, cursor = view.state.selection.main;
    let sel = getSelection(view.root);
    let { anchorNode, anchorOffset } = view.observer.selectionRange;
    if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
      return;
    let line = LineView.find(this, cursor.head);
    if (!line)
      return;
    let lineStart = line.posAtStart;
    if (cursor.head == lineStart || cursor.head == lineStart + line.length)
      return;
    let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
    if (!before || !after || before.bottom > after.top)
      return;
    let dom = this.domAtPos(cursor.head + cursor.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
    view.observer.readSelectionRange();
    let newRange = view.observer.selectionRange;
    if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
      sel.collapse(anchorNode, anchorOffset);
  }
  mayControlSelection() {
    let active = this.view.root.activeElement;
    return active == this.dom || hasSelection(this.dom, this.view.observer.selectionRange) && !(active && this.dom.contains(active));
  }
  nearest(dom) {
    for (let cur2 = dom; cur2; ) {
      let domView = ContentView.get(cur2);
      if (domView && domView.rootView == this)
        return domView;
      cur2 = cur2.parentNode;
    }
    return null;
  }
  posFromDOM(node, offset) {
    let view = this.nearest(node);
    if (!view)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return view.localPosFromDOM(node, offset) + view.posAtStart;
  }
  domAtPos(pos) {
    let { i, off } = this.childCursor().findPos(pos, -1);
    for (; i < this.children.length - 1; ) {
      let child = this.children[i];
      if (off < child.length || child instanceof LineView)
        break;
      i++;
      off = 0;
    }
    return this.children[i].domAtPos(off);
  }
  coordsAt(pos, side) {
    for (let off = this.length, i = this.children.length - 1; ; i--) {
      let child = this.children[i], start = off - child.breakAfter - child.length;
      if (pos > start || pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i || side == 2 || this.children[i - 1].breakAfter || this.children[i - 1].type == BlockType.WidgetBefore && side > -2))
        return child.coordsAt(pos - start, side);
      off = start;
    }
  }
  measureVisibleLineHeights(viewport) {
    let result = [], { from, to } = viewport;
    let contentWidth = this.view.contentDOM.clientWidth;
    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
    let widest = -1, ltr = this.view.textDirection == Direction.LTR;
    for (let pos = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (end > to)
        break;
      if (pos >= from) {
        let childRect = child.dom.getBoundingClientRect();
        result.push(childRect.height);
        if (isWider) {
          let last = child.dom.lastChild;
          let rects = last ? clientRectsFor(last) : [];
          if (rects.length) {
            let rect = rects[rects.length - 1];
            let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
            if (width > widest) {
              widest = width;
              this.minWidth = contentWidth;
              this.minWidthFrom = pos;
              this.minWidthTo = end;
            }
          }
        }
      }
      pos = end + child.breakAfter;
    }
    return result;
  }
  textDirectionAt(pos) {
    let { i } = this.childPos(pos, 1);
    return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
  }
  measureTextSize() {
    for (let child of this.children) {
      if (child instanceof LineView) {
        let measure = child.measureTextSize();
        if (measure)
          return measure;
      }
    }
    let dummy = document.createElement("div"), lineHeight, charWidth;
    dummy.className = "cm-line";
    dummy.style.width = "99999px";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.dom.appendChild(dummy);
      let rect = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect ? rect.width / 27 : 7;
      dummy.remove();
    });
    return { lineHeight, charWidth };
  }
  childCursor(pos = this.length) {
    let i = this.children.length;
    if (i)
      pos -= this.children[--i].length;
    return new ChildCursor(this.children, pos, i);
  }
  computeBlockGapDeco() {
    let deco = [], vs = this.view.viewState;
    for (let pos = 0, i = 0; ; i++) {
      let next = i == vs.viewports.length ? null : vs.viewports[i];
      let end = next ? next.from - 1 : this.length;
      if (end > pos) {
        let height = vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top;
        deco.push(Decoration.replace({
          widget: new BlockGapWidget(height),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(pos, end));
      }
      if (!next)
        break;
      pos = next.to + 1;
    }
    return Decoration.set(deco);
  }
  updateDeco() {
    let allDeco = this.view.state.facet(decorations).map((d, i) => {
      let dynamic = this.dynamicDecorationMap[i] = typeof d == "function";
      return dynamic ? d(this.view) : d;
    });
    for (let i = allDeco.length; i < allDeco.length + 3; i++)
      this.dynamicDecorationMap[i] = false;
    return this.decorations = [
      ...allDeco,
      this.compositionDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(target) {
    let { range } = target;
    let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
    if (!rect)
      return;
    if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
      rect = {
        left: Math.min(rect.left, other.left),
        top: Math.min(rect.top, other.top),
        right: Math.max(rect.right, other.right),
        bottom: Math.max(rect.bottom, other.bottom)
      };
    let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;
    for (let margins of this.view.state.facet(scrollMargins).map((f) => f(this.view)))
      if (margins) {
        let { left, right, top: top2, bottom } = margins;
        if (left != null)
          mLeft = Math.max(mLeft, left);
        if (right != null)
          mRight = Math.max(mRight, right);
        if (top2 != null)
          mTop = Math.max(mTop, top2);
        if (bottom != null)
          mBottom = Math.max(mBottom, bottom);
      }
    let targetRect = {
      left: rect.left - mLeft,
      top: rect.top - mTop,
      right: rect.right + mRight,
      bottom: rect.bottom + mBottom
    };
    scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);
  }
};
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
var BlockGapWidget = class extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }
  toDOM() {
    let elt = document.createElement("div");
    this.updateDOM(elt);
    return elt;
  }
  eq(other) {
    return other.height == this.height;
  }
  updateDOM(elt) {
    elt.style.height = this.height + "px";
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
};
function compositionSurroundingNode(view) {
  let sel = view.observer.selectionRange;
  let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
  if (!textNode)
    return null;
  let cView = view.docView.nearest(textNode);
  if (!cView)
    return null;
  if (cView instanceof LineView) {
    let topNode = textNode;
    while (topNode.parentNode != cView.dom)
      topNode = topNode.parentNode;
    let prev = topNode.previousSibling;
    while (prev && !ContentView.get(prev))
      prev = prev.previousSibling;
    let pos = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
    return { from: pos, to: pos, node: topNode, text: textNode };
  } else {
    for (; ; ) {
      let { parent } = cView;
      if (!parent)
        return null;
      if (parent instanceof LineView)
        break;
      cView = parent;
    }
    let from = cView.posAtStart;
    return { from, to: from + cView.length, node: cView.dom, text: textNode };
  }
}
function computeCompositionDeco(view, changes) {
  let surrounding = compositionSurroundingNode(view);
  if (!surrounding)
    return Decoration.none;
  let { from, to, node, text: textNode } = surrounding;
  let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));
  let { state } = view, text = node.nodeType == 3 ? node.nodeValue : new DOMReader([], state).readRange(node.firstChild, null).text;
  if (newTo - newFrom < text.length) {
    if (state.doc.sliceString(newFrom, Math.min(state.doc.length, newFrom + text.length), LineBreakPlaceholder) == text)
      newTo = newFrom + text.length;
    else if (state.doc.sliceString(Math.max(0, newTo - text.length), newTo, LineBreakPlaceholder) == text)
      newFrom = newTo - text.length;
    else
      return Decoration.none;
  } else if (state.doc.sliceString(newFrom, newTo, LineBreakPlaceholder) != text) {
    return Decoration.none;
  }
  let topView = ContentView.get(node);
  if (topView instanceof CompositionView)
    topView = topView.widget.topView;
  else if (topView)
    topView.parent = null;
  return Decoration.set(Decoration.replace({ widget: new CompositionWidget(node, textNode, topView), inclusive: true }).range(newFrom, newTo));
}
var CompositionWidget = class extends WidgetType {
  constructor(top2, text, topView) {
    super();
    this.top = top2;
    this.text = text;
    this.topView = topView;
  }
  eq(other) {
    return this.top == other.top && this.text == other.text;
  }
  toDOM() {
    return this.top;
  }
  ignoreEvent() {
    return false;
  }
  get customView() {
    return CompositionView;
  }
};
function nearbyTextNode(node, offset, side) {
  for (; ; ) {
    if (node.nodeType == 3)
      return node;
    if (node.nodeType == 1 && offset > 0 && side <= 0) {
      node = node.childNodes[offset - 1];
      offset = maxOffset(node);
    } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
      node = node.childNodes[offset];
      offset = 0;
    } else {
      return null;
    }
  }
}
function nextToUneditable(node, offset) {
  if (node.nodeType != 1)
    return 0;
  return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
}
var DecorationComparator$1 = class {
  constructor() {
    this.changes = [];
  }
  compareRange(from, to) {
    addRange(from, to, this.changes);
  }
  comparePoint(from, to) {
    addRange(from, to, this.changes);
  }
};
function findChangedDeco(a, b, diff) {
  let comp = new DecorationComparator$1();
  RangeSet.compare(a, b, diff, comp);
  return comp.changes;
}
function inUneditable(node, inside2) {
  for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
    if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
      return true;
    }
  }
  return false;
}
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line = state.doc.lineAt(pos), linePos = pos - line.from;
  if (line.length == 0)
    return EditorSelection.cursor(pos);
  if (linePos == 0)
    bias = 1;
  else if (linePos == line.length)
    bias = -1;
  let from = linePos, to = linePos;
  if (bias < 0)
    from = findClusterBreak(line.text, linePos, false);
  else
    to = findClusterBreak(line.text, linePos);
  let cat = categorize(line.text.slice(from, to));
  while (from > 0) {
    let prev = findClusterBreak(line.text, from, false);
    if (categorize(line.text.slice(prev, from)) != cat)
      break;
    from = prev;
  }
  while (to < line.length) {
    let next = findClusterBreak(line.text, to);
    if (categorize(line.text.slice(to, next)) != cat)
      break;
    to = next;
  }
  return EditorSelection.range(from + line.from, to + line.from);
}
function getdx(x, rect) {
  return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}
function getdy(y, rect) {
  return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a, b) {
  return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}
function upTop(rect, top2) {
  return top2 < rect.top ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
}
function upBot(rect, bottom) {
  return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
}
function domPosAtCoords(parent, x, y) {
  let closest, closestRect, closestX, closestY, closestOverlap = false;
  let above, below, aboveRect, belowRect;
  for (let child = parent.firstChild; child; child = child.nextSibling) {
    let rects = clientRectsFor(child);
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (closestRect && yOverlap(closestRect, rect))
        rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
      let dx = getdx(x, rect), dy = getdy(y, rect);
      if (dx == 0 && dy == 0)
        return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
      if (!closest || closestY > dy || closestY == dy && closestX > dx) {
        closest = child;
        closestRect = rect;
        closestX = dx;
        closestY = dy;
        let side = dy ? y < rect.top ? -1 : 1 : dx ? x < rect.left ? -1 : 1 : 0;
        closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);
      }
      if (dx == 0) {
        if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
          above = child;
          aboveRect = rect;
        } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
          below = child;
          belowRect = rect;
        }
      } else if (aboveRect && yOverlap(aboveRect, rect)) {
        aboveRect = upBot(aboveRect, rect.bottom);
      } else if (belowRect && yOverlap(belowRect, rect)) {
        belowRect = upTop(belowRect, rect.top);
      }
    }
  }
  if (aboveRect && aboveRect.bottom >= y) {
    closest = above;
    closestRect = aboveRect;
  } else if (belowRect && belowRect.top <= y) {
    closest = below;
    closestRect = belowRect;
  }
  if (!closest)
    return { node: parent, offset: 0 };
  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
  if (closest.nodeType == 3)
    return domPosInText(closest, clipX, y);
  if (closestOverlap && closest.contentEditable != "false")
    return domPosAtCoords(closest, clipX, y);
  let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
  return { node: parent, offset };
}
function domPosInText(node, x, y) {
  let len = node.nodeValue.length;
  let closestOffset = -1, closestDY = 1e9, generalSide = 0;
  for (let i = 0; i < len; i++) {
    let rects = textRange(node, i, i + 1).getClientRects();
    for (let j = 0; j < rects.length; j++) {
      let rect = rects[j];
      if (rect.top == rect.bottom)
        continue;
      if (!generalSide)
        generalSide = x - rect.left;
      let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
      if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
        let right = x >= (rect.left + rect.right) / 2, after = right;
        if (browser.chrome || browser.gecko) {
          let rectBefore = textRange(node, i).getBoundingClientRect();
          if (rectBefore.left == rect.right)
            after = !right;
        }
        if (dy <= 0)
          return { node, offset: i + (after ? 1 : 0) };
        closestOffset = i + (after ? 1 : 0);
        closestDY = dy;
      }
    }
  }
  return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
}
function posAtCoords(view, coords, precise, bias = -1) {
  var _a2;
  let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
  let block, { docHeight } = view.viewState;
  let { x, y } = coords, yOffset = y - docTop;
  if (yOffset < 0)
    return 0;
  if (yOffset > docHeight)
    return view.state.doc.length;
  for (let halfLine = view.defaultLineHeight / 2, bounced = false; ; ) {
    block = view.elementAtHeight(yOffset);
    if (block.type == BlockType.Text)
      break;
    for (; ; ) {
      yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
      if (yOffset >= 0 && yOffset <= docHeight)
        break;
      if (bounced)
        return precise ? null : 0;
      bounced = true;
      bias = -bias;
    }
  }
  y = docTop + yOffset;
  let lineStart = block.from;
  if (lineStart < view.viewport.from)
    return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
  if (lineStart > view.viewport.to)
    return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
  let doc2 = view.dom.ownerDocument;
  let root = view.root.elementFromPoint ? view.root : doc2;
  let element = root.elementFromPoint(x, y);
  if (element && !view.contentDOM.contains(element))
    element = null;
  if (!element) {
    x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
    element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element))
      element = null;
  }
  let node, offset = -1;
  if (element && ((_a2 = view.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
    if (doc2.caretPositionFromPoint) {
      let pos = doc2.caretPositionFromPoint(x, y);
      if (pos)
        ({ offsetNode: node, offset } = pos);
    } else if (doc2.caretRangeFromPoint) {
      let range = doc2.caretRangeFromPoint(x, y);
      if (range) {
        ({ startContainer: node, startOffset: offset } = range);
        if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
          node = void 0;
      }
    }
  }
  if (!node || !view.docView.dom.contains(node)) {
    let line = LineView.find(view.docView, lineStart);
    if (!line)
      return yOffset > block.top + block.height / 2 ? block.to : block.from;
    ({ node, offset } = domPosAtCoords(line.dom, x, y));
  }
  let nearest = view.docView.nearest(node);
  if (!nearest)
    return null;
  if (nearest.isWidget) {
    let rect = nearest.dom.getBoundingClientRect();
    return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
  } else {
    return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
  }
}
function posAtCoordsImprecise(view, contentRect, block, x, y) {
  let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
    let line = Math.floor((y - block.top) / view.defaultLineHeight);
    into += line * view.viewState.heightOracle.lineLength;
  }
  let content2 = view.state.sliceDoc(block.from, block.to);
  return block.from + findColumn(content2, into, view.state.tabSize);
}
function isSuspiciousSafariCaretResult(node, offset, x) {
  let len;
  if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
    return false;
  for (let next = node.nextSibling; next; next = next.nextSibling)
    if (next.nodeType != 1 || next.nodeName != "BR")
      return false;
  return textRange(node, len - 1, len).getBoundingClientRect().left > x;
}
function isSuspiciousChromeCaretResult(node, offset, x) {
  if (offset != 0)
    return false;
  for (let cur2 = node; ; ) {
    let parent = cur2.parentNode;
    if (!parent || parent.nodeType != 1 || parent.firstChild != cur2)
      return false;
    if (parent.classList.contains("cm-line"))
      break;
    cur2 = parent;
  }
  let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
  return x - rect.left > 5;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
  let line = view.state.doc.lineAt(start.head);
  let coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let direction = view.textDirectionAt(line.from);
    let pos = view.posAtCoords({
      x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null)
      return EditorSelection.cursor(pos, forward ? -1 : 1);
  }
  let lineView = LineView.find(view.docView, start.head);
  let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;
  return EditorSelection.cursor(end, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
  let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
  let direction = view.textDirectionAt(line.from);
  for (let cur2 = start, check = null; ; ) {
    let next = moveVisually(line, spans, direction, cur2, forward), char = movedOver;
    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1))
        return cur2;
      char = "\n";
      line = view.state.doc.line(line.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line);
      next = EditorSelection.cursor(forward ? line.from : line.to);
    }
    if (!check) {
      if (!by)
        return next;
      check = by(char);
    } else if (!check(char)) {
      return cur2;
    }
    cur2 = next;
  }
}
function byGroup(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start);
  return (next) => {
    let nextCat = categorize(next);
    if (cat == CharCategory.Space)
      cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start, forward, distance) {
  let startPos = start.head, dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0))
    return EditorSelection.cursor(startPos, start.assoc);
  let goal = start.goalColumn, startY;
  let rect = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos), docTop = view.documentTop;
  if (startCoords) {
    if (goal == null)
      goal = startCoords.left - rect.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line = view.viewState.lineBlockAt(startPos);
    if (goal == null)
      goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
    startY = (dir < 0 ? line.top : line.bottom) + docTop;
  }
  let resolvedGoal = rect.left + goal;
  let dist = distance !== null && distance !== void 0 ? distance : view.defaultLineHeight >> 1;
  for (let extra = 0; ; extra += 10) {
    let curY = startY + (dist + extra) * dir;
    let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
    if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos))
      return EditorSelection.cursor(pos, start.assoc, void 0, goal);
  }
}
function skipAtoms(view, oldPos, pos) {
  let atoms = view.state.facet(atomicRanges).map((f) => f(view));
  for (; ; ) {
    let moved = false;
    for (let set of atoms) {
      set.between(pos.from - 1, pos.from + 1, (from, to, value) => {
        if (pos.from > from && pos.from < to) {
          pos = oldPos.head > pos.from ? EditorSelection.cursor(from, 1) : EditorSelection.cursor(to, -1);
          moved = true;
        }
      });
    }
    if (!moved)
      return pos;
  }
}
var InputState = class {
  constructor(view) {
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.lastTouchTime = 0;
    this.lastFocusTime = 0;
    this.lastScrollTop = 0;
    this.lastScrollLeft = 0;
    this.chromeScrollHack = -1;
    this.pendingIOSKey = void 0;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastEscPress = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.registeredEvents = [];
    this.customHandlers = [];
    this.composing = -1;
    this.compositionFirstChange = null;
    this.compositionEndedAt = 0;
    this.mouseSelection = null;
    let handleEvent = (handler, event) => {
      if (this.ignoreDuringComposition(event))
        return;
      if (event.type == "keydown" && this.keydown(view, event))
        return;
      if (this.mustFlushObserver(event))
        view.observer.forceFlush();
      if (this.runCustomHandlers(event.type, view, event))
        event.preventDefault();
      else
        handler(view, event);
    };
    for (let type in handlers) {
      let handler = handlers[type];
      view.contentDOM.addEventListener(type, (event) => {
        if (eventBelongsToEditor(view, event))
          handleEvent(handler, event);
      }, handlerOptions[type]);
      this.registeredEvents.push(type);
    }
    view.scrollDOM.addEventListener("mousedown", (event) => {
      if (event.target == view.scrollDOM && event.clientY > view.contentDOM.getBoundingClientRect().bottom)
        handleEvent(handlers.mousedown, event);
    });
    if (browser.chrome && browser.chrome_version == 102) {
      view.scrollDOM.addEventListener("wheel", () => {
        if (this.chromeScrollHack < 0)
          view.contentDOM.style.pointerEvents = "none";
        else
          window.clearTimeout(this.chromeScrollHack);
        this.chromeScrollHack = setTimeout(() => {
          this.chromeScrollHack = -1;
          view.contentDOM.style.pointerEvents = "";
        }, 100);
      }, { passive: true });
    }
    this.notifiedFocused = view.hasFocus;
    if (browser.safari)
      view.contentDOM.addEventListener("input", () => null);
  }
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }
  ensureHandlers(view, plugins) {
    var _a2;
    let handlers2;
    this.customHandlers = [];
    for (let plugin of plugins)
      if (handlers2 = (_a2 = plugin.update(view).spec) === null || _a2 === void 0 ? void 0 : _a2.domEventHandlers) {
        this.customHandlers.push({ plugin: plugin.value, handlers: handlers2 });
        for (let type in handlers2)
          if (this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
            this.registeredEvents.push(type);
            view.contentDOM.addEventListener(type, (event) => {
              if (!eventBelongsToEditor(view, event))
                return;
              if (this.runCustomHandlers(type, view, event))
                event.preventDefault();
            });
          }
      }
  }
  runCustomHandlers(type, view, event) {
    for (let set of this.customHandlers) {
      let handler = set.handlers[type];
      if (handler) {
        try {
          if (handler.call(set.plugin, event, view) || event.defaultPrevented)
            return true;
        } catch (e) {
          logException(view.state, e);
        }
      }
    }
    return false;
  }
  runScrollHandlers(view, event) {
    this.lastScrollTop = view.scrollDOM.scrollTop;
    this.lastScrollLeft = view.scrollDOM.scrollLeft;
    for (let set of this.customHandlers) {
      let handler = set.handlers.scroll;
      if (handler) {
        try {
          handler.call(set.plugin, event, view);
        } catch (e) {
          logException(view.state, e);
        }
      }
    }
  }
  keydown(view, event) {
    this.lastKeyCode = event.keyCode;
    this.lastKeyTime = Date.now();
    if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return true;
    if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
      view.observer.delayAndroidKey(event.key, event.keyCode);
      return true;
    }
    let pending;
    if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
      this.pendingIOSKey = pending || event;
      setTimeout(() => this.flushIOSKey(view), 250);
      return true;
    }
    return false;
  }
  flushIOSKey(view) {
    let key = this.pendingIOSKey;
    if (!key)
      return false;
    this.pendingIOSKey = void 0;
    return dispatchKey(view.contentDOM, key.key, key.keyCode);
  }
  ignoreDuringComposition(event) {
    if (!/^key/.test(event.type))
      return false;
    if (this.composing > 0)
      return true;
    if (browser.safari && !browser.ios && Date.now() - this.compositionEndedAt < 100) {
      this.compositionEndedAt = 0;
      return true;
    }
    return false;
  }
  mustFlushObserver(event) {
    return event.type == "keydown" && event.keyCode != 229;
  }
  startMouseSelection(mouseSelection) {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
    this.mouseSelection = mouseSelection;
  }
  update(update) {
    if (this.mouseSelection)
      this.mouseSelection.update(update);
    if (update.transactions.length)
      this.lastKeyCode = this.lastSelectionTime = 0;
  }
  destroy() {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
  }
};
var PendingKeys = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
var EmacsyPendingKeys = "dthko";
var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
function dragScrollSpeed(dist) {
  return dist * 0.7 + 8;
}
var MouseSelection = class {
  constructor(view, startEvent, style, mustSelect) {
    this.view = view;
    this.style = style;
    this.mustSelect = mustSelect;
    this.scrollSpeed = { x: 0, y: 0 };
    this.scrolling = -1;
    this.lastEvent = startEvent;
    this.scrollParent = scrollableParent(view.contentDOM);
    let doc2 = view.contentDOM.ownerDocument;
    doc2.addEventListener("mousemove", this.move = this.move.bind(this));
    doc2.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragMove = dragMovesSelection(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
  }
  start(event) {
    if (this.dragging === false) {
      event.preventDefault();
      this.select(event);
    }
  }
  move(event) {
    var _a2;
    if (event.buttons == 0)
      return this.destroy();
    if (this.dragging !== false)
      return;
    this.select(this.lastEvent = event);
    let sx = 0, sy = 0;
    let rect = ((_a2 = this.scrollParent) === null || _a2 === void 0 ? void 0 : _a2.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight };
    if (event.clientX <= rect.left)
      sx = -dragScrollSpeed(rect.left - event.clientX);
    else if (event.clientX >= rect.right)
      sx = dragScrollSpeed(event.clientX - rect.right);
    if (event.clientY <= rect.top)
      sy = -dragScrollSpeed(rect.top - event.clientY);
    else if (event.clientY >= rect.bottom)
      sy = dragScrollSpeed(event.clientY - rect.bottom);
    this.setScrollSpeed(sx, sy);
  }
  up(event) {
    if (this.dragging == null)
      this.select(this.lastEvent);
    if (!this.dragging)
      event.preventDefault();
    this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let doc2 = this.view.contentDOM.ownerDocument;
    doc2.removeEventListener("mousemove", this.move);
    doc2.removeEventListener("mouseup", this.up);
    this.view.inputState.mouseSelection = null;
  }
  setScrollSpeed(sx, sy) {
    this.scrollSpeed = { x: sx, y: sy };
    if (sx || sy) {
      if (this.scrolling < 0)
        this.scrolling = setInterval(() => this.scroll(), 50);
    } else if (this.scrolling > -1) {
      clearInterval(this.scrolling);
      this.scrolling = -1;
    }
  }
  scroll() {
    if (this.scrollParent) {
      this.scrollParent.scrollLeft += this.scrollSpeed.x;
      this.scrollParent.scrollTop += this.scrollSpeed.y;
    } else {
      this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);
    }
    if (this.dragging === false)
      this.select(this.lastEvent);
  }
  select(event) {
    let selection = this.style.get(event, this.extend, this.multiple);
    if (this.mustSelect || !selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc)
      this.view.dispatch({
        selection,
        userEvent: "select.pointer"
      });
    this.mustSelect = false;
  }
  update(update) {
    if (update.docChanged && this.dragging)
      this.dragging = this.dragging.map(update.changes);
    if (this.style.update(update))
      setTimeout(() => this.select(this.lastEvent), 20);
  }
};
function addsSelectionRange(view, event) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
  let { main } = view.state.selection;
  if (main.empty)
    return false;
  let sel = getSelection(view.root);
  if (!sel || sel.rangeCount == 0)
    return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i = 0; i < rects.length; i++) {
    let rect = rects[i];
    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
      return true;
  }
  return false;
}
function eventBelongsToEditor(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
    if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
      return false;
  return true;
}
var handlers = /* @__PURE__ */ Object.create(null);
var handlerOptions = /* @__PURE__ */ Object.create(null);
var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    target.remove();
    doPaste(view, target.value);
  }, 50);
}
function doPaste(view, input) {
  let { state } = view, changes, i = 1, text = state.toText(input);
  let byLine = text.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange((range) => {
      let line = state.doc.lineAt(range.from);
      if (line.from == lastLine)
        return { range };
      lastLine = line.from;
      let insert2 = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
      return {
        changes: { from: line.from, insert: insert2 },
        range: EditorSelection.cursor(range.from + insert2.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange((range) => {
      let line = text.line(i++);
      return {
        changes: { from: range.from, to: range.to, insert: line.text },
        range: EditorSelection.cursor(range.from + line.length)
      };
    });
  } else {
    changes = state.replaceSelection(text);
  }
  view.dispatch(changes, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
handlers.keydown = (view, event) => {
  view.inputState.setSelectionOrigin("select");
  if (event.keyCode == 27)
    view.inputState.lastEscPress = Date.now();
  else if (modifierCodes.indexOf(event.keyCode) < 0)
    view.inputState.lastEscPress = 0;
};
handlers.touchstart = (view, e) => {
  view.inputState.lastTouchTime = Date.now();
  view.inputState.setSelectionOrigin("select.pointer");
};
handlers.touchmove = (view) => {
  view.inputState.setSelectionOrigin("select.pointer");
};
handlerOptions.touchstart = handlerOptions.touchmove = { passive: true };
handlers.mousedown = (view, event) => {
  view.observer.flush();
  if (view.inputState.lastTouchTime > Date.now() - 2e3)
    return;
  let style = null;
  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style = makeStyle(view, event);
    if (style)
      break;
  }
  if (!style && event.button == 0)
    style = basicMouseSelection(view, event);
  if (style) {
    let mustFocus = view.root.activeElement != view.contentDOM;
    view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
    if (mustFocus)
      view.observer.ignore(() => focusPreventScroll(view.contentDOM));
    if (view.inputState.mouseSelection)
      view.inputState.mouseSelection.start(event);
  }
};
function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    return EditorSelection.cursor(pos, bias);
  } else if (type == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
    if (to < view.state.doc.length && to == line.to)
      to++;
    return EditorSelection.range(from, to);
  }
}
var insideY = (y, rect) => y >= rect.top && y <= rect.bottom;
var inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;
function findPositionSide(view, pos, x, y) {
  let line = LineView.find(view.docView, pos);
  if (!line)
    return 1;
  let off = pos - line.posAtStart;
  if (off == 0)
    return 1;
  if (off == line.length)
    return -1;
  let before = line.coordsAt(off, -1);
  if (before && inside(x, y, before))
    return -1;
  let after = line.coordsAt(off, 1);
  if (after && inside(x, y, after))
    return 1;
  return before && insideY(y, before) ? -1 : 1;
}
function queryPos(view, event) {
  let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
}
var BadMouseDetail = browser.ie && browser.ie_version <= 11;
var lastMouseDown = null;
var lastMouseDownCount = 0;
var lastMouseDownTime = 0;
function getClickType(event) {
  if (!BadMouseDetail)
    return event.detail;
  let last = lastMouseDown, lastTime = lastMouseDownTime;
  lastMouseDown = event;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
  let start = queryPos(view, event), type = getClickType(event);
  let startSel = view.state.selection;
  return {
    update(update) {
      if (update.docChanged) {
        start.pos = update.changes.mapPos(start.pos);
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, extend2, multiple) {
      let cur2 = queryPos(view, event2);
      let range = rangeForClick(view, cur2.pos, cur2.bias, type);
      if (start.pos != cur2.pos && !extend2) {
        let startRange = rangeForClick(view, start.pos, start.bias, type);
        let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
        range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
      }
      if (extend2)
        return startSel.replaceRange(startSel.main.extend(range.from, range.to));
      else if (multiple && startSel.ranges.length > 1 && startSel.ranges.some((r) => r.eq(range)))
        return removeRange(startSel, range);
      else if (multiple)
        return startSel.addRange(range);
      else
        return EditorSelection.create([range]);
    }
  };
}
function removeRange(sel, range) {
  for (let i = 0; ; i++) {
    if (sel.ranges[i].eq(range))
      return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
  }
}
handlers.dragstart = (view, event) => {
  let { selection: { main } } = view.state;
  let { mouseSelection } = view.inputState;
  if (mouseSelection)
    mouseSelection.dragging = main;
  if (event.dataTransfer) {
    event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
    event.dataTransfer.effectAllowed = "copyMove";
  }
};
function dropText(view, event, text, direct) {
  if (!text)
    return;
  let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  event.preventDefault();
  let { mouseSelection } = view.inputState;
  let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;
  let ins = { from: dropPos, insert: text };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
    userEvent: del ? "move.drop" : "input.drop"
  });
}
handlers.drop = (view, event) => {
  if (!event.dataTransfer)
    return;
  if (view.state.readOnly)
    return event.preventDefault();
  let files = event.dataTransfer.files;
  if (files && files.length) {
    event.preventDefault();
    let text = Array(files.length), read = 0;
    let finishFile = () => {
      if (++read == files.length)
        dropText(view, event, text.filter((s) => s != null).join(view.state.lineBreak), false);
    };
    for (let i = 0; i < files.length; i++) {
      let reader = new FileReader();
      reader.onerror = finishFile;
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
          text[i] = reader.result;
        finishFile();
      };
      reader.readAsText(files[i]);
    }
  } else {
    dropText(view, event, event.dataTransfer.getData("Text"), true);
  }
};
handlers.paste = (view, event) => {
  if (view.state.readOnly)
    return event.preventDefault();
  view.observer.flush();
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    doPaste(view, data.getData("text/plain"));
    event.preventDefault();
  } else {
    capturePaste(view);
  }
};
function captureCopy(view, text) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.value = text;
  target.focus();
  target.selectionEnd = text.length;
  target.selectionStart = 0;
  setTimeout(() => {
    target.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content2 = [], ranges = [], linewise = false;
  for (let range of state.selection.ranges)
    if (!range.empty) {
      content2.push(state.sliceDoc(range.from, range.to));
      ranges.push(range);
    }
  if (!content2.length) {
    let upto = -1;
    for (let { from } of state.selection.ranges) {
      let line = state.doc.lineAt(from);
      if (line.number > upto) {
        content2.push(line.text);
        ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
      }
      upto = line.number;
    }
    linewise = true;
  }
  return { text: content2.join(state.lineBreak), ranges, linewise };
}
var lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
  let { text, ranges, linewise } = copiedRange(view.state);
  if (!text && !linewise)
    return;
  lastLinewiseCopy = linewise ? text : null;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/plain", text);
  } else {
    captureCopy(view, text);
  }
  if (event.type == "cut" && !view.state.readOnly)
    view.dispatch({
      changes: ranges,
      scrollIntoView: true,
      userEvent: "delete.cut"
    });
};
var isFocusChange = /* @__PURE__ */ Annotation.define();
function focusChangeTransaction(state, focus) {
  let effects = [];
  for (let getEffect of state.facet(focusChangeEffect)) {
    let effect = getEffect(state, focus);
    if (effect)
      effects.push(effect);
  }
  return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
}
function updateForFocusChange(view) {
  setTimeout(() => {
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      let tr = focusChangeTransaction(view.state, focus);
      if (tr)
        view.dispatch(tr);
      else
        view.update([]);
    }
  }, 10);
}
handlers.focus = (view) => {
  view.inputState.lastFocusTime = Date.now();
  if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
    view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
    view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
  }
  updateForFocusChange(view);
};
handlers.blur = (view) => {
  view.observer.clearSelectionRange();
  updateForFocusChange(view);
};
handlers.compositionstart = handlers.compositionupdate = (view) => {
  if (view.inputState.compositionFirstChange == null)
    view.inputState.compositionFirstChange = true;
  if (view.inputState.composing < 0) {
    view.inputState.composing = 0;
  }
};
handlers.compositionend = (view) => {
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  view.inputState.compositionFirstChange = null;
  if (browser.chrome && browser.android)
    view.observer.flushSoon();
  setTimeout(() => {
    if (view.inputState.composing < 0 && view.docView.compositionDeco.size)
      view.update([]);
  }, 50);
};
handlers.contextmenu = (view) => {
  view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
  var _a2;
  let pending;
  if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
    view.observer.delayAndroidKey(pending.key, pending.keyCode);
    if (pending.key == "Backspace" || pending.key == "Delete") {
      let startViewHeight = ((_a2 = window.visualViewport) === null || _a2 === void 0 ? void 0 : _a2.height) || 0;
      setTimeout(() => {
        var _a3;
        if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
          view.contentDOM.blur();
          view.focus();
        }
      }, 100);
    }
  }
};
var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
var HeightOracle = class {
  constructor(lineWrapping) {
    this.lineWrapping = lineWrapping;
    this.doc = Text.empty;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.lineLength = 30;
    this.heightChanged = false;
  }
  heightForGap(from, to) {
    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
    if (this.lineWrapping)
      lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));
    return this.lineHeight * lines;
  }
  heightForLine(length) {
    if (!this.lineWrapping)
      return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
    return lines * this.lineHeight;
  }
  setDoc(doc2) {
    this.doc = doc2;
    return this;
  }
  mustRefreshForWrapping(whiteSpace) {
    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(lineHeights) {
    let newHeight = false;
    for (let i = 0; i < lineHeights.length; i++) {
      let h = lineHeights[i];
      if (h < 0) {
        i++;
      } else if (!this.heightSamples[Math.floor(h * 10)]) {
        newHeight = true;
        this.heightSamples[Math.floor(h * 10)] = true;
      }
    }
    return newHeight;
  }
  refresh(whiteSpace, lineHeight, charWidth, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
    this.lineWrapping = lineWrapping;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.lineLength = lineLength;
    if (changed) {
      this.heightSamples = {};
      for (let i = 0; i < knownHeights.length; i++) {
        let h = knownHeights[i];
        if (h < 0)
          i++;
        else
          this.heightSamples[Math.floor(h * 10)] = true;
      }
    }
    return changed;
  }
};
var MeasuredHeights = class {
  constructor(from, heights) {
    this.from = from;
    this.heights = heights;
    this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
};
var BlockInfo = class _BlockInfo {
  /**
  @internal
  */
  constructor(from, length, top2, height, type) {
    this.from = from;
    this.length = length;
    this.top = top2;
    this.height = height;
    this.type = type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  @internal
  */
  join(other) {
    let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);
    return new _BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
  }
};
var QueryType = /* @__PURE__ */ function(QueryType3) {
  QueryType3[QueryType3["ByPos"] = 0] = "ByPos";
  QueryType3[QueryType3["ByHeight"] = 1] = "ByHeight";
  QueryType3[QueryType3["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType3;
}(QueryType || (QueryType = {}));
var Epsilon = 1e-3;
var HeightMap = class _HeightMap {
  constructor(length, height, flags = 2) {
    this.length = length;
    this.height = height;
    this.flags = flags;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | this.flags & ~2;
  }
  setHeight(oracle, height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon)
        oracle.heightChanged = true;
      this.height = height;
    }
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(_from, _to, nodes) {
    return _HeightMap.of(nodes);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(_to, result) {
    result.push(this);
  }
  decomposeRight(_from, result) {
    result.push(this);
  }
  applyChanges(decorations2, oldDoc, oracle, changes) {
    let me = this, doc2 = oracle.doc;
    for (let i = changes.length - 1; i >= 0; i--) {
      let { fromA, toA, fromB, toB } = changes[i];
      let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
      let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
      toB += end.to - toA;
      toA = end.to;
      while (i > 0 && start.from <= changes[i - 1].toA) {
        fromA = changes[i - 1].fromA;
        fromB = changes[i - 1].fromB;
        i--;
        if (fromA < start.from)
          start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
      }
      fromB += start.from - fromA;
      fromA = start.from;
      let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
      me = me.replace(fromA, toA, nodes);
    }
    return me.updateHeight(oracle, 0);
  }
  static empty() {
    return new HeightMapText(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(nodes) {
    if (nodes.length == 1)
      return nodes[0];
    let i = 0, j = nodes.length, before = 0, after = 0;
    for (; ; ) {
      if (i == j) {
        if (before > after * 2) {
          let split = nodes[i - 1];
          if (split.break)
            nodes.splice(--i, 1, split.left, null, split.right);
          else
            nodes.splice(--i, 1, split.left, split.right);
          j += 1 + split.break;
          before -= split.size;
        } else if (after > before * 2) {
          let split = nodes[j];
          if (split.break)
            nodes.splice(j, 1, split.left, null, split.right);
          else
            nodes.splice(j, 1, split.left, split.right);
          j += 2 + split.break;
          after -= split.size;
        } else {
          break;
        }
      } else if (before < after) {
        let next = nodes[i++];
        if (next)
          before += next.size;
      } else {
        let next = nodes[--j];
        if (next)
          after += next.size;
      }
    }
    let brk = 0;
    if (nodes[i - 1] == null) {
      brk = 1;
      i--;
    } else if (nodes[i] == null) {
      brk = 1;
      j++;
    }
    return new HeightMapBranch(_HeightMap.of(nodes.slice(0, i)), brk, _HeightMap.of(nodes.slice(j)));
  }
};
HeightMap.prototype.size = 1;
var HeightMapBlock = class extends HeightMap {
  constructor(length, height, type) {
    super(length, height);
    this.type = type;
  }
  blockAt(_height, _oracle, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.type);
  }
  lineAt(_value, _type, oracle, top2, offset) {
    return this.blockAt(0, oracle, top2, offset);
  }
  forEachLine(from, to, oracle, top2, offset, f) {
    if (from <= offset + this.length && to >= offset)
      f(this.blockAt(0, oracle, top2, offset));
  }
  updateHeight(oracle, offset = 0, _force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(oracle, measured.heights[measured.index++]);
    this.outdated = false;
    return this;
  }
  toString() {
    return `block(${this.length})`;
  }
};
var HeightMapText = class _HeightMapText extends HeightMapBlock {
  constructor(length, height) {
    super(length, height, BlockType.Text);
    this.collapsed = 0;
    this.widgetHeight = 0;
  }
  replace(_from, _to, nodes) {
    let node = nodes[0];
    if (nodes.length == 1 && (node instanceof _HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
      if (node instanceof HeightMapGap)
        node = new _HeightMapText(node.length, this.height);
      else
        node.height = this.height;
      if (!this.outdated)
        node.outdated = false;
      return node;
    } else {
      return HeightMap.of(nodes);
    }
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(oracle, measured.heights[measured.index++]);
    else if (force || this.outdated)
      this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
    this.outdated = false;
    return this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
};
var HeightMapGap = class _HeightMapGap extends HeightMap {
  constructor(length) {
    super(length, 0);
  }
  heightMetrics(oracle, offset) {
    let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
    let lines = lastLine - firstLine + 1;
    let perLine, perChar = 0;
    if (oracle.lineWrapping) {
      let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
      perLine = totalPerLine / lines;
      perChar = (this.height - totalPerLine) / (this.length - lines - 1);
    } else {
      perLine = this.height / lines;
    }
    return { firstLine, lastLine, perLine, perChar };
  }
  blockAt(height, oracle, top2, offset) {
    let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    if (oracle.lineWrapping) {
      let guess = offset + Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length);
      let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
      let lineTop = Math.max(top2, height - lineHeight / 2);
      return new BlockInfo(line.from, line.length, lineTop, lineHeight, BlockType.Text);
    } else {
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
      let { from, length } = oracle.doc.line(firstLine + line);
      return new BlockInfo(from, length, top2 + perLine * line, perLine, BlockType.Text);
    }
  }
  lineAt(value, type, oracle, top2, offset) {
    if (type == QueryType.ByHeight)
      return this.blockAt(value, oracle, top2, offset);
    if (type == QueryType.ByPosNoHeight) {
      let { from, to } = oracle.doc.lineAt(value);
      return new BlockInfo(from, to - from, 0, 0, BlockType.Text);
    }
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
    let linesAbove = line.number - firstLine;
    let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
    return new BlockInfo(line.from, line.length, Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)), lineHeight, BlockType.Text);
  }
  forEachLine(from, to, oracle, top2, offset, f) {
    from = Math.max(from, offset);
    to = Math.min(to, offset + this.length);
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    for (let pos = from, lineTop = top2; pos <= to; ) {
      let line = oracle.doc.lineAt(pos);
      if (pos == from) {
        let linesAbove = line.number - firstLine;
        lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
      }
      let lineHeight = perLine + perChar * line.length;
      f(new BlockInfo(line.from, line.length, lineTop, lineHeight, BlockType.Text));
      lineTop += lineHeight;
      pos = line.to + 1;
    }
  }
  replace(from, to, nodes) {
    let after = this.length - to;
    if (after > 0) {
      let last = nodes[nodes.length - 1];
      if (last instanceof _HeightMapGap)
        nodes[nodes.length - 1] = new _HeightMapGap(last.length + after);
      else
        nodes.push(null, new _HeightMapGap(after - 1));
    }
    if (from > 0) {
      let first = nodes[0];
      if (first instanceof _HeightMapGap)
        nodes[0] = new _HeightMapGap(from + first.length);
      else
        nodes.unshift(new _HeightMapGap(from - 1), null);
    }
    return HeightMap.of(nodes);
  }
  decomposeLeft(to, result) {
    result.push(new _HeightMapGap(to - 1), null);
  }
  decomposeRight(from, result) {
    result.push(null, new _HeightMapGap(this.length - from - 1));
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let end = offset + this.length;
    if (measured && measured.from <= offset + this.length && measured.more) {
      let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
      if (measured.from > offset)
        nodes.push(new _HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
      while (pos <= end && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length)
          nodes.push(null);
        let height = measured.heights[measured.index++];
        if (singleHeight == -1)
          singleHeight = height;
        else if (Math.abs(height - singleHeight) >= Epsilon)
          singleHeight = -2;
        let line = new HeightMapText(len, height);
        line.outdated = false;
        nodes.push(line);
        pos += len + 1;
      }
      if (pos <= end)
        nodes.push(null, new _HeightMapGap(end - pos).updateHeight(oracle, pos));
      let result = HeightMap.of(nodes);
      if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
        oracle.heightChanged = true;
      return result;
    } else if (force || this.outdated) {
      this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
      this.outdated = false;
    }
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
};
var HeightMapBranch = class extends HeightMap {
  constructor(left, brk, right) {
    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
    this.left = left;
    this.right = right;
    this.size = left.size + right.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(height, oracle, top2, offset) {
    let mid = top2 + this.left.height;
    return height < mid ? this.left.blockAt(height, oracle, top2, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
  }
  lineAt(value, type, oracle, top2, offset) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
    let base2 = left ? this.left.lineAt(value, type, oracle, top2, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
    if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
      return base2;
    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
    if (left)
      return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
    else
      return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset).join(base2);
  }
  forEachLine(from, to, oracle, top2, offset, f) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    if (this.break) {
      if (from < rightOffset)
        this.left.forEachLine(from, to, oracle, top2, offset, f);
      if (to >= rightOffset)
        this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);
    } else {
      let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top2, offset);
      if (from < mid.from)
        this.left.forEachLine(from, mid.from - 1, oracle, top2, offset, f);
      if (mid.to >= from && mid.from <= to)
        f(mid);
      if (to > mid.to)
        this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
    }
  }
  replace(from, to, nodes) {
    let rightStart = this.left.length + this.break;
    if (to < rightStart)
      return this.balanced(this.left.replace(from, to, nodes), this.right);
    if (from > this.left.length)
      return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
    let result = [];
    if (from > 0)
      this.decomposeLeft(from, result);
    let left = result.length;
    for (let node of nodes)
      result.push(node);
    if (from > 0)
      mergeGaps(result, left - 1);
    if (to < this.length) {
      let right = result.length;
      this.decomposeRight(to, result);
      mergeGaps(result, right);
    }
    return HeightMap.of(result);
  }
  decomposeLeft(to, result) {
    let left = this.left.length;
    if (to <= left)
      return this.left.decomposeLeft(to, result);
    result.push(this.left);
    if (this.break) {
      left++;
      if (to >= left)
        result.push(null);
    }
    if (to > left)
      this.right.decomposeLeft(to - left, result);
  }
  decomposeRight(from, result) {
    let left = this.left.length, right = left + this.break;
    if (from >= right)
      return this.right.decomposeRight(from - right, result);
    if (from < left)
      this.left.decomposeRight(from, result);
    if (this.break && from < right)
      result.push(null);
    result.push(this.right);
  }
  balanced(left, right) {
    if (left.size > 2 * right.size || right.size > 2 * left.size)
      return HeightMap.of(this.break ? [left, null, right] : [left, right]);
    this.left = left;
    this.right = right;
    this.height = left.height + right.height;
    this.outdated = left.outdated || right.outdated;
    this.size = left.size + right.size;
    this.length = left.length + this.break + right.length;
    return this;
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
    if (measured && measured.from <= offset + left.length && measured.more)
      rebalance = left = left.updateHeight(oracle, offset, force, measured);
    else
      left.updateHeight(oracle, offset, force);
    if (measured && measured.from <= rightStart + right.length && measured.more)
      rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
    else
      right.updateHeight(oracle, rightStart, force);
    if (rebalance)
      return this.balanced(left, right);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
};
function mergeGaps(nodes, around) {
  let before, after;
  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
    nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
var relevantWidgetHeight = 5;
var NodeBuilder = class _NodeBuilder {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(_from, to) {
    if (this.lineStart > -1) {
      let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
      if (last instanceof HeightMapText)
        last.length += end - this.pos;
      else if (end > this.pos || !this.isCovered)
        this.nodes.push(new HeightMapText(end - this.pos, -1));
      this.writtenTo = end;
      if (to > end) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }
    this.pos = to;
  }
  point(from, to, deco) {
    if (from < to || deco.heightRelevant) {
      let height = deco.widget ? deco.widget.estimatedHeight : 0;
      if (height < 0)
        height = this.oracle.lineHeight;
      let len = to - from;
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco.type));
      } else if (len || height >= relevantWidgetHeight) {
        this.addLineDeco(height, len);
      }
    } else if (to > from) {
      this.span(from, to);
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos)
      this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from, to } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from;
    this.lineEnd = to;
    if (this.writtenTo < from) {
      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
        this.nodes.push(this.blankContent(this.writtenTo, from - 1));
      this.nodes.push(null);
    }
    if (this.pos > from)
      this.nodes.push(new HeightMapText(this.pos - from, -1));
    this.writtenTo = this.pos;
  }
  blankContent(from, to) {
    let gap = new HeightMapGap(to - from);
    if (this.oracle.doc.lineAt(from).to == to)
      gap.flags |= 4;
    return gap;
  }
  ensureLine() {
    this.enterLine();
    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last instanceof HeightMapText)
      return last;
    let line = new HeightMapText(0, -1);
    this.nodes.push(line);
    return line;
  }
  addBlock(block) {
    this.enterLine();
    if (block.type == BlockType.WidgetAfter && !this.isCovered)
      this.ensureLine();
    this.nodes.push(block);
    this.writtenTo = this.pos = this.pos + block.length;
    if (block.type != BlockType.WidgetBefore)
      this.covering = block;
  }
  addLineDeco(height, length) {
    let line = this.ensureLine();
    line.length += length;
    line.collapsed += length;
    line.widgetHeight = Math.max(line.widgetHeight, height);
    this.writtenTo = this.pos = this.pos + length;
  }
  finish(from) {
    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
      this.nodes.push(new HeightMapText(0, -1));
    else if (this.writtenTo < this.pos || last == null)
      this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from;
    for (let node of this.nodes) {
      if (node instanceof HeightMapText)
        node.updateHeight(this.oracle, pos);
      pos += node ? node.length : 1;
    }
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(oracle, decorations2, from, to) {
    let builder = new _NodeBuilder(from, oracle);
    RangeSet.spans(decorations2, from, to, builder, 0);
    return builder.finish(from);
  }
};
function heightRelevantDecoChanges(a, b, diff) {
  let comp = new DecorationComparator();
  RangeSet.compare(a, b, diff, comp, 0);
  return comp.changes;
}
var DecorationComparator = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(from, to, a, b) {
    if (from < to || a && a.heightRelevant || b && b.heightRelevant)
      addRange(from, to, this.changes, 5);
  }
};
function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
  let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
  for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
    if (parent.nodeType == 1) {
      let elt = parent;
      let style = window.getComputedStyle(elt);
      if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
        let parentRect = elt.getBoundingClientRect();
        left = Math.max(left, parentRect.left);
        right = Math.min(right, parentRect.right);
        top2 = Math.max(top2, parentRect.top);
        bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);
      }
      parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
    } else if (parent.nodeType == 11) {
      parent = parent.host;
    } else {
      break;
    }
  }
  return {
    left: left - rect.left,
    right: Math.max(left, right) - rect.left,
    top: top2 - (rect.top + paddingTop),
    bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
  };
}
function fullPixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  return {
    left: 0,
    right: rect.right - rect.left,
    top: paddingTop,
    bottom: rect.bottom - (rect.top + paddingTop)
  };
}
var LineGap = class {
  constructor(from, to, size) {
    this.from = from;
    this.to = to;
    this.size = size;
  }
  static same(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      let gA = a[i], gB = b[i];
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
        return false;
    }
    return true;
  }
  draw(wrapping) {
    return Decoration.replace({ widget: new LineGapWidget(this.size, wrapping) }).range(this.from, this.to);
  }
};
var LineGapWidget = class extends WidgetType {
  constructor(size, vertical) {
    super();
    this.size = size;
    this.vertical = vertical;
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }
  toDOM() {
    let elt = document.createElement("div");
    if (this.vertical) {
      elt.style.height = this.size + "px";
    } else {
      elt.style.width = this.size + "px";
      elt.style.height = "2px";
      elt.style.display = "inline-block";
    }
    return elt;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
};
var ViewState = class {
  constructor(state) {
    this.state = state;
    this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentDOMWidth = 0;
    this.contentDOMHeight = 0;
    this.editorHeight = 0;
    this.editorWidth = 0;
    this.scaler = IdScaler;
    this.scrollTarget = null;
    this.printing = false;
    this.mustMeasureContent = true;
    this.defaultTextDirection = Direction.LTR;
    this.visibleRanges = [];
    this.mustEnforceCursorAssoc = false;
    let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
    this.heightOracle = new HeightOracle(guessWrapping);
    this.stateDeco = state.facet(decorations).filter((d) => typeof d != "function");
    this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    this.viewport = this.getViewport(0, null);
    this.updateViewportLines();
    this.updateForViewport();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(false)));
    this.computeVisibleRanges();
  }
  updateForViewport() {
    let viewports = [this.viewport], { main } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let pos = i ? main.head : main.anchor;
      if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
        let { from, to } = this.lineBlockAt(pos);
        viewports.push(new Viewport(from, to));
      }
    }
    this.viewports = viewports.sort((a, b) => a.from - b.from);
    this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [];
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
      this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
    });
  }
  update(update, scrollTarget = null) {
    this.state = update.state;
    let prevDeco = this.stateDeco;
    this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
    let contentChanges = update.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight)
      update.flags |= 2;
    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
    if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
      viewport = this.getViewport(0, scrollTarget);
    let updateLines = !update.changes.empty || update.flags & 2 || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
    this.viewport = viewport;
    this.updateForViewport();
    if (updateLines)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
    update.flags |= this.computeVisibleRanges();
    if (scrollTarget)
      this.scrollTarget = scrollTarget;
    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
      this.mustEnforceCursorAssoc = true;
  }
  measure(view) {
    let dom = view.contentDOM, style = window.getComputedStyle(dom);
    let oracle = this.heightOracle;
    let whiteSpace = style.whiteSpace;
    this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
    let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
    let domRect = dom.getBoundingClientRect();
    let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
    this.contentDOMHeight = domRect.height;
    this.mustMeasureContent = false;
    let result = 0, bias = 0;
    let paddingTop = parseInt(style.paddingTop) || 0, paddingBottom = parseInt(style.paddingBottom) || 0;
    if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
      this.paddingTop = paddingTop;
      this.paddingBottom = paddingBottom;
      result |= 8 | 2;
    }
    if (this.editorWidth != view.scrollDOM.clientWidth) {
      if (oracle.lineWrapping)
        measureContent = true;
      this.editorWidth = view.scrollDOM.clientWidth;
      result |= 8;
    }
    let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (inView != this.inView) {
      this.inView = inView;
      if (inView)
        measureContent = true;
    }
    if (!this.inView && !this.scrollTarget)
      return 0;
    let contentWidth = domRect.width;
    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
      this.contentDOMWidth = domRect.width;
      this.editorHeight = view.scrollDOM.clientHeight;
      result |= 8;
    }
    if (measureContent) {
      let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
      if (oracle.mustRefreshForHeights(lineHeights))
        refresh = true;
      if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
        let { lineHeight, charWidth } = view.docView.measureTextSize();
        refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
        if (refresh) {
          view.docView.minWidth = 0;
          result |= 8;
        }
      }
      if (dTop > 0 && dBottom > 0)
        bias = Math.max(dTop, dBottom);
      else if (dTop < 0 && dBottom < 0)
        bias = Math.min(dTop, dBottom);
      oracle.heightChanged = false;
      for (let vp of this.viewports) {
        let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
        this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
      }
      if (oracle.heightChanged)
        result |= 2;
    }
    let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    if (viewportChange)
      this.viewport = this.getViewport(bias, this.scrollTarget);
    this.updateForViewport();
    if (result & 2 || viewportChange)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
    result |= this.computeVisibleRanges();
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false;
      view.docView.enforceCursorAssoc();
    }
    return result;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(bias, scrollTarget) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
    let map = this.heightMap, oracle = this.heightOracle;
    let { visibleTop, visibleBottom } = this;
    let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
    if (scrollTarget) {
      let { head } = scrollTarget.range;
      if (head < viewport.from || head > viewport.to) {
        let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
        let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
        if (scrollTarget.y == "center")
          topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
        else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
          topPos = block.top;
        else
          topPos = block.bottom - viewHeight;
        viewport = new Viewport(map.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
      }
    }
    return viewport;
  }
  mapViewport(viewport, changes) {
    let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
    return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from, to }, bias = 0) {
    if (!this.inView)
      return true;
    let { top: top2 } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
    let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
    let { visibleTop, visibleBottom } = this;
    return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(
      -bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(
      bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty)
      return gaps;
    let mapped = [];
    for (let gap of gaps)
      if (!changes.touchesRange(gap.from, gap.to))
        mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
    return mapped;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(current, mayMeasure) {
    let wrapping = this.heightOracle.lineWrapping;
    let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
    if (this.defaultTextDirection != Direction.LTR && !wrapping)
      return [];
    let gaps = [];
    let addGap = (from, to, line, structure) => {
      if (to - from < halfMargin)
        return;
      let sel = this.state.selection.main, avoid = [sel.from];
      if (!sel.empty)
        avoid.push(sel.to);
      for (let pos of avoid) {
        if (pos > from && pos < to) {
          addGap(from, pos - 10, line, structure);
          addGap(pos + 10, to, line, structure);
          return;
        }
      }
      let gap = find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
      if (!gap) {
        if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to && r.to >= to)) {
          let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
          if (lineStart > from)
            to = lineStart;
        }
        gap = new LineGap(from, to, this.gapSize(line, from, to, structure));
      }
      gaps.push(gap);
    };
    for (let line of this.viewportLines) {
      if (line.length < doubleMargin)
        continue;
      let structure = lineStructure(line.from, line.to, this.stateDeco);
      if (structure.total < doubleMargin)
        continue;
      let target = this.scrollTarget ? this.scrollTarget.range.head : null;
      let viewFrom, viewTo;
      if (wrapping) {
        let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        let top2, bot;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
          top2 = targetFrac - spaceFrac;
          bot = targetFrac + spaceFrac;
        } else {
          top2 = (this.visibleTop - line.top - marginHeight) / line.height;
          bot = (this.visibleBottom - line.top + marginHeight) / line.height;
        }
        viewFrom = findPosition(structure, top2);
        viewTo = findPosition(structure, bot);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        let marginWidth = margin * this.heightOracle.charWidth;
        let left, right;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
          left = targetFrac - spaceFrac;
          right = targetFrac + spaceFrac;
        } else {
          left = (this.pixelViewport.left - marginWidth) / totalWidth;
          right = (this.pixelViewport.right + marginWidth) / totalWidth;
        }
        viewFrom = findPosition(structure, left);
        viewTo = findPosition(structure, right);
      }
      if (viewFrom > line.from)
        addGap(line.from, viewFrom, line, structure);
      if (viewTo < line.to)
        addGap(viewTo, line.to, line, structure);
    }
    return gaps;
  }
  gapSize(line, from, to, structure) {
    let fraction = findFraction(structure, to) - findFraction(structure, from);
    if (this.heightOracle.lineWrapping) {
      return line.height * fraction;
    } else {
      return structure.total * this.heightOracle.charWidth * fraction;
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this.heightOracle.lineWrapping)));
    }
  }
  computeVisibleRanges() {
    let deco = this.stateDeco;
    if (this.lineGaps.length)
      deco = deco.concat(this.lineGapDeco);
    let ranges = [];
    RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
      span(from, to) {
        ranges.push({ from, to });
      },
      point() {
      }
    }, 20);
    let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
    this.visibleRanges = ranges;
    return changed ? 4 : 0;
  }
  lineBlockAt(pos) {
    return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(height) {
    return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  elementAtHeight(height) {
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
};
var Viewport = class {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
};
function lineStructure(from, to, stateDeco) {
  let ranges = [], pos = from, total = 0;
  RangeSet.spans(stateDeco, from, to, {
    span() {
    },
    point(from2, to2) {
      if (from2 > pos) {
        ranges.push({ from: pos, to: from2 });
        total += from2 - pos;
      }
      pos = to2;
    }
  }, 20);
  if (pos < to) {
    ranges.push({ from: pos, to });
    total += to - pos;
  }
  return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
  if (ratio <= 0)
    return ranges[0].from;
  if (ratio >= 1)
    return ranges[ranges.length - 1].to;
  let dist = Math.floor(total * ratio);
  for (let i = 0; ; i++) {
    let { from, to } = ranges[i], size = to - from;
    if (dist <= size)
      return from + dist;
    dist -= size;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (let { from, to } of structure.ranges) {
    if (pos <= to) {
      counted += pos - from;
      break;
    }
    counted += to - from;
  }
  return counted / structure.total;
}
function find(array, f) {
  for (let val of array)
    if (f(val))
      return val;
  return void 0;
}
var IdScaler = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1
};
var BigScaler = class {
  constructor(oracle, heightMap, viewports) {
    let vpHeight = 0, base2 = 0, domBase = 0;
    this.viewports = viewports.map(({ from, to }) => {
      let top2 = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
      let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
      vpHeight += bottom - top2;
      return { from, to, top: top2, bottom, domTop: 0, domBottom: 0 };
    });
    this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base2) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base2 = obj.bottom;
    }
  }
  toDOM(n) {
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.top)
        return domBase + (n - base2) * this.scale;
      if (n <= vp.bottom)
        return vp.domTop + (n - vp.top);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  fromDOM(n) {
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.domTop)
        return base2 + (n - domBase) / this.scale;
      if (n <= vp.domBottom)
        return vp.top + (n - vp.domTop);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
};
function scaleBlock(block, scaler) {
  if (scaler.scale == 1)
    return block;
  let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map((b) => scaleBlock(b, scaler)) : block.type);
}
var theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
var darkTheme = /* @__PURE__ */ Facet.define({ combine: (values) => values.indexOf(true) > -1 });
var baseThemeID = /* @__PURE__ */ StyleModule.newName();
var baseLightID = /* @__PURE__ */ StyleModule.newName();
var baseDarkID = /* @__PURE__ */ StyleModule.newName();
var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
        if (m == "&")
          return main;
        if (!scopes || !scopes[m])
          throw new RangeError(`Unsupported selector: ${m}`);
        return scopes[m];
      }) : main + " " + sel;
    }
  });
}
var baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    left: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
var DOMChange = class {
  constructor(view, start, end, typeOver) {
    this.typeOver = typeOver;
    this.bounds = null;
    this.text = "";
    let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
    if (view.state.readOnly && start > -1) {
      this.newSel = null;
    } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
      let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
      let reader = new DOMReader(selPoints, view.state);
      reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
      this.text = reader.text;
      this.newSel = selectionFromPoints(selPoints, this.bounds.from);
    } else {
      let domSel = view.observer.selectionRange;
      let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      this.newSel = EditorSelection.single(anchor, head);
    }
  }
};
function applyDOMChange(view, domChange) {
  let change;
  let { newSel } = domChange, sel = view.state.selection.main;
  if (domChange.bounds) {
    let { from, to } = domChange.bounds;
    let preferredPos = sel.from, preferredSide = null;
    if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || browser.android && domChange.text.length < to - from) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
    if (diff) {
      if (browser.chrome && view.inputState.lastKeyCode == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
        diff.toB--;
      change = {
        from: from + diff.from,
        to: from + diff.toA,
        insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
      };
    }
  } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
    newSel = null;
  }
  if (!change && !newSel)
    return false;
  if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
    change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
  } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
  } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
    if (newSel && change.insert.length == 2)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
    if (newSel)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  }
  if (change) {
    let startState = view.state;
    if (browser.ios && view.inputState.flushIOSKey(view))
      return true;
    if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
      return true;
    let text = change.insert.toString();
    if (view.state.facet(inputHandler).some((h) => h(view, change.from, change.to, text)))
      return true;
    if (view.inputState.composing >= 0)
      view.inputState.composing++;
    let tr;
    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
      let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
      let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
      tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
    } else {
      let changes = startState.changes(change);
      let mainSel = newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? newSel.main : void 0;
      if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
        let replaced = view.state.sliceDoc(change.from, change.to);
        let compositionRange = compositionSurroundingNode(view) || view.state.doc.lineAt(sel.head);
        let offset = sel.to - change.to, size = sel.to - sel.from;
        tr = startState.changeByRange((range) => {
          if (range.from == sel.from && range.to == sel.to)
            return { changes, range: mainSel || range.map(changes) };
          let to = range.to - offset, from = to - replaced.length;
          if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || // Unfortunately, there's no way to make multiple
          // changes in the same node work without aborting
          // composition, so cursors in the composition range are
          // ignored.
          compositionRange && range.to >= compositionRange.from && range.from <= compositionRange.to)
            return { range };
          let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
          return {
            changes: rangeChanges,
            range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
          };
        });
      } else {
        tr = {
          changes,
          selection: mainSel && startState.selection.replaceRange(mainSel)
        };
      }
    }
    let userEvent = "input.type";
    if (view.composing) {
      userEvent += ".compose";
      if (view.inputState.compositionFirstChange) {
        userEvent += ".start";
        view.inputState.compositionFirstChange = false;
      }
    }
    view.dispatch(tr, { scrollIntoView: true, userEvent });
    return true;
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView3 = false, userEvent = "select";
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "select")
        scrollIntoView3 = true;
      userEvent = view.inputState.lastSelectionOrigin;
    }
    view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView3, userEvent });
    return true;
  } else {
    return false;
  }
}
function findDiff(a, b, preferredPos, preferredSide) {
  let minLen = Math.min(a.length, b.length);
  let from = 0;
  while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
    from++;
  if (from == minLen && a.length == b.length)
    return null;
  let toA = a.length, toB = b.length;
  while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust = Math.max(0, from - Math.min(toA, toB));
    preferredPos -= toA + adjust - from;
  }
  if (toA < from && a.length < b.length) {
    let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
    from -= move;
    toB = from + (toB - toA);
    toA = from;
  } else if (toB < from) {
    let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
    from -= move;
    toA = from + (toA - toB);
    toB = from;
  }
  return { from, toA, toB };
}
function selectionPoints(view) {
  let result = [];
  if (view.root.activeElement != view.contentDOM)
    return result;
  let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset)
      result.push(new DOMPoint(focusNode, focusOffset));
  }
  return result;
}
function selectionFromPoints(points, base2) {
  if (points.length == 0)
    return null;
  let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
}
var observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
var useCharData = browser.ie && browser.ie_version <= 11;
var DOMObserver = class {
  constructor(view) {
    this.view = view;
    this.active = false;
    this.selectionRange = new DOMSelectionState();
    this.selectionChanged = false;
    this.delayedFlush = -1;
    this.resizeTimeout = -1;
    this.queue = [];
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
    this.lastChange = 0;
    this.scrollTargets = [];
    this.intersection = null;
    this.resizeScroll = null;
    this.resizeContent = null;
    this.intersecting = false;
    this.gapIntersection = null;
    this.gaps = [];
    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver((mutations) => {
      for (let mut of mutations)
        this.queue.push(mut);
      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData)
      this.onCharData = (event) => {
        this.queue.push({
          target: event.target,
          type: "characterData",
          oldValue: event.prevValue
        });
        this.flushSoon();
      };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.onResize = this.onResize.bind(this);
    this.onPrint = this.onPrint.bind(this);
    this.onScroll = this.onScroll.bind(this);
    if (typeof ResizeObserver == "function") {
      this.resizeScroll = new ResizeObserver(() => {
        var _a2;
        if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
          this.onResize();
      });
      this.resizeScroll.observe(view.scrollDOM);
      this.resizeContent = new ResizeObserver(() => this.view.requestMeasure());
      this.resizeContent.observe(view.contentDOM);
    }
    this.addWindowListeners(this.win = view.win);
    this.start();
    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver((entries) => {
        if (this.parentCheck < 0)
          this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView)
            this.onScrollChanged(document.createEvent("Event"));
        }
      }, {});
      this.intersection.observe(this.dom);
      this.gapIntersection = new IntersectionObserver((entries) => {
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
          this.onScrollChanged(document.createEvent("Event"));
      }, {});
    }
    this.listenForScroll();
    this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runScrollHandlers(this.view, e);
    if (this.intersecting)
      this.view.measure();
  }
  onScroll(e) {
    if (this.intersecting)
      this.flush(false);
    this.onScrollChanged(e);
  }
  onResize() {
    if (this.resizeTimeout < 0)
      this.resizeTimeout = setTimeout(() => {
        this.resizeTimeout = -1;
        this.view.requestMeasure();
      }, 50);
  }
  onPrint() {
    this.view.viewState.printing = true;
    this.view.measure();
    setTimeout(() => {
      this.view.viewState.printing = false;
      this.view.requestMeasure();
    }, 500);
  }
  updateGaps(gaps) {
    if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
      this.gapIntersection.disconnect();
      for (let gap of gaps)
        this.gapIntersection.observe(gap);
      this.gaps = gaps;
    }
  }
  onSelectionChange(event) {
    let wasChanged = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view } = this, sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
      return;
    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
    if (context && context.ignoreEvent(event)) {
      if (!wasChanged)
        this.selectionChanged = false;
      return;
    }
    if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      this.flushSoon();
    else
      this.flush(false);
  }
  readSelectionRange() {
    let { view } = this;
    let range = browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);
    if (!range || this.selectionRange.eq(range))
      return false;
    let local = hasSelection(this.dom, range);
    if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
      this.view.inputState.lastFocusTime = 0;
      view.docView.updateSelection();
      return false;
    }
    this.selectionRange.setRange(range);
    if (local)
      this.selectionChanged = true;
    return true;
  }
  setSelectionRange(anchor, head) {
    this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
    this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let i = 0, changed = null;
    for (let dom = this.dom; dom; ) {
      if (dom.nodeType == 1) {
        if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
          i++;
        else if (!changed)
          changed = this.scrollTargets.slice(0, i);
        if (changed)
          changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        dom = dom.host;
      } else {
        break;
      }
    }
    if (i < this.scrollTargets.length && !changed)
      changed = this.scrollTargets.slice(0, i);
    if (changed) {
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      for (let dom of this.scrollTargets = changed)
        dom.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(f) {
    if (!this.active)
      return f();
    try {
      this.stop();
      return f();
    } finally {
      this.start();
      this.clear();
    }
  }
  start() {
    if (this.active)
      return;
    this.observer.observe(this.dom, observeOptions);
    if (useCharData)
      this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }
  stop() {
    if (!this.active)
      return;
    this.active = false;
    this.observer.disconnect();
    if (useCharData)
      this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  // Throw away any pending changes
  clear() {
    this.processRecords();
    this.queue.length = 0;
    this.selectionChanged = false;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(key, keyCode) {
    var _a2;
    if (!this.delayedAndroidKey) {
      let flush = () => {
        let key2 = this.delayedAndroidKey;
        if (key2) {
          this.clearDelayedAndroidKey();
          if (!this.flush() && key2.force)
            dispatchKey(this.dom, key2.key, key2.keyCode);
        }
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
    }
    if (!this.delayedAndroidKey || key == "Enter")
      this.delayedAndroidKey = {
        key,
        keyCode,
        // Only run the key handler when no changes are detected if
        // this isn't coming right after another change, in which case
        // it is probably part of a weird chain of updates, and should
        // be ignored if it returns the DOM to its previous state.
        force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
      };
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
  }
  flushSoon() {
    if (this.delayedFlush < 0)
      this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        this.delayedFlush = -1;
        this.flush();
      });
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      this.view.win.cancelAnimationFrame(this.delayedFlush);
      this.delayedFlush = -1;
    }
    this.flush();
  }
  processRecords() {
    let records = this.queue;
    for (let mut of this.observer.takeRecords())
      records.push(mut);
    if (records.length)
      this.queue = [];
    let from = -1, to = -1, typeOver = false;
    for (let record of records) {
      let range = this.readMutation(record);
      if (!range)
        continue;
      if (range.typeOver)
        typeOver = true;
      if (from == -1) {
        ({ from, to } = range);
      } else {
        from = Math.min(range.from, from);
        to = Math.max(range.to, to);
      }
    }
    return { from, to, typeOver };
  }
  readChange() {
    let { from, to, typeOver } = this.processRecords();
    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
    if (from < 0 && !newSel)
      return null;
    if (from > -1)
      this.lastChange = Date.now();
    this.view.inputState.lastFocusTime = 0;
    this.selectionChanged = false;
    return new DOMChange(this.view, from, to, typeOver);
  }
  // Apply pending changes, if any
  flush(readSelection = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return false;
    if (readSelection)
      this.readSelectionRange();
    let domChange = this.readChange();
    if (!domChange)
      return false;
    let startState = this.view.state;
    let handled = applyDOMChange(this.view, domChange);
    if (this.view.state == startState)
      this.view.update([]);
    return handled;
  }
  readMutation(rec) {
    let cView = this.view.docView.nearest(rec.target);
    if (!cView || cView.ignoreMutation(rec))
      return null;
    cView.markDirty(rec.type == "attributes");
    if (rec.type == "attributes")
      cView.dirty |= 4;
    if (rec.type == "childList") {
      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
        typeOver: false
      };
    } else if (rec.type == "characterData") {
      return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
    } else {
      return null;
    }
  }
  setWindow(win) {
    if (win != this.win) {
      this.removeWindowListeners(this.win);
      this.win = win;
      this.addWindowListeners(this.win);
    }
  }
  addWindowListeners(win) {
    win.addEventListener("resize", this.onResize);
    win.addEventListener("beforeprint", this.onPrint);
    win.addEventListener("scroll", this.onScroll);
    win.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(win) {
    win.removeEventListener("scroll", this.onScroll);
    win.removeEventListener("resize", this.onResize);
    win.removeEventListener("beforeprint", this.onPrint);
    win.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var _a2, _b, _c, _d;
    this.stop();
    (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
    (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
    (_d = this.resizeContent) === null || _d === void 0 ? void 0 : _d.disconnect();
    for (let dom of this.scrollTargets)
      dom.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win);
    clearTimeout(this.parentCheck);
    clearTimeout(this.resizeTimeout);
    this.win.cancelAnimationFrame(this.delayedFlush);
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
};
function findChild(cView, dom, dir) {
  while (dom) {
    let curView = ContentView.get(dom);
    if (curView && curView.parent == cView)
      return curView;
    let parent = dom.parentNode;
    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function safariSelectionRangeHack(view) {
  let found = null;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read, true);
  view.dom.ownerDocument.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read, true);
  if (!found)
    return null;
  let anchorNode = found.startContainer, anchorOffset = found.startOffset;
  let focusNode = found.endContainer, focusOffset = found.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
var EditorView = class _EditorView {
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(config2 = {}) {
    this.plugins = [];
    this.pluginMap = /* @__PURE__ */ new Map();
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.destroyed = false;
    this.updateState = 2;
    this.measureScheduled = -1;
    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.style.cssText = "position: fixed; top: -10000px";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);
    this._dispatch = config2.dispatch || ((tr) => this.update([tr]));
    this.dispatch = this.dispatch.bind(this);
    this._root = config2.root || getRoot(config2.parent) || document;
    this.viewState = new ViewState(config2.state || EditorState.create(config2));
    this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
    for (let plugin of this.plugins)
      plugin.update(this);
    this.observer = new DOMObserver(this);
    this.inputState = new InputState(this);
    this.inputState.ensureHandlers(this, this.plugins);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0;
    this.requestMeasure();
    if (config2.parent)
      config2.parent.appendChild(this.dom);
  }
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  dispatch(...input) {
    this._dispatch(input.length == 1 && input[0] instanceof Transaction ? input[0] : this.state.update(...input));
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(transactions) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false, attrsChanged = false, update;
    let state = this.state;
    for (let tr of transactions) {
      if (tr.startState != state)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr.state;
    }
    if (this.destroyed) {
      this.viewState.state = state;
      return;
    }
    let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
    if (transactions.some((tr) => tr.annotation(isFocusChange))) {
      this.inputState.notifiedFocused = focus;
      focusFlag = 1;
    } else if (focus != this.inputState.notifiedFocused) {
      this.inputState.notifiedFocused = focus;
      dispatchFocus = focusChangeTransaction(state, focus);
      if (!dispatchFocus)
        focusFlag = 1;
    }
    let pendingKey = this.observer.delayedAndroidKey, domChange = null;
    if (pendingKey) {
      this.observer.clearDelayedAndroidKey();
      domChange = this.observer.readChange();
      if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
        domChange = null;
    } else {
      this.observer.clear();
    }
    if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
      return this.setState(state);
    update = ViewUpdate.create(this, state, transactions);
    update.flags |= focusFlag;
    let scrollTarget = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let tr of transactions) {
        if (scrollTarget)
          scrollTarget = scrollTarget.map(tr.changes);
        if (tr.scrollIntoView) {
          let { main } = tr.state.selection;
          scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
        }
        for (let e of tr.effects)
          if (e.is(scrollIntoView))
            scrollTarget = e.value;
      }
      this.viewState.update(update, scrollTarget);
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
      if (!update.empty) {
        this.updatePlugins(update);
        this.inputState.update(update);
      }
      redrawn = this.docView.update(update);
      if (this.state.facet(styleModule) != this.styleModules)
        this.mountStyles();
      attrsChanged = this.updateAttrs();
      this.showAnnouncements(transactions);
      this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (update.startState.facet(theme) != update.state.facet(theme))
      this.viewState.mustMeasureContent = true;
    if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
      this.requestMeasure();
    if (!update.empty)
      for (let listener of this.state.facet(updateListener))
        listener(update);
    if (dispatchFocus || domChange)
      Promise.resolve().then(() => {
        if (dispatchFocus && this.state == dispatchFocus.startState)
          this.dispatch(dispatchFocus);
        if (domChange) {
          if (!applyDOMChange(this, domChange) && pendingKey.force)
            dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
        }
      });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(newState) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = newState;
      return;
    }
    this.updateState = 2;
    let hadFocus = this.hasFocus;
    try {
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      this.pluginMap.clear();
      for (let plugin of this.plugins)
        plugin.update(this);
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this, this.plugins);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    if (hadFocus)
      this.focus();
    this.requestMeasure();
  }
  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
    if (prevSpecs != specs) {
      let newPlugins = [];
      for (let spec of specs) {
        let found = prevSpecs.indexOf(spec);
        if (found < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin = this.plugins[found];
          plugin.mustUpdate = update;
          newPlugins.push(plugin);
        }
      }
      for (let plugin of this.plugins)
        if (plugin.mustUpdate != update)
          plugin.destroy(this);
      this.plugins = newPlugins;
      this.pluginMap.clear();
      this.inputState.ensureHandlers(this, this.plugins);
    } else {
      for (let p of this.plugins)
        p.mustUpdate = update;
    }
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
  }
  /**
  @internal
  */
  measure(flush = true) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1)
      cancelAnimationFrame(this.measureScheduled);
    this.measureScheduled = 0;
    if (flush)
      this.observer.forceFlush();
    let updated = null;
    let { scrollHeight, scrollTop, clientHeight } = this.scrollDOM;
    let refHeight = scrollTop > scrollHeight - clientHeight - 4 ? scrollHeight : scrollTop;
    try {
      for (let i = 0; ; i++) {
        this.updateState = 1;
        let oldViewport = this.viewport;
        let refBlock = this.viewState.lineBlockAtHeight(refHeight);
        let changed = this.viewState.measure(this);
        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (i > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let measuring = [];
        if (!(changed & 4))
          [this.measureRequests, measuring] = [measuring, this.measureRequests];
        let measured = measuring.map((m) => {
          try {
            return m.read(this);
          } catch (e) {
            logException(this.state, e);
            return BadMeasure;
          }
        });
        let update = ViewUpdate.create(this, this.state, []), redrawn = false, scrolled = false;
        update.flags |= changed;
        if (!updated)
          updated = update;
        else
          updated.flags |= changed;
        this.updateState = 2;
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
          this.updateAttrs();
          redrawn = this.docView.update(update);
        }
        for (let i2 = 0; i2 < measuring.length; i2++)
          if (measured[i2] != BadMeasure) {
            try {
              let m = measuring[i2];
              if (m.write)
                m.write(measured[i2], this);
            } catch (e) {
              logException(this.state, e);
            }
          }
        if (this.viewState.editorHeight) {
          if (this.viewState.scrollTarget) {
            this.docView.scrollIntoView(this.viewState.scrollTarget);
            this.viewState.scrollTarget = null;
            scrolled = true;
          } else {
            let diff = this.viewState.lineBlockAt(refBlock.from).top - refBlock.top;
            if (diff > 1 || diff < -1) {
              this.scrollDOM.scrollTop += diff;
              scrolled = true;
            }
          }
        }
        if (redrawn)
          this.docView.updateSelection(true);
        if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && !scrolled && this.measureRequests.length == 0)
          break;
      }
    } finally {
      this.updateState = 0;
      this.measureScheduled = -1;
    }
    if (updated && !updated.empty)
      for (let listener of this.state.facet(updateListener))
        listener(updated);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
  }
  updateAttrs() {
    let editorAttrs = attrsFromFacet(this, editorAttributes, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    let contentAttrs = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: !this.state.facet(editable) ? "false" : "true",
      class: "cm-content",
      style: `${browser.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    if (this.state.readOnly)
      contentAttrs["aria-readonly"] = "true";
    attrsFromFacet(this, contentAttributes, contentAttrs);
    let changed = this.observer.ignore(() => {
      let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
      let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
      return changedContent || changedEditor;
    });
    this.editorAttrs = editorAttrs;
    this.contentAttrs = contentAttrs;
    return changed;
  }
  showAnnouncements(trs) {
    let first = true;
    for (let tr of trs)
      for (let effect of tr.effects)
        if (effect.is(_EditorView.announce)) {
          if (first)
            this.announceDOM.textContent = "";
          first = false;
          let div = this.announceDOM.appendChild(document.createElement("div"));
          div.textContent = effect.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse());
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0 && this.measureScheduled > -1)
      this.measure(false);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(request) {
    if (this.measureScheduled < 0)
      this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
    if (request) {
      if (this.measureRequests.indexOf(request) > -1)
        return;
      if (request.key != null)
        for (let i = 0; i < this.measureRequests.length; i++) {
          if (this.measureRequests[i].key === request.key) {
            this.measureRequests[i] = request;
            return;
          }
        }
      this.measureRequests.push(request);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(plugin) {
    let known = this.pluginMap.get(plugin);
    if (known === void 0 || known && known.spec != plugin)
      this.pluginMap.set(plugin, known = this.plugins.find((p) => p.spec == plugin) || null);
    return known && known.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(height) {
    this.readMeasured();
    return this.viewState.elementAtHeight(height);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(height) {
    this.readMeasured();
    return this.viewState.lineBlockAtHeight(height);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(pos) {
    return this.viewState.lineBlockAt(pos);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(start, forward, by) {
    return skipAtoms(this, start, moveByChar(this, start, forward, by));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(start, forward) {
    return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(start, forward, includeWrap = true) {
    return moveToLineBoundary(this, start, forward, includeWrap);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(start, forward, distance) {
    return skipAtoms(this, start, moveVertically(this, start, forward, distance));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(pos) {
    return this.docView.domAtPos(pos);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(node, offset = 0) {
    return this.docView.posFromDOM(node, offset);
  }
  posAtCoords(coords, precise = true) {
    this.readMeasured();
    return posAtCoords(this, coords, precise);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(pos, side = 1) {
    this.readMeasured();
    let rect = this.docView.coordsAt(pos, side);
    if (!rect || rect.left == rect.right)
      return rect;
    let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
    let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
    return flattenRect(rect, span.dir == Direction.LTR == side > 0);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(pos) {
    let perLine = this.state.facet(perLineTextDirection);
    if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
      return this.textDirection;
    this.readMeasured();
    return this.docView.textDirectionAt(pos);
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(line) {
    if (line.length > MaxBidiLine)
      return trivialOrder(line.length);
    let dir = this.textDirectionAt(line.from);
    for (let entry of this.bidiCache)
      if (entry.from == line.from && entry.dir == dir)
        return entry.order;
    let order = computeOrder(line.text, dir);
    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
    return order;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var _a2;
    return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(root) {
    if (this._root != root) {
      this._root = root;
      this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
      this.mountStyles();
    }
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let plugin of this.plugins)
      plugin.destroy(this);
    this.plugins = [];
    this.inputState.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1)
      cancelAnimationFrame(this.measureScheduled);
    this.destroyed = true;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(pos, options = {}) {
    return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(handlers2) {
    return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(spec, options) {
    let prefix = StyleModule.newName();
    let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
    if (options && options.dark)
      result.push(darkTheme.of(true));
    return result;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(spec) {
    return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(dom) {
    var _a2;
    let content2 = dom.querySelector(".cm-content");
    let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
    return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
  }
};
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler;
EditorView.focusChangeEffect = focusChangeEffect;
EditorView.perLineTextDirection = perLineTextDirection;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.atomicRanges = atomicRanges;
EditorView.scrollMargins = scrollMargins;
EditorView.darkTheme = darkTheme;
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
EditorView.announce = /* @__PURE__ */ StateEffect.define();
var MaxBidiLine = 4096;
var BadMeasure = {};
var CachedOrder = class _CachedOrder {
  constructor(from, to, dir, order) {
    this.from = from;
    this.to = to;
    this.dir = dir;
    this.order = order;
  }
  static update(cache, changes) {
    if (changes.empty)
      return cache;
    let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
    for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
      let entry = cache[i];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
        result.push(new _CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
    }
    return result;
  }
};
function attrsFromFacet(view, facet, base2) {
  for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
    let source = sources[i], value = typeof source == "function" ? source(view) : source;
    if (value)
      combineAttrs(value, base2);
  }
  return base2;
}
var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
function normalizeKeyName(name2, platform) {
  const parts = name2.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta2;
  for (let i = 0; i < parts.length - 1; ++i) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta2 = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (platform == "mac")
        meta2 = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta2)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function modifiers(name2, event, shift2) {
  if (event.altKey)
    name2 = "Alt-" + name2;
  if (event.ctrlKey)
    name2 = "Ctrl-" + name2;
  if (event.metaKey)
    name2 = "Meta-" + name2;
  if (shift2 !== false && event.shiftKey)
    name2 = "Shift-" + name2;
  return name2;
}
var handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
  keydown(event, view) {
    return runHandlers(getKeymap(view.state), event, view, "editor");
  }
}));
var keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
var Keymaps = /* @__PURE__ */ new WeakMap();
function getKeymap(state) {
  let bindings = state.facet(keymap);
  let map = Keymaps.get(bindings);
  if (!map)
    Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
  return map;
}
function runScopeHandlers(view, event, scope) {
  return runHandlers(getKeymap(view.state), event, view, scope);
}
var storedPrefix = null;
var PrefixTimeout = 4e3;
function buildKeymap(bindings, platform = currentPlatform) {
  let bound = /* @__PURE__ */ Object.create(null);
  let isPrefix = /* @__PURE__ */ Object.create(null);
  let checkPrefix = (name2, is) => {
    let current = isPrefix[name2];
    if (current == null)
      isPrefix[name2] = is;
    else if (current != is)
      throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
  };
  let add2 = (scope, key, command2, preventDefault) => {
    var _a2, _b;
    let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
    let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
    for (let i = 1; i < parts.length; i++) {
      let prefix = parts.slice(0, i).join(" ");
      checkPrefix(prefix, true);
      if (!scopeObj[prefix])
        scopeObj[prefix] = {
          preventDefault: true,
          run: [(view) => {
            let ourObj = storedPrefix = { view, prefix, scope };
            setTimeout(() => {
              if (storedPrefix == ourObj)
                storedPrefix = null;
            }, PrefixTimeout);
            return true;
          }]
        };
    }
    let full = parts.join(" ");
    checkPrefix(full, false);
    let binding = scopeObj[full] || (scopeObj[full] = { preventDefault: false, run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || [] });
    if (command2)
      binding.run.push(command2);
    if (preventDefault)
      binding.preventDefault = true;
  };
  for (let b of bindings) {
    let scopes = b.scope ? b.scope.split(" ") : ["editor"];
    if (b.any)
      for (let scope of scopes) {
        let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
        if (!scopeObj._any)
          scopeObj._any = { preventDefault: false, run: [] };
        for (let key in scopeObj)
          scopeObj[key].run.push(b.any);
      }
    let name2 = b[platform] || b.key;
    if (!name2)
      continue;
    for (let scope of scopes) {
      add2(scope, name2, b.run, b.preventDefault);
      if (b.shift)
        add2(scope, "Shift-" + name2, b.shift, b.preventDefault);
    }
  }
  return bound;
}
function runHandlers(map, event, view, scope) {
  let name2 = keyName(event);
  let charCode = codePointAt(name2, 0), isChar = codePointSize(charCode) == name2.length && name2 != " ";
  let prefix = "", fallthrough = false;
  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
    prefix = storedPrefix.prefix + " ";
    if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0)
      storedPrefix = null;
  }
  let ran = /* @__PURE__ */ new Set();
  let runFor = (binding) => {
    if (binding) {
      for (let cmd2 of binding.run)
        if (!ran.has(cmd2)) {
          ran.add(cmd2);
          if (cmd2(view, event))
            return true;
        }
      if (binding.preventDefault)
        fallthrough = true;
    }
    return false;
  };
  let scopeObj = map[scope], baseName, shiftName;
  if (scopeObj) {
    if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)]))
      return true;
    if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
    !(browser.windows && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name2) {
      if (runFor(scopeObj[prefix + modifiers(baseName, event, true)]))
        return true;
      else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)]))
        return true;
    } else if (isChar && event.shiftKey) {
      if (runFor(scopeObj[prefix + modifiers(name2, event, true)]))
        return true;
    }
    if (runFor(scopeObj._any))
      return true;
  }
  return fallthrough;
}
var RectangleMarker = class _RectangleMarker {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(className, left, top2, width, height) {
    this.className = className;
    this.left = left;
    this.top = top2;
    this.width = width;
    this.height = height;
  }
  draw() {
    let elt = document.createElement("div");
    elt.className = this.className;
    this.adjust(elt);
    return elt;
  }
  update(elt, prev) {
    if (prev.className != this.className)
      return false;
    this.adjust(elt);
    return true;
  }
  adjust(elt) {
    elt.style.left = this.left + "px";
    elt.style.top = this.top + "px";
    if (this.width != null)
      elt.style.width = this.width + "px";
    elt.style.height = this.height + "px";
  }
  eq(p) {
    return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(view, className, range) {
    if (range.empty) {
      let pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (!pos)
        return [];
      let base2 = getBase(view);
      return [new _RectangleMarker(className, pos.left - base2.left, pos.top - base2.top, null, pos.bottom - pos.top)];
    } else {
      return rectanglesForRange(view, className, range);
    }
  }
};
function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
  return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };
}
function wrappedLine(view, pos, inside2) {
  let range = EditorSelection.cursor(pos);
  return {
    from: Math.max(inside2.from, view.moveToLineBoundary(range, false, true).from),
    to: Math.min(inside2.to, view.moveToLineBoundary(range, true, true).from),
    type: BlockType.Text
  };
}
function blockAt(view, pos) {
  let line = view.lineBlockAt(pos);
  if (Array.isArray(line.type))
    for (let l of line.type) {
      if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
        return l;
    }
  return line;
}
function rectanglesForRange(view, className, range) {
  if (range.to <= view.viewport.from || range.from >= view.viewport.to)
    return [];
  let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
  let ltr = view.textDirection == Direction.LTR;
  let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
  let lineStyle = window.getComputedStyle(content2.firstChild);
  let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent));
  let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);
  let startBlock = blockAt(view, from), endBlock = blockAt(view, to);
  let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
  let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
  if (view.lineWrapping) {
    if (visualStart)
      visualStart = wrappedLine(view, from, visualStart);
    if (visualEnd)
      visualEnd = wrappedLine(view, to, visualEnd);
  }
  if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
    return pieces(drawForLine(range.from, range.to, visualStart));
  } else {
    let top2 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
    let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
    let between = [];
    if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1)
      between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
    else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text)
      top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
    return pieces(top2).concat(between).concat(pieces(bottom));
  }
  function piece(left, top2, right, bottom) {
    return new RectangleMarker(
      className,
      left - base2.left,
      top2 - base2.top - 0.01,
      right - left,
      bottom - top2 + 0.01
      /* C.Epsilon */
    );
  }
  function pieces({ top: top2, bottom, horizontal }) {
    let pieces2 = [];
    for (let i = 0; i < horizontal.length; i += 2)
      pieces2.push(piece(horizontal[i], top2, horizontal[i + 1], bottom));
    return pieces2;
  }
  function drawForLine(from2, to2, line) {
    let top2 = 1e9, bottom = -1e9, horizontal = [];
    function addSpan(from3, fromOpen, to3, toOpen, dir) {
      let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
      let toCoords = view.coordsAtPos(to3, to3 == line.from ? 2 : -2);
      top2 = Math.min(fromCoords.top, toCoords.top, top2);
      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
      if (dir == Direction.LTR)
        horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
      else
        horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
    }
    let start = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to2 !== null && to2 !== void 0 ? to2 : line.to;
    for (let r of view.visibleRanges)
      if (r.to > start && r.from < end) {
        for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {
          let docLine = view.state.doc.lineAt(pos);
          for (let span of view.bidiSpans(docLine)) {
            let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
            if (spanFrom >= endPos)
              break;
            if (spanTo > pos)
              addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span.dir);
          }
          pos = docLine.to + 1;
          if (pos >= endPos)
            break;
        }
      }
    if (horizontal.length == 0)
      addSpan(start, from2 == null, end, to2 == null, view.textDirection);
    return { top: top2, bottom, horizontal };
  }
  function drawForWidget(block, top2) {
    let y = contentRect.top + (top2 ? block.top : block.bottom);
    return { top: y, bottom: y, horizontal: [] };
  }
}
function sameMarker(a, b) {
  return a.constructor == b.constructor && a.eq(b);
}
var LayerView = class {
  constructor(view, layer2) {
    this.view = view;
    this.layer = layer2;
    this.drawn = [];
    this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
    this.dom = view.scrollDOM.appendChild(document.createElement("div"));
    this.dom.classList.add("cm-layer");
    if (layer2.above)
      this.dom.classList.add("cm-layer-above");
    if (layer2.class)
      this.dom.classList.add(layer2.class);
    this.dom.setAttribute("aria-hidden", "true");
    this.setOrder(view.state);
    view.requestMeasure(this.measureReq);
    if (layer2.mount)
      layer2.mount(this.dom, view);
  }
  update(update) {
    if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
      this.setOrder(update.state);
    if (this.layer.update(update, this.dom) || update.geometryChanged)
      update.view.requestMeasure(this.measureReq);
  }
  setOrder(state) {
    let pos = 0, order = state.facet(layerOrder);
    while (pos < order.length && order[pos] != this.layer)
      pos++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  draw(markers) {
    if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
      let old = this.dom.firstChild, oldI = 0;
      for (let marker of markers) {
        if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
          old = old.nextSibling;
          oldI++;
        } else {
          this.dom.insertBefore(marker.draw(), old);
        }
      }
      while (old) {
        let next = old.nextSibling;
        old.remove();
        old = next;
      }
      this.drawn = markers;
    }
  }
  destroy() {
    if (this.layer.destroy)
      this.layer.destroy(this.dom, this.view);
    this.dom.remove();
  }
};
var layerOrder = /* @__PURE__ */ Facet.define();
function layer(config2) {
  return [
    ViewPlugin.define((v) => new LayerView(v, config2)),
    layerOrder.of(config2)
  ];
}
var CanHidePrimary = !browser.ios;
var selectionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      cursorBlinkRate: 1200,
      drawRangeCursor: true
    }, {
      cursorBlinkRate: (a, b) => Math.min(a, b),
      drawRangeCursor: (a, b) => a || b
    });
  }
});
function drawSelection(config2 = {}) {
  return [
    selectionConfig.of(config2),
    cursorLayer,
    selectionLayer,
    hideNativeSelection,
    nativeSelectionHidden.of(true)
  ];
}
function configChanged(update) {
  return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
}
var cursorLayer = /* @__PURE__ */ layer({
  above: true,
  markers(view) {
    let { state } = view, conf = state.facet(selectionConfig);
    let cursors = [];
    for (let r of state.selection.ranges) {
      let prim = r == state.selection.main;
      if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
        let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
        let cursor = r.empty ? r : EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
        for (let piece of RectangleMarker.forRange(view, className, cursor))
          cursors.push(piece);
      }
    }
    return cursors;
  },
  update(update, dom) {
    if (update.transactions.some((tr) => tr.selection))
      dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
    let confChange = configChanged(update);
    if (confChange)
      setBlinkRate(update.state, dom);
    return update.docChanged || update.selectionSet || confChange;
  },
  mount(dom, view) {
    setBlinkRate(view.state, dom);
  },
  class: "cm-cursorLayer"
});
function setBlinkRate(state, dom) {
  dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
}
var selectionLayer = /* @__PURE__ */ layer({
  above: false,
  markers(view) {
    return view.state.selection.ranges.map((r) => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r)).reduce((a, b) => a.concat(b));
  },
  update(update, dom) {
    return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
  },
  class: "cm-selectionLayer"
});
var themeSpec = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
if (CanHidePrimary)
  themeSpec[".cm-line"].caretColor = "transparent !important";
var hideNativeSelection = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.theme(themeSpec));
var setDropCursorPos = /* @__PURE__ */ StateEffect.define({
  map(pos, mapping) {
    return pos == null ? null : mapping.mapPos(pos);
  }
});
var dropCursorPos = /* @__PURE__ */ StateField.define({
  create() {
    return null;
  },
  update(pos, tr) {
    if (pos != null)
      pos = tr.changes.mapPos(pos);
    return tr.effects.reduce((pos2, e) => e.is(setDropCursorPos) ? e.value : pos2, pos);
  }
});
var drawDropCursor = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.cursor = null;
    this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(update) {
    var _a2;
    let cursorPos = update.state.field(dropCursorPos);
    if (cursorPos == null) {
      if (this.cursor != null) {
        (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
        this.cursor = null;
      }
    } else {
      if (!this.cursor) {
        this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
        this.cursor.className = "cm-dropCursor";
      }
      if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
        this.view.requestMeasure(this.measureReq);
    }
  }
  readPos() {
    let pos = this.view.state.field(dropCursorPos);
    let rect = pos != null && this.view.coordsAtPos(pos);
    if (!rect)
      return null;
    let outer = this.view.scrollDOM.getBoundingClientRect();
    return {
      left: rect.left - outer.left + this.view.scrollDOM.scrollLeft,
      top: rect.top - outer.top + this.view.scrollDOM.scrollTop,
      height: rect.bottom - rect.top
    };
  }
  drawCursor(pos) {
    if (this.cursor) {
      if (pos) {
        this.cursor.style.left = pos.left + "px";
        this.cursor.style.top = pos.top + "px";
        this.cursor.style.height = pos.height + "px";
      } else {
        this.cursor.style.left = "-100000px";
      }
    }
  }
  destroy() {
    if (this.cursor)
      this.cursor.remove();
  }
  setDropPos(pos) {
    if (this.view.state.field(dropCursorPos) != pos)
      this.view.dispatch({ effects: setDropCursorPos.of(pos) });
  }
}, {
  eventHandlers: {
    dragover(event) {
      this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
    },
    dragleave(event) {
      if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
        this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function dropCursor() {
  return [dropCursorPos, drawDropCursor];
}
function iterMatches(doc2, re, from, to, f) {
  re.lastIndex = 0;
  for (let cursor = doc2.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
    if (!cursor.lineBreak)
      while (m = re.exec(cursor.value))
        f(pos + m.index, m);
  }
}
function matchRanges(view, maxLength) {
  let visible = view.visibleRanges;
  if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
    return visible;
  let result = [];
  for (let { from, to } of visible) {
    from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
    to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
    if (result.length && result[result.length - 1].to >= from)
      result[result.length - 1].to = to;
    else
      result.push({ from, to });
  }
  return result;
}
var MatchDecorator = class {
  /**
  Create a decorator.
  */
  constructor(config2) {
    const { regexp, decoration, decorate, boundary, maxLength = 1e3 } = config2;
    if (!regexp.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    this.regexp = regexp;
    if (decorate) {
      this.addMatch = (match, view, from, add2) => decorate(add2, from, from + match[0].length, match, view);
    } else if (typeof decoration == "function") {
      this.addMatch = (match, view, from, add2) => {
        let deco = decoration(match, view, from);
        if (deco)
          add2(from, from + match[0].length, deco);
      };
    } else if (decoration) {
      this.addMatch = (match, _view, from, add2) => add2(from, from + match[0].length, decoration);
    } else {
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    }
    this.boundary = boundary;
    this.maxLength = maxLength;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(view) {
    let build = new RangeSetBuilder(), add2 = build.add.bind(build);
    for (let { from, to } of matchRanges(view, this.maxLength))
      iterMatches(view.state.doc, this.regexp, from, to, (from2, m) => this.addMatch(m, view, from2, add2));
    return build.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(update, deco) {
    let changeFrom = 1e9, changeTo = -1;
    if (update.docChanged)
      update.changes.iterChanges((_f, _t, from, to) => {
        if (to > update.view.viewport.from && from < update.view.viewport.to) {
          changeFrom = Math.min(from, changeFrom);
          changeTo = Math.max(to, changeTo);
        }
      });
    if (update.viewportChanged || changeTo - changeFrom > 1e3)
      return this.createDeco(update.view);
    if (changeTo > -1)
      return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
    return deco;
  }
  updateRange(view, deco, updateFrom, updateTo) {
    for (let r of view.visibleRanges) {
      let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
      if (to > from) {
        let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
        let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
        if (this.boundary) {
          for (; from > fromLine.from; from--)
            if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
              start = from;
              break;
            }
          for (; to < toLine.to; to++)
            if (this.boundary.test(toLine.text[to - toLine.from])) {
              end = to;
              break;
            }
        }
        let ranges = [], m;
        let add2 = (from2, to2, deco2) => ranges.push(deco2.range(from2, to2));
        if (fromLine == toLine) {
          this.regexp.lastIndex = start - fromLine.from;
          while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
            this.addMatch(m, view, m.index + fromLine.from, add2);
        } else {
          iterMatches(view.state.doc, this.regexp, start, end, (from2, m2) => this.addMatch(m2, view, from2, add2));
        }
        deco = deco.update({ filterFrom: start, filterTo: end, filter: (from2, to2) => from2 < start || to2 > end, add: ranges });
      }
    }
    return deco;
  }
};
var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
var Specials = /* @__PURE__ */ new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
var Names = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
var _supportsTabSize = null;
function supportsTabSize() {
  var _a2;
  if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
    let styles = document.body.style;
    _supportsTabSize = ((_a2 = styles.tabSize) !== null && _a2 !== void 0 ? _a2 : styles.MozTabSize) != null;
  }
  return _supportsTabSize || false;
}
var specialCharConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    let config2 = combineConfig(configs, {
      render: null,
      specialChars: Specials,
      addSpecialChars: null
    });
    if (config2.replaceTabs = !supportsTabSize())
      config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
    if (config2.addSpecialChars)
      config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
    return config2;
  }
});
function highlightSpecialChars(config2 = {}) {
  return [specialCharConfig.of(config2), specialCharPlugin()];
}
var _plugin = null;
function specialCharPlugin() {
  return _plugin || (_plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = Decoration.none;
      this.decorationCache = /* @__PURE__ */ Object.create(null);
      this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
      this.decorations = this.decorator.createDeco(view);
    }
    makeDecorator(conf) {
      return new MatchDecorator({
        regexp: conf.specialChars,
        decoration: (m, view, pos) => {
          let { doc: doc2 } = view.state;
          let code = codePointAt(m[0], 0);
          if (code == 9) {
            let line = doc2.lineAt(pos);
            let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
            return Decoration.replace({ widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth) });
          }
          return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
        },
        boundary: conf.replaceTabs ? void 0 : /[^]/
      });
    }
    update(update) {
      let conf = update.state.facet(specialCharConfig);
      if (update.startState.facet(specialCharConfig) != conf) {
        this.decorator = this.makeDecorator(conf);
        this.decorations = this.decorator.createDeco(update.view);
      } else {
        this.decorations = this.decorator.updateDeco(update, this.decorations);
      }
    }
  }, {
    decorations: (v) => v.decorations
  }));
}
var DefaultPlaceholder = "\u2022";
function placeholder$1(code) {
  if (code >= 32)
    return DefaultPlaceholder;
  if (code == 10)
    return "\u2424";
  return String.fromCharCode(9216 + code);
}
var SpecialCharWidget = class extends WidgetType {
  constructor(options, code) {
    super();
    this.options = options;
    this.code = code;
  }
  eq(other) {
    return other.code == this.code;
  }
  toDOM(view) {
    let ph = placeholder$1(this.code);
    let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
    let custom = this.options.render && this.options.render(this.code, desc, ph);
    if (custom)
      return custom;
    let span = document.createElement("span");
    span.textContent = ph;
    span.title = desc;
    span.setAttribute("aria-label", desc);
    span.className = "cm-specialChar";
    return span;
  }
  ignoreEvent() {
    return false;
  }
};
var TabWidget = class extends WidgetType {
  constructor(width) {
    super();
    this.width = width;
  }
  eq(other) {
    return other.width == this.width;
  }
  toDOM() {
    let span = document.createElement("span");
    span.textContent = "	";
    span.className = "cm-tab";
    span.style.width = this.width + "px";
    return span;
  }
  ignoreEvent() {
    return false;
  }
};
function highlightActiveLine() {
  return activeLineHighlighter;
}
var lineDeco = /* @__PURE__ */ Decoration.line({ class: "cm-activeLine" });
var activeLineHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.docChanged || update.selectionSet)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let lastLineStart = -1, deco = [];
    for (let r of view.state.selection.ranges) {
      let line = view.lineBlockAt(r.head);
      if (line.from > lastLineStart) {
        deco.push(lineDeco.range(line.from));
        lastLineStart = line.from;
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
var MaxOff = 2e3;
function rectangleFor(state, a, b) {
  let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
  let ranges = [];
  if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
    let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
    for (let i = startLine; i <= endLine; i++) {
      let line = state.doc.line(i);
      if (line.length <= endOff)
        ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
    }
  } else {
    let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
    for (let i = startLine; i <= endLine; i++) {
      let line = state.doc.line(i);
      let start = findColumn(line.text, startCol, state.tabSize, true);
      if (start < 0) {
        ranges.push(EditorSelection.cursor(line.to));
      } else {
        let end = findColumn(line.text, endCol, state.tabSize);
        ranges.push(EditorSelection.range(line.from + start, line.from + end));
      }
    }
  }
  return ranges;
}
function absoluteColumn(view, x) {
  let ref = view.coordsAtPos(view.viewport.from);
  return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
  let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  let line = view.state.doc.lineAt(offset), off = offset - line.from;
  let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
  return { line: line.number, col, off };
}
function rectangleSelectionStyle(view, event) {
  let start = getPos(view, event), startSel = view.state.selection;
  if (!start)
    return null;
  return {
    update(update) {
      if (update.docChanged) {
        let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
        let newLine = update.state.doc.lineAt(newStart);
        start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, _extend, multiple) {
      let cur2 = getPos(view, event2);
      if (!cur2)
        return startSel;
      let ranges = rectangleFor(view.state, start, cur2);
      if (!ranges.length)
        return startSel;
      if (multiple)
        return EditorSelection.create(ranges.concat(startSel.ranges));
      else
        return EditorSelection.create(ranges);
    }
  };
}
function rectangularSelection(options) {
  let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e) => e.altKey && e.button == 0);
  return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
}
var keys = {
  Alt: [18, (e) => e.altKey],
  Control: [17, (e) => e.ctrlKey],
  Shift: [16, (e) => e.shiftKey],
  Meta: [91, (e) => e.metaKey]
};
var showCrosshair = { style: "cursor: crosshair" };
function crosshairCursor(options = {}) {
  let [code, getter] = keys[options.key || "Alt"];
  let plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.isDown = false;
    }
    set(isDown) {
      if (this.isDown != isDown) {
        this.isDown = isDown;
        this.view.update([]);
      }
    }
  }, {
    eventHandlers: {
      keydown(e) {
        this.set(e.keyCode == code || getter(e));
      },
      keyup(e) {
        if (e.keyCode == code || !getter(e))
          this.set(false);
      },
      mousemove(e) {
        this.set(getter(e));
      }
    }
  });
  return [
    plugin,
    EditorView.contentAttributes.of((view) => {
      var _a2;
      return ((_a2 = view.plugin(plugin)) === null || _a2 === void 0 ? void 0 : _a2.isDown) ? showCrosshair : null;
    })
  ];
}
var Outside = "-10000px";
var TooltipViewManager = class {
  constructor(view, facet, createTooltipView) {
    this.facet = facet;
    this.createTooltipView = createTooltipView;
    this.input = view.state.facet(facet);
    this.tooltips = this.input.filter((t2) => t2);
    this.tooltipViews = this.tooltips.map(createTooltipView);
  }
  update(update) {
    var _a2;
    let input = update.state.facet(this.facet);
    let tooltips = input.filter((x) => x);
    if (input === this.input) {
      for (let t2 of this.tooltipViews)
        if (t2.update)
          t2.update(update);
      return false;
    }
    let tooltipViews = [];
    for (let i = 0; i < tooltips.length; i++) {
      let tip = tooltips[i], known = -1;
      if (!tip)
        continue;
      for (let i2 = 0; i2 < this.tooltips.length; i2++) {
        let other = this.tooltips[i2];
        if (other && other.create == tip.create)
          known = i2;
      }
      if (known < 0) {
        tooltipViews[i] = this.createTooltipView(tip);
      } else {
        let tooltipView = tooltipViews[i] = this.tooltipViews[known];
        if (tooltipView.update)
          tooltipView.update(update);
      }
    }
    for (let t2 of this.tooltipViews)
      if (tooltipViews.indexOf(t2) < 0) {
        t2.dom.remove();
        (_a2 = t2.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t2);
      }
    this.input = input;
    this.tooltips = tooltips;
    this.tooltipViews = tooltipViews;
    return true;
  }
};
function windowSpace(view) {
  let { win } = view;
  return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth };
}
var tooltipConfig = /* @__PURE__ */ Facet.define({
  combine: (values) => {
    var _a2, _b, _c;
    return {
      position: browser.ios ? "absolute" : ((_a2 = values.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
      parent: ((_b = values.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
      tooltipSpace: ((_c = values.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
    };
  }
});
var knownHeight = /* @__PURE__ */ new WeakMap();
var tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.inView = true;
    this.lastTransaction = 0;
    this.measureTimeout = -1;
    let config2 = view.state.facet(tooltipConfig);
    this.position = config2.position;
    this.parent = config2.parent;
    this.classes = view.themeClasses;
    this.createContainer();
    this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
    this.manager = new TooltipViewManager(view, showTooltip, (t2) => this.createTooltip(t2));
    this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
      if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
        this.measureSoon();
    }, { threshold: [1] }) : null;
    this.observeIntersection();
    view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
    this.maybeMeasure();
  }
  createContainer() {
    if (this.parent) {
      this.container = document.createElement("div");
      this.container.style.position = "relative";
      this.container.className = this.view.themeClasses;
      this.parent.appendChild(this.container);
    } else {
      this.container = this.view.dom;
    }
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let tooltip of this.manager.tooltipViews)
        this.intersectionObserver.observe(tooltip.dom);
    }
  }
  measureSoon() {
    if (this.measureTimeout < 0)
      this.measureTimeout = setTimeout(() => {
        this.measureTimeout = -1;
        this.maybeMeasure();
      }, 50);
  }
  update(update) {
    if (update.transactions.length)
      this.lastTransaction = Date.now();
    let updated = this.manager.update(update);
    if (updated)
      this.observeIntersection();
    let shouldMeasure = updated || update.geometryChanged;
    let newConfig = update.state.facet(tooltipConfig);
    if (newConfig.position != this.position) {
      this.position = newConfig.position;
      for (let t2 of this.manager.tooltipViews)
        t2.dom.style.position = this.position;
      shouldMeasure = true;
    }
    if (newConfig.parent != this.parent) {
      if (this.parent)
        this.container.remove();
      this.parent = newConfig.parent;
      this.createContainer();
      for (let t2 of this.manager.tooltipViews)
        this.container.appendChild(t2.dom);
      shouldMeasure = true;
    } else if (this.parent && this.view.themeClasses != this.classes) {
      this.classes = this.container.className = this.view.themeClasses;
    }
    if (shouldMeasure)
      this.maybeMeasure();
  }
  createTooltip(tooltip) {
    let tooltipView = tooltip.create(this.view);
    tooltipView.dom.classList.add("cm-tooltip");
    if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let arrow = document.createElement("div");
      arrow.className = "cm-tooltip-arrow";
      tooltipView.dom.appendChild(arrow);
    }
    tooltipView.dom.style.position = this.position;
    tooltipView.dom.style.top = Outside;
    this.container.appendChild(tooltipView.dom);
    if (tooltipView.mount)
      tooltipView.mount(this.view);
    return tooltipView;
  }
  destroy() {
    var _a2, _b;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let tooltipView of this.manager.tooltipViews) {
      tooltipView.dom.remove();
      (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
    }
    (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let editor = this.view.dom.getBoundingClientRect();
    return {
      editor,
      parent: this.parent ? this.container.getBoundingClientRect() : editor,
      pos: this.manager.tooltips.map((t2, i) => {
        let tv = this.manager.tooltipViews[i];
        return tv.getCoords ? tv.getCoords(t2.pos) : this.view.coordsAtPos(t2.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
      space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view)
    };
  }
  writeMeasure(measured) {
    var _a2;
    let { editor, space } = measured;
    let others = [];
    for (let i = 0; i < this.manager.tooltips.length; i++) {
      let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;
      let pos = measured.pos[i], size = measured.size[i];
      if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - 0.1 || pos.left > Math.min(editor.right, space.right) + 0.1) {
        dom.style.top = Outside;
        continue;
      }
      let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
      let arrowHeight = arrow ? 7 : 0;
      let width = size.right - size.left, height = (_a2 = knownHeight.get(tView)) !== null && _a2 !== void 0 ? _a2 : size.bottom - size.top;
      let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
      let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow ? 14 : 0) - offset.x);
      let above = !!tooltip.above;
      if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space.top : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top)
        above = !above;
      let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
      if (spaceVert < height && tView.resize !== false) {
        if (spaceVert < this.view.defaultLineHeight) {
          dom.style.top = Outside;
          continue;
        }
        knownHeight.set(tView, height);
        dom.style.height = (height = spaceVert) + "px";
      } else if (dom.style.height) {
        dom.style.height = "";
      }
      let top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
      let right = left + width;
      if (tView.overlap !== true) {
        for (let r of others)
          if (r.left < right && r.right > left && r.top < top2 + height && r.bottom > top2)
            top2 = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
      }
      if (this.position == "absolute") {
        dom.style.top = top2 - measured.parent.top + "px";
        dom.style.left = left - measured.parent.left + "px";
      } else {
        dom.style.top = top2 + "px";
        dom.style.left = left + "px";
      }
      if (arrow)
        arrow.style.left = `${pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7)}px`;
      if (tView.overlap !== true)
        others.push({ left, top: top2, right, bottom: top2 + height });
      dom.classList.toggle("cm-tooltip-above", above);
      dom.classList.toggle("cm-tooltip-below", !above);
      if (tView.positioned)
        tView.positioned(measured.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length) {
      if (this.view.inView)
        this.view.requestMeasure(this.measureReq);
      if (this.inView != this.view.inView) {
        this.inView = this.view.inView;
        if (!this.inView)
          for (let tv of this.manager.tooltipViews)
            tv.dom.style.top = Outside;
      }
    }
  }
}, {
  eventHandlers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
});
var noOffset = { x: 0, y: 0 };
var showTooltip = /* @__PURE__ */ Facet.define({
  enables: [tooltipPlugin, baseTheme]
});
var showHoverTooltip = /* @__PURE__ */ Facet.define();
var HoverTooltipHost = class _HoverTooltipHost {
  constructor(view) {
    this.view = view;
    this.mounted = false;
    this.dom = document.createElement("div");
    this.dom.classList.add("cm-tooltip-hover");
    this.manager = new TooltipViewManager(view, showHoverTooltip, (t2) => this.createHostedView(t2));
  }
  // Needs to be static so that host tooltip instances always match
  static create(view) {
    return new _HoverTooltipHost(view);
  }
  createHostedView(tooltip) {
    let hostedView = tooltip.create(this.view);
    hostedView.dom.classList.add("cm-tooltip-section");
    this.dom.appendChild(hostedView.dom);
    if (this.mounted && hostedView.mount)
      hostedView.mount(this.view);
    return hostedView;
  }
  mount(view) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.mount)
        hostedView.mount(view);
    }
    this.mounted = true;
  }
  positioned(space) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.positioned)
        hostedView.positioned(space);
    }
  }
  update(update) {
    this.manager.update(update);
  }
};
var showHoverTooltipHost = /* @__PURE__ */ showTooltip.compute([showHoverTooltip], (state) => {
  let tooltips = state.facet(showHoverTooltip).filter((t2) => t2);
  if (tooltips.length === 0)
    return null;
  return {
    pos: Math.min(...tooltips.map((t2) => t2.pos)),
    end: Math.max(...tooltips.filter((t2) => t2.end != null).map((t2) => t2.end)),
    create: HoverTooltipHost.create,
    above: tooltips[0].above,
    arrow: tooltips.some((t2) => t2.arrow)
  };
});
var HoverPlugin = class {
  constructor(view, source, field, setHover, hoverTime) {
    this.view = view;
    this.source = source;
    this.field = field;
    this.setHover = setHover;
    this.hoverTime = hoverTime;
    this.hoverTimeout = -1;
    this.restartTimeout = -1;
    this.pending = null;
    this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
    this.checkHover = this.checkHover.bind(this);
    view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
    view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    if (this.pending) {
      this.pending = null;
      clearTimeout(this.restartTimeout);
      this.restartTimeout = setTimeout(() => this.startHover(), 20);
    }
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    this.hoverTimeout = -1;
    if (this.active)
      return;
    let hovered = Date.now() - this.lastMove.time;
    if (hovered < this.hoverTime)
      this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
    else
      this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { lastMove } = this;
    let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(lastMove) : null;
    if (pos == null)
      return;
    let posCoords = this.view.coordsAtPos(pos);
    if (posCoords == null || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - this.view.defaultCharacterWidth || lastMove.x > posCoords.right + this.view.defaultCharacterWidth)
      return;
    let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find((s) => s.from <= pos && s.to >= pos);
    let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
    let open = this.source(this.view, pos, lastMove.x < posCoords.left ? -rtl : rtl);
    if (open === null || open === void 0 ? void 0 : open.then) {
      let pending = this.pending = { pos };
      open.then((result) => {
        if (this.pending == pending) {
          this.pending = null;
          if (result)
            this.view.dispatch({ effects: this.setHover.of(result) });
        }
      }, (e) => logException(this.view.state, e, "hover tooltip"));
    } else if (open) {
      this.view.dispatch({ effects: this.setHover.of(open) });
    }
  }
  mousemove(event) {
    var _a2;
    this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
    if (this.hoverTimeout < 0)
      this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
    let tooltip = this.active;
    if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {
      let { pos } = tooltip || this.pending, end = (_a2 = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a2 !== void 0 ? _a2 : pos;
      if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(
        this.view,
        pos,
        end,
        event.clientX,
        event.clientY,
        6
        /* Hover.MaxDist */
      )) {
        this.view.dispatch({ effects: this.setHover.of(null) });
        this.pending = null;
      }
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout);
    this.hoverTimeout = -1;
    if (this.active && !isInTooltip(e.relatedTarget))
      this.view.dispatch({ effects: this.setHover.of(null) });
  }
  destroy() {
    clearTimeout(this.hoverTimeout);
    this.view.dom.removeEventListener("mouseleave", this.mouseleave);
    this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
};
function isInTooltip(elt) {
  for (let cur2 = elt; cur2; cur2 = cur2.parentNode)
    if (cur2.nodeType == 1 && cur2.classList.contains("cm-tooltip"))
      return true;
  return false;
}
function isOverRange(view, from, to, x, y, margin) {
  let range = document.createRange();
  let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);
  range.setEnd(toDOM.node, toDOM.offset);
  range.setStart(fromDOM.node, fromDOM.offset);
  let rects = range.getClientRects();
  range.detach();
  for (let i = 0; i < rects.length; i++) {
    let rect = rects[i];
    let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);
    if (dist <= margin)
      return true;
  }
  return false;
}
function hoverTooltip(source, options = {}) {
  let setHover = StateEffect.define();
  let hoverState = StateField.define({
    create() {
      return null;
    },
    update(value, tr) {
      if (value && (options.hideOnChange && (tr.docChanged || tr.selection) || options.hideOn && options.hideOn(tr, value)))
        return null;
      if (value && tr.docChanged) {
        let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);
        if (newPos == null)
          return null;
        let copy = Object.assign(/* @__PURE__ */ Object.create(null), value);
        copy.pos = newPos;
        if (value.end != null)
          copy.end = tr.changes.mapPos(value.end);
        value = copy;
      }
      for (let effect of tr.effects) {
        if (effect.is(setHover))
          value = effect.value;
        if (effect.is(closeHoverTooltipEffect))
          value = null;
      }
      return value;
    },
    provide: (f) => showHoverTooltip.from(f)
  });
  return [
    hoverState,
    ViewPlugin.define((view) => new HoverPlugin(
      view,
      source,
      hoverState,
      setHover,
      options.hoverTime || 300
      /* Hover.Time */
    )),
    showHoverTooltipHost
  ];
}
function getTooltip(view, tooltip) {
  let plugin = view.plugin(tooltipPlugin);
  if (!plugin)
    return null;
  let found = plugin.manager.tooltips.indexOf(tooltip);
  return found < 0 ? null : plugin.manager.tooltipViews[found];
}
var closeHoverTooltipEffect = /* @__PURE__ */ StateEffect.define();
var panelConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    let topContainer, bottomContainer;
    for (let c of configs) {
      topContainer = topContainer || c.topContainer;
      bottomContainer = bottomContainer || c.bottomContainer;
    }
    return { topContainer, bottomContainer };
  }
});
function getPanel(view, panel) {
  let plugin = view.plugin(panelPlugin);
  let index = plugin ? plugin.specs.indexOf(panel) : -1;
  return index > -1 ? plugin.panels[index] : null;
}
var panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.input = view.state.facet(showPanel);
    this.specs = this.input.filter((s) => s);
    this.panels = this.specs.map((spec) => spec(view));
    let conf = view.state.facet(panelConfig);
    this.top = new PanelGroup(view, true, conf.topContainer);
    this.bottom = new PanelGroup(view, false, conf.bottomContainer);
    this.top.sync(this.panels.filter((p) => p.top));
    this.bottom.sync(this.panels.filter((p) => !p.top));
    for (let p of this.panels) {
      p.dom.classList.add("cm-panel");
      if (p.mount)
        p.mount();
    }
  }
  update(update) {
    let conf = update.state.facet(panelConfig);
    if (this.top.container != conf.topContainer) {
      this.top.sync([]);
      this.top = new PanelGroup(update.view, true, conf.topContainer);
    }
    if (this.bottom.container != conf.bottomContainer) {
      this.bottom.sync([]);
      this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
    }
    this.top.syncClasses();
    this.bottom.syncClasses();
    let input = update.state.facet(showPanel);
    if (input != this.input) {
      let specs = input.filter((x) => x);
      let panels = [], top2 = [], bottom = [], mount = [];
      for (let spec of specs) {
        let known = this.specs.indexOf(spec), panel;
        if (known < 0) {
          panel = spec(update.view);
          mount.push(panel);
        } else {
          panel = this.panels[known];
          if (panel.update)
            panel.update(update);
        }
        panels.push(panel);
        (panel.top ? top2 : bottom).push(panel);
      }
      this.specs = specs;
      this.panels = panels;
      this.top.sync(top2);
      this.bottom.sync(bottom);
      for (let p of mount) {
        p.dom.classList.add("cm-panel");
        if (p.mount)
          p.mount();
      }
    } else {
      for (let p of this.panels)
        if (p.update)
          p.update(update);
    }
  }
  destroy() {
    this.top.sync([]);
    this.bottom.sync([]);
  }
}, {
  provide: (plugin) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin);
    return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
  })
});
var PanelGroup = class {
  constructor(view, top2, container) {
    this.view = view;
    this.top = top2;
    this.container = container;
    this.dom = void 0;
    this.classes = "";
    this.panels = [];
    this.syncClasses();
  }
  sync(panels) {
    for (let p of this.panels)
      if (p.destroy && panels.indexOf(p) < 0)
        p.destroy();
    this.panels = panels;
    this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      if (this.dom) {
        this.dom.remove();
        this.dom = void 0;
      }
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div");
      this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
      this.dom.style[this.top ? "top" : "bottom"] = "0";
      let parent = this.container || this.view.dom;
      parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
    }
    let curDOM = this.dom.firstChild;
    for (let panel of this.panels) {
      if (panel.dom.parentNode == this.dom) {
        while (curDOM != panel.dom)
          curDOM = rm(curDOM);
        curDOM = curDOM.nextSibling;
      } else {
        this.dom.insertBefore(panel.dom, curDOM);
      }
    }
    while (curDOM)
      curDOM = rm(curDOM);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!this.container || this.classes == this.view.themeClasses)
      return;
    for (let cls of this.classes.split(" "))
      if (cls)
        this.container.classList.remove(cls);
    for (let cls of (this.classes = this.view.themeClasses).split(" "))
      if (cls)
        this.container.classList.add(cls);
  }
};
function rm(node) {
  let next = node.nextSibling;
  node.remove();
  return next;
}
var showPanel = /* @__PURE__ */ Facet.define({
  enables: panelPlugin
});
var GutterMarker = class extends RangeValue {
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(other) {
    return false;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(dom) {
  }
};
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = void 0;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
var gutterLineClass = /* @__PURE__ */ Facet.define();
var defaults = {
  class: "",
  renderEmptyElements: false,
  elementStyle: "",
  markers: () => RangeSet.empty,
  lineMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
};
var activeGutters = /* @__PURE__ */ Facet.define();
function gutter(config2) {
  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config2))];
}
var unfixGutters = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x) => x)
});
function gutters(config2) {
  let result = [
    gutterView
  ];
  if (config2 && config2.fixed === false)
    result.push(unfixGutters.of(true));
  return result;
}
var gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.prevViewport = view.viewport;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutters";
    this.dom.setAttribute("aria-hidden", "true");
    this.dom.style.minHeight = this.view.contentHeight + "px";
    this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
    for (let gutter2 of this.gutters)
      this.dom.appendChild(gutter2.dom);
    this.fixed = !view.state.facet(unfixGutters);
    if (this.fixed) {
      this.dom.style.position = "sticky";
    }
    this.syncGutters(false);
    view.scrollDOM.insertBefore(this.dom, view.contentDOM);
  }
  update(update) {
    if (this.updateGutters(update)) {
      let vpA = this.prevViewport, vpB = update.view.viewport;
      let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
      this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
    }
    if (update.geometryChanged)
      this.dom.style.minHeight = this.view.contentHeight + "px";
    if (this.view.state.facet(unfixGutters) != !this.fixed) {
      this.fixed = !this.fixed;
      this.dom.style.position = this.fixed ? "sticky" : "";
    }
    this.prevViewport = update.view.viewport;
  }
  syncGutters(detach) {
    let after = this.dom.nextSibling;
    if (detach)
      this.dom.remove();
    let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
    let classSet = [];
    let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
    for (let line of this.view.viewportLineBlocks) {
      let text;
      if (Array.isArray(line.type)) {
        for (let b of line.type)
          if (b.type == BlockType.Text) {
            text = b;
            break;
          }
      } else {
        text = line.type == BlockType.Text ? line : void 0;
      }
      if (!text)
        continue;
      if (classSet.length)
        classSet = [];
      advanceCursor(lineClasses, classSet, line.from);
      for (let cx of contexts)
        cx.line(this.view, text, classSet);
    }
    for (let cx of contexts)
      cx.finish();
    if (detach)
      this.view.scrollDOM.insertBefore(this.dom, after);
  }
  updateGutters(update) {
    let prev = update.startState.facet(activeGutters), cur2 = update.state.facet(activeGutters);
    let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
    if (prev == cur2) {
      for (let gutter2 of this.gutters)
        if (gutter2.update(update))
          change = true;
    } else {
      change = true;
      let gutters2 = [];
      for (let conf of cur2) {
        let known = prev.indexOf(conf);
        if (known < 0) {
          gutters2.push(new SingleGutterView(this.view, conf));
        } else {
          this.gutters[known].update(update);
          gutters2.push(this.gutters[known]);
        }
      }
      for (let g of this.gutters) {
        g.dom.remove();
        if (gutters2.indexOf(g) < 0)
          g.destroy();
      }
      for (let g of gutters2)
        this.dom.appendChild(g.dom);
      this.gutters = gutters2;
    }
    return change;
  }
  destroy() {
    for (let view of this.gutters)
      view.destroy();
    this.dom.remove();
  }
}, {
  provide: (plugin) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin);
    if (!value || value.gutters.length == 0 || !value.fixed)
      return null;
    return view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };
  })
});
function asArray2(val) {
  return Array.isArray(val) ? val : [val];
}
function advanceCursor(cursor, collect, pos) {
  while (cursor.value && cursor.from <= pos) {
    if (cursor.from == pos)
      collect.push(cursor.value);
    cursor.next();
  }
}
var UpdateContext = class {
  constructor(gutter2, viewport, height) {
    this.gutter = gutter2;
    this.height = height;
    this.i = 0;
    this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
  }
  line(view, line, extraMarkers) {
    let localMarkers = [];
    advanceCursor(this.cursor, localMarkers, line.from);
    if (extraMarkers.length)
      localMarkers = localMarkers.concat(extraMarkers);
    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
    if (forLine)
      localMarkers.unshift(forLine);
    let gutter2 = this.gutter;
    if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
      return;
    let above = line.top - this.height;
    if (this.i == gutter2.elements.length) {
      let newElt = new GutterElement(view, line.height, above, localMarkers);
      gutter2.elements.push(newElt);
      gutter2.dom.appendChild(newElt.dom);
    } else {
      gutter2.elements[this.i].update(view, line.height, above, localMarkers);
    }
    this.height = line.bottom;
    this.i++;
  }
  finish() {
    let gutter2 = this.gutter;
    while (gutter2.elements.length > this.i) {
      let last = gutter2.elements.pop();
      gutter2.dom.removeChild(last.dom);
      last.destroy();
    }
  }
};
var SingleGutterView = class {
  constructor(view, config2) {
    this.view = view;
    this.config = config2;
    this.elements = [];
    this.spacer = null;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let prop in config2.domEventHandlers) {
      this.dom.addEventListener(prop, (event) => {
        let target = event.target, y;
        if (target != this.dom && this.dom.contains(target)) {
          while (target.parentNode != this.dom)
            target = target.parentNode;
          let rect = target.getBoundingClientRect();
          y = (rect.top + rect.bottom) / 2;
        } else {
          y = event.clientY;
        }
        let line = view.lineBlockAtHeight(y - view.documentTop);
        if (config2.domEventHandlers[prop](view, line, event))
          event.preventDefault();
      });
    }
    this.markers = asArray2(config2.markers(view));
    if (config2.initialSpacer) {
      this.spacer = new GutterElement(view, 0, 0, [config2.initialSpacer(view)]);
      this.dom.appendChild(this.spacer.dom);
      this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
    }
  }
  update(update) {
    let prevMarkers = this.markers;
    this.markers = asArray2(this.config.markers(update.view));
    if (this.spacer && this.config.updateSpacer) {
      let updated = this.config.updateSpacer(this.spacer.markers[0], update);
      if (updated != this.spacer.markers[0])
        this.spacer.update(update.view, 0, 0, [updated]);
    }
    let vp = update.view.viewport;
    return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
  }
  destroy() {
    for (let elt of this.elements)
      elt.destroy();
  }
};
var GutterElement = class {
  constructor(view, height, above, markers) {
    this.height = -1;
    this.above = 0;
    this.markers = [];
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutterElement";
    this.update(view, height, above, markers);
  }
  update(view, height, above, markers) {
    if (this.height != height)
      this.dom.style.height = (this.height = height) + "px";
    if (this.above != above)
      this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
    if (!sameMarkers(this.markers, markers))
      this.setMarkers(view, markers);
  }
  setMarkers(view, markers) {
    let cls = "cm-gutterElement", domPos = this.dom.firstChild;
    for (let iNew = 0, iOld = 0; ; ) {
      let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
      if (marker) {
        let c = marker.elementClass;
        if (c)
          cls += " " + c;
        for (let i = iOld; i < this.markers.length; i++)
          if (this.markers[i].compare(marker)) {
            skipTo = i;
            matched = true;
            break;
          }
      } else {
        skipTo = this.markers.length;
      }
      while (iOld < skipTo) {
        let next = this.markers[iOld++];
        if (next.toDOM) {
          next.destroy(domPos);
          let after = domPos.nextSibling;
          domPos.remove();
          domPos = after;
        }
      }
      if (!marker)
        break;
      if (marker.toDOM) {
        if (matched)
          domPos = domPos.nextSibling;
        else
          this.dom.insertBefore(marker.toDOM(view), domPos);
      }
      if (matched)
        iOld++;
    }
    this.dom.className = cls;
    this.markers = markers;
  }
  destroy() {
    this.setMarkers(null, []);
  }
};
function sameMarkers(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].compare(b[i]))
      return false;
  return true;
}
var lineNumberMarkers = /* @__PURE__ */ Facet.define();
var lineNumberConfig = /* @__PURE__ */ Facet.define({
  combine(values) {
    return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(a, b) {
        let result = Object.assign({}, a);
        for (let event in b) {
          let exists = result[event], add2 = b[event];
          result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add2(view, line, event2) : add2;
        }
        return result;
      }
    });
  }
});
var NumberMarker = class extends GutterMarker {
  constructor(number2) {
    super();
    this.number = number2;
  }
  eq(other) {
    return this.number == other.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
};
function formatNumber(view, number2) {
  return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
}
var lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: false,
  markers(view) {
    return view.state.facet(lineNumberMarkers);
  },
  lineMarker(view, line, others) {
    if (others.some((m) => m.toDOM))
      return null;
    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
  },
  lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
  initialSpacer(view) {
    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
  },
  updateSpacer(spacer, update) {
    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
    return max == spacer.number ? spacer : new NumberMarker(max);
  },
  domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
}));
function lineNumbers(config2 = {}) {
  return [
    lineNumberConfig.of(config2),
    gutters(),
    lineNumberGutter
  ];
}
function maxLineNumber(lines) {
  let last = 9;
  while (last < lines)
    last = last * 10 + 9;
  return last;
}
var activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
  constructor() {
    super(...arguments);
    this.elementClass = "cm-activeLineGutter";
  }
}();
var activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state) => {
  let marks = [], last = -1;
  for (let range of state.selection.ranges) {
    let linePos = state.doc.lineAt(range.head).from;
    if (linePos > last) {
      last = linePos;
      marks.push(activeLineGutterMarker.range(linePos));
    }
  }
  return RangeSet.of(marks);
});
function highlightActiveLineGutter() {
  return activeLineGutterHighlighter;
}

// node_modules/@lezer/common/dist/index.js
var DefaultBufferLength = 1024;
var nextPropID = 0;
var Range2 = class {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
};
var NodeProp = class {
  /// Create a new node prop type.
  constructor(config2 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config2.perNode;
    this.deserialize = config2.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /// This is meant to be used with
  /// [`NodeSet.extend`](#common.NodeSet.extend) or
  /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
  /// prop values for each node type in the set. Takes a [match
  /// object](#common.NodeType^match) or function that returns undefined
  /// if the node type doesn't get this prop, and the prop's value if
  /// it does.
  add(match) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function")
      match = NodeType.match(match);
    return (type) => {
      let result = match(type);
      return result === void 0 ? null : [this, result];
    };
  }
};
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
var noProps = /* @__PURE__ */ Object.create(null);
var NodeType = class _NodeType {
  /// @internal
  constructor(name2, props, id, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id;
    this.flags = flags;
  }
  /// Define a node type.
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new _NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type;
  }
  /// Retrieves a node prop for this type. Will return `undefined` if
  /// the prop isn't present on this node.
  prop(prop) {
    return this.props[prop.id];
  }
  /// True when this is the top node of a grammar.
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /// True when this node is produced by a skip rule.
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /// Indicates whether this is an error node.
  get isError() {
    return (this.flags & 4) > 0;
  }
  /// When true, this node type doesn't correspond to a user-declared
  /// named node, for example because it is used to cache repetition.
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /// Returns true when this node's name or one of its
  /// [groups](#common.NodeProp^group) matches the given string.
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  /// Create a function from node types to arbitrary values by
  /// specifying an object whose property names are node or
  /// [group](#common.NodeProp^group) names. Often useful with
  /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  /// names, separated by spaces, in a single property name to map
  /// multiple node names to a single value.
  static match(map) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map)
      for (let name2 of prop.split(" "))
        direct[name2] = map[prop];
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node.name : groups[i]];
        if (found)
          return found;
      }
    };
  }
};
NodeType.none = new NodeType(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var NodeSet = class _NodeSet {
  /// Create a set with the given types. The `id` property of each
  /// type should correspond to its position within the array.
  constructor(types2) {
    this.types = types2;
    for (let i = 0; i < types2.length; i++)
      if (types2[i].id != i)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /// Create a copy of this set with some node properties added. The
  /// arguments to this method can be created with
  /// [`NodeProp.add`](#common.NodeProp.add).
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add2 = source(type);
        if (add2) {
          if (!newProps)
            newProps = Object.assign({}, type.props);
          newProps[add2[0].id] = add2[1];
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new _NodeSet(newTypes);
  }
};
var CachedNode = /* @__PURE__ */ new WeakMap();
var CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
var Tree = class _Tree {
  /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  constructor(type, children, positions, length, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  /// @internal
  toString() {
    let mounted = this.prop(NodeProp.mounted);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children = "";
    for (let ch of this.children) {
      let str = ch.toString();
      if (str) {
        if (children)
          children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  /// Get a [tree cursor](#common.TreeCursor) positioned at the top of
  /// the tree. Mode can be used to [control](#common.IterMode) which
  /// nodes the cursor visits.
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  /// Get a [tree cursor](#common.TreeCursor) pointing into this tree
  /// at the given position and side (see
  /// [`moveTo`](#common.TreeCursor.moveTo).
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor = new TreeCursor(scope);
    cursor.moveTo(pos, side);
    CachedNode.set(this, cursor._tree);
    return cursor;
  }
  /// Get a [syntax node](#common.SyntaxNode) object for the top of the
  /// tree.
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  /// Get the [syntax node](#common.SyntaxNode) at the given position.
  /// If `side` is -1, this will move into nodes that end at the
  /// position. If 1, it'll move into nodes that start at the
  /// position. With 0, it'll only enter nodes that cover the position
  /// from both sides.
  ///
  /// Note that this will not enter
  /// [overlays](#common.MountedTree.overlay), and you often want
  /// [`resolveInner`](#common.Tree.resolveInner) instead.
  resolve(pos, side = 0) {
    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node);
    return node;
  }
  /// Like [`resolve`](#common.Tree.resolve), but will enter
  /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  /// pointing into the innermost overlaid tree at the given position
  /// (with parent links going through all parent structure, including
  /// the host trees).
  resolveInner(pos, side = 0) {
    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node);
    return node;
  }
  /// Iterate over the tree and its children, calling `enter` for any
  /// node that touches the `from`/`to` region (if given) before
  /// running over such a node's children, and `leave` (if given) when
  /// leaving the node. When `enter` returns `false`, that node will
  /// not have its children iterated over (or `leave` called).
  iterate(spec) {
    let { enter, leave, from = 0, to = this.length } = spec;
    for (let c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {
        if (c.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && !c.type.isAnonymous)
          leave(c);
        if (c.nextSibling())
          break;
        if (!c.parent())
          return;
        entered = true;
      }
    }
  }
  /// Get the value of the given [node prop](#common.NodeProp) for this
  /// node. Works with both per-node and per-type props.
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
  /// format that can be passed to the [`Tree`](#common.Tree)
  /// constructor.
  get propValues() {
    let result = [];
    if (this.props)
      for (let id in this.props)
        result.push([+id, this.props[id]]);
    return result;
  }
  /// Balance the direct children of this tree, producing a copy of
  /// which may have children grouped into subtrees with type
  /// [`NodeType.none`](#common.NodeType^none).
  balance(config2 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new _Tree(this.type, children, positions, length, this.propValues), config2.makeTree || ((children, positions, length) => new _Tree(NodeType.none, children, positions, length)));
  }
  /// Build a tree from a postfix-ordered buffer of node information,
  /// or a cursor over such a buffer.
  static build(data) {
    return buildTree(data);
  }
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
var FlatBufferCursor = class _FlatBufferCursor {
  constructor(buffer, index) {
    this.buffer = buffer;
    this.index = index;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new _FlatBufferCursor(this.buffer, this.index);
  }
};
var TreeBuffer = class _TreeBuffer {
  /// Create a tree buffer.
  constructor(buffer, length, set) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
  }
  /// @internal
  get type() {
    return NodeType.none;
  }
  /// @internal
  toString() {
    let result = [];
    for (let index = 0; index < this.buffer.length; ) {
      result.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result.join(",");
  }
  /// @internal
  childString(index) {
    let id = this.buffer[index], endIndex = this.buffer[index + 3];
    let type = this.set.types[id], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index += 4;
    if (endIndex == index)
      return result;
    let children = [];
    while (index < endIndex) {
      children.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  /// @internal
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick = -1;
    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
        pick = i;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
  /// @internal
  slice(startI, endI, from) {
    let b = this.buffer;
    let copy = new Uint16Array(endI - startI), len = 0;
    for (let i = startI, j = 0; i < endI; ) {
      copy[j++] = b[i++];
      copy[j++] = b[i++] - from;
      let to = copy[j++] = b[i++] - from;
      copy[j++] = b[i++] - startI;
      len = Math.max(len, to);
    }
    return new _TreeBuffer(copy, len, this.set);
  }
};
function checkSide(side, pos, from, to) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to >= pos && from < pos;
    case 0:
      return from < pos && to > pos;
    case 1:
      return from <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function enterUnfinishedNodesBefore(node, pos) {
  let scan = node.childBefore(pos);
  while (scan) {
    let last = scan.lastChild;
    if (!last || last.to != scan.to)
      break;
    if (last.type.isError && last.from == last.to) {
      node = scan;
      scan = last.prevSibling;
    } else {
      scan = last;
    }
  }
  return node;
}
function resolveNode(node, pos, side, overlays) {
  var _a2;
  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
    if (!parent)
      return node;
    node = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
        node = parent;
    }
  for (; ; ) {
    let inner = node.enter(pos, side, mode);
    if (!inner)
      return node;
    node = inner;
  }
}
var TreeNode = class _TreeNode {
  constructor(_tree, from, index, _parent) {
    this._tree = _tree;
    this.from = from;
    this.index = index;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
        let next = children[i], start = positions[i] + parent.from;
        if (!checkSide(side, pos, start, start + next.length))
          continue;
        if (next instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers)
            continue;
          let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index > -1)
            return new BufferNode(new BufferContext(parent, next, i, start), null, index);
        } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
            return new _TreeNode(mounted.tree, start, i, parent);
          let inner = new _TreeNode(next, start, i, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i = parent.index + dir;
      else
        i = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.nextChild(
      0,
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let { from, to } of mounted.overlay) {
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
          return new _TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  enterUnfinishedNodesBefore(pos) {
    return enterUnfinishedNodesBefore(this, pos);
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  /// @internal
  toString() {
    return this._tree.toString();
  }
  get node() {
    return this;
  }
  matchContext(context) {
    return matchNodeContext(this, context);
  }
};
function getChildren(node, type, before, after) {
  let cur2 = node.cursor(), result = [];
  if (!cur2.firstChild())
    return result;
  if (before != null) {
    while (!cur2.type.is(before))
      if (!cur2.nextSibling())
        return result;
  }
  for (; ; ) {
    if (after != null && cur2.type.is(after))
      return result;
    if (cur2.type.is(type))
      result.push(cur2.node);
    if (!cur2.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node, context, i = context.length - 1) {
  for (let p = node.parent; i >= 0; p = p.parent) {
    if (!p)
      return false;
    if (!p.type.isAnonymous) {
      if (context[i] && context[i] != p.name)
        return false;
      i--;
    }
  }
  return true;
}
var BufferContext = class {
  constructor(parent, buffer, index, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index;
    this.start = start;
  }
};
var BufferNode = class _BufferNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(context, _parent, index) {
    this.context = context;
    this._parent = _parent;
    this.index = index;
    this.type = context.buffer.set.types[context.buffer.buffer[index]];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index < 0 ? null : new _BufferNode(this.context, this, index);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.child(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.child(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers)
      return null;
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index < 0 ? null : new _BufferNode(this.context, this, index);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + dir,
      dir,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new _BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new _BufferNode(this.context, this._parent, buffer.findChild(
      parentStart,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1];
      children.push(buffer.slice(startI, endI, from));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  enterUnfinishedNodesBefore(pos) {
    return enterUnfinishedNodesBefore(this, pos);
  }
  /// @internal
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  get node() {
    return this;
  }
  matchContext(context) {
    return matchNodeContext(this, context);
  }
};
var TreeCursor = class {
  /// Shorthand for `.type.name`.
  get name() {
    return this.type.name;
  }
  /// @internal
  constructor(node, mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n = node._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  yieldNode(node) {
    if (!node)
      return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index, type) {
    this.index = index;
    let { start, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index]];
    this.from = start + buffer.buffer[index + 1];
    this.to = start + buffer.buffer[index + 2];
    return true;
  }
  yield(node) {
    if (!node)
      return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  /// @internal
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /// @internal
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index);
  }
  /// Move the cursor to this node's first child. When this returns
  /// false, the node has no child, and the cursor has not been moved.
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /// Move the cursor to this node's last child.
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /// Move the cursor to the first child that ends after `pos`.
  childAfter(pos) {
    return this.enterChild(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  /// Move to the last child that starts before `pos`.
  childBefore(pos) {
    return this.enterChild(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  /// Move the cursor to the child around `pos`. If side is -1 the
  /// child may end at that position, when 1 it may start there. This
  /// will also enter [overlaid](#common.MountedTree.overlay)
  /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  /// set to false.
  enter(pos, side, mode = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  /// Move to the node's parent node, if this isn't the top node.
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  /// @internal
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(
          parentStart,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
        return this.yieldBuf(after);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  /// Move to this node's next sibling, if any.
  nextSibling() {
    return this.sibling(1);
  }
  /// Move to this node's previous sibling, if any.
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i = 0; i < this.index; i++)
          if (buffer.buffer.buffer[i + 3] < this.index)
            return false;
      }
      ({ index, parent } = buffer);
    } else {
      ({ index, _parent: parent } = this._tree);
    }
    for (; parent; { index, _parent: parent } = parent) {
      if (index > -1)
        for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
          let child = parent._tree.children[i];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(
      dir,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  /// Move to the next node in a
  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  /// traversal, going from a node to its first child or, if the
  /// current node is empty or `enter` is false, its next sibling or
  /// the next sibling of the first parent node that has one.
  next(enter = true) {
    return this.move(1, enter);
  }
  /// Move to the next node in a last-to-first pre-order traveral. A
  /// node is followed by its last child or, if it has none, its
  /// previous sibling or the previous sibling of the first parent
  /// node that has one.
  prev(enter = true) {
    return this.move(-1, enter);
  }
  /// Move the cursor to the innermost node that covers `pos`. If
  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  /// it will enter nodes that start at `pos`.
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
  /// position.
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache = this.bufferNode, result = null, depth = 0;
    if (cache && cache.context == this.buffer) {
      scan:
        for (let index = this.index, d = this.stack.length; d >= 0; ) {
          for (let c = cache; c; c = c._parent)
            if (c.index == index) {
              if (index == this.index)
                return c;
              result = c;
              depth = d + 1;
              break scan;
            }
          index = this.stack[--d];
        }
    }
    for (let i = depth; i < this.stack.length; i++)
      result = new BufferNode(this.buffer, result, this.stack[i]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  /// Get the [tree](#common.Tree) that represents the current node, if
  /// any. Will return null when the node is in a [tree
  /// buffer](#common.TreeBuffer).
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /// Iterate over the current node and all its descendants, calling
  /// `enter` when entering a node and `leave`, if given, when leaving
  /// one. When `enter` returns `false`, any children of that node are
  /// skipped, and `leave` isn't called for it.
  iterate(enter, leave) {
    for (let depth = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (this.nextSibling())
          break;
        if (!depth)
          return;
        this.parent();
        depth--;
        mustLeave = true;
      }
    }
  }
  /// Test whether the current node matches a given context—a sequence
  /// of direct parent node names. Empty strings in the context array
  /// are treated as wildcards.
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node, context);
    let { buffer } = this.buffer, { types: types2 } = buffer.set;
    for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
      if (d < 0)
        return matchNodeContext(this.node, context, i);
      let type = types2[buffer.buffer[this.stack[d]]];
      if (!type.isAnonymous) {
        if (context[i] && context[i] != type.name)
          return false;
        i--;
      }
    }
    return true;
  }
};
function hasChild(tree) {
  return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
  var _a2;
  let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types2 = nodeSet.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat) {
    let { id, start, end, size } = cursor;
    let lookAheadAtStart = lookAhead;
    while (size < 0) {
      cursor.next();
      if (size == -1) {
        let node2 = reused[id];
        children2.push(node2);
        positions2.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id;
        return;
      } else if (size == -4) {
        lookAhead = id;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type = types2[id], node, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor.pos - buffer2.size, index = data2.length;
      while (cursor.pos > endPos)
        index = copyToBuffer(buffer2.start, data2, index);
      node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor.pos - size;
      cursor.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id >= minRepeatType ? id : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor.pos > endPos) {
        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
          if (cursor.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor.end;
          }
          cursor.next();
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
      }
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function makeBalanced(type) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
      if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length2)
          return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length2, lookAhead2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base2, i, from, to, type, lookAhead2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base2 - from);
    }
    children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to));
    positions2.push(from - base2);
  }
  function makeTree(type, children2, positions2, length2, lookAhead2 = 0, props) {
    if (contextHash) {
      let pair = [NodeProp.contextHash, contextHash];
      props = props ? [pair].concat(props) : [pair];
    }
    if (lookAhead2 > 25) {
      let pair = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair].concat(props) : [pair];
    }
    return new Tree(type, children2, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor.fork();
    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan:
      for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
        let nodeSize2 = fork.size;
        if (fork.id == inRepeat && nodeSize2 >= 0) {
          result.size = size;
          result.start = start;
          result.skip = skip;
          skip += 4;
          size += 4;
          fork.next();
          continue;
        }
        let startPos = fork.pos - nodeSize2;
        if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
          break;
        let localSkipped = fork.id >= minRepeatType ? 4 : 0;
        let nodeStart2 = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0) {
            if (fork.size == -3)
              localSkipped += 4;
            else
              break scan;
          } else if (fork.id >= minRepeatType) {
            localSkipped += 4;
          }
          fork.next();
        }
        start = nodeStart2;
        size += nodeSize2;
        skip += localSkipped;
      }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index) {
    let { id, start, end, size } = cursor;
    cursor.next();
    if (size >= 0 && id < minRepeatType) {
      let startIndex = index;
      if (size > 4) {
        let endPos = cursor.pos - (size - 4);
        while (cursor.pos > endPos)
          index = copyToBuffer(bufferStart, buffer2, index);
      }
      buffer2[--index] = startIndex;
      buffer2[--index] = end - bufferStart;
      buffer2[--index] = start - bufferStart;
      buffer2[--index] = id;
    } else if (size == -3) {
      contextHash = id;
    } else if (size == -4) {
      lookAhead = id;
    }
    return index;
  }
  let children = [], positions = [];
  while (cursor.pos > 0)
    takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
  let length = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types2[data.topID], children.reverse(), positions.reverse(), length);
}
var nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node);
  if (size == null) {
    size = 1;
    for (let child of node.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node, size);
  }
  return size;
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i = from; i < to; i++)
    total += nodeSize(balanceType, children[i]);
  let maxChild = Math.ceil(
    total * 1.5 / 8
    /* Balance.BranchFactor */
  );
  let localChildren = [], localPositions = [];
  function divide(children2, positions2, from2, to2, offset) {
    for (let i = from2; i < to2; ) {
      let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
      i++;
      for (; i < to2; i++) {
        let nextSize = nodeSize(balanceType, children2[i]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide(children, positions, from, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
var TreeFragment = class _TreeFragment {
  /// Construct a tree fragment. You'll usually want to use
  /// [`addTree`](#common.TreeFragment^addTree) and
  /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  /// calling this directly.
  constructor(from, to, tree, offset, openStart = false, openEnd = false) {
    this.from = from;
    this.to = to;
    this.tree = tree;
    this.offset = offset;
    this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
  }
  /// Whether the start of the fragment represents the start of a
  /// parse, or the end of a change. (In the second case, it may not
  /// be safe to reuse some nodes at the start, depending on the
  /// parsing algorithm.)
  get openStart() {
    return (this.open & 1) > 0;
  }
  /// Whether the end of the fragment represents the end of a
  /// full-document parse, or the start of a change.
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /// Create a set of fragments from a freshly parsed tree, or update
  /// an existing set of fragments by replacing the ones that overlap
  /// with a tree with content from the new tree. When `partial` is
  /// true, the parse is treated as incomplete, and the resulting
  /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  /// true.
  static addTree(tree, fragments = [], partial = false) {
    let result = [new _TreeFragment(0, tree.length, tree, 0, false, partial)];
    for (let f of fragments)
      if (f.to > tree.length)
        result.push(f);
    return result;
  }
  /// Apply a set of edits to an array of fragments, removing or
  /// splitting fragments as necessary to remove edited ranges, and
  /// adjusting offsets for fragments that moved.
  static applyChanges(fragments, changes, minGap = 128) {
    if (!changes.length)
      return fragments;
    let result = [];
    let fI = 1, nextF = fragments.length ? fragments[0] : null;
    for (let cI = 0, pos = 0, off = 0; ; cI++) {
      let nextC = cI < changes.length ? changes[cI] : null;
      let nextPos = nextC ? nextC.fromA : 1e9;
      if (nextPos - pos >= minGap)
        while (nextF && nextF.from < nextPos) {
          let cut = nextF;
          if (pos >= cut.from || nextPos <= cut.to || off) {
            let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
            cut = fFrom >= fTo ? null : new _TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
          }
          if (cut)
            result.push(cut);
          if (nextF.to > nextPos)
            break;
          nextF = fI < fragments.length ? fragments[fI++] : null;
        }
      if (!nextC)
        break;
      pos = nextC.toA;
      off = nextC.toA - nextC.toB;
    }
    return result;
  }
};
var Parser = class {
  /// Start a parse, returning a [partial parse](#common.PartialParse)
  /// object. [`fragments`](#common.TreeFragment) can be passed in to
  /// make the parse incremental.
  ///
  /// By default, the entire input is parsed. You can pass `ranges`,
  /// which should be a sorted array of non-empty, non-overlapping
  /// ranges, to parse only those ranges. The tree returned in that
  /// case will start at `ranges[0].from`.
  startParse(input, fragments, ranges) {
    if (typeof input == "string")
      input = new StringInput(input);
    ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r) => new Range2(r.from, r.to)) : [new Range2(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  /// Run a full parse, returning the resulting tree.
  parse(input, fragments, ranges) {
    let parse = this.startParse(input, fragments, ranges);
    for (; ; ) {
      let done = parse.advance();
      if (done)
        return done;
    }
  }
};
var StringInput = class {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from) {
    return this.string.slice(from);
  }
  get lineChunks() {
    return false;
  }
  read(from, to) {
    return this.string.slice(from, to);
  }
};
var stoppedInner = new NodeProp({ perNode: true });

// node_modules/@lezer/highlight/dist/index.js
var nextTagID = 0;
var Tag = class _Tag {
  /// @internal
  constructor(set, base2, modified) {
    this.set = set;
    this.base = base2;
    this.modified = modified;
    this.id = nextTagID++;
  }
  /// Define a new tag. If `parent` is given, the tag is treated as a
  /// sub-tag of that parent, and
  /// [highlighters](#highlight.tagHighlighter) that don't mention
  /// this tag will try to fall back to the parent tag (or grandparent
  /// tag, etc).
  static define(parent) {
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new _Tag([], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t2 of parent.set)
        tag.set.push(t2);
    return tag;
  }
  /// Define a tag _modifier_, which is a function that, given a tag,
  /// will return a tag that is a subtag of the original. Applying the
  /// same modifier to a twice tag will return the same value (`m1(t1)
  /// == m1(t1)`) and applying multiple modifiers will, regardless or
  /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  ///
  /// When multiple modifiers are applied to a given base tag, each
  /// smaller set of modifiers is registered as a parent, so that for
  /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  /// `m1(m3(t1)`, and so on.
  static defineModifier() {
    let mod = new Modifier();
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
    };
  }
};
var nextModifierID = 0;
var Modifier = class _Modifier {
  constructor() {
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base2, mods) {
    if (!mods.length)
      return base2;
    let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray2(mods, t2.modified));
    if (exists)
      return exists;
    let set = [], tag = new Tag(set, base2, mods);
    for (let m of mods)
      m.instances.push(tag);
    let configs = powerSet(mods);
    for (let parent of base2.set)
      if (!parent.modified.length)
        for (let config2 of configs)
          set.push(_Modifier.get(parent, config2));
    return tag;
  }
};
function sameArray2(a, b) {
  return a.length == b.length && a.every((x, i) => x == b[i]);
}
function powerSet(array) {
  let sets = [[]];
  for (let i = 0; i < array.length; i++) {
    for (let j = 0, e = sets.length; j < e; j++) {
      sets.push(sets[j].concat(array[i]));
    }
  }
  return sets.sort((a, b) => b.length - a.length);
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
var ruleNodeProp = new NodeProp();
var Rule = class {
  constructor(tags2, mode, context, next) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
Rule.empty = new Rule([], 2, null);
function tagHighlighter(tags2, options) {
  let map = /* @__PURE__ */ Object.create(null);
  for (let style of tags2) {
    if (!Array.isArray(style.tag))
      map[style.tag.id] = style.class;
    else
      for (let tag of style.tag)
        map[tag.id] = style.class;
  }
  let { scope, all = null } = options || {};
  return {
    style: (tags3) => {
      let cls = all;
      for (let tag of tags3) {
        for (let sub of tag.set) {
          let tagClass = map[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
function highlightTags(highlighters, tags2) {
  let result = null;
  for (let highlighter of highlighters) {
    let value = highlighter.style(tags2);
    if (value)
      result = result ? result + " " + value : value;
  }
  return result;
}
function highlightTree(tree, highlighter, putStyle, from = 0, to = tree.length) {
  let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
  builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
  builder.flush(to);
}
var HighlightBuilder = class {
  constructor(at, highlighters, span) {
    this.at = at;
    this.highlighters = highlighters;
    this.span = span;
    this.class = "";
  }
  startSpan(at, cls) {
    if (cls != this.class) {
      this.flush(at);
      if (at > this.at)
        this.at = at;
      this.class = cls;
    }
  }
  flush(to) {
    if (to > this.at && this.class)
      this.span(this.at, to, this.class);
  }
  highlightRange(cursor, from, to, inheritedClass, highlighters) {
    let { type, from: start, to: end } = cursor;
    if (start >= to || end <= from)
      return;
    if (type.isTop)
      highlighters = this.highlighters.filter((h) => !h.scope || h.scope(type));
    let cls = inheritedClass;
    let rule = getStyleTags(cursor) || Rule.empty;
    let tagCls = highlightTags(highlighters, rule.tags);
    if (tagCls) {
      if (cls)
        cls += " ";
      cls += tagCls;
      if (rule.mode == 1)
        inheritedClass += (inheritedClass ? " " : "") + tagCls;
    }
    this.startSpan(cursor.from, cls);
    if (rule.opaque)
      return;
    let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
    if (mounted && mounted.overlay) {
      let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
      let innerHighlighters = this.highlighters.filter((h) => !h.scope || h.scope(mounted.tree.type));
      let hasChild2 = cursor.firstChild();
      for (let i = 0, pos = start; ; i++) {
        let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
        let nextPos = next ? next.from + start : end;
        let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
        if (rangeFrom < rangeTo && hasChild2) {
          while (cursor.from < rangeTo) {
            this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
            this.startSpan(Math.min(rangeTo, cursor.to), cls);
            if (cursor.to >= nextPos || !cursor.nextSibling())
              break;
          }
        }
        if (!next || nextPos > to)
          break;
        pos = next.to + start;
        if (pos > from) {
          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);
          this.startSpan(pos, cls);
        }
      }
      if (hasChild2)
        cursor.parent();
    } else if (cursor.firstChild()) {
      do {
        if (cursor.to <= from)
          continue;
        if (cursor.from >= to)
          break;
        this.highlightRange(cursor, from, to, inheritedClass, highlighters);
        this.startSpan(Math.min(to, cursor.to), cls);
      } while (cursor.nextSibling());
      cursor.parent();
    }
  }
};
function getStyleTags(node) {
  let rule = node.type.prop(ruleNodeProp);
  while (rule && rule.context && !node.matchContext(rule.context))
    rule = rule.next;
  return rule || null;
}
var t = Tag.define;
var comment = t();
var name = t();
var typeName = t(name);
var propertyName = t(name);
var literal = t();
var string = t(literal);
var number = t(literal);
var content = t();
var heading = t(content);
var keyword = t();
var operator = t();
var punctuation = t();
var bracket = t(punctuation);
var meta = t();
var tags = {
  /// A comment.
  comment,
  /// A line [comment](#highlight.tags.comment).
  lineComment: t(comment),
  /// A block [comment](#highlight.tags.comment).
  blockComment: t(comment),
  /// A documentation [comment](#highlight.tags.comment).
  docComment: t(comment),
  /// Any kind of identifier.
  name,
  /// The [name](#highlight.tags.name) of a variable.
  variableName: t(name),
  /// A type [name](#highlight.tags.name).
  typeName,
  /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  tagName: t(typeName),
  /// A property or field [name](#highlight.tags.name).
  propertyName,
  /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  attributeName: t(propertyName),
  /// The [name](#highlight.tags.name) of a class.
  className: t(name),
  /// A label [name](#highlight.tags.name).
  labelName: t(name),
  /// A namespace [name](#highlight.tags.name).
  namespace: t(name),
  /// The [name](#highlight.tags.name) of a macro.
  macroName: t(name),
  /// A literal value.
  literal,
  /// A string [literal](#highlight.tags.literal).
  string,
  /// A documentation [string](#highlight.tags.string).
  docString: t(string),
  /// A character literal (subtag of [string](#highlight.tags.string)).
  character: t(string),
  /// An attribute value (subtag of [string](#highlight.tags.string)).
  attributeValue: t(string),
  /// A number [literal](#highlight.tags.literal).
  number,
  /// An integer [number](#highlight.tags.number) literal.
  integer: t(number),
  /// A floating-point [number](#highlight.tags.number) literal.
  float: t(number),
  /// A boolean [literal](#highlight.tags.literal).
  bool: t(literal),
  /// Regular expression [literal](#highlight.tags.literal).
  regexp: t(literal),
  /// An escape [literal](#highlight.tags.literal), for example a
  /// backslash escape in a string.
  escape: t(literal),
  /// A color [literal](#highlight.tags.literal).
  color: t(literal),
  /// A URL [literal](#highlight.tags.literal).
  url: t(literal),
  /// A language keyword.
  keyword,
  /// The [keyword](#highlight.tags.keyword) for the self or this
  /// object.
  self: t(keyword),
  /// The [keyword](#highlight.tags.keyword) for null.
  null: t(keyword),
  /// A [keyword](#highlight.tags.keyword) denoting some atomic value.
  atom: t(keyword),
  /// A [keyword](#highlight.tags.keyword) that represents a unit.
  unit: t(keyword),
  /// A modifier [keyword](#highlight.tags.keyword).
  modifier: t(keyword),
  /// A [keyword](#highlight.tags.keyword) that acts as an operator.
  operatorKeyword: t(keyword),
  /// A control-flow related [keyword](#highlight.tags.keyword).
  controlKeyword: t(keyword),
  /// A [keyword](#highlight.tags.keyword) that defines something.
  definitionKeyword: t(keyword),
  /// A [keyword](#highlight.tags.keyword) related to defining or
  /// interfacing with modules.
  moduleKeyword: t(keyword),
  /// An operator.
  operator,
  /// An [operator](#highlight.tags.operator) that dereferences something.
  derefOperator: t(operator),
  /// Arithmetic-related [operator](#highlight.tags.operator).
  arithmeticOperator: t(operator),
  /// Logical [operator](#highlight.tags.operator).
  logicOperator: t(operator),
  /// Bit [operator](#highlight.tags.operator).
  bitwiseOperator: t(operator),
  /// Comparison [operator](#highlight.tags.operator).
  compareOperator: t(operator),
  /// [Operator](#highlight.tags.operator) that updates its operand.
  updateOperator: t(operator),
  /// [Operator](#highlight.tags.operator) that defines something.
  definitionOperator: t(operator),
  /// Type-related [operator](#highlight.tags.operator).
  typeOperator: t(operator),
  /// Control-flow [operator](#highlight.tags.operator).
  controlOperator: t(operator),
  /// Program or markup punctuation.
  punctuation,
  /// [Punctuation](#highlight.tags.punctuation) that separates
  /// things.
  separator: t(punctuation),
  /// Bracket-style [punctuation](#highlight.tags.punctuation).
  bracket,
  /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  /// tokens).
  angleBracket: t(bracket),
  /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  /// tokens).
  squareBracket: t(bracket),
  /// Parentheses (usually `(` and `)` tokens). Subtag of
  /// [bracket](#highlight.tags.bracket).
  paren: t(bracket),
  /// Braces (usually `{` and `}` tokens). Subtag of
  /// [bracket](#highlight.tags.bracket).
  brace: t(bracket),
  /// Content, for example plain text in XML or markup documents.
  content,
  /// [Content](#highlight.tags.content) that represents a heading.
  heading,
  /// A level 1 [heading](#highlight.tags.heading).
  heading1: t(heading),
  /// A level 2 [heading](#highlight.tags.heading).
  heading2: t(heading),
  /// A level 3 [heading](#highlight.tags.heading).
  heading3: t(heading),
  /// A level 4 [heading](#highlight.tags.heading).
  heading4: t(heading),
  /// A level 5 [heading](#highlight.tags.heading).
  heading5: t(heading),
  /// A level 6 [heading](#highlight.tags.heading).
  heading6: t(heading),
  /// A prose separator (such as a horizontal rule).
  contentSeparator: t(content),
  /// [Content](#highlight.tags.content) that represents a list.
  list: t(content),
  /// [Content](#highlight.tags.content) that represents a quote.
  quote: t(content),
  /// [Content](#highlight.tags.content) that is emphasized.
  emphasis: t(content),
  /// [Content](#highlight.tags.content) that is styled strong.
  strong: t(content),
  /// [Content](#highlight.tags.content) that is part of a link.
  link: t(content),
  /// [Content](#highlight.tags.content) that is styled as code or
  /// monospace.
  monospace: t(content),
  /// [Content](#highlight.tags.content) that has a strike-through
  /// style.
  strikethrough: t(content),
  /// Inserted text in a change-tracking format.
  inserted: t(),
  /// Deleted text.
  deleted: t(),
  /// Changed text.
  changed: t(),
  /// An invalid or unsyntactic element.
  invalid: t(),
  /// Metadata or meta-instruction.
  meta,
  /// [Metadata](#highlight.tags.meta) that applies to the entire
  /// document.
  documentMeta: t(meta),
  /// [Metadata](#highlight.tags.meta) that annotates or adds
  /// attributes to a given syntactic element.
  annotation: t(meta),
  /// Processing instruction or preprocessor directive. Subtag of
  /// [meta](#highlight.tags.meta).
  processingInstruction: t(meta),
  /// [Modifier](#highlight.Tag^defineModifier) that indicates that a
  /// given element is being defined. Expected to be used with the
  /// various [name](#highlight.tags.name) tags.
  definition: Tag.defineModifier(),
  /// [Modifier](#highlight.Tag^defineModifier) that indicates that
  /// something is constant. Mostly expected to be used with
  /// [variable names](#highlight.tags.variableName).
  constant: Tag.defineModifier(),
  /// [Modifier](#highlight.Tag^defineModifier) used to indicate that
  /// a [variable](#highlight.tags.variableName) or [property
  /// name](#highlight.tags.propertyName) is being called or defined
  /// as a function.
  function: Tag.defineModifier(),
  /// [Modifier](#highlight.Tag^defineModifier) that can be applied to
  /// [names](#highlight.tags.name) to indicate that they belong to
  /// the language's standard environment.
  standard: Tag.defineModifier(),
  /// [Modifier](#highlight.Tag^defineModifier) that indicates a given
  /// [names](#highlight.tags.name) is local to some scope.
  local: Tag.defineModifier(),
  /// A generic variant [modifier](#highlight.Tag^defineModifier) that
  /// can be used to tag language-specific alternative variants of
  /// some common tag. It is recommended for themes to define special
  /// forms of at least the [string](#highlight.tags.string) and
  /// [variable name](#highlight.tags.variableName) tags, since those
  /// come up a lot.
  special: Tag.defineModifier()
};
var classHighlighter = tagHighlighter([
  { tag: tags.link, class: "tok-link" },
  { tag: tags.heading, class: "tok-heading" },
  { tag: tags.emphasis, class: "tok-emphasis" },
  { tag: tags.strong, class: "tok-strong" },
  { tag: tags.keyword, class: "tok-keyword" },
  { tag: tags.atom, class: "tok-atom" },
  { tag: tags.bool, class: "tok-bool" },
  { tag: tags.url, class: "tok-url" },
  { tag: tags.labelName, class: "tok-labelName" },
  { tag: tags.inserted, class: "tok-inserted" },
  { tag: tags.deleted, class: "tok-deleted" },
  { tag: tags.literal, class: "tok-literal" },
  { tag: tags.string, class: "tok-string" },
  { tag: tags.number, class: "tok-number" },
  { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
  { tag: tags.variableName, class: "tok-variableName" },
  { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
  { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
  { tag: tags.special(tags.variableName), class: "tok-variableName2" },
  { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
  { tag: tags.typeName, class: "tok-typeName" },
  { tag: tags.namespace, class: "tok-namespace" },
  { tag: tags.className, class: "tok-className" },
  { tag: tags.macroName, class: "tok-macroName" },
  { tag: tags.propertyName, class: "tok-propertyName" },
  { tag: tags.operator, class: "tok-operator" },
  { tag: tags.comment, class: "tok-comment" },
  { tag: tags.meta, class: "tok-meta" },
  { tag: tags.invalid, class: "tok-invalid" },
  { tag: tags.punctuation, class: "tok-punctuation" }
]);

// node_modules/@codemirror/language/dist/index.js
var _a;
var languageDataProp = /* @__PURE__ */ new NodeProp();
function defineLanguageFacet(baseData) {
  return Facet.define({
    combine: baseData ? (values) => values.concat(baseData) : void 0
  });
}
var sublanguageProp = /* @__PURE__ */ new NodeProp();
var Language = class {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(data, parser, extraExtensions = [], name2 = "") {
    this.data = data;
    this.name = name2;
    if (!EditorState.prototype.hasOwnProperty("tree"))
      Object.defineProperty(EditorState.prototype, "tree", { get() {
        return syntaxTree(this);
      } });
    this.parser = parser;
    this.extension = [
      language.of(this),
      EditorState.languageData.of((state, pos, side) => {
        let top2 = topNodeAt(state, pos, side), data2 = top2.type.prop(languageDataProp);
        if (!data2)
          return [];
        let base2 = state.facet(data2), sub = top2.type.prop(sublanguageProp);
        if (sub) {
          let innerNode = top2.resolve(pos - top2.from, side);
          for (let sublang of sub)
            if (sublang.test(innerNode, state)) {
              let data3 = state.facet(sublang.facet);
              return sublang.type == "replace" ? data3 : data3.concat(base2);
            }
        }
        return base2;
      })
    ].concat(extraExtensions);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(state, pos, side = -1) {
    return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(state) {
    let lang = state.facet(language);
    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
      return [{ from: 0, to: state.doc.length }];
    if (!lang || !lang.allowsNesting)
      return [];
    let result = [];
    let explore = (tree, from) => {
      if (tree.prop(languageDataProp) == this.data) {
        result.push({ from, to: from + tree.length });
        return;
      }
      let mount = tree.prop(NodeProp.mounted);
      if (mount) {
        if (mount.tree.prop(languageDataProp) == this.data) {
          if (mount.overlay)
            for (let r of mount.overlay)
              result.push({ from: r.from + from, to: r.to + from });
          else
            result.push({ from, to: from + tree.length });
          return;
        } else if (mount.overlay) {
          let size = result.length;
          explore(mount.tree, mount.overlay[0].from + from);
          if (result.length > size)
            return;
        }
      }
      for (let i = 0; i < tree.children.length; i++) {
        let ch = tree.children[i];
        if (ch instanceof Tree)
          explore(ch, tree.positions[i] + from);
      }
    };
    explore(syntaxTree(state), 0);
    return result;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return true;
  }
};
Language.setState = /* @__PURE__ */ StateEffect.define();
function topNodeAt(state, pos, side) {
  let topLang = state.facet(language), tree = syntaxTree(state).topNode;
  if (!topLang || topLang.allowsNesting) {
    for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
      if (node.type.isTop)
        tree = node;
  }
  return tree;
}
function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : Tree.empty;
}
var DocInput = class {
  constructor(doc2) {
    this.doc = doc2;
    this.cursorPos = 0;
    this.string = "";
    this.cursor = doc2.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(pos) {
    this.string = this.cursor.next(pos - this.cursorPos).value;
    this.cursorPos = pos + this.string.length;
    return this.cursorPos - this.string.length;
  }
  chunk(pos) {
    this.syncTo(pos);
    return this.string;
  }
  get lineChunks() {
    return true;
  }
  read(from, to) {
    let stringStart = this.cursorPos - this.string.length;
    if (from < stringStart || to >= this.cursorPos)
      return this.doc.sliceString(from, to);
    else
      return this.string.slice(from - stringStart, to - stringStart);
  }
};
var currentContext = null;
var ParseContext = class _ParseContext {
  constructor(parser, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
    this.parser = parser;
    this.state = state;
    this.fragments = fragments;
    this.tree = tree;
    this.treeLen = treeLen;
    this.viewport = viewport;
    this.skipped = skipped;
    this.scheduleOn = scheduleOn;
    this.parse = null;
    this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(parser, state, viewport) {
    return new _ParseContext(parser, state, [], Tree.empty, 0, viewport, [], null);
  }
  startParse() {
    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(until, upto) {
    if (upto != null && upto >= this.state.doc.length)
      upto = void 0;
    if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
      this.takeTree();
      return true;
    }
    return this.withContext(() => {
      var _a2;
      if (typeof until == "number") {
        let endTime = Date.now() + until;
        until = () => Date.now() > endTime;
      }
      if (!this.parse)
        this.parse = this.startParse();
      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
        this.parse.stopAt(upto);
      for (; ; ) {
        let done = this.parse.advance();
        if (done) {
          this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
          this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
          this.tree = done;
          this.parse = null;
          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
            this.parse = this.startParse();
          else
            return true;
        }
        if (until())
          return false;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let pos, tree;
    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
        this.parse.stopAt(pos);
      this.withContext(() => {
        while (!(tree = this.parse.advance())) {
        }
      });
      this.treeLen = pos;
      this.tree = tree;
      this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
      this.parse = null;
    }
  }
  withContext(f) {
    let prev = currentContext;
    currentContext = this;
    try {
      return f();
    } finally {
      currentContext = prev;
    }
  }
  withoutTempSkipped(fragments) {
    for (let r; r = this.tempSkipped.pop(); )
      fragments = cutFragments(fragments, r.from, r.to);
    return fragments;
  }
  /**
  @internal
  */
  changes(changes, newState) {
    let { fragments, tree, treeLen, viewport, skipped } = this;
    this.takeTree();
    if (!changes.empty) {
      let ranges = [];
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
      fragments = TreeFragment.applyChanges(fragments, ranges);
      tree = Tree.empty;
      treeLen = 0;
      viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
      if (this.skipped.length) {
        skipped = [];
        for (let r of this.skipped) {
          let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
          if (from < to)
            skipped.push({ from, to });
        }
      }
    }
    return new _ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(viewport) {
    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
      return false;
    this.viewport = viewport;
    let startLen = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from, to } = this.skipped[i];
      if (from < viewport.to && to > viewport.from) {
        this.fragments = cutFragments(this.fragments, from, to);
        this.skipped.splice(i--, 1);
      }
    }
    if (this.skipped.length >= startLen)
      return false;
    this.reset();
    return true;
  }
  /**
  @internal
  */
  reset() {
    if (this.parse) {
      this.takeTree();
      this.parse = null;
    }
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(from, to) {
    this.skipped.push({ from, to });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(until) {
    return new class extends Parser {
      createParse(input, fragments, ranges) {
        let from = ranges[0].from, to = ranges[ranges.length - 1].to;
        let parser = {
          parsedPos: from,
          advance() {
            let cx = currentContext;
            if (cx) {
              for (let r of ranges)
                cx.tempSkipped.push(r);
              if (until)
                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
            }
            this.parsedPos = to;
            return new Tree(NodeType.none, [], [], to - from);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
        return parser;
      }
    }();
  }
  /**
  @internal
  */
  isDone(upto) {
    upto = Math.min(upto, this.state.doc.length);
    let frags = this.fragments;
    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return currentContext;
  }
};
function cutFragments(fragments, from, to) {
  return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
}
var LanguageState = class _LanguageState {
  constructor(context) {
    this.context = context;
    this.tree = context.tree;
  }
  apply(tr) {
    if (!tr.docChanged && this.tree == this.context.tree)
      return this;
    let newCx = this.context.changes(tr.changes, tr.state);
    let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
    if (!newCx.work(20, upto))
      newCx.takeTree();
    return new _LanguageState(newCx);
  }
  static init(state) {
    let vpTo = Math.min(3e3, state.doc.length);
    let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
    if (!parseState.work(20, vpTo))
      parseState.takeTree();
    return new _LanguageState(parseState);
  }
};
Language.state = /* @__PURE__ */ StateField.define({
  create: LanguageState.init,
  update(value, tr) {
    for (let e of tr.effects)
      if (e.is(Language.setState))
        return e.value;
    if (tr.startState.facet(language) != tr.state.facet(language))
      return LanguageState.init(tr.state);
    return value.apply(tr);
  }
});
var requestIdle = (callback) => {
  let timeout = setTimeout(
    () => callback(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined")
  requestIdle = (callback) => {
    let idle = -1, timeout = setTimeout(
      () => {
        idle = requestIdleCallback(callback, {
          timeout: 500 - 100
          /* Work.MinPause */
        });
      },
      100
      /* Work.MinPause */
    );
    return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
  };
var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
  constructor(view) {
    this.view = view;
    this.working = null;
    this.workScheduled = 0;
    this.chunkEnd = -1;
    this.chunkBudget = -1;
    this.work = this.work.bind(this);
    this.scheduleWork();
  }
  update(update) {
    let cx = this.view.state.field(Language.state).context;
    if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
      this.scheduleWork();
    if (update.docChanged) {
      if (this.view.hasFocus)
        this.chunkBudget += 50;
      this.scheduleWork();
    }
    this.checkAsyncSchedule(cx);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state } = this.view, field = state.field(Language.state);
    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
      this.working = requestIdle(this.work);
  }
  work(deadline) {
    this.working = null;
    let now = Date.now();
    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
      this.chunkEnd = now + 3e4;
      this.chunkBudget = 3e3;
    }
    if (this.chunkBudget <= 0)
      return;
    let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
    if (field.tree == field.context.tree && field.context.isDone(
      vpTo + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
    let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
    let done = field.context.work(() => {
      return isInputPending && isInputPending() || Date.now() > endTime;
    }, vpTo + (viewportFirst ? 0 : 1e5));
    this.chunkBudget -= Date.now() - now;
    if (done || this.chunkBudget <= 0) {
      field.context.takeTree();
      this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
    }
    if (this.chunkBudget > 0 && !(done && !viewportFirst))
      this.scheduleWork();
    this.checkAsyncSchedule(field.context);
  }
  checkAsyncSchedule(cx) {
    if (cx.scheduleOn) {
      this.workScheduled++;
      cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
      cx.scheduleOn = null;
    }
  }
  destroy() {
    if (this.working)
      this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
});
var language = /* @__PURE__ */ Facet.define({
  combine(languages) {
    return languages.length ? languages[0] : null;
  },
  enables: (language2) => [
    Language.state,
    parseWorker,
    EditorView.contentAttributes.compute([language2], (state) => {
      let lang = state.facet(language2);
      return lang && lang.name ? { "data-language": lang.name } : {};
    })
  ]
});
var LanguageSupport = class {
  /**
  Create a language support object.
  */
  constructor(language2, support = []) {
    this.language = language2;
    this.support = support;
    this.extension = [language2, support];
  }
};
var indentService = /* @__PURE__ */ Facet.define();
var indentUnit = /* @__PURE__ */ Facet.define({
  combine: (values) => {
    if (!values.length)
      return "  ";
    let unit = values[0];
    if (!unit || /\S/.test(unit) || Array.from(unit).some((e) => e != unit[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
    return unit;
  }
});
function getIndentUnit(state) {
  let unit = state.facet(indentUnit);
  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
function indentString(state, cols) {
  let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
  if (ch == "	") {
    while (cols >= ts) {
      result += "	";
      cols -= ts;
    }
    ch = " ";
  }
  for (let i = 0; i < cols; i++)
    result += ch;
  return result;
}
function getIndentation(context, pos) {
  if (context instanceof EditorState)
    context = new IndentContext(context);
  for (let service of context.state.facet(indentService)) {
    let result = service(context, pos);
    if (result !== void 0)
      return result;
  }
  let tree = syntaxTree(context.state);
  return tree ? syntaxIndentation(context, tree, pos) : null;
}
var IndentContext = class {
  /**
  Create an indent context.
  */
  constructor(state, options = {}) {
    this.state = state;
    this.options = options;
    this.unit = getIndentUnit(state);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(pos, bias = 1) {
    let line = this.state.doc.lineAt(pos);
    let { simulateBreak, simulateDoubleBreak } = this.options;
    if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
      if (simulateDoubleBreak && simulateBreak == pos)
        return { text: "", from: pos };
      else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
        return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
      else
        return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
    }
    return line;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(pos, bias = 1) {
    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
      return "";
    let { text, from } = this.lineAt(pos, bias);
    return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
  }
  /**
  Find the column for the given position.
  */
  column(pos, bias = 1) {
    let { text, from } = this.lineAt(pos, bias);
    let result = this.countColumn(text, pos - from);
    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
    if (override > -1)
      result += override - this.countColumn(text, text.search(/\S|$/));
    return result;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(line, pos = line.length) {
    return countColumn(line, this.state.tabSize, pos);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(pos, bias = 1) {
    let { text, from } = this.lineAt(pos, bias);
    let override = this.options.overrideIndentation;
    if (override) {
      let overriden = override(from);
      if (overriden > -1)
        return overriden;
    }
    return this.countColumn(text, text.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
};
var indentNodeProp = /* @__PURE__ */ new NodeProp();
function syntaxIndentation(cx, ast, pos) {
  return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
}
function ignoreClosed(cx) {
  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
  let strategy = tree.type.prop(indentNodeProp);
  if (strategy)
    return strategy;
  let first = tree.firstChild, close;
  if (first && (close = first.type.prop(NodeProp.closedBy))) {
    let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
    return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
  }
  return tree.parent == null ? topIndent : null;
}
function indentFrom(node, pos, base2) {
  for (; node; node = node.parent) {
    let strategy = indentStrategy(node);
    if (strategy)
      return strategy(TreeIndentContext.create(base2, pos, node));
  }
  return null;
}
function topIndent() {
  return 0;
}
var TreeIndentContext = class _TreeIndentContext extends IndentContext {
  constructor(base2, pos, node) {
    super(base2.state, base2.options);
    this.base = base2;
    this.pos = pos;
    this.node = node;
  }
  /**
  @internal
  */
  static create(base2, pos, node) {
    return new _TreeIndentContext(base2, pos, node);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    let line = this.state.doc.lineAt(this.node.from);
    for (; ; ) {
      let atBreak = this.node.resolve(line.from);
      while (atBreak.parent && atBreak.parent.from == atBreak.from)
        atBreak = atBreak.parent;
      if (isParent(atBreak, this.node))
        break;
      line = this.state.doc.lineAt(atBreak.from);
    }
    return this.lineIndent(line.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    let parent = this.node.parent;
    return parent ? indentFrom(parent, this.pos, this.base) : 0;
  }
};
function isParent(parent, of) {
  for (let cur2 = of; cur2; cur2 = cur2.parent)
    if (parent == cur2)
      return true;
  return false;
}
function bracketedAligned(context) {
  let tree = context.node;
  let openToken = tree.childAfter(tree.from), last = tree.lastChild;
  if (!openToken)
    return null;
  let sim = context.options.simulateBreak;
  let openLine = context.state.doc.lineAt(openToken.from);
  let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
  for (let pos = openToken.to; ; ) {
    let next = tree.childAfter(pos);
    if (!next || next == last)
      return null;
    if (!next.type.isSkipped)
      return next.from < lineEnd ? openToken : null;
    pos = next.to;
  }
}
function delimitedStrategy(context, align, units, closing2, closedAt) {
  let after = context.textAfter, space = after.match(/^\s*/)[0].length;
  let closed = closing2 && after.slice(space, space + closing2.length) == closing2 || closedAt == context.pos + space;
  let aligned = align ? bracketedAligned(context) : null;
  if (aligned)
    return closed ? context.column(aligned.from) : context.column(aligned.to);
  return context.baseIndent + (closed ? 0 : context.unit * units);
}
var DontIndentBeyond = 200;
function indentOnInput() {
  return EditorState.transactionFilter.of((tr) => {
    if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
      return tr;
    let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
    if (!rules.length)
      return tr;
    let doc2 = tr.newDoc, { head } = tr.newSelection.main, line = doc2.lineAt(head);
    if (head > line.from + DontIndentBeyond)
      return tr;
    let lineStart = doc2.sliceString(line.from, head);
    if (!rules.some((r) => r.test(lineStart)))
      return tr;
    let { state } = tr, last = -1, changes = [];
    for (let { head: head2 } of state.selection.ranges) {
      let line2 = state.doc.lineAt(head2);
      if (line2.from == last)
        continue;
      last = line2.from;
      let indent = getIndentation(state, line2.from);
      if (indent == null)
        continue;
      let cur2 = /^\s*/.exec(line2.text)[0];
      let norm = indentString(state, indent);
      if (cur2 != norm)
        changes.push({ from: line2.from, to: line2.from + cur2.length, insert: norm });
    }
    return changes.length ? [tr, { changes, sequential: true }] : tr;
  });
}
var foldService = /* @__PURE__ */ Facet.define();
var foldNodeProp = /* @__PURE__ */ new NodeProp();
function syntaxFolding(state, start, end) {
  let tree = syntaxTree(state);
  if (tree.length < end)
    return null;
  let inner = tree.resolveInner(end, 1);
  let found = null;
  for (let cur2 = inner; cur2; cur2 = cur2.parent) {
    if (cur2.to <= end || cur2.from > end)
      continue;
    if (found && cur2.from < start)
      break;
    let prop = cur2.type.prop(foldNodeProp);
    if (prop && (cur2.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur2))) {
      let value = prop(cur2, state);
      if (value && value.from <= end && value.from >= start && value.to > end)
        found = value;
    }
  }
  return found;
}
function isUnfinished(node) {
  let ch = node.lastChild;
  return ch && ch.to == node.to && ch.type.isError;
}
function foldable(state, lineStart, lineEnd) {
  for (let service of state.facet(foldService)) {
    let result = service(state, lineStart, lineEnd);
    if (result)
      return result;
  }
  return syntaxFolding(state, lineStart, lineEnd);
}
function mapRange(range, mapping) {
  let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
  return from >= to ? void 0 : { from, to };
}
var foldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
var unfoldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
function selectedLines(view) {
  let lines = [];
  for (let { head } of view.state.selection.ranges) {
    if (lines.some((l) => l.from <= head && l.to >= head))
      continue;
    lines.push(view.lineBlockAt(head));
  }
  return lines;
}
var foldState = /* @__PURE__ */ StateField.define({
  create() {
    return Decoration.none;
  },
  update(folded, tr) {
    folded = folded.map(tr.changes);
    for (let e of tr.effects) {
      if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to))
        folded = folded.update({ add: [foldWidget.range(e.value.from, e.value.to)] });
      else if (e.is(unfoldEffect))
        folded = folded.update({
          filter: (from, to) => e.value.from != from || e.value.to != to,
          filterFrom: e.value.from,
          filterTo: e.value.to
        });
    }
    if (tr.selection) {
      let onSelection = false, { head } = tr.selection.main;
      folded.between(head, head, (a, b) => {
        if (a < head && b > head)
          onSelection = true;
      });
      if (onSelection)
        folded = folded.update({
          filterFrom: head,
          filterTo: head,
          filter: (a, b) => b <= head || a >= head
        });
    }
    return folded;
  },
  provide: (f) => EditorView.decorations.from(f),
  toJSON(folded, state) {
    let ranges = [];
    folded.between(0, state.doc.length, (from, to) => {
      ranges.push(from, to);
    });
    return ranges;
  },
  fromJSON(value) {
    if (!Array.isArray(value) || value.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let ranges = [];
    for (let i = 0; i < value.length; ) {
      let from = value[i++], to = value[i++];
      if (typeof from != "number" || typeof to != "number")
        throw new RangeError("Invalid JSON for fold state");
      ranges.push(foldWidget.range(from, to));
    }
    return Decoration.set(ranges, true);
  }
});
function findFold(state, from, to) {
  var _a2;
  let found = null;
  (_a2 = state.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from, to, (from2, to2) => {
    if (!found || found.from > from2)
      found = { from: from2, to: to2 };
  });
  return found;
}
function foldExists(folded, from, to) {
  let found = false;
  folded.between(from, from, (a, b) => {
    if (a == from && b == to)
      found = true;
  });
  return found;
}
function maybeEnable(state, other) {
  return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
}
var foldCode = (view) => {
  for (let line of selectedLines(view)) {
    let range = foldable(view.state, line.from, line.to);
    if (range) {
      view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });
      return true;
    }
  }
  return false;
};
var unfoldCode = (view) => {
  if (!view.state.field(foldState, false))
    return false;
  let effects = [];
  for (let line of selectedLines(view)) {
    let folded = findFold(view.state, line.from, line.to);
    if (folded)
      effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
  }
  if (effects.length)
    view.dispatch({ effects });
  return effects.length > 0;
};
function announceFold(view, range, fold = true) {
  let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
  return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
var foldAll = (view) => {
  let { state } = view, effects = [];
  for (let pos = 0; pos < state.doc.length; ) {
    let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);
    if (range)
      effects.push(foldEffect.of(range));
    pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
  }
  if (effects.length)
    view.dispatch({ effects: maybeEnable(view.state, effects) });
  return !!effects.length;
};
var unfoldAll = (view) => {
  let field = view.state.field(foldState, false);
  if (!field || !field.size)
    return false;
  let effects = [];
  field.between(0, view.state.doc.length, (from, to) => {
    effects.push(unfoldEffect.of({ from, to }));
  });
  view.dispatch({ effects });
  return true;
};
var foldKeymap = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
  { key: "Ctrl-Alt-[", run: foldAll },
  { key: "Ctrl-Alt-]", run: unfoldAll }
];
var defaultConfig = {
  placeholderDOM: null,
  placeholderText: "\u2026"
};
var foldConfig = /* @__PURE__ */ Facet.define({
  combine(values) {
    return combineConfig(values, defaultConfig);
  }
});
function codeFolding(config2) {
  let result = [foldState, baseTheme$12];
  if (config2)
    result.push(foldConfig.of(config2));
  return result;
}
var foldWidget = /* @__PURE__ */ Decoration.replace({ widget: /* @__PURE__ */ new class extends WidgetType {
  toDOM(view) {
    let { state } = view, conf = state.facet(foldConfig);
    let onclick = (event) => {
      let line = view.lineBlockAt(view.posAtDOM(event.target));
      let folded = findFold(view.state, line.from, line.to);
      if (folded)
        view.dispatch({ effects: unfoldEffect.of(folded) });
      event.preventDefault();
    };
    if (conf.placeholderDOM)
      return conf.placeholderDOM(view, onclick);
    let element = document.createElement("span");
    element.textContent = conf.placeholderText;
    element.setAttribute("aria-label", state.phrase("folded code"));
    element.title = state.phrase("unfold");
    element.className = "cm-foldPlaceholder";
    element.onclick = onclick;
    return element;
  }
}() });
var foldGutterDefaults = {
  openText: "\u2304",
  closedText: "\u203A",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => false
};
var FoldMarker = class extends GutterMarker {
  constructor(config2, open) {
    super();
    this.config = config2;
    this.open = open;
  }
  eq(other) {
    return this.config == other.config && this.open == other.open;
  }
  toDOM(view) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let span = document.createElement("span");
    span.textContent = this.open ? this.config.openText : this.config.closedText;
    span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
    return span;
  }
};
function foldGutter(config2 = {}) {
  let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config2);
  let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
  let markers = ViewPlugin.fromClass(class {
    constructor(view) {
      this.from = view.viewport.from;
      this.markers = this.buildMarkers(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update))
        this.markers = this.buildMarkers(update.view);
    }
    buildMarkers(view) {
      let builder = new RangeSetBuilder();
      for (let line of view.viewportLineBlocks) {
        let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
        if (mark)
          builder.add(line.from, line.from, mark);
      }
      return builder.finish();
    }
  });
  let { domEventHandlers } = fullConfig;
  return [
    markers,
    gutter({
      class: "cm-foldGutter",
      markers(view) {
        var _a2;
        return ((_a2 = view.plugin(markers)) === null || _a2 === void 0 ? void 0 : _a2.markers) || RangeSet.empty;
      },
      initialSpacer() {
        return new FoldMarker(fullConfig, false);
      },
      domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view, line, event) => {
        if (domEventHandlers.click && domEventHandlers.click(view, line, event))
          return true;
        let folded = findFold(view.state, line.from, line.to);
        if (folded) {
          view.dispatch({ effects: unfoldEffect.of(folded) });
          return true;
        }
        let range = foldable(view.state, line.from, line.to);
        if (range) {
          view.dispatch({ effects: foldEffect.of(range) });
          return true;
        }
        return false;
      } })
    }),
    codeFolding()
  ];
}
var baseTheme$12 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
var HighlightStyle = class _HighlightStyle {
  constructor(specs, options) {
    this.specs = specs;
    let modSpec;
    function def(spec) {
      let cls = StyleModule.newName();
      (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
      return cls;
    }
    const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
    const scopeOpt = options.scope;
    this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
    this.style = tagHighlighter(specs.map((style) => ({
      tag: style.tag,
      class: style.class || def(Object.assign({}, style, { tag: null }))
    })), {
      all
    }).style;
    this.module = modSpec ? new StyleModule(modSpec) : null;
    this.themeType = options.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(specs, options) {
    return new _HighlightStyle(specs, options || {});
  }
};
var highlighterFacet = /* @__PURE__ */ Facet.define();
var fallbackHighlighter = /* @__PURE__ */ Facet.define({
  combine(values) {
    return values.length ? [values[0]] : null;
  }
});
function getHighlighters(state) {
  let main = state.facet(highlighterFacet);
  return main.length ? main : state.facet(fallbackHighlighter);
}
function syntaxHighlighting(highlighter, options) {
  let ext = [treeHighlighter], themeType;
  if (highlighter instanceof HighlightStyle) {
    if (highlighter.module)
      ext.push(EditorView.styleModule.of(highlighter.module));
    themeType = highlighter.themeType;
  }
  if (options === null || options === void 0 ? void 0 : options.fallback)
    ext.push(fallbackHighlighter.of(highlighter));
  else if (themeType)
    ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
      return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
    }));
  else
    ext.push(highlighterFacet.of(highlighter));
  return ext;
}
var TreeHighlighter = class {
  constructor(view) {
    this.markCache = /* @__PURE__ */ Object.create(null);
    this.tree = syntaxTree(view.state);
    this.decorations = this.buildDeco(view, getHighlighters(view.state));
  }
  update(update) {
    let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
    let styleChange = highlighters != getHighlighters(update.startState);
    if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
      this.decorations = this.decorations.map(update.changes);
    } else if (tree != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree;
      this.decorations = this.buildDeco(update.view, highlighters);
    }
  }
  buildDeco(view, highlighters) {
    if (!highlighters || !this.tree.length)
      return Decoration.none;
    let builder = new RangeSetBuilder();
    for (let { from, to } of view.visibleRanges) {
      highlightTree(this.tree, highlighters, (from2, to2, style) => {
        builder.add(from2, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
      }, from, to);
    }
    return builder.finish();
  }
};
var treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
  decorations: (v) => v.decorations
}));
var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
  {
    tag: tags.meta,
    color: "#404740"
  },
  {
    tag: tags.link,
    textDecoration: "underline"
  },
  {
    tag: tags.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: tags.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags.strong,
    fontWeight: "bold"
  },
  {
    tag: tags.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags.keyword,
    color: "#708"
  },
  {
    tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
    color: "#219"
  },
  {
    tag: [tags.literal, tags.inserted],
    color: "#164"
  },
  {
    tag: [tags.string, tags.deleted],
    color: "#a11"
  },
  {
    tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ tags.definition(tags.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ tags.local(tags.variableName),
    color: "#30a"
  },
  {
    tag: [tags.typeName, tags.namespace],
    color: "#085"
  },
  {
    tag: tags.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ tags.definition(tags.propertyName),
    color: "#00c"
  },
  {
    tag: tags.comment,
    color: "#940"
  },
  {
    tag: tags.invalid,
    color: "#f00"
  }
]);
var baseTheme2 = /* @__PURE__ */ EditorView.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
var DefaultScanDist = 1e4;
var DefaultBrackets = "()[]{}";
var bracketMatchingConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      afterCursor: true,
      brackets: DefaultBrackets,
      maxScanDistance: DefaultScanDist,
      renderMatch: defaultRenderMatch
    });
  }
});
var matchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-matchingBracket" });
var nonmatchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-nonmatchingBracket" });
function defaultRenderMatch(match) {
  let decorations2 = [];
  let mark = match.matched ? matchingMark : nonmatchingMark;
  decorations2.push(mark.range(match.start.from, match.start.to));
  if (match.end)
    decorations2.push(mark.range(match.end.from, match.end.to));
  return decorations2;
}
var bracketMatchingState = /* @__PURE__ */ StateField.define({
  create() {
    return Decoration.none;
  },
  update(deco, tr) {
    if (!tr.docChanged && !tr.selection)
      return deco;
    let decorations2 = [];
    let config2 = tr.state.facet(bracketMatchingConfig);
    for (let range of tr.state.selection.ranges) {
      if (!range.empty)
        continue;
      let match = matchBrackets(tr.state, range.head, -1, config2) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr.state, range.head, 1, config2) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config2));
      if (match)
        decorations2 = decorations2.concat(config2.renderMatch(match, tr.state));
    }
    return Decoration.set(decorations2, true);
  },
  provide: (f) => EditorView.decorations.from(f)
});
var bracketMatchingUnique = [
  bracketMatchingState,
  baseTheme2
];
function bracketMatching(config2 = {}) {
  return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
}
var bracketMatchingHandle = /* @__PURE__ */ new NodeProp();
function matchingNodes(node, dir, brackets) {
  let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
  if (byProp)
    return byProp;
  if (node.name.length == 1) {
    let index = brackets.indexOf(node.name);
    if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
      return [brackets[index + dir]];
  }
  return null;
}
function findHandle(node) {
  let hasHandle = node.type.prop(bracketMatchingHandle);
  return hasHandle ? hasHandle(node.node) : node;
}
function matchBrackets(state, pos, dir, config2 = {}) {
  let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
  let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
  for (let cur2 = node; cur2; cur2 = cur2.parent) {
    let matches = matchingNodes(cur2.type, dir, brackets);
    if (matches && cur2.from < cur2.to) {
      let handle = findHandle(cur2);
      if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
        return matchMarkedBrackets(state, pos, dir, cur2, handle, matches, brackets);
    }
  }
  return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
  let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
  let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
  if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
    do {
      if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
        if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
          let endHandle = findHandle(cursor);
          return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0, matched: true };
        } else if (matchingNodes(cursor.type, dir, brackets)) {
          depth++;
        } else if (matchingNodes(cursor.type, -dir, brackets)) {
          if (depth == 0) {
            let endHandle = findHandle(cursor);
            return {
              start: firstToken,
              end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : void 0,
              matched: false
            };
          }
          depth--;
        }
      }
    } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
  return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
  let bracket2 = brackets.indexOf(startCh);
  if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
    return null;
  let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
  for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
    let text = iter.value;
    if (dir < 0)
      distance += text.length;
    let basePos = pos + distance * dir;
    for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
      let found = brackets.indexOf(text[pos2]);
      if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
        continue;
      if (found % 2 == 0 == dir > 0) {
        depth++;
      } else if (depth == 1) {
        return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
      } else {
        depth--;
      }
    }
    if (dir > 0)
      distance += text.length;
  }
  return iter.done ? { start: startToken, matched: false } : null;
}
var noTokens = /* @__PURE__ */ Object.create(null);
var typeArray = [NodeType.none];
var warned = [];
var defaultTable = /* @__PURE__ */ Object.create(null);
for (let [legacyName, name2] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2);
function warnForPart(part, msg) {
  if (warned.indexOf(part) > -1)
    return;
  warned.push(part);
  console.warn(msg);
}
function createTokenType(extra, tagStr) {
  let tag = null;
  for (let part of tagStr.split(".")) {
    let value = extra[part] || tags[part];
    if (!value) {
      warnForPart(part, `Unknown highlighting tag ${part}`);
    } else if (typeof value == "function") {
      if (!tag)
        warnForPart(part, `Modifier ${part} used at start of tag`);
      else
        tag = value(tag);
    } else {
      if (tag)
        warnForPart(part, `Tag ${part} used as modifier`);
      else
        tag = value;
    }
  }
  if (!tag)
    return 0;
  let name2 = tagStr.replace(/ /g, "_"), type = NodeType.define({
    id: typeArray.length,
    name: name2,
    props: [styleTags({ [name2]: tag })]
  });
  typeArray.push(type);
  return type.id;
}

// node_modules/@codemirror/commands/dist/index.js
var toggleComment = (target) => {
  let { state } = target, line = state.doc.lineAt(state.selection.main.head), config2 = getConfig(target.state, line.from);
  return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
};
function command(f, option) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let tr = f(option, state);
    if (!tr)
      return false;
    dispatch(state.update(tr));
    return true;
  };
}
var toggleLineComment = /* @__PURE__ */ command(
  changeLineComment,
  0
  /* CommentOption.Toggle */
);
var toggleBlockComment = /* @__PURE__ */ command(
  changeBlockComment,
  0
  /* CommentOption.Toggle */
);
var toggleBlockCommentByLine = /* @__PURE__ */ command(
  (o, s) => changeBlockComment(o, s, selectedLineRanges(s)),
  0
  /* CommentOption.Toggle */
);
function getConfig(state, pos) {
  let data = state.languageDataAt("commentTokens", pos);
  return data.length ? data[0] : {};
}
var SearchMargin = 50;
function findBlockComment(state, { open, close }, from, to) {
  let textBefore = state.sliceDoc(from - SearchMargin, from);
  let textAfter = state.sliceDoc(to, to + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
      close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
    };
  }
  let startText, endText;
  if (to - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to);
  } else {
    startText = state.sliceDoc(from, from + SearchMargin);
    endText = state.sliceDoc(to - SearchMargin, to);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges = [];
  for (let r of state.selection.ranges) {
    let fromLine = state.doc.lineAt(r.from);
    let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last].to > fromLine.from)
      ranges[last].to = toLine.to;
    else
      ranges.push({ from: fromLine.from, to: toLine.to });
  }
  return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
  let tokens = ranges.map((r) => getConfig(state, r.from).block);
  if (!tokens.every((c) => c))
    return null;
  let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
  if (option != 2 && !comments.every((c) => c)) {
    return { changes: state.changes(ranges.map((range, i) => {
      if (comments[i])
        return [];
      return [{ from: range.from, insert: tokens[i].open + " " }, { from: range.to, insert: " " + tokens[i].close }];
    })) };
  } else if (option != 1 && comments.some((c) => c)) {
    let changes = [];
    for (let i = 0, comment2; i < comments.length; i++)
      if (comment2 = comments[i]) {
        let token = tokens[i], { open, close } = comment2;
        changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
      }
    return { changes };
  }
  return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
  let lines = [];
  let prevLine = -1;
  for (let { from, to } of ranges) {
    let startI = lines.length, minIndent = 1e9;
    for (let pos = from; pos <= to; ) {
      let line = state.doc.lineAt(pos);
      if (line.from > prevLine && (from == to || to > line.from)) {
        prevLine = line.from;
        let token = getConfig(state, line.from).line;
        if (!token)
          continue;
        let indent = /^\s*/.exec(line.text)[0].length;
        let empty2 = indent == line.length;
        let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
        if (indent < line.text.length && indent < minIndent)
          minIndent = indent;
        lines.push({ line, comment: comment2, token, indent, empty: empty2, single: false });
      }
      pos = line.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i = startI; i < lines.length; i++)
        if (lines[i].indent < lines[i].line.text.length)
          lines[i].indent = minIndent;
    }
    if (lines.length == startI + 1)
      lines[startI].single = true;
  }
  if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
    let changes = [];
    for (let { line, token, indent, empty: empty2, single } of lines)
      if (single || !empty2)
        changes.push({ from: line.from + indent, insert: token + " " });
    let changeSet = state.changes(changes);
    return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
  } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
    let changes = [];
    for (let { line, comment: comment2, token } of lines)
      if (comment2 >= 0) {
        let from = line.from + comment2, to = from + token.length;
        if (line.text[to - line.from] == " ")
          to++;
        changes.push({ from, to });
      }
    return { changes };
  }
  return null;
}
var fromHistory = /* @__PURE__ */ Annotation.define();
var isolateHistory = /* @__PURE__ */ Annotation.define();
var invertedEffects = /* @__PURE__ */ Facet.define();
var historyConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (_t, isAdjacent2) => isAdjacent2
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)
    });
  }
});
function changeEnd(changes) {
  let end = 0;
  changes.iterChangedRanges((_, to) => end = to);
  return end;
}
var historyField_ = /* @__PURE__ */ StateField.define({
  create() {
    return HistoryState.empty;
  },
  update(state, tr) {
    let config2 = tr.state.facet(historyConfig);
    let fromHist = tr.annotation(fromHistory);
    if (fromHist) {
      let selection = tr.docChanged ? EditorSelection.single(changeEnd(tr.changes)) : void 0;
      let item = HistEvent.fromTransaction(tr, selection), from = fromHist.side;
      let other = from == 0 ? state.undone : state.done;
      if (item)
        other = updateBranch(other, other.length, config2.minDepth, item);
      else
        other = addSelection(other, tr.startState.selection);
      return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
    }
    let isolate = tr.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before")
      state = state.isolate();
    if (tr.annotation(Transaction.addToHistory) === false)
      return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
    let event = HistEvent.fromTransaction(tr);
    let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
    if (event)
      state = state.addChanges(event, time, userEvent, config2, tr);
    else if (tr.selection)
      state = state.addSelection(tr.startState.selection, time, userEvent, config2.newGroupDelay);
    if (isolate == "full" || isolate == "after")
      state = state.isolate();
    return state;
  },
  toJSON(value) {
    return { done: value.done.map((e) => e.toJSON()), undone: value.undone.map((e) => e.toJSON()) };
  },
  fromJSON(json) {
    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
  }
});
function history(config2 = {}) {
  return [
    historyField_,
    historyConfig.of(config2),
    EditorView.domEventHandlers({
      beforeinput(e, view) {
        let command2 = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
        if (!command2)
          return false;
        e.preventDefault();
        return command2(view);
      }
    })
  ];
}
function cmd(side, selection) {
  return function({ state, dispatch }) {
    if (!selection && state.readOnly)
      return false;
    let historyState = state.field(historyField_, false);
    if (!historyState)
      return false;
    let tr = historyState.pop(side, state, selection);
    if (!tr)
      return false;
    dispatch(tr);
    return true;
  };
}
var undo = /* @__PURE__ */ cmd(0, false);
var redo = /* @__PURE__ */ cmd(1, false);
var undoSelection = /* @__PURE__ */ cmd(0, true);
var redoSelection = /* @__PURE__ */ cmd(1, true);
var HistEvent = class _HistEvent {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }
  setSelAfter(after) {
    return new _HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
  }
  toJSON() {
    var _a2, _b, _c;
    return {
      changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
    };
  }
  static fromJSON(json) {
    return new _HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(tr, selection) {
    let effects = none2;
    for (let invert of tr.startState.facet(invertedEffects)) {
      let result = invert(tr);
      if (result.length)
        effects = effects.concat(result);
    }
    if (!effects.length && tr.changes.empty)
      return null;
    return new _HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection || tr.startState.selection, none2);
  }
  static selection(selections) {
    return new _HistEvent(void 0, none2, void 0, void 0, selections);
  }
};
function updateBranch(branch, to, maxLen, newEvent) {
  let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
  let newBranch = branch.slice(start, to);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a, b) {
  let ranges = [], isAdjacent2 = false;
  a.iterChangedRanges((f, t2) => ranges.push(f, t2));
  b.iterChangedRanges((_f, _t, f, t2) => {
    for (let i = 0; i < ranges.length; ) {
      let from = ranges[i++], to = ranges[i++];
      if (t2 >= from && f <= to)
        isAdjacent2 = true;
    }
  });
  return isAdjacent2;
}
function eqSelectionShape(a, b) {
  return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
}
function conc(a, b) {
  return !a.length ? b : !b.length ? a : a.concat(b);
}
var none2 = [];
var MaxSelectionsPerEvent = 200;
function addSelection(branch, selection) {
  if (!branch.length) {
    return [HistEvent.selection([selection])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection))
      return branch;
    sels.push(selection);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch) {
  let last = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length)
    return branch;
  let length = branch.length, selections = none2;
  while (length) {
    let event = mapEvent(branch[length - 1], mapping, selections);
    if (event.changes && !event.changes.empty || event.effects.length) {
      let result = branch.slice(0, length);
      result[length - 1] = event;
      return result;
    } else {
      mapping = event.mapped;
      length--;
      selections = event.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none2;
}
function mapEvent(event, mapping, extraSelections) {
  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none2, extraSelections);
  if (!event.changes)
    return HistEvent.selection(selections);
  let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
var joinableUserEvent = /^(input\.type|delete)($|\.)/;
var HistoryState = class _HistoryState {
  constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
    this.done = done;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }
  isolate() {
    return this.prevTime ? new _HistoryState(this.done, this.undone) : this;
  }
  addChanges(event, time, userEvent, config2, tr) {
    let done = this.done, lastEvent = done[done.length - 1];
    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config2.newGroupDelay && config2.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event
    userEvent == "input.type.compose")) {
      done = updateBranch(done, done.length - 1, config2.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none2));
    } else {
      done = updateBranch(done, done.length, config2.minDepth, event);
    }
    return new _HistoryState(done, none2, time, userEvent);
  }
  addSelection(selection, time, userEvent, newGroupDelay) {
    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none2;
    if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection))
      return this;
    return new _HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
  }
  addMapping(mapping) {
    return new _HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }
  pop(side, state, selection) {
    let branch = side == 0 ? this.done : this.undone;
    if (branch.length == 0)
      return null;
    let event = branch[branch.length - 1];
    if (selection && event.selectionsAfter.length) {
      return state.update({
        selection: event.selectionsAfter[event.selectionsAfter.length - 1],
        annotations: fromHistory.of({ side, rest: popSelection(branch) }),
        userEvent: side == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    } else if (!event.changes) {
      return null;
    } else {
      let rest = branch.length == 1 ? none2 : branch.slice(0, branch.length - 1);
      if (event.mapped)
        rest = addMappingToBranch(rest, event.mapped);
      return state.update({
        changes: event.changes,
        selection: event.startSelection,
        effects: event.effects,
        annotations: fromHistory.of({ side, rest }),
        filter: false,
        userEvent: side == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    }
  }
};
HistoryState.empty = /* @__PURE__ */ new HistoryState(none2, none2);
var historyKeymap = [
  { key: "Mod-z", run: undo, preventDefault: true },
  { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
  { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
  { key: "Mod-u", run: undoSelection, preventDefault: true },
  { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection) {
  return state.update({ selection, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
  let selection = updateSel(state.selection, how);
  if (selection.eq(state.selection))
    return false;
  dispatch(setSel(state, selection));
  return true;
}
function rangeEnd(range, forward) {
  return EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
function cursorByGroup(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
function interestingNode(state, node, bracketProp) {
  if (node.type.prop(bracketProp))
    return true;
  let len = node.to - node.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
  let pos = syntaxTree(state).resolveInner(start.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at = start.head; ; ) {
    let next = forward ? pos.childAfter(at) : pos.childBefore(at);
    if (!next)
      break;
    if (interestingNode(state, next, bracketProp))
      pos = next;
    else
      at = forward ? next.to : next.from;
  }
  let bracket2 = pos.type.prop(bracketProp), match, newPos;
  if (bracket2 && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
    newPos = forward ? match.end.to : match.end.from;
  else
    newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
var cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
  return moveSel(view, (range) => {
    if (!range.empty)
      return rangeEnd(range, forward);
    let moved = view.moveVertically(range, forward);
    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
  });
}
var cursorLineUp = (view) => cursorByLine(view, false);
var cursorLineDown = (view) => cursorByLine(view, true);
function pageInfo(view) {
  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
  let marginTop = 0, marginBottom = 0, height;
  if (selfScroll) {
    for (let source of view.state.facet(EditorView.scrollMargins)) {
      let margins = source(view);
      if (margins === null || margins === void 0 ? void 0 : margins.top)
        marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
      if (margins === null || margins === void 0 ? void 0 : margins.bottom)
        marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
    }
    height = view.scrollDOM.clientHeight - marginTop - marginBottom;
  } else {
    height = (view.dom.ownerDocument.defaultView || window).innerHeight;
  }
  return {
    marginTop,
    marginBottom,
    selfScroll,
    height: Math.max(view.defaultLineHeight, height - 5)
  };
}
function cursorByPage(view, forward) {
  let page = pageInfo(view);
  let { state } = view, selection = updateSel(state.selection, (range) => {
    return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
  });
  if (selection.eq(state.selection))
    return false;
  let effect;
  if (page.selfScroll) {
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
      effect = EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollTop });
  }
  view.dispatch(setSel(state, selection), { effects: effect });
  return true;
}
var cursorPageUp = (view) => cursorByPage(view, false);
var cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
  let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
    moved = view.moveToLineBoundary(start, forward, false);
  if (!forward && moved.head == line.from && line.length) {
    let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space && start.head != line.from + space)
      moved = EditorSelection.cursor(line.from + space);
  }
  return moved;
}
var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
var cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend2) {
  let found = false, selection = updateSel(state.selection, (range) => {
    let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
    if (!matching || !matching.end)
      return range;
    found = true;
    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
    return extend2 ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
  });
  if (!found)
    return false;
  dispatch(setSel(state, selection));
  return true;
}
var cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
function extendSel(view, how) {
  let selection = updateSel(view.state.selection, (range) => {
    let head = how(range);
    return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
  });
  if (selection.eq(view.state.selection))
    return false;
  view.dispatch(setSel(view.state, selection));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range) => view.moveByChar(range, forward));
}
var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
function selectByGroup(view, forward) {
  return extendSel(view, (range) => view.moveByGroup(range, forward));
}
var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
var selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward));
}
var selectLineUp = (view) => selectByLine(view, false);
var selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
}
var selectPageUp = (view) => selectByPage(view, false);
var selectPageDown = (view) => selectByPage(view, true);
var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
var selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
var cursorDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: 0 }));
  return true;
};
var cursorDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.doc.length }));
  return true;
};
var selectDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
  return true;
};
var selectDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
  return true;
};
var selectAll = ({ state, dispatch }) => {
  dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
  return true;
};
var selectLine = ({ state, dispatch }) => {
  let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
  dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
  return true;
};
var selectParentSyntax = ({ state, dispatch }) => {
  let selection = updateSel(state.selection, (range) => {
    var _a2;
    let context = syntaxTree(state).resolveInner(range.head, 1);
    while (!(context.from < range.from && context.to >= range.to || context.to > range.to && context.from <= range.from || !((_a2 = context.parent) === null || _a2 === void 0 ? void 0 : _a2.parent)))
      context = context.parent;
    return EditorSelection.range(context.to, context.from);
  });
  dispatch(setSel(state, selection));
  return true;
};
var simplifySelection = ({ state, dispatch }) => {
  let cur2 = state.selection, selection = null;
  if (cur2.ranges.length > 1)
    selection = EditorSelection.create([cur2.main]);
  else if (!cur2.main.empty)
    selection = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
  if (!selection)
    return false;
  dispatch(setSel(state, selection));
  return true;
};
function deleteBy(target, by) {
  if (target.state.readOnly)
    return false;
  let event = "delete.selection", { state } = target;
  let changes = state.changeByRange((range) => {
    let { from, to } = range;
    if (from == to) {
      let towards = by(from);
      if (towards < from) {
        event = "delete.backward";
        towards = skipAtomic(target, towards, false);
      } else if (towards > from) {
        event = "delete.forward";
        towards = skipAtomic(target, towards, true);
      }
      from = Math.min(from, towards);
      to = Math.max(to, towards);
    } else {
      from = skipAtomic(target, from, false);
      to = skipAtomic(target, to, true);
    }
    return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from) };
  });
  if (changes.changes.empty)
    return false;
  target.dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event,
    effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
  }));
  return true;
}
function skipAtomic(target, pos, forward) {
  if (target instanceof EditorView)
    for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
      ranges.between(pos, pos, (from, to) => {
        if (from < pos && to > pos)
          pos = forward ? to : from;
      });
  return pos;
}
var deleteByChar = (target, forward) => deleteBy(target, (pos) => {
  let { state } = target, line = state.doc.lineAt(pos), before, targetPos;
  if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
    if (before[before.length - 1] == "	")
      return pos - 1;
    let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
    for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
      pos--;
    targetPos = pos;
  } else {
    targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
      targetPos += forward ? 1 : -1;
  }
  return targetPos;
});
var deleteCharBackward = (view) => deleteByChar(view, false);
var deleteCharForward = (view) => deleteByChar(view, true);
var deleteByGroup = (target, forward) => deleteBy(target, (start) => {
  let pos = start, { state } = target, line = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null; ; ) {
    if (pos == (forward ? line.to : line.from)) {
      if (pos == start && line.number != (forward ? state.doc.lines : 1))
        pos += forward ? 1 : -1;
      break;
    }
    let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
    let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
    let nextCat = categorize(nextChar2);
    if (cat != null && nextCat != cat)
      break;
    if (nextChar2 != " " || pos != start)
      cat = nextCat;
    pos = next;
  }
  return pos;
});
var deleteGroupBackward = (target) => deleteByGroup(target, false);
var deleteGroupForward = (target) => deleteByGroup(target, true);
var deleteToLineEnd = (view) => deleteBy(view, (pos) => {
  let lineEnd = view.lineBlockAt(pos).to;
  return pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1);
});
var deleteToLineStart = (view) => deleteBy(view, (pos) => {
  let lineStart = view.lineBlockAt(pos).from;
  return pos > lineStart ? lineStart : Math.max(0, pos - 1);
});
var splitLine = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    return {
      changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
      range: EditorSelection.cursor(range.from)
    };
  });
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
var transposeChars = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    if (!range.empty || range.from == 0 || range.from == state.doc.length)
      return { range };
    let pos = range.from, line = state.doc.lineAt(pos);
    let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
    let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
    return {
      changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
      range: EditorSelection.cursor(to)
    };
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range of state.selection.ranges) {
    let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
    if (!range.empty && range.to == endLine.from)
      endLine = state.doc.lineAt(range.to - 1);
    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1];
      prev.to = endLine.to;
      prev.ranges.push(range);
    } else {
      blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [], ranges = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward ? block.to == state.doc.length : block.from == 0)
      continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    let size = nextLine.length + 1;
    if (forward) {
      changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
      for (let r of block.ranges)
        ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
    } else {
      changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
      for (let r of block.ranges)
        ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
    }
  }
  if (!changes.length)
    return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: EditorSelection.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
var moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
var moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward)
      changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
    else
      changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
  }
  dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
  return true;
}
var copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
var copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
var deleteLine = (view) => {
  if (view.state.readOnly)
    return false;
  let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
    if (from > 0)
      from--;
    else if (to < state.doc.length)
      to++;
    return { from, to };
  }));
  let selection = updateSel(state.selection, (range) => view.moveVertically(range, true)).map(changes);
  view.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
    return { from: pos, to: pos };
  let context = syntaxTree(state).resolveInner(pos);
  let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from)
    return { from: before.to, to: after.from };
  return null;
}
var insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
var insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
function newlineAndIndent(atEof) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      let { from, to } = range, line = state.doc.lineAt(from);
      let explode = !atEof && from == to && isBetweenBrackets(state, from);
      if (atEof)
        from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
      let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
      let indent = getIndentation(cx, from);
      if (indent == null)
        indent = /^\s*/.exec(state.doc.lineAt(from).text)[0].length;
      while (to < line.to && /\s/.test(line.text[to - line.from]))
        to++;
      if (explode)
        ({ from, to } = explode);
      else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
        from = line.from;
      let insert2 = ["", indentString(state, indent)];
      if (explode)
        insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
      return {
        changes: { from, to, insert: Text.of(insert2) },
        range: EditorSelection.cursor(from + 1 + insert2[1].length)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
}
function changeBySelectedLine(state, f) {
  let atLine = -1;
  return state.changeByRange((range) => {
    let changes = [];
    for (let pos = range.from; pos <= range.to; ) {
      let line = state.doc.lineAt(pos);
      if (line.number > atLine && (range.empty || range.to > line.from)) {
        f(line, changes, range);
        atLine = line.number;
      }
      pos = line.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
    };
  });
}
var indentSelection = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let updated = /* @__PURE__ */ Object.create(null);
  let context = new IndentContext(state, { overrideIndentation: (start) => {
    let found = updated[start];
    return found == null ? -1 : found;
  } });
  let changes = changeBySelectedLine(state, (line, changes2, range) => {
    let indent = getIndentation(context, line.from);
    if (indent == null)
      return;
    if (!/\S/.test(line.text))
      indent = 0;
    let cur2 = /^\s*/.exec(line.text)[0];
    let norm = indentString(state, indent);
    if (cur2 != norm || range.from < line.from + cur2.length) {
      updated[line.from] = indent;
      changes2.push({ from: line.from, to: line.from + cur2.length, insert: norm });
    }
  });
  if (!changes.changes.empty)
    dispatch(state.update(changes, { userEvent: "indent" }));
  return true;
};
var indentMore = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    changes.push({ from: line.from, insert: state.facet(indentUnit) });
  }), { userEvent: "input.indent" }));
  return true;
};
var indentLess = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    let space = /^\s*/.exec(line.text)[0];
    if (!space)
      return;
    let col = countColumn(space, state.tabSize), keep = 0;
    let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
    while (keep < space.length && keep < insert2.length && space.charCodeAt(keep) == insert2.charCodeAt(keep))
      keep++;
    changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert2.slice(keep) });
  }), { userEvent: "delete.dedent" }));
  return true;
};
var emacsStyleKeymap = [
  { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
  { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
  { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
  { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
  { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
  { key: "Ctrl-d", run: deleteCharForward },
  { key: "Ctrl-h", run: deleteCharBackward },
  { key: "Ctrl-k", run: deleteToLineEnd },
  { key: "Ctrl-Alt-h", run: deleteGroupBackward },
  { key: "Ctrl-o", run: splitLine },
  { key: "Ctrl-t", run: transposeChars },
  { key: "Ctrl-v", run: cursorPageDown }
];
var standardKeymap = /* @__PURE__ */ [
  { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
  { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
  { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
  { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
  { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
  { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
  { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
  { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
  { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
  { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
  { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
  { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
  { key: "Enter", run: insertNewlineAndIndent },
  { key: "Mod-a", run: selectAll },
  { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
  { key: "Delete", run: deleteCharForward },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
  { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
  { mac: "Mod-Backspace", run: deleteToLineStart },
  { mac: "Mod-Delete", run: deleteToLineEnd }
].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
var defaultKeymap = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
  { key: "Alt-ArrowUp", run: moveLineUp },
  { key: "Shift-Alt-ArrowUp", run: copyLineUp },
  { key: "Alt-ArrowDown", run: moveLineDown },
  { key: "Shift-Alt-ArrowDown", run: copyLineDown },
  { key: "Escape", run: simplifySelection },
  { key: "Mod-Enter", run: insertBlankLine },
  { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
  { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
  { key: "Mod-[", run: indentLess },
  { key: "Mod-]", run: indentMore },
  { key: "Mod-Alt-\\", run: indentSelection },
  { key: "Shift-Mod-k", run: deleteLine },
  { key: "Shift-Mod-\\", run: cursorMatchingBracket },
  { key: "Mod-/", run: toggleComment },
  { key: "Alt-A", run: toggleBlockComment }
].concat(standardKeymap);

// node_modules/crelt/index.es.js
function crelt() {
  var elt = arguments[0];
  if (typeof elt == "string")
    elt = document.createElement(elt);
  var i = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name2 in next)
      if (Object.prototype.hasOwnProperty.call(next, name2)) {
        var value = next[name2];
        if (typeof value == "string")
          elt.setAttribute(name2, value);
        else if (value != null)
          elt[name2] = value;
      }
    i++;
  }
  for (; i < arguments.length; i++)
    add(elt, arguments[i]);
  return elt;
}
function add(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child));
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++)
      add(elt, child[i]);
  } else {
    throw new RangeError("Unsupported child node: " + child);
  }
}

// node_modules/@codemirror/search/dist/index.js
var basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
var SearchCursor = class {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(text, query, from = 0, to = text.length, normalize, test) {
    this.test = test;
    this.value = { from: 0, to: 0 };
    this.done = false;
    this.matches = [];
    this.buffer = "";
    this.bufferPos = 0;
    this.iter = text.iterRange(from, to);
    this.bufferStart = from;
    this.normalize = normalize ? (x) => normalize(basicNormalize(x)) : basicNormalize;
    this.query = this.normalize(query);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      this.bufferStart += this.buffer.length;
      this.iter.next();
      if (this.iter.done)
        return -1;
      this.bufferPos = 0;
      this.buffer = this.iter.value;
    }
    return codePointAt(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    while (this.matches.length)
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let next = this.peek();
      if (next < 0) {
        this.done = true;
        return this;
      }
      let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
      this.bufferPos += codePointSize(next);
      let norm = this.normalize(str);
      for (let i = 0, pos = start; ; i++) {
        let code = norm.charCodeAt(i);
        let match = this.match(code, pos);
        if (match) {
          this.value = match;
          return this;
        }
        if (i == norm.length - 1)
          break;
        if (pos == start && i < str.length && str.charCodeAt(i) == code)
          pos++;
      }
    }
  }
  match(code, pos) {
    let match = null;
    for (let i = 0; i < this.matches.length; i += 2) {
      let index = this.matches[i], keep = false;
      if (this.query.charCodeAt(index) == code) {
        if (index == this.query.length - 1) {
          match = { from: this.matches[i + 1], to: pos + 1 };
        } else {
          this.matches[i]++;
          keep = true;
        }
      }
      if (!keep) {
        this.matches.splice(i, 2);
        i -= 2;
      }
    }
    if (this.query.charCodeAt(0) == code) {
      if (this.query.length == 1)
        match = { from: pos, to: pos + 1 };
      else
        this.matches.push(1, pos);
    }
    if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferPos))
      match = null;
    return match;
  }
};
if (typeof Symbol != "undefined")
  SearchCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
var empty = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") };
var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
var RegExpCursor = class {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(text, query, options, from = 0, to = text.length) {
    this.text = text;
    this.to = to;
    this.curLine = "";
    this.done = false;
    this.value = empty;
    if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
      return new MultilineRegExpCursor(text, query, options, from, to);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.test = options === null || options === void 0 ? void 0 : options.test;
    this.iter = text.iter();
    let startLine = text.lineAt(from);
    this.curLineStart = startLine.from;
    this.matchPos = toCharEnd(text, from);
    this.getLine(this.curLineStart);
  }
  getLine(skip) {
    this.iter.next(skip);
    if (this.iter.lineBreak) {
      this.curLine = "";
    } else {
      this.curLine = this.iter.value;
      if (this.curLineStart + this.curLine.length > this.to)
        this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
      this.iter.next();
    }
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1;
    if (this.curLineStart > this.to)
      this.curLine = "";
    else
      this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let off = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = off;
      let match = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (match) {
        let from = this.curLineStart + match.index, to = from + match[0].length;
        this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
        if (from == this.curLineStart + this.curLine.length)
          this.nextLine();
        if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {
          this.value = { from, to, match };
          return this;
        }
        off = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) {
        this.nextLine();
        off = 0;
      } else {
        this.done = true;
        return this;
      }
    }
  }
};
var flattened = /* @__PURE__ */ new WeakMap();
var FlattenedDoc = class _FlattenedDoc {
  constructor(from, text) {
    this.from = from;
    this.text = text;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(doc2, from, to) {
    let cached = flattened.get(doc2);
    if (!cached || cached.from >= to || cached.to <= from) {
      let flat = new _FlattenedDoc(from, doc2.sliceString(from, to));
      flattened.set(doc2, flat);
      return flat;
    }
    if (cached.from == from && cached.to == to)
      return cached;
    let { text, from: cachedFrom } = cached;
    if (cachedFrom > from) {
      text = doc2.sliceString(from, cachedFrom) + text;
      cachedFrom = from;
    }
    if (cached.to < to)
      text += doc2.sliceString(cached.to, to);
    flattened.set(doc2, new _FlattenedDoc(cachedFrom, text));
    return new _FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
  }
};
var MultilineRegExpCursor = class {
  constructor(text, query, options, from, to) {
    this.text = text;
    this.to = to;
    this.done = false;
    this.value = empty;
    this.matchPos = toCharEnd(text, from);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.test = options === null || options === void 0 ? void 0 : options.test;
    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(
      from + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(pos) {
    return pos >= this.to ? this.to : this.text.lineAt(pos).to;
  }
  next() {
    for (; ; ) {
      let off = this.re.lastIndex = this.matchPos - this.flat.from;
      let match = this.re.exec(this.flat.text);
      if (match && !match[0] && match.index == off) {
        this.re.lastIndex = off + 1;
        match = this.re.exec(this.flat.text);
      }
      if (match) {
        let from = this.flat.from + match.index, to = from + match[0].length;
        if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {
          this.value = { from, to, match };
          this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
          return this;
        }
      }
      if (this.flat.to == this.to) {
        this.done = true;
        return this;
      }
      this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
};
if (typeof Symbol != "undefined") {
  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a2) {
    return false;
  }
}
function toCharEnd(text, pos) {
  if (pos >= text.length)
    return pos;
  let line = text.lineAt(pos), next;
  while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
    pos++;
  return pos;
}
function createLineDialog(view) {
  let input = crelt("input", { class: "cm-textfield", name: "line" });
  let dom = crelt("form", {
    class: "cm-gotoLine",
    onkeydown: (event) => {
      if (event.keyCode == 27) {
        event.preventDefault();
        view.dispatch({ effects: dialogEffect.of(false) });
        view.focus();
      } else if (event.keyCode == 13) {
        event.preventDefault();
        go();
      }
    },
    onsubmit: (event) => {
      event.preventDefault();
      go();
    }
  }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")));
  function go() {
    let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
    if (!match)
      return;
    let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
    let [, sign, ln, cl, percent] = match;
    let col = cl ? +cl.slice(1) : 0;
    let line = ln ? +ln : startLine.number;
    if (ln && percent) {
      let pc = line / 100;
      if (sign)
        pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
      line = Math.round(state.doc.lines * pc);
    } else if (ln && sign) {
      line = line * (sign == "-" ? -1 : 1) + startLine.number;
    }
    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));
    view.dispatch({
      effects: dialogEffect.of(false),
      selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),
      scrollIntoView: true
    });
    view.focus();
  }
  return { dom };
}
var dialogEffect = /* @__PURE__ */ StateEffect.define();
var dialogField = /* @__PURE__ */ StateField.define({
  create() {
    return true;
  },
  update(value, tr) {
    for (let e of tr.effects)
      if (e.is(dialogEffect))
        value = e.value;
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
});
var gotoLine = (view) => {
  let panel = getPanel(view, createLineDialog);
  if (!panel) {
    let effects = [dialogEffect.of(true)];
    if (view.state.field(dialogField, false) == null)
      effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$13]));
    view.dispatch({ effects });
    panel = getPanel(view, createLineDialog);
  }
  if (panel)
    panel.dom.querySelector("input").focus();
  return true;
};
var baseTheme$13 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
});
var defaultHighlightOptions = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: false
};
var highlightConfig = /* @__PURE__ */ Facet.define({
  combine(options) {
    return combineConfig(options, defaultHighlightOptions, {
      highlightWordAroundCursor: (a, b) => a || b,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function highlightSelectionMatches(options) {
  let ext = [defaultTheme, matchHighlighter];
  if (options)
    ext.push(highlightConfig.of(options));
  return ext;
}
var matchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch" });
var mainMatchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function insideWordBoundaries(check, state, from, to) {
  return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);
}
function insideWord(check, state, from, to) {
  return check(state.sliceDoc(from, from + 1)) == CharCategory.Word && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;
}
var matchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.selectionSet || update.docChanged || update.viewportChanged)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let conf = view.state.facet(highlightConfig);
    let { state } = view, sel = state.selection;
    if (sel.ranges.length > 1)
      return Decoration.none;
    let range = sel.main, query, check = null;
    if (range.empty) {
      if (!conf.highlightWordAroundCursor)
        return Decoration.none;
      let word = state.wordAt(range.head);
      if (!word)
        return Decoration.none;
      check = state.charCategorizer(range.head);
      query = state.sliceDoc(word.from, word.to);
    } else {
      let len = range.to - range.from;
      if (len < conf.minSelectionLength || len > 200)
        return Decoration.none;
      if (conf.wholeWords) {
        query = state.sliceDoc(range.from, range.to);
        check = state.charCategorizer(range.head);
        if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to)))
          return Decoration.none;
      } else {
        query = state.sliceDoc(range.from, range.to).trim();
        if (!query)
          return Decoration.none;
      }
    }
    let deco = [];
    for (let part of view.visibleRanges) {
      let cursor = new SearchCursor(state.doc, query, part.from, part.to);
      while (!cursor.next().done) {
        let { from, to } = cursor.value;
        if (!check || insideWordBoundaries(check, state, from, to)) {
          if (range.empty && from <= range.from && to >= range.to)
            deco.push(mainMatchDeco.range(from, to));
          else if (from >= range.to || to <= range.from)
            deco.push(matchDeco.range(from, to));
          if (deco.length > conf.maxMatches)
            return Decoration.none;
        }
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
var defaultTheme = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
var selectWord = ({ state, dispatch }) => {
  let { selection } = state;
  let newSel = EditorSelection.create(selection.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);
  if (newSel.eq(selection))
    return false;
  dispatch(state.update({ selection: newSel }));
  return true;
};
function findNextOccurrence(state, query) {
  let { main, ranges } = state.selection;
  let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
  for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
    cursor.next();
    if (cursor.done) {
      if (cycled)
        return null;
      cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
      cycled = true;
    } else {
      if (cycled && ranges.some((r) => r.from == cursor.value.from))
        continue;
      if (fullWord) {
        let word2 = state.wordAt(cursor.value.from);
        if (!word2 || word2.from != cursor.value.from || word2.to != cursor.value.to)
          continue;
      }
      return cursor.value;
    }
  }
}
var selectNextOccurrence = ({ state, dispatch }) => {
  let { ranges } = state.selection;
  if (ranges.some((sel) => sel.from === sel.to))
    return selectWord({ state, dispatch });
  let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
  if (state.selection.ranges.some((r) => state.sliceDoc(r.from, r.to) != searchedText))
    return false;
  let range = findNextOccurrence(state, searchedText);
  if (!range)
    return false;
  dispatch(state.update({
    selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
    effects: EditorView.scrollIntoView(range.to)
  }));
  return true;
};
var searchConfigFacet = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      top: false,
      caseSensitive: false,
      literal: false,
      wholeWord: false,
      createPanel: (view) => new SearchPanel(view)
    });
  }
});
var SearchQuery = class {
  /**
  Create a query object.
  */
  constructor(config2) {
    this.search = config2.search;
    this.caseSensitive = !!config2.caseSensitive;
    this.literal = !!config2.literal;
    this.regexp = !!config2.regexp;
    this.replace = config2.replace || "";
    this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
    this.unquoted = this.unquote(this.search);
    this.wholeWord = !!config2.wholeWord;
  }
  /**
  @internal
  */
  unquote(text) {
    return this.literal ? text : text.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(state, from = 0, to) {
    let st = state.doc ? state : EditorState.create({ doc: state });
    if (to == null)
      to = st.doc.length;
    return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);
  }
};
var QueryType2 = class {
  constructor(spec) {
    this.spec = spec;
  }
};
function stringCursor(spec, state, from, to) {
  return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? void 0 : (x) => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
}
function stringWordTest(doc2, categorizer) {
  return (from, to, buf, bufPos) => {
    if (bufPos > from || bufPos + buf.length < to) {
      bufPos = Math.max(0, from - 2);
      buf = doc2.sliceString(bufPos, Math.min(doc2.length, to + 2));
    }
    return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);
  };
}
var StringQuery = class extends QueryType2 {
  constructor(spec) {
    super(spec);
  }
  nextMatch(state, curFrom, curTo) {
    let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
    if (cursor.done)
      cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();
    return cursor.done ? null : cursor.value;
  }
  // Searching in reverse is, rather than implementing inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(state, from, to) {
    for (let pos = to; ; ) {
      let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
      let cursor = stringCursor(this.spec, state, start, pos), range = null;
      while (!cursor.nextOverlapping().done)
        range = cursor.value;
      if (range)
        return range;
      if (start == from)
        return null;
      pos -= 1e4;
    }
  }
  prevMatch(state, curFrom, curTo) {
    return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
  }
  getReplacement(_result) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(state, limit) {
    let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor.value);
    }
    return ranges;
  }
  highlight(state, from, to, add2) {
    let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
    while (!cursor.next().done)
      add2(cursor.value.from, cursor.value.to);
  }
};
function regexpCursor(spec, state, from, to) {
  return new RegExpCursor(state.doc, spec.search, {
    ignoreCase: !spec.caseSensitive,
    test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
  }, from, to);
}
function charBefore(str, index) {
  return str.slice(findClusterBreak(str, index, false), index);
}
function charAfter(str, index) {
  return str.slice(index, findClusterBreak(str, index));
}
function regexpWordTest(categorizer) {
  return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
}
var RegExpQuery = class extends QueryType2 {
  nextMatch(state, curFrom, curTo) {
    let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();
    if (cursor.done)
      cursor = regexpCursor(this.spec, state, 0, curFrom).next();
    return cursor.done ? null : cursor.value;
  }
  prevMatchInRange(state, from, to) {
    for (let size = 1; ; size++) {
      let start = Math.max(
        from,
        to - size * 1e4
        /* FindPrev.ChunkSize */
      );
      let cursor = regexpCursor(this.spec, state, start, to), range = null;
      while (!cursor.next().done)
        range = cursor.value;
      if (range && (start == from || range.from > start + 10))
        return range;
      if (start == from)
        return null;
    }
  }
  prevMatch(state, curFrom, curTo) {
    return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
  }
  getReplacement(result) {
    return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (m, i) => i == "$" ? "$" : i == "&" ? result.match[0] : i != "0" && +i < result.match.length ? result.match[i] : m));
  }
  matchAll(state, limit) {
    let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor.value);
    }
    return ranges;
  }
  highlight(state, from, to, add2) {
    let cursor = regexpCursor(this.spec, state, Math.max(
      0,
      from - 250
      /* RegExp.HighlightMargin */
    ), Math.min(to + 250, state.doc.length));
    while (!cursor.next().done)
      add2(cursor.value.from, cursor.value.to);
  }
};
var setSearchQuery = /* @__PURE__ */ StateEffect.define();
var togglePanel = /* @__PURE__ */ StateEffect.define();
var searchState = /* @__PURE__ */ StateField.define({
  create(state) {
    return new SearchState(defaultQuery(state).create(), null);
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setSearchQuery))
        value = new SearchState(effect.value.create(), value.panel);
      else if (effect.is(togglePanel))
        value = new SearchState(value.query, effect.value ? createSearchPanel : null);
    }
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val.panel)
});
var SearchState = class {
  constructor(query, panel) {
    this.query = query;
    this.panel = panel;
  }
};
var matchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch" });
var selectedMatchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
var searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.decorations = this.highlight(view.state.field(searchState));
  }
  update(update) {
    let state = update.state.field(searchState);
    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
      this.decorations = this.highlight(state);
  }
  highlight({ query, panel }) {
    if (!panel || !query.spec.valid)
      return Decoration.none;
    let { view } = this;
    let builder = new RangeSetBuilder();
    for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
      let { from, to } = ranges[i];
      while (i < l - 1 && to > ranges[i + 1].from - 2 * 250)
        to = ranges[++i].to;
      query.highlight(view.state, from, to, (from2, to2) => {
        let selected = view.state.selection.ranges.some((r) => r.from == from2 && r.to == to2);
        builder.add(from2, to2, selected ? selectedMatchMark : matchMark);
      });
    }
    return builder.finish();
  }
}, {
  decorations: (v) => v.decorations
});
function searchCommand(f) {
  return (view) => {
    let state = view.state.field(searchState, false);
    return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
  };
}
var findNext = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { to } = view.state.selection.main;
  let next = query.nextMatch(view.state, to, to);
  if (!next)
    return false;
  view.dispatch({
    selection: { anchor: next.from, head: next.to },
    scrollIntoView: true,
    effects: announceMatch(view, next),
    userEvent: "select.search"
  });
  return true;
});
var findPrevious = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { state } = view, { from } = state.selection.main;
  let range = query.prevMatch(state, from, from);
  if (!range)
    return false;
  view.dispatch({
    selection: { anchor: range.from, head: range.to },
    scrollIntoView: true,
    effects: announceMatch(view, range),
    userEvent: "select.search"
  });
  return true;
});
var selectMatches = /* @__PURE__ */ searchCommand((view, { query }) => {
  let ranges = query.matchAll(view.state, 1e3);
  if (!ranges || !ranges.length)
    return false;
  view.dispatch({
    selection: EditorSelection.create(ranges.map((r) => EditorSelection.range(r.from, r.to))),
    userEvent: "select.search.matches"
  });
  return true;
});
var selectSelectionMatches = ({ state, dispatch }) => {
  let sel = state.selection;
  if (sel.ranges.length > 1 || sel.main.empty)
    return false;
  let { from, to } = sel.main;
  let ranges = [], main = 0;
  for (let cur2 = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur2.next().done; ) {
    if (ranges.length > 1e3)
      return false;
    if (cur2.value.from == from)
      main = ranges.length;
    ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
  }
  dispatch(state.update({
    selection: EditorSelection.create(ranges, main),
    userEvent: "select.search.matches"
  }));
  return true;
};
var replaceNext = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { state } = view, { from, to } = state.selection.main;
  if (state.readOnly)
    return false;
  let next = query.nextMatch(state, from, from);
  if (!next)
    return false;
  let changes = [], selection, replacement;
  let announce = [];
  if (next.from == from && next.to == to) {
    replacement = state.toText(query.getReplacement(next));
    changes.push({ from: next.from, to: next.to, insert: replacement });
    next = query.nextMatch(state, next.from, next.to);
    announce.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
  }
  if (next) {
    let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
    selection = { anchor: next.from - off, head: next.to - off };
    announce.push(announceMatch(view, next));
  }
  view.dispatch({
    changes,
    selection,
    scrollIntoView: !!selection,
    effects: announce,
    userEvent: "input.replace"
  });
  return true;
});
var replaceAll = /* @__PURE__ */ searchCommand((view, { query }) => {
  if (view.state.readOnly)
    return false;
  let changes = query.matchAll(view.state, 1e9).map((match) => {
    let { from, to } = match;
    return { from, to, insert: query.getReplacement(match) };
  });
  if (!changes.length)
    return false;
  let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
  view.dispatch({
    changes,
    effects: EditorView.announce.of(announceText),
    userEvent: "input.replace.all"
  });
  return true;
});
function createSearchPanel(view) {
  return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
  var _a2, _b, _c, _d;
  let sel = state.selection.main;
  let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
  if (fallback && !selText)
    return fallback;
  let config2 = state.facet(searchConfigFacet);
  return new SearchQuery({
    search: ((_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a2 !== void 0 ? _a2 : config2.literal) ? selText : selText.replace(/\n/g, "\\n"),
    caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config2.caseSensitive,
    literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config2.literal,
    wholeWord: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _d !== void 0 ? _d : config2.wholeWord
  });
}
var openSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (state && state.panel) {
    let panel = getPanel(view, createSearchPanel);
    if (!panel)
      return false;
    let searchInput = panel.dom.querySelector("[main-field]");
    if (searchInput && searchInput != view.root.activeElement) {
      let query = defaultQuery(view.state, state.query.spec);
      if (query.valid)
        view.dispatch({ effects: setSearchQuery.of(query) });
      searchInput.focus();
      searchInput.select();
    }
  } else {
    view.dispatch({ effects: [
      togglePanel.of(true),
      state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
    ] });
  }
  return true;
};
var closeSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (!state || !state.panel)
    return false;
  let panel = getPanel(view, createSearchPanel);
  if (panel && panel.dom.contains(view.root.activeElement))
    view.focus();
  view.dispatch({ effects: togglePanel.of(false) });
  return true;
};
var searchKeymap = [
  { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
  { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: selectSelectionMatches },
  { key: "Alt-g", run: gotoLine },
  { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
];
var SearchPanel = class {
  constructor(view) {
    this.view = view;
    let query = this.query = view.state.field(searchState).query.spec;
    this.commit = this.commit.bind(this);
    this.searchField = crelt("input", {
      value: query.search,
      placeholder: phrase(view, "Find"),
      "aria-label": phrase(view, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.replaceField = crelt("input", {
      value: query.replace,
      placeholder: phrase(view, "Replace"),
      "aria-label": phrase(view, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.caseField = crelt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: query.caseSensitive,
      onchange: this.commit
    });
    this.reField = crelt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: query.regexp,
      onchange: this.commit
    });
    this.wordField = crelt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: query.wholeWord,
      onchange: this.commit
    });
    function button(name2, onclick, content2) {
      return crelt("button", { class: "cm-button", name: name2, onclick, type: "button" }, content2);
    }
    this.dom = crelt("div", { onkeydown: (e) => this.keydown(e), class: "cm-search" }, [
      this.searchField,
      button("next", () => findNext(view), [phrase(view, "next")]),
      button("prev", () => findPrevious(view), [phrase(view, "previous")]),
      button("select", () => selectMatches(view), [phrase(view, "all")]),
      crelt("label", null, [this.caseField, phrase(view, "match case")]),
      crelt("label", null, [this.reField, phrase(view, "regexp")]),
      crelt("label", null, [this.wordField, phrase(view, "by word")]),
      ...view.state.readOnly ? [] : [
        crelt("br"),
        this.replaceField,
        button("replace", () => replaceNext(view), [phrase(view, "replace")]),
        button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
      ],
      crelt("button", {
        name: "close",
        onclick: () => closeSearchPanel(view),
        "aria-label": phrase(view, "close"),
        type: "button"
      }, ["\xD7"])
    ]);
  }
  commit() {
    let query = new SearchQuery({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    if (!query.eq(this.query)) {
      this.query = query;
      this.view.dispatch({ effects: setSearchQuery.of(query) });
    }
  }
  keydown(e) {
    if (runScopeHandlers(this.view, e, "search-panel")) {
      e.preventDefault();
    } else if (e.keyCode == 13 && e.target == this.searchField) {
      e.preventDefault();
      (e.shiftKey ? findPrevious : findNext)(this.view);
    } else if (e.keyCode == 13 && e.target == this.replaceField) {
      e.preventDefault();
      replaceNext(this.view);
    }
  }
  update(update) {
    for (let tr of update.transactions)
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
          this.setQuery(effect.value);
      }
  }
  setQuery(query) {
    this.query = query;
    this.searchField.value = query.search;
    this.replaceField.value = query.replace;
    this.caseField.checked = query.caseSensitive;
    this.reField.checked = query.regexp;
    this.wordField.checked = query.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(searchConfigFacet).top;
  }
};
function phrase(view, phrase2) {
  return view.state.phrase(phrase2);
}
var AnnounceMargin = 30;
var Break = /[\s\.,:;?!]/;
function announceMatch(view, { from, to }) {
  let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;
  let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
  let text = view.state.sliceDoc(start, end);
  if (start != line.from) {
    for (let i = 0; i < AnnounceMargin; i++)
      if (!Break.test(text[i + 1]) && Break.test(text[i])) {
        text = text.slice(i);
        break;
      }
  }
  if (end != lineEnd) {
    for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
      if (!Break.test(text[i - 1]) && Break.test(text[i])) {
        text = text.slice(0, i);
        break;
      }
  }
  return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
}
var baseTheme3 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
var searchExtensions = [
  searchState,
  /* @__PURE__ */ Prec.lowest(searchHighlighter),
  baseTheme3
];

// node_modules/@codemirror/autocomplete/dist/index.js
var CompletionContext = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(state, pos, explicit) {
    this.state = state;
    this.pos = pos;
    this.explicit = explicit;
    this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(types2) {
    let token = syntaxTree(this.state).resolveInner(this.pos, -1);
    while (token && types2.indexOf(token.name) < 0)
      token = token.parent;
    return token ? {
      from: token.from,
      to: this.pos,
      text: this.state.sliceDoc(token.from, this.pos),
      type: token.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(expr) {
    let line = this.state.doc.lineAt(this.pos);
    let start = Math.max(line.from, this.pos - 250);
    let str = line.text.slice(start - line.from, this.pos - line.from);
    let found = str.search(ensureAnchor(expr, false));
    return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(type, listener) {
    if (type == "abort" && this.abortListeners)
      this.abortListeners.push(listener);
  }
};
function toSet(chars) {
  let flat = Object.keys(chars).join("");
  let words = /\w/.test(flat);
  if (words)
    flat = flat.replace(/\w/g, "");
  return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options) {
  let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
  for (let { label } of options) {
    first[label[0]] = true;
    for (let i = 1; i < label.length; i++)
      rest[label[i]] = true;
  }
  let source = toSet(first) + toSet(rest) + "*$";
  return [new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list) {
  let options = list.map((o) => typeof o == "string" ? { label: o } : o);
  let [validFor, match] = options.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
  return (context) => {
    let token = context.matchBefore(match);
    return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;
  };
}
var Option = class {
  constructor(completion, source, match) {
    this.completion = completion;
    this.source = source;
    this.match = match;
  }
};
function cur(state) {
  return state.selection.main.head;
}
function ensureAnchor(expr, start) {
  var _a2;
  let { source } = expr;
  let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
  if (!addStart && !addEnd)
    return expr;
  return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
}
var pickedCompletion = /* @__PURE__ */ Annotation.define();
function insertCompletionText(state, text, from, to) {
  return Object.assign(Object.assign({}, state.changeByRange((range) => {
    if (range == state.selection.main)
      return {
        changes: { from, to, insert: text },
        range: EditorSelection.cursor(from + text.length)
      };
    let len = to - from;
    if (!range.empty || len && state.sliceDoc(range.from - len, range.from) != state.sliceDoc(from, to))
      return { range };
    return {
      changes: { from: range.from - len, to: range.from, insert: text },
      range: EditorSelection.cursor(range.from - len + text.length)
    };
  })), { userEvent: "input.complete" });
}
function applyCompletion(view, option) {
  const apply = option.completion.apply || option.completion.label;
  let result = option.source;
  if (typeof apply == "string")
    view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));
  else
    apply(view, option.completion, result.from, result.to);
}
var SourceCache = /* @__PURE__ */ new WeakMap();
function asSource(source) {
  if (!Array.isArray(source))
    return source;
  let known = SourceCache.get(source);
  if (!known)
    SourceCache.set(source, known = completeFromList(source));
  return known;
}
var FuzzyMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.chars = [];
    this.folded = [];
    this.any = [];
    this.precise = [];
    this.byWord = [];
    for (let p = 0; p < pattern.length; ) {
      let char = codePointAt(pattern, p), size = codePointSize(char);
      this.chars.push(char);
      let part = pattern.slice(p, p + size), upper = part.toUpperCase();
      this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
      p += size;
    }
    this.astral = pattern.length != this.chars.length;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return null for no match, and otherwise an array that starts
  // with the match score, followed by any number of `from, to` pairs
  // indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(word) {
    if (this.pattern.length == 0)
      return [0];
    if (word.length < this.pattern.length)
      return null;
    let { chars, folded, any, precise, byWord } = this;
    if (chars.length == 1) {
      let first = codePointAt(word, 0), firstSize = codePointSize(first);
      let score2 = firstSize == word.length ? 0 : -100;
      if (first == chars[0])
        ;
      else if (first == folded[0])
        score2 += -200;
      else
        return null;
      return [score2, 0, firstSize];
    }
    let direct = word.indexOf(this.pattern);
    if (direct == 0)
      return [word.length == this.pattern.length ? 0 : -100, 0, this.pattern.length];
    let len = chars.length, anyTo = 0;
    if (direct < 0) {
      for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len; ) {
        let next = codePointAt(word, i);
        if (next == chars[anyTo] || next == folded[anyTo])
          any[anyTo++] = i;
        i += codePointSize(next);
      }
      if (anyTo < len)
        return null;
    }
    let preciseTo = 0;
    let byWordTo = 0, byWordFolded = false;
    let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
    let hasLower = /[a-z]/.test(word), wordAdjacent = true;
    for (let i = 0, e = Math.min(word.length, 200), prevType = 0; i < e && byWordTo < len; ) {
      let next = codePointAt(word, i);
      if (direct < 0) {
        if (preciseTo < len && next == chars[preciseTo])
          precise[preciseTo++] = i;
        if (adjacentTo < len) {
          if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
            if (adjacentTo == 0)
              adjacentStart = i;
            adjacentEnd = i + 1;
            adjacentTo++;
          } else {
            adjacentTo = 0;
          }
        }
      }
      let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
      if (!i || type == 1 && hasLower || prevType == 0 && type != 0) {
        if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
          byWord[byWordTo++] = i;
        else if (byWord.length)
          wordAdjacent = false;
      }
      prevType = type;
      i += codePointSize(next);
    }
    if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
      return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
    if (adjacentTo == len && adjacentStart == 0)
      return [-200 - word.length + (adjacentEnd == word.length ? 0 : -100), 0, adjacentEnd];
    if (direct > -1)
      return [-700 - word.length, direct, direct + this.pattern.length];
    if (adjacentTo == len)
      return [-200 + -700 - word.length, adjacentStart, adjacentEnd];
    if (byWordTo == len)
      return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
    return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
  }
  result(score2, positions, word) {
    let result = [score2 - word.length], i = 1;
    for (let pos of positions) {
      let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
      if (i > 1 && result[i - 1] == pos)
        result[i - 1] = to;
      else {
        result[i++] = pos;
        result[i++] = to;
      }
    }
    return result;
  }
};
var completionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      activateOnTyping: true,
      selectOnOpen: true,
      override: null,
      closeOnBlur: true,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: false,
      icons: true,
      addToOptions: [],
      compareCompletions: (a, b) => a.label.localeCompare(b.label),
      interactionDelay: 75
    }, {
      defaultKeymap: (a, b) => a && b,
      closeOnBlur: (a, b) => a && b,
      icons: (a, b) => a && b,
      tooltipClass: (a, b) => (c) => joinClass(a(c), b(c)),
      optionClass: (a, b) => (c) => joinClass(a(c), b(c)),
      addToOptions: (a, b) => a.concat(b)
    });
  }
});
function joinClass(a, b) {
  return a ? b ? a + " " + b : a : b;
}
function optionContent(config2) {
  let content2 = config2.addToOptions.slice();
  if (config2.icons)
    content2.push({
      render(completion) {
        let icon = document.createElement("div");
        icon.classList.add("cm-completionIcon");
        if (completion.type)
          icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
        icon.setAttribute("aria-hidden", "true");
        return icon;
      },
      position: 20
    });
  content2.push({
    render(completion, _s, match) {
      let labelElt = document.createElement("span");
      labelElt.className = "cm-completionLabel";
      let { label } = completion, off = 0;
      for (let j = 1; j < match.length; ) {
        let from = match[j++], to = match[j++];
        if (from > off)
          labelElt.appendChild(document.createTextNode(label.slice(off, from)));
        let span = labelElt.appendChild(document.createElement("span"));
        span.appendChild(document.createTextNode(label.slice(from, to)));
        span.className = "cm-completionMatchedText";
        off = to;
      }
      if (off < label.length)
        labelElt.appendChild(document.createTextNode(label.slice(off)));
      return labelElt;
    },
    position: 50
  }, {
    render(completion) {
      if (!completion.detail)
        return null;
      let detailElt = document.createElement("span");
      detailElt.className = "cm-completionDetail";
      detailElt.textContent = completion.detail;
      return detailElt;
    },
    position: 80
  });
  return content2.sort((a, b) => a.position - b.position).map((a) => a.render);
}
function rangeAroundSelected(total, selected, max) {
  if (total <= max)
    return { from: 0, to: total };
  if (selected < 0)
    selected = 0;
  if (selected <= total >> 1) {
    let off2 = Math.floor(selected / max);
    return { from: off2 * max, to: (off2 + 1) * max };
  }
  let off = Math.floor((total - selected) / max);
  return { from: total - (off + 1) * max, to: total - off * max };
}
var CompletionTooltip = class {
  constructor(view, stateField) {
    this.view = view;
    this.stateField = stateField;
    this.info = null;
    this.placeInfo = {
      read: () => this.measureInfo(),
      write: (pos) => this.positionInfo(pos),
      key: this
    };
    this.space = null;
    this.currentClass = "";
    let cState = view.state.field(stateField);
    let { options, selected } = cState.open;
    let config2 = view.state.facet(completionConfig);
    this.optionContent = optionContent(config2);
    this.optionClass = config2.optionClass;
    this.tooltipClass = config2.tooltipClass;
    this.range = rangeAroundSelected(options.length, selected, config2.maxRenderedOptions);
    this.dom = document.createElement("div");
    this.dom.className = "cm-tooltip-autocomplete";
    this.updateTooltipClass(view.state);
    this.dom.addEventListener("mousedown", (e) => {
      for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
        if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options.length) {
          applyCompletion(view, options[+match[1]]);
          e.preventDefault();
          return;
        }
      }
    });
    this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));
    this.list.addEventListener("scroll", () => {
      if (this.info)
        this.view.requestMeasure(this.placeInfo);
    });
  }
  mount() {
    this.updateSel();
  }
  update(update) {
    var _a2, _b, _c;
    let cState = update.state.field(this.stateField);
    let prevState = update.startState.field(this.stateField);
    this.updateTooltipClass(update.state);
    if (cState != prevState) {
      this.updateSel();
      if (((_a2 = cState.open) === null || _a2 === void 0 ? void 0 : _a2.disabled) != ((_b = prevState.open) === null || _b === void 0 ? void 0 : _b.disabled))
        this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!((_c = cState.open) === null || _c === void 0 ? void 0 : _c.disabled));
    }
  }
  updateTooltipClass(state) {
    let cls = this.tooltipClass(state);
    if (cls != this.currentClass) {
      for (let c of this.currentClass.split(" "))
        if (c)
          this.dom.classList.remove(c);
      for (let c of cls.split(" "))
        if (c)
          this.dom.classList.add(c);
      this.currentClass = cls;
    }
  }
  positioned(space) {
    this.space = space;
    if (this.info)
      this.view.requestMeasure(this.placeInfo);
  }
  updateSel() {
    let cState = this.view.state.field(this.stateField), open = cState.open;
    if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
      this.list.remove();
      this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));
      this.list.addEventListener("scroll", () => {
        if (this.info)
          this.view.requestMeasure(this.placeInfo);
      });
    }
    if (this.updateSelectedOption(open.selected)) {
      if (this.info) {
        this.info.remove();
        this.info = null;
      }
      let { completion } = open.options[open.selected];
      let { info } = completion;
      if (!info)
        return;
      let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
      if (!infoResult)
        return;
      if ("then" in infoResult) {
        infoResult.then((node) => {
          if (node && this.view.state.field(this.stateField, false) == cState)
            this.addInfoPane(node);
        }).catch((e) => logException(this.view.state, e, "completion info"));
      } else {
        this.addInfoPane(infoResult);
      }
    }
  }
  addInfoPane(content2) {
    let dom = this.info = document.createElement("div");
    dom.className = "cm-tooltip cm-completionInfo";
    dom.appendChild(content2);
    this.dom.appendChild(dom);
    this.view.requestMeasure(this.placeInfo);
  }
  updateSelectedOption(selected) {
    let set = null;
    for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
      if (i == selected) {
        if (!opt.hasAttribute("aria-selected")) {
          opt.setAttribute("aria-selected", "true");
          set = opt;
        }
      } else {
        if (opt.hasAttribute("aria-selected"))
          opt.removeAttribute("aria-selected");
      }
    }
    if (set)
      scrollIntoView2(this.list, set);
    return set;
  }
  measureInfo() {
    let sel = this.dom.querySelector("[aria-selected]");
    if (!sel || !this.info)
      return null;
    let listRect = this.dom.getBoundingClientRect();
    let infoRect = this.info.getBoundingClientRect();
    let selRect = sel.getBoundingClientRect();
    let space = this.space;
    if (!space) {
      let win = this.dom.ownerDocument.defaultView || window;
      space = { left: 0, top: 0, right: win.innerWidth, bottom: win.innerHeight };
    }
    if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10)
      return null;
    let rtl = this.view.textDirection == Direction.RTL, left = rtl, narrow = false, maxWidth;
    let top2 = "", bottom = "";
    let spaceLeft = listRect.left - space.left, spaceRight = space.right - listRect.right;
    if (left && spaceLeft < Math.min(infoRect.width, spaceRight))
      left = false;
    else if (!left && spaceRight < Math.min(infoRect.width, spaceLeft))
      left = true;
    if (infoRect.width <= (left ? spaceLeft : spaceRight)) {
      top2 = Math.max(space.top, Math.min(selRect.top, space.bottom - infoRect.height)) - listRect.top + "px";
      maxWidth = Math.min(400, left ? spaceLeft : spaceRight) + "px";
    } else {
      narrow = true;
      maxWidth = Math.min(
        400,
        (rtl ? listRect.right : space.right - listRect.left) - 30
        /* Info.Margin */
      ) + "px";
      let spaceBelow = space.bottom - listRect.bottom;
      if (spaceBelow >= infoRect.height || spaceBelow > listRect.top)
        top2 = selRect.bottom - listRect.top + "px";
      else
        bottom = listRect.bottom - selRect.top + "px";
    }
    return {
      top: top2,
      bottom,
      maxWidth,
      class: narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right"
    };
  }
  positionInfo(pos) {
    if (this.info) {
      if (pos) {
        this.info.style.top = pos.top;
        this.info.style.bottom = pos.bottom;
        this.info.style.maxWidth = pos.maxWidth;
        this.info.className = "cm-tooltip cm-completionInfo cm-completionInfo-" + pos.class;
      } else {
        this.info.style.top = "-1e6px";
      }
    }
  }
  createListBox(options, id, range) {
    const ul = document.createElement("ul");
    ul.id = id;
    ul.setAttribute("role", "listbox");
    ul.setAttribute("aria-expanded", "true");
    ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
    for (let i = range.from; i < range.to; i++) {
      let { completion, match } = options[i];
      const li = ul.appendChild(document.createElement("li"));
      li.id = id + "-" + i;
      li.setAttribute("role", "option");
      let cls = this.optionClass(completion);
      if (cls)
        li.className = cls;
      for (let source of this.optionContent) {
        let node = source(completion, this.view.state, match);
        if (node)
          li.appendChild(node);
      }
    }
    if (range.from)
      ul.classList.add("cm-completionListIncompleteTop");
    if (range.to < options.length)
      ul.classList.add("cm-completionListIncompleteBottom");
    return ul;
  }
};
function completionTooltip(stateField) {
  return (view) => new CompletionTooltip(view, stateField);
}
function scrollIntoView2(container, element) {
  let parent = container.getBoundingClientRect();
  let self = element.getBoundingClientRect();
  if (self.top < parent.top)
    container.scrollTop -= parent.top - self.top;
  else if (self.bottom > parent.bottom)
    container.scrollTop += self.bottom - parent.bottom;
}
function score(option) {
  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
}
function sortOptions(active, state) {
  let options = [], i = 0;
  for (let a of active)
    if (a.hasResult()) {
      if (a.result.filter === false) {
        let getMatch = a.result.getMatch;
        for (let option of a.result.options) {
          let match = [1e9 - i++];
          if (getMatch)
            for (let n of getMatch(option))
              match.push(n);
          options.push(new Option(option, a, match));
        }
      } else {
        let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)), match;
        for (let option of a.result.options)
          if (match = matcher.match(option.label)) {
            if (option.boost != null)
              match[0] += option.boost;
            options.push(new Option(option, a, match));
          }
      }
    }
  let result = [], prev = null;
  let compare2 = state.facet(completionConfig).compareCompletions;
  for (let opt of options.sort((a, b) => b.match[0] - a.match[0] || compare2(a.completion, b.completion))) {
    if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail || prev.type != null && opt.completion.type != null && prev.type != opt.completion.type || prev.apply != opt.completion.apply)
      result.push(opt);
    else if (score(opt.completion) > score(prev))
      result[result.length - 1] = opt;
    prev = opt.completion;
  }
  return result;
}
var CompletionDialog = class _CompletionDialog {
  constructor(options, attrs, tooltip, timestamp, selected, disabled) {
    this.options = options;
    this.attrs = attrs;
    this.tooltip = tooltip;
    this.timestamp = timestamp;
    this.selected = selected;
    this.disabled = disabled;
  }
  setSelected(selected, id) {
    return selected == this.selected || selected >= this.options.length ? this : new _CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);
  }
  static build(active, state, id, prev, conf) {
    let options = sortOptions(active, state);
    if (!options.length) {
      return prev && active.some(
        (a) => a.state == 1
        /* State.Pending */
      ) ? new _CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;
    }
    let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
    if (prev && prev.selected != selected && prev.selected != -1) {
      let selectedValue = prev.options[prev.selected].completion;
      for (let i = 0; i < options.length; i++)
        if (options[i].completion == selectedValue) {
          selected = i;
          break;
        }
    }
    return new _CompletionDialog(options, makeAttrs(id, selected), {
      pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
      create: completionTooltip(completionState),
      above: conf.aboveCursor
    }, prev ? prev.timestamp : Date.now(), selected, false);
  }
  map(changes) {
    return new _CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
};
var CompletionState = class _CompletionState {
  constructor(active, id, open) {
    this.active = active;
    this.id = id;
    this.open = open;
  }
  static start() {
    return new _CompletionState(none3, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(tr) {
    let { state } = tr, conf = state.facet(completionConfig);
    let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
    let active = sources.map((source) => {
      let value = this.active.find((s) => s.source == source) || new ActiveSource(
        source,
        this.active.some(
          (a) => a.state != 0
          /* State.Inactive */
        ) ? 1 : 0
        /* State.Inactive */
      );
      return value.update(tr, conf);
    });
    if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
      active = this.active;
    let open = this.open;
    if (open && tr.docChanged)
      open = open.map(tr.changes);
    if (tr.selection || active.some((a) => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active))
      open = CompletionDialog.build(active, state, this.id, open, conf);
    else if (open && open.disabled && !active.some(
      (a) => a.state == 1
      /* State.Pending */
    ))
      open = null;
    if (!open && active.every(
      (a) => a.state != 1
      /* State.Pending */
    ) && active.some((a) => a.hasResult()))
      active = active.map((a) => a.hasResult() ? new ActiveSource(
        a.source,
        0
        /* State.Inactive */
      ) : a);
    for (let effect of tr.effects)
      if (effect.is(setSelectedEffect))
        open = open && open.setSelected(effect.value, this.id);
    return active == this.active && open == this.open ? this : new _CompletionState(active, this.id, open);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : baseAttrs;
  }
};
function sameResults(a, b) {
  if (a == b)
    return true;
  for (let iA = 0, iB = 0; ; ) {
    while (iA < a.length && !a[iA].hasResult)
      iA++;
    while (iB < b.length && !b[iB].hasResult)
      iB++;
    let endA = iA == a.length, endB = iB == b.length;
    if (endA || endB)
      return endA == endB;
    if (a[iA++].result != b[iB++].result)
      return false;
  }
}
var baseAttrs = {
  "aria-autocomplete": "list"
};
function makeAttrs(id, selected) {
  let result = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": id
  };
  if (selected > -1)
    result["aria-activedescendant"] = id + "-" + selected;
  return result;
}
var none3 = [];
function getUserEvent(tr) {
  return tr.isUserEvent("input.type") ? "input" : tr.isUserEvent("delete.backward") ? "delete" : null;
}
var ActiveSource = class _ActiveSource {
  constructor(source, state, explicitPos = -1) {
    this.source = source;
    this.state = state;
    this.explicitPos = explicitPos;
  }
  hasResult() {
    return false;
  }
  update(tr, conf) {
    let event = getUserEvent(tr), value = this;
    if (event)
      value = value.handleUserEvent(tr, event, conf);
    else if (tr.docChanged)
      value = value.handleChange(tr);
    else if (tr.selection && value.state != 0)
      value = new _ActiveSource(
        value.source,
        0
        /* State.Inactive */
      );
    for (let effect of tr.effects) {
      if (effect.is(startCompletionEffect))
        value = new _ActiveSource(value.source, 1, effect.value ? cur(tr.state) : -1);
      else if (effect.is(closeCompletionEffect))
        value = new _ActiveSource(
          value.source,
          0
          /* State.Inactive */
        );
      else if (effect.is(setActiveEffect)) {
        for (let active of effect.value)
          if (active.source == value.source)
            value = active;
      }
    }
    return value;
  }
  handleUserEvent(tr, type, conf) {
    return type == "delete" || !conf.activateOnTyping ? this.map(tr.changes) : new _ActiveSource(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(tr) {
    return tr.changes.touchesRange(cur(tr.startState)) ? new _ActiveSource(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(tr.changes);
  }
  map(changes) {
    return changes.empty || this.explicitPos < 0 ? this : new _ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
  }
};
var ActiveResult = class _ActiveResult extends ActiveSource {
  constructor(source, explicitPos, result, from, to) {
    super(source, 2, explicitPos);
    this.result = result;
    this.from = from;
    this.to = to;
  }
  hasResult() {
    return true;
  }
  handleUserEvent(tr, type, conf) {
    var _a2;
    let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
    let pos = cur(tr.state);
    if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to || type == "delete" && cur(tr.startState) == this.from)
      return new ActiveSource(
        this.source,
        type == "input" && conf.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos), updated;
    if (checkValid(this.result.validFor, tr.state, from, to))
      return new _ActiveResult(this.source, explicitPos, this.result, from, to);
    if (this.result.update && (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0))))
      return new _ActiveResult(this.source, explicitPos, updated, updated.from, (_a2 = updated.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state));
    return new ActiveSource(this.source, 1, explicitPos);
  }
  handleChange(tr) {
    return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(tr.changes);
  }
  map(mapping) {
    return mapping.empty ? this : new _ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
  }
};
function checkValid(validFor, state, from, to) {
  if (!validFor)
    return false;
  let text = state.sliceDoc(from, to);
  return typeof validFor == "function" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);
}
var startCompletionEffect = /* @__PURE__ */ StateEffect.define();
var closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
var setActiveEffect = /* @__PURE__ */ StateEffect.define({
  map(sources, mapping) {
    return sources.map((s) => s.map(mapping));
  }
});
var setSelectedEffect = /* @__PURE__ */ StateEffect.define();
var completionState = /* @__PURE__ */ StateField.define({
  create() {
    return CompletionState.start();
  },
  update(value, tr) {
    return value.update(tr);
  },
  provide: (f) => [
    showTooltip.from(f, (val) => val.tooltip),
    EditorView.contentAttributes.from(f, (state) => state.attrs)
  ]
});
function moveCompletionSelection(forward, by = "option") {
  return (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
      return false;
    let step = 1, tooltip;
    if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
      step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
    let { length } = cState.open.options;
    let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
    if (selected < 0)
      selected = by == "page" ? 0 : length - 1;
    else if (selected >= length)
      selected = by == "page" ? length - 1 : 0;
    view.dispatch({ effects: setSelectedEffect.of(selected) });
    return true;
  };
}
var acceptCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
    return false;
  if (!cState.open.disabled)
    applyCompletion(view, cState.open.options[cState.open.selected]);
  return true;
};
var startCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState)
    return false;
  view.dispatch({ effects: startCompletionEffect.of(true) });
  return true;
};
var closeCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState || !cState.active.some(
    (a) => a.state != 0
    /* State.Inactive */
  ))
    return false;
  view.dispatch({ effects: closeCompletionEffect.of(null) });
  return true;
};
var RunningQuery = class {
  constructor(active, context) {
    this.active = active;
    this.context = context;
    this.time = Date.now();
    this.updates = [];
    this.done = void 0;
  }
};
var DebounceTime = 50;
var MaxUpdateCount = 50;
var MinAbortTime = 1e3;
var completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.debounceUpdate = -1;
    this.running = [];
    this.debounceAccept = -1;
    this.composing = 0;
    for (let active of view.state.field(completionState).active)
      if (active.state == 1)
        this.startQuery(active);
  }
  update(update) {
    let cState = update.state.field(completionState);
    if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
      return;
    let doesReset = update.transactions.some((tr) => {
      return (tr.selection || tr.docChanged) && !getUserEvent(tr);
    });
    for (let i = 0; i < this.running.length; i++) {
      let query = this.running[i];
      if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
        for (let handler of query.context.abortListeners) {
          try {
            handler();
          } catch (e) {
            logException(this.view.state, e);
          }
        }
        query.context.abortListeners = null;
        this.running.splice(i--, 1);
      } else {
        query.updates.push(...update.transactions);
      }
    }
    if (this.debounceUpdate > -1)
      clearTimeout(this.debounceUpdate);
    this.debounceUpdate = cState.active.some((a) => a.state == 1 && !this.running.some((q) => q.active.source == a.source)) ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;
    if (this.composing != 0)
      for (let tr of update.transactions) {
        if (getUserEvent(tr) == "input")
          this.composing = 2;
        else if (this.composing == 2 && tr.selection)
          this.composing = 3;
      }
  }
  startUpdate() {
    this.debounceUpdate = -1;
    let { state } = this.view, cState = state.field(completionState);
    for (let active of cState.active) {
      if (active.state == 1 && !this.running.some((r) => r.active.source == active.source))
        this.startQuery(active);
    }
  }
  startQuery(active) {
    let { state } = this.view, pos = cur(state);
    let context = new CompletionContext(state, pos, active.explicitPos == pos);
    let pending = new RunningQuery(active, context);
    this.running.push(pending);
    Promise.resolve(active.source(context)).then((result) => {
      if (!pending.context.aborted) {
        pending.done = result || null;
        this.scheduleAccept();
      }
    }, (err) => {
      this.view.dispatch({ effects: closeCompletionEffect.of(null) });
      logException(this.view.state, err);
    });
  }
  scheduleAccept() {
    if (this.running.every((q) => q.done !== void 0))
      this.accept();
    else if (this.debounceAccept < 0)
      this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var _a2;
    if (this.debounceAccept > -1)
      clearTimeout(this.debounceAccept);
    this.debounceAccept = -1;
    let updated = [];
    let conf = this.view.state.facet(completionConfig);
    for (let i = 0; i < this.running.length; i++) {
      let query = this.running[i];
      if (query.done === void 0)
        continue;
      this.running.splice(i--, 1);
      if (query.done) {
        let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a2 = query.done.to) !== null && _a2 !== void 0 ? _a2 : cur(query.updates.length ? query.updates[0].startState : this.view.state));
        for (let tr of query.updates)
          active = active.update(tr, conf);
        if (active.hasResult()) {
          updated.push(active);
          continue;
        }
      }
      let current = this.view.state.field(completionState).active.find((a) => a.source == query.active.source);
      if (current && current.state == 1) {
        if (query.done == null) {
          let active = new ActiveSource(
            query.active.source,
            0
            /* State.Inactive */
          );
          for (let tr of query.updates)
            active = active.update(tr, conf);
          if (active.state != 1)
            updated.push(active);
        } else {
          this.startQuery(current);
        }
      }
    }
    if (updated.length)
      this.view.dispatch({ effects: setActiveEffect.of(updated) });
  }
}, {
  eventHandlers: {
    blur() {
      let state = this.view.state.field(completionState, false);
      if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur)
        this.view.dispatch({ effects: closeCompletionEffect.of(null) });
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      if (this.composing == 3) {
        setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
      }
      this.composing = 0;
    }
  }
});
var baseTheme4 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer",
        padding: "1px 3px",
        lineHeight: 1.2
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"\xB7\xB7\xB7"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: `${400}px`,
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'\u0192'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'\u25CB'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'\u25CC'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'\u{1D465}'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'\u{1D436}'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'\u{1D461}'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'\u222A'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'\u25A1'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'\u{1F511}\uFE0E'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'\u25A2'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
var defaults2 = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
};
var closeBracketEffect = /* @__PURE__ */ StateEffect.define({
  map(value, mapping) {
    let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
    return mapped == null ? void 0 : mapped;
  }
});
var skipBracketEffect = /* @__PURE__ */ StateEffect.define({
  map(value, mapping) {
    return mapping.mapPos(value);
  }
});
var closedBracket = /* @__PURE__ */ new class extends RangeValue {
}();
closedBracket.startSide = 1;
closedBracket.endSide = -1;
var bracketState = /* @__PURE__ */ StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(value, tr) {
    if (tr.selection) {
      let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;
      let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;
      if (lineStart != tr.changes.mapPos(prevLineStart, -1))
        value = RangeSet.empty;
    }
    value = value.map(tr.changes);
    for (let effect of tr.effects) {
      if (effect.is(closeBracketEffect))
        value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
      else if (effect.is(skipBracketEffect))
        value = value.update({ filter: (from) => from != effect.value });
    }
    return value;
  }
});
function closeBrackets() {
  return [inputHandler2, bracketState];
}
var definedClosing = "()[]{}<>";
function closing(ch) {
  for (let i = 0; i < definedClosing.length; i += 2)
    if (definedClosing.charCodeAt(i) == ch)
      return definedClosing.charAt(i + 1);
  return fromCodePoint(ch < 128 ? ch : ch + 1);
}
function config(state, pos) {
  return state.languageDataAt("closeBrackets", pos)[0] || defaults2;
}
var android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
var inputHandler2 = /* @__PURE__ */ EditorView.inputHandler.of((view, from, to, insert2) => {
  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
    return false;
  let sel = view.state.selection.main;
  if (insert2.length > 2 || insert2.length == 2 && codePointSize(codePointAt(insert2, 0)) == 1 || from != sel.from || to != sel.to)
    return false;
  let tr = insertBracket(view.state, insert2);
  if (!tr)
    return false;
  view.dispatch(tr);
  return true;
});
var deleteBracketPair = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults2.brackets;
  let dont = null, changes = state.changeByRange((range) => {
    if (range.empty) {
      let before = prevChar(state.doc, range.head);
      for (let token of tokens) {
        if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0)))
          return {
            changes: { from: range.head - token.length, to: range.head + token.length },
            range: EditorSelection.cursor(range.head - token.length)
          };
      }
    }
    return { range: dont = range };
  });
  if (!dont)
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "delete.backward" }));
  return !dont;
};
var closeBracketsKeymap = [
  { key: "Backspace", run: deleteBracketPair }
];
function insertBracket(state, bracket2) {
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults2.brackets;
  for (let tok of tokens) {
    let closed = closing(codePointAt(tok, 0));
    if (bracket2 == tok)
      return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults2.before);
    if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
      return handleClose(state, tok, closed);
  }
  return null;
}
function closedBracketAt(state, pos) {
  let found = false;
  state.field(bracketState).between(0, state.doc.length, (from) => {
    if (from == pos)
      found = true;
  });
  return found;
}
function nextChar(doc2, pos) {
  let next = doc2.sliceString(pos, pos + 2);
  return next.slice(0, codePointSize(codePointAt(next, 0)));
}
function prevChar(doc2, pos) {
  let prev = doc2.sliceString(pos - 2, pos);
  return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
}
function handleOpen(state, open, close, closeBefore) {
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
        effects: closeBracketEffect.of(range.to + open.length),
        range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
      };
    let next = nextChar(state.doc, range.head);
    if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
      return {
        changes: { insert: open + close, from: range.head },
        effects: closeBracketEffect.of(range.head + open.length),
        range: EditorSelection.cursor(range.head + open.length)
      };
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleClose(state, _open, close) {
  let dont = null, moved = state.selection.ranges.map((range) => {
    if (range.empty && nextChar(state.doc, range.head) == close)
      return EditorSelection.cursor(range.head + close.length);
    return dont = range;
  });
  return dont ? null : state.update({
    selection: EditorSelection.create(moved, state.selection.mainIndex),
    scrollIntoView: true,
    effects: state.selection.ranges.map(({ from }) => skipBracketEffect.of(from))
  });
}
function handleSame(state, token, allowTriple, config2) {
  let stringPrefixes = config2.stringPrefixes || defaults2.stringPrefixes;
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
        effects: closeBracketEffect.of(range.to + token.length),
        range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
      };
    let pos = range.head, next = nextChar(state.doc, pos), start;
    if (next == token) {
      if (nodeStart(state, pos)) {
        return {
          changes: { insert: token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (closedBracketAt(state, pos)) {
        let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
        return {
          range: EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),
          effects: skipBracketEffect.of(pos)
        };
      }
    } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
      return {
        changes: { insert: token + token + token + token, from: pos },
        effects: closeBracketEffect.of(pos + token.length),
        range: EditorSelection.cursor(pos + token.length)
      };
    } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
      if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
        return {
          changes: { insert: token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
    }
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function nodeStart(state, pos) {
  let tree = syntaxTree(state).resolveInner(pos + 1);
  return tree.parent && tree.from == pos;
}
function probablyInString(state, pos, quoteToken, prefixes) {
  let node = syntaxTree(state).resolveInner(pos, -1);
  let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);
  for (let i = 0; i < 5; i++) {
    let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
    let quotePos = start.indexOf(quoteToken);
    if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
      let first = node.firstChild;
      while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
        if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
          return false;
        first = first.firstChild;
      }
      return true;
    }
    let parent = node.to == pos && node.parent;
    if (!parent)
      break;
    node = parent;
  }
  return false;
}
function canStartStringAt(state, pos, prefixes) {
  let charCat = state.charCategorizer(pos);
  if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
    return pos;
  for (let prefix of prefixes) {
    let start = pos - prefix.length;
    if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)
      return start;
  }
  return -1;
}
function autocompletion(config2 = {}) {
  return [
    completionState,
    completionConfig.of(config2),
    completionPlugin,
    completionKeymapExt,
    baseTheme4
  ];
}
var completionKeymap = [
  { key: "Ctrl-Space", run: startCompletion },
  { key: "Escape", run: closeCompletion },
  { key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true) },
  { key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false) },
  { key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page") },
  { key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page") },
  { key: "Enter", run: acceptCompletion }
];
var completionKeymapExt = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));

// node_modules/@codemirror/lint/dist/index.js
var SelectedDiagnostic = class {
  constructor(from, to, diagnostic) {
    this.from = from;
    this.to = to;
    this.diagnostic = diagnostic;
  }
};
var LintState = class _LintState {
  constructor(diagnostics, panel, selected) {
    this.diagnostics = diagnostics;
    this.panel = panel;
    this.selected = selected;
  }
  static init(diagnostics, panel, state) {
    let markedDiagnostics = diagnostics;
    let diagnosticFilter = state.facet(lintConfig).markerFilter;
    if (diagnosticFilter)
      markedDiagnostics = diagnosticFilter(markedDiagnostics);
    let ranges = Decoration.set(markedDiagnostics.map((d) => {
      return d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from ? Decoration.widget({
        widget: new DiagnosticWidget(d),
        diagnostic: d
      }).range(d.from) : Decoration.mark({
        attributes: { class: "cm-lintRange cm-lintRange-" + d.severity },
        diagnostic: d
      }).range(d.from, d.to);
    }), true);
    return new _LintState(ranges, panel, findDiagnostic(ranges));
  }
};
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
  let found = null;
  diagnostics.between(after, 1e9, (from, to, { spec }) => {
    if (diagnostic && spec.diagnostic != diagnostic)
      return;
    found = new SelectedDiagnostic(from, to, spec.diagnostic);
    return false;
  });
  return found;
}
function hideTooltip(tr, tooltip) {
  return !!(tr.effects.some((e) => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(tooltip.pos));
}
function maybeEnableLint(state, effects) {
  return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of([
    lintState,
    EditorView.decorations.compute([lintState], (state2) => {
      let { selected, panel } = state2.field(lintState);
      return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
        activeMark.range(selected.from, selected.to)
      ]);
    }),
    hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
    baseTheme5
  ]));
}
function setDiagnostics(state, diagnostics) {
  return {
    effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
  };
}
var setDiagnosticsEffect = /* @__PURE__ */ StateEffect.define();
var togglePanel2 = /* @__PURE__ */ StateEffect.define();
var movePanelSelection = /* @__PURE__ */ StateEffect.define();
var lintState = /* @__PURE__ */ StateField.define({
  create() {
    return new LintState(Decoration.none, null, null);
  },
  update(value, tr) {
    if (tr.docChanged) {
      let mapped = value.diagnostics.map(tr.changes), selected = null;
      if (value.selected) {
        let selPos = tr.changes.mapPos(value.selected.from, 1);
        selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
      }
      value = new LintState(mapped, value.panel, selected);
    }
    for (let effect of tr.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        value = LintState.init(effect.value, value.panel, tr.state);
      } else if (effect.is(togglePanel2)) {
        value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
      } else if (effect.is(movePanelSelection)) {
        value = new LintState(value.diagnostics, value.panel, effect.value);
      }
    }
    return value;
  },
  provide: (f) => [
    showPanel.from(f, (val) => val.panel),
    EditorView.decorations.from(f, (s) => s.diagnostics)
  ]
});
var activeMark = /* @__PURE__ */ Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
function lintTooltip(view, pos, side) {
  let { diagnostics } = view.state.field(lintState);
  let found = [], stackStart = 2e8, stackEnd = 0;
  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
    if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
      found.push(spec.diagnostic);
      stackStart = Math.min(from, stackStart);
      stackEnd = Math.max(to, stackEnd);
    }
  });
  let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
  if (diagnosticFilter)
    found = diagnosticFilter(found);
  if (!found.length)
    return null;
  return {
    pos: stackStart,
    end: stackEnd,
    above: view.state.doc.lineAt(stackStart).to < stackEnd,
    create() {
      return { dom: diagnosticsTooltip(view, found) };
    }
  };
}
function diagnosticsTooltip(view, diagnostics) {
  return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d) => renderDiagnostic(view, d, false)));
}
var openLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel2.of(true)]) });
  let panel = getPanel(view, LintPanel.open);
  if (panel)
    panel.dom.querySelector(".cm-panel-lint ul").focus();
  return true;
};
var closeLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    return false;
  view.dispatch({ effects: togglePanel2.of(false) });
  return true;
};
var nextDiagnostic = (view) => {
  let field = view.state.field(lintState, false);
  if (!field)
    return false;
  let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
  if (!next.value) {
    next = field.diagnostics.iter(0);
    if (!next.value || next.from == sel.from && next.to == sel.to)
      return false;
  }
  view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
  return true;
};
var lintKeymap = [
  { key: "Mod-Shift-m", run: openLintPanel, preventDefault: true },
  { key: "F8", run: nextDiagnostic }
];
var lintPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.timeout = -1;
    this.set = true;
    let { delay } = view.state.facet(lintConfig);
    this.lintTime = Date.now() + delay;
    this.run = this.run.bind(this);
    this.timeout = setTimeout(this.run, delay);
  }
  run() {
    let now = Date.now();
    if (now < this.lintTime - 10) {
      setTimeout(this.run, this.lintTime - now);
    } else {
      this.set = false;
      let { state } = this.view, { sources } = state.facet(lintConfig);
      Promise.all(sources.map((source) => Promise.resolve(source(this.view)))).then((annotations) => {
        let all = annotations.reduce((a, b) => a.concat(b));
        if (this.view.state.doc == state.doc)
          this.view.dispatch(setDiagnostics(this.view.state, all));
      }, (error) => {
        logException(this.view.state, error);
      });
    }
  }
  update(update) {
    let config2 = update.state.facet(lintConfig);
    if (update.docChanged || config2 != update.startState.facet(lintConfig) || config2.needsRefresh && config2.needsRefresh(update)) {
      this.lintTime = Date.now() + config2.delay;
      if (!this.set) {
        this.set = true;
        this.timeout = setTimeout(this.run, config2.delay);
      }
    }
  }
  force() {
    if (this.set) {
      this.lintTime = Date.now();
      this.run();
    }
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
var lintConfig = /* @__PURE__ */ Facet.define({
  combine(input) {
    return Object.assign({ sources: input.map((i) => i.source) }, combineConfig(input.map((i) => i.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (a, b) => !a ? b : !b ? a : (u) => a(u) || b(u)
    }));
  },
  enables: lintPlugin
});
function linter(source, config2 = {}) {
  return lintConfig.of({ source, config: config2 });
}
function assignKeys(actions) {
  let assigned = [];
  if (actions)
    actions:
      for (let { name: name2 } of actions) {
        for (let i = 0; i < name2.length; i++) {
          let ch = name2[i];
          if (/[a-zA-Z]/.test(ch) && !assigned.some((c) => c.toLowerCase() == ch.toLowerCase())) {
            assigned.push(ch);
            continue actions;
          }
        }
        assigned.push("");
      }
  return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
  var _a2;
  let keys2 = inPanel ? assignKeys(diagnostic.actions) : [];
  return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action, i) => {
    let fired = false, click = (e) => {
      e.preventDefault();
      if (fired)
        return;
      fired = true;
      let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
      if (found)
        action.apply(view, found.from, found.to);
    };
    let { name: name2 } = action, keyIndex = keys2[i] ? name2.indexOf(keys2[i]) : -1;
    let nameElt = keyIndex < 0 ? name2 : [
      name2.slice(0, keyIndex),
      crelt("u", name2.slice(keyIndex, keyIndex + 1)),
      name2.slice(keyIndex + 1)
    ];
    return crelt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: click,
      onmousedown: click,
      "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys2[i]})"`}.`
    }, nameElt);
  }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
}
var DiagnosticWidget = class extends WidgetType {
  constructor(diagnostic) {
    super();
    this.diagnostic = diagnostic;
  }
  eq(other) {
    return other.diagnostic == this.diagnostic;
  }
  toDOM() {
    return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
};
var PanelItem = class {
  constructor(view, diagnostic) {
    this.diagnostic = diagnostic;
    this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
    this.dom = renderDiagnostic(view, diagnostic, true);
    this.dom.id = this.id;
    this.dom.setAttribute("role", "option");
  }
};
var LintPanel = class _LintPanel {
  constructor(view) {
    this.view = view;
    this.items = [];
    let onkeydown = (event) => {
      if (event.keyCode == 27) {
        closeLintPanel(this.view);
        this.view.focus();
      } else if (event.keyCode == 38 || event.keyCode == 33) {
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      } else if (event.keyCode == 40 || event.keyCode == 34) {
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      } else if (event.keyCode == 36) {
        this.moveSelection(0);
      } else if (event.keyCode == 35) {
        this.moveSelection(this.items.length - 1);
      } else if (event.keyCode == 13) {
        this.view.focus();
      } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic } = this.items[this.selectedIndex], keys2 = assignKeys(diagnostic.actions);
        for (let i = 0; i < keys2.length; i++)
          if (keys2[i].toUpperCase().charCodeAt(0) == event.keyCode) {
            let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
            if (found)
              diagnostic.actions[i].apply(view, found.from, found.to);
          }
      } else {
        return;
      }
      event.preventDefault();
    };
    let onclick = (event) => {
      for (let i = 0; i < this.items.length; i++) {
        if (this.items[i].dom.contains(event.target))
          this.moveSelection(i);
      }
    };
    this.list = crelt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown,
      onclick
    });
    this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => closeLintPanel(this.view)
    }, "\xD7"));
    this.update();
  }
  get selectedIndex() {
    let selected = this.view.state.field(lintState).selected;
    if (!selected)
      return -1;
    for (let i = 0; i < this.items.length; i++)
      if (this.items[i].diagnostic == selected.diagnostic)
        return i;
    return -1;
  }
  update() {
    let { diagnostics, selected } = this.view.state.field(lintState);
    let i = 0, needsSync = false, newSelectedItem = null;
    diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
      let found = -1, item;
      for (let j = i; j < this.items.length; j++)
        if (this.items[j].diagnostic == spec.diagnostic) {
          found = j;
          break;
        }
      if (found < 0) {
        item = new PanelItem(this.view, spec.diagnostic);
        this.items.splice(i, 0, item);
        needsSync = true;
      } else {
        item = this.items[found];
        if (found > i) {
          this.items.splice(i, found - i);
          needsSync = true;
        }
      }
      if (selected && item.diagnostic == selected.diagnostic) {
        if (!item.dom.hasAttribute("aria-selected")) {
          item.dom.setAttribute("aria-selected", "true");
          newSelectedItem = item;
        }
      } else if (item.dom.hasAttribute("aria-selected")) {
        item.dom.removeAttribute("aria-selected");
      }
      i++;
    });
    while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
      needsSync = true;
      this.items.pop();
    }
    if (this.items.length == 0) {
      this.items.push(new PanelItem(this.view, {
        from: -1,
        to: -1,
        severity: "info",
        message: this.view.state.phrase("No diagnostics")
      }));
      needsSync = true;
    }
    if (newSelectedItem) {
      this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
      this.view.requestMeasure({
        key: this,
        read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
        write: ({ sel, panel }) => {
          if (sel.top < panel.top)
            this.list.scrollTop -= panel.top - sel.top;
          else if (sel.bottom > panel.bottom)
            this.list.scrollTop += sel.bottom - panel.bottom;
        }
      });
    } else if (this.selectedIndex < 0) {
      this.list.removeAttribute("aria-activedescendant");
    }
    if (needsSync)
      this.sync();
  }
  sync() {
    let domPos = this.list.firstChild;
    function rm2() {
      let prev = domPos;
      domPos = prev.nextSibling;
      prev.remove();
    }
    for (let item of this.items) {
      if (item.dom.parentNode == this.list) {
        while (domPos != item.dom)
          rm2();
        domPos = item.dom.nextSibling;
      } else {
        this.list.insertBefore(item.dom, domPos);
      }
    }
    while (domPos)
      rm2();
  }
  moveSelection(selectedIndex) {
    if (this.selectedIndex < 0)
      return;
    let field = this.view.state.field(lintState);
    let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
    if (!selection)
      return;
    this.view.dispatch({
      selection: { anchor: selection.from, head: selection.to },
      scrollIntoView: true,
      effects: movePanelSelection.of(selection)
    });
  }
  static open(view) {
    return new _LintPanel(view);
  }
};
function svg(content2, attrs = `viewBox="0 0 40 40"`) {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
}
function underline(color) {
  return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
}
var baseTheme5 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ underline("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ underline("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ underline("#999") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});

// node_modules/codemirror/dist/index.js
var basicSetup = /* @__PURE__ */ (() => [
  lineNumbers(),
  highlightActiveLineGutter(),
  highlightSpecialChars(),
  history(),
  foldGutter(),
  drawSelection(),
  dropCursor(),
  EditorState.allowMultipleSelections.of(true),
  indentOnInput(),
  syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
  bracketMatching(),
  closeBrackets(),
  autocompletion(),
  rectangularSelection(),
  crosshairCursor(),
  highlightActiveLine(),
  highlightSelectionMatches(),
  keymap.of([
    ...closeBracketsKeymap,
    ...defaultKeymap,
    ...searchKeymap,
    ...historyKeymap,
    ...foldKeymap,
    ...completionKeymap,
    ...lintKeymap
  ])
])();

// ns-hugo:/home/runner/work/sherpa/sherpa/src/web/doc/assets/js/lab/logger.ts
function log(...args) {
  console.log(...args);
}

// ns-hugo:/home/runner/work/sherpa/sherpa/src/web/doc/assets/js/controls/scroll.ts
var ScrollHandler = class {
  ele;
  handle;
  scroll_host;
  scroll;
  scroll_end;
  scroll_beg;
  resize_obs;
  mutate_obs;
  curr_height;
  target_height;
  target_pos;
  curr_pos;
  sb_distance;
  scroll_box_ratio;
  grab_diff;
  scroll_amount;
  HANDLE_MOVE;
  bound_handle_wheel;
  bound_handle_scroll;
  constructor(ele, scroll_host = ele) {
    this.scroll_host = scroll_host;
    this.scroll = document.createElement("div");
    this.scroll.classList.add("scroll");
    this.handle = document.createElement("div");
    this.handle.classList.add("scroll-handle");
    this.handle.addEventListener("pointerdown", this.handle_down.bind(this));
    this.handle.addEventListener("pointermove", this.handle_move.bind(this));
    this.handle.addEventListener("pointerup", this.handle_up.bind(this));
    this.scroll_beg = document.createElement("div");
    this.scroll_beg.classList.add("scroll-beg");
    this.scroll_end = document.createElement("div");
    this.scroll_end.classList.add("scroll-end");
    this.scroll.appendChild(this.handle);
    this.scroll.appendChild(this.scroll_beg);
    this.scroll.appendChild(this.scroll_end);
    this.scroll_host.appendChild(this.scroll);
    this.resize_obs = new ResizeObserver(this.handle_resize.bind(this));
    this.mutate_obs = new MutationObserver(this.handle_resize.bind(this));
    this.resize_obs.observe(scroll_host);
    this.bound_handle_wheel = this.handle_wheel.bind(this);
    this.bound_handle_scroll = this.handle_scroll.bind(this);
    this.scroll_amount = 0;
    this.scroll_box_ratio = 1;
    this.sb_distance = 0;
    this.target_height = 0;
    this.curr_height = 0;
    this.curr_pos = 0;
    this.target_pos = 0;
    this.HANDLE_MOVE = false;
    this.grab_diff = 0;
    this.set_target(ele);
  }
  set_target(target) {
    if (this.ele) {
      this.ele.removeEventListener("wheel", this.bound_handle_wheel);
      this.ele.removeEventListener("scroll", this.bound_handle_scroll);
      this.resize_obs.unobserve(this.ele);
      this.mutate_obs.disconnect();
    }
    this.resize_obs.observe(target);
    this.mutate_obs.observe(target, {
      subtree: true,
      attributes: true,
      childList: true
    });
    for (const ele of Array.from(target.children))
      this.resize_obs.observe(ele);
    target.addEventListener("wheel", this.bound_handle_wheel);
    target.addEventListener("scroll", this.bound_handle_scroll);
    this.ele = target;
    this.handle_resize();
  }
  handle_resize() {
    if (this.ele) {
      const clientHeight = this.ele.clientHeight;
      this.scroll_amount = this.ele.scrollHeight - clientHeight;
      this.scroll_box_ratio = clientHeight / this.ele.scrollHeight;
      this.target_height = this.scroll_box_ratio * this.scroll.clientHeight;
      this.target_pos = this.ele.scrollTop / this.scroll_amount * (this.scroll.clientHeight - this.target_height);
      this.sb_distance = this.scroll.clientHeight - this.target_height;
      if (this.sb_distance < 1) {
        this.scroll.classList.add("no-scroll");
      } else {
        this.scroll.classList.remove("no-scroll");
      }
      this.handle_pos_adjust();
      this.handle_height_adjust();
      this.handle_scrolled();
    }
  }
  handle_height_adjust() {
    if (this.curr_height != this.target_height && this.ele) {
      const diff = (this.target_height - this.curr_height) * 0.5;
      if (Math.abs(diff) > 0.01) {
        this.curr_height += diff;
        setTimeout(this.handle_height_adjust.bind(this), 10);
      } else {
        this.curr_height = this.target_height;
      }
      if (this.curr_height + this.target_pos > this.ele.scrollHeight)
        this.curr_height -= this.curr_height + this.target_pos - this.ele.scrollHeight;
      this.handle.style.height = this.curr_height + "px";
    }
  }
  handle_pos_adjust() {
    if (this.curr_pos != this.target_pos) {
      const diff = (this.target_pos - this.curr_pos) * 0.5;
      if (Math.abs(diff) > 1e19) {
        this.curr_pos += diff;
        setTimeout(this.handle_pos_adjust.bind(this), 10);
      } else {
        this.curr_pos = this.target_pos;
      }
      this.handle.style.top = this.curr_pos + "px";
    }
  }
  set_handle_pos_diff(diff) {
    this.set_handle_pos(this.target_pos + diff);
  }
  set_handle_pos(pos) {
    if (this.ele) {
      this.target_pos = Math.max(Math.min(pos, this.sb_distance), 0);
      this.handle_pos_adjust();
      this.handle_scrolled();
      const ratio = this.target_pos / this.sb_distance;
      this.ele.scrollTop = this.scroll_amount * ratio;
    }
  }
  handle_scrolled() {
  }
  handle_scroll(e) {
    if (this.HANDLE_MOVE)
      return;
    this.handle_resize();
  }
  handle_move(e) {
    if (this.HANDLE_MOVE) {
      const y = e.clientY - getTop(this.scroll) + this.grab_diff;
      this.set_handle_pos(y);
      e.preventDefault();
      e.stopImmediatePropagation();
      e.stopPropagation();
      return false;
    }
  }
  handle_up(e) {
    this.handle.releasePointerCapture(e.pointerId);
    this.HANDLE_MOVE = false;
    e.preventDefault();
    e.stopPropagation();
  }
  handle_down(e) {
    this.handle.setPointerCapture(e.pointerId);
    this.grab_diff = -(e.clientY - getTop(this.scroll)) + this.target_pos;
    this.HANDLE_MOVE = true;
  }
  handle_wheel(e) {
    this.set_handle_pos_diff(Math.sign(e.deltaY) * 50 * this.scroll_box_ratio);
  }
};
function getTop(ele) {
  let top2 = 0;
  while (ele) {
    top2 += ele.offsetTop;
    ele = ele.parentElement;
  }
  return top2;
}

// ns-hugo:/home/runner/work/sherpa/sherpa/src/web/doc/assets/js/lab/session_storage.ts
var LAB_GRAMMAR_KEY = "lab-data";
var LAB_INPUT_KEY = "lab-input-key";
function get_grammar() {
  let sessionText = sessionStorage.getItem(LAB_GRAMMAR_KEY);
  return sessionText || `<> A > 'B' C? 

<> C > "D"`;
}
function set_grammar(grammar) {
  sessionStorage.setItem(LAB_GRAMMAR_KEY, grammar);
}
function get_input() {
  let sessionText = sessionStorage.getItem(LAB_INPUT_KEY);
  return sessionText || `BD`;
}
function set_input(input) {
  sessionStorage.setItem(LAB_INPUT_KEY, input);
}

// ns-hugo:/home/runner/work/sherpa/sherpa/src/web/doc/assets/js/lab/sherpa_lang.ts
var SherpaParser = class extends Parser {
  names;
  types = {};
  nodeSet;
  ctx;
  constructor(ctx) {
    super();
    this.ctx = ctx;
    let names = get_production_names();
    names.push("token");
    this.nodeSet = new NodeSet(names.map((name2, id) => {
      return NodeType.define({ id, top: name2 == "sherpa::grammar", name: name2.replace("::", "-") });
    })).extend(styleTags({
      "sherpa_symbol-production_symbol!": tags.definitionKeyword,
      "sherpa_symbol-terminal!": tags.string,
      "sherpa-production/...": tags.definitionOperator,
      "sherpa_symbol-class!": tags.className
    }));
    this.names = get_production_names();
  }
  createParse(input, fragments, ranges) {
    let input_string = input.read(ranges[0].from, ranges[0].to);
    let parser = JSGrammarParser.new(input_string);
    let stack = get_codemirror_parse_tree(input_string);
    this.ctx.addGrammar(input_string, "/");
    stack[stack.length - 4] = 4;
    let nodeSet = this.nodeSet;
    let len = input_string.length;
    return {
      advance() {
        return Tree.build({
          topID: 0,
          buffer: stack,
          nodeSet
        });
      },
      stopAt(pos) {
        console.log("end", pos);
      },
      parsedPos: len,
      stoppedAt: len
    };
  }
};
function SherpaLinter(ctx) {
  return linter((view) => {
    console.log("Linting!");
    set_grammar(view.state.doc.toString());
    let messages = [];
    let parser_errors = ctx.parse_errors;
    if (parser_errors.length > 0) {
      convertPosErrorsToDiagnostics(parser_errors, "parser", messages);
    }
    if (!ctx.createDB("/")) {
      convertPosErrorsToDiagnostics(ctx.db_errors, "semantic-evaluator", messages);
    } else {
      let db = ctx.db;
      if (!db)
        return messages;
      console.log("DB Created");
      try {
        let output = document.getElementById("ast-output");
        if (output) {
          output.innerText = create_rust_ast_output(db);
        }
      } catch (e) {
        if (e instanceof PositionedErrors) {
          convertPosErrorsToDiagnostics(e, "ast-compiler", messages);
          e.free();
        } else {
          console.log(e);
        }
      }
    }
    return messages;
  }, {
    delay: 130
  });
}
function convertPosErrorsToDiagnostics(e, source, messages = []) {
  for (let i = 0; i < e.length; i++) {
    let error = Array.isArray(e) ? e[i] : e.get_error_at(i);
    ;
    if (error) {
      messages.push({
        from: error.start_offset,
        to: error.end_offset,
        severity: "error",
        source,
        message: error.message
      });
    }
  }
  return messages;
}
function sherpaLang(ctx) {
  let lang_sys = new SherpaParser(ctx);
  return new LanguageSupport(
    new Language(
      defineLanguageFacet({ commentTokens: { block: { open: "/*", close: "*/" } } }),
      lang_sys,
      [
        SherpaLinter(ctx),
        syntaxHighlighting(
          HighlightStyle.define([
            {
              tag: tags.definitionOperator,
              class: "syn-prod"
            },
            {
              tag: tags.definitionKeyword,
              class: "syn-prod-id"
            },
            {
              tag: tags.string,
              class: "syn-term"
            },
            {
              tag: tags.className,
              class: "syn-class"
            }
          ])
        )
      ],
      "sherpa"
    ),
    []
  );
}

// ns-hugo:/home/runner/work/sherpa/sherpa/src/web/doc/assets/js/lab/grammar_context.ts
var GrammarContext = class {
  soup_;
  db_;
  listeners;
  pending_events;
  RUNNING_EVENTS;
  current_parse_errors;
  current_db_errors;
  /// Should only be called after sherpa is initialized
  constructor() {
    this.soup_ = create_soup();
    this.listeners = /* @__PURE__ */ new Map();
    this.pending_events = [];
    this.RUNNING_EVENTS = false;
    this.db_ = null;
    this.current_parse_errors = [];
    this.current_db_errors = [];
  }
  get soup() {
    return this.soup_;
  }
  get db() {
    return this.db_;
  }
  get parse_errors() {
    return this.current_parse_errors;
  }
  get db_errors() {
    return this.current_db_errors;
  }
  addGrammar(input_string, grammar_name) {
    this.current_parse_errors.map((e) => e.free());
    this.current_parse_errors.length = 0;
    try {
      this.soup.add_grammar(input_string, grammar_name);
      this.signal("grammar-added" /* GrammarAdded */);
    } catch (e) {
      if (e instanceof PositionedErrors) {
        for (let i = 0; i < e.length; i++) {
          let error = e.get_error_at(i);
          if (error)
            this.current_parse_errors.push(error);
        }
        e.free();
      } else {
        console.log(e);
      }
    }
  }
  createDB(grammar_name) {
    if (this.db_) {
      this.db_.free();
      this.db_ = null;
      this.signal("db-deleted" /* DBDeleted */, false);
    }
    this.current_db_errors.map((e) => e.free());
    this.current_db_errors.length = 0;
    try {
      this.db_ = create_parse_db(grammar_name, this.soup_);
      this.signal("db-created" /* DBCreated */, false);
      return true;
    } catch (e) {
      if (e instanceof PositionedErrors) {
        for (let i = 0; i < e.length; i++) {
          let error = e.get_error_at(i);
          if (error)
            this.current_db_errors.push(error);
        }
        e.free();
      } else {
        console.log(e);
      }
    }
    return false;
  }
  addListener(event, fn) {
    if (!this.listeners.has(event))
      this.listeners.set(event, /* @__PURE__ */ new Set());
    this.listeners.get(event)?.add(fn);
  }
  signal(event, process_rest = true) {
    if (event)
      this.pending_events.push(event);
    if (this.RUNNING_EVENTS)
      return;
    this.RUNNING_EVENTS = true;
    let e;
    while (e = this.pending_events.shift()) {
      let listeners = this.listeners.get(e) ?? [];
      for (const listener of listeners) {
        listener(this);
      }
      if (!process_rest)
        break;
    }
    this.RUNNING_EVENTS = false;
  }
};

// ns-hugo:/home/runner/work/sherpa/sherpa/src/web/doc/assets/js/lab/parser.ts
var head_dec = Decoration.mark({ attributes: { style: "background-color: red" } });
var scan_dec = Decoration.mark({ attributes: { style: "background-color: blue" } });
var end_dec = Decoration.mark({ attributes: { style: "background-color: green" } });
var highlight_effect = StateEffect.define();
var filter_effects = StateEffect.define();
function parserHost(ctx, {
  debugger_start_stop_button,
  debugger_step_button,
  debugger_into_button,
  debugger_out_button,
  debugger_output,
  debugger_entry_selection,
  debugger_optimize_checkbox
}) {
  let view = null;
  let bytecode = null;
  let states = null;
  let parser = null;
  let PARSING = false;
  let debugger_steps = [];
  let debugger_offset = -1;
  let play_interval = -1;
  let optimize = false;
  let active_search_symbols = /* @__PURE__ */ new Set();
  let active_state_source = "";
  let active_scanner_state_source = "";
  let parser_off = [0, 0];
  let scanner_off = [0, 0];
  ctx.addListener("grammar-added" /* GrammarAdded */, (ctx2) => {
    console.log("Grammar Added");
    states = null;
  });
  ctx.addListener("db-deleted" /* DBDeleted */, (ctx2) => {
    console.log("DBDeleted");
    destroy_states();
  });
  ctx.addListener("db-created" /* DBCreated */, (ctx2) => {
    console.log("DBCreated");
    let db = ctx2.db;
    if (!db)
      return;
    configure_entry_options(db);
  });
  function create_parser_data() {
    if (states)
      return;
    if (!ctx.db)
      return;
    let db = ctx.db;
    try {
      states = create_parser_states(db, optimize);
      console.log(states);
      bytecode = create_bytecode(db, states);
      let output = document.getElementById("bytecode-output");
      if (output) {
        output.innerText = create_bytecode_disassembly(bytecode);
      }
    } catch (e) {
      console.log(e);
    }
    if (db)
      return;
  }
  function configure_entry_options(db) {
    debugger_entry_selection.innerHTML = "";
    for (const entry_name of get_entry_names(db)) {
      let option = document.createElement("option");
      option.innerText = entry_name;
      option.value = entry_name;
      debugger_entry_selection.appendChild(option);
    }
  }
  function destroy_parser() {
    if (parser) {
      parser.free();
      parser = null;
    }
  }
  function destroy_states() {
    if (states) {
      states.free();
      states = null;
    }
  }
  function create_parser() {
    if (!(view && bytecode && ctx.db))
      return;
    destroy_parser();
    parser = JSByteCodeParser.new(view.state.doc.toString(), bytecode);
    parser.init(debugger_entry_selection.value, bytecode, ctx.db);
  }
  function stop_parser() {
    if (!PARSING)
      return;
    destroy_parser();
    toggle_play(true);
    PARSING = false;
    debugger_start_stop_button.innerHTML = "start";
    debugger_start_stop_button.classList.remove("started");
  }
  function start_parser() {
    if (!(view && ctx.db && !PARSING))
      return;
    create_parser_data();
    if (!(states && bytecode))
      return;
    debugger_start_stop_button.innerHTML = "stop";
    debugger_start_stop_button.classList.add("started");
    create_parser();
    if (!parser)
      return;
    debugger_offset = -1;
    active_search_symbols.clear();
    debugger_steps.length = 0;
    debugger_output.innerText = "";
    active_state_source = "";
    active_scanner_state_source = "";
    view.dispatch({ userEvent: "debugger.start" });
    PARSING = true;
    step_forward();
  }
  function step_forward() {
    if (view && parser && states && bytecode && ctx.db && PARSING) {
      let db = ctx.db;
      debugger_offset += 1;
      if (debugger_offset >= debugger_steps.length) {
        let result = parser.next();
        if (Array.isArray(result))
          debugger_steps.push(...result);
        if (debugger_offset >= debugger_steps.length) {
          toggle_play(true);
        }
      }
      debugger_offset = Math.min(debugger_offset, debugger_steps.length - 1);
      let step;
      outer:
        while (step = debugger_steps[debugger_offset]) {
          switch (step.type) {
            case "ShiftToken":
              active_search_symbols.clear();
              break;
            case "ExecuteInstruction":
              {
                if (!step.is_scanner) {
                  active_scanner_state_source = "";
                  let token_offset = get_debug_tok_offsets(step.instruction, bytecode);
                  if (token_offset) {
                    parser_off[0] = token_offset.start - 1;
                    parser_off[1] = token_offset.end - 1;
                    break;
                  }
                  let debug_symbols = get_debug_symbol_ids(step.instruction, bytecode);
                  if (debug_symbols.length > 0) {
                    debug_symbols.forEach((s) => active_search_symbols.add(get_symbol_name_from_id(s, db)));
                    break;
                  }
                  let name2 = get_debug_state_name(step.instruction, bytecode);
                  if (name2) {
                    active_state_source = get_state_source_string(name2, states, db);
                    break;
                  }
                } else {
                  let token_offset = get_debug_tok_offsets(step.instruction, bytecode);
                  if (token_offset) {
                    scanner_off[0] = token_offset.start - 1;
                    scanner_off[1] = token_offset.end - 1;
                    break;
                  }
                  let name2 = get_debug_state_name(step.instruction, bytecode);
                  if (name2) {
                    active_scanner_state_source = get_state_source_string(name2, states, db);
                    break;
                  }
                }
                debugger_output.innerText = JSON.stringify(step, void 0, 2) + "\n\n" + [...active_search_symbols].join(" | ") + "\n\n" + create_instruction_disassembly(step.instruction, bytecode) + "\n\n" + markSource(active_state_source, parser_off) + "\n\n" + markSource(active_scanner_state_source, scanner_off);
                let effects = [filter_effects.of((from, to) => false)];
                let { head_ptr, scan_ptr } = step;
                effects.push(highlight_effect.of([
                  head_dec.range(head_ptr, head_ptr + 1)
                ]));
                if (scan_ptr > head_ptr) {
                  effects.push(highlight_effect.of([
                    scan_dec.range(scan_ptr, scan_ptr + 1)
                  ]));
                }
                view.dispatch({ effects });
              }
              break outer;
          }
          debugger_offset++;
        }
    }
    function markSource(source, offsets) {
      return source.slice(0, offsets[0]) + "|" + source.slice(...offsets) + "|" + source.slice(offsets[1]);
    }
  }
  function toggle_play(force_stop = false) {
    if (play_interval >= 0 || force_stop) {
      clearInterval(play_interval);
      play_interval = -1;
    } else if (PARSING) {
      play_interval = setInterval(step_forward, 1);
    }
  }
  debugger_optimize_checkbox.addEventListener("change", (e) => {
    stop_parser();
    destroy_states();
    optimize = debugger_optimize_checkbox.checked;
  });
  debugger_step_button.addEventListener("click", step_forward);
  debugger_into_button.addEventListener("click", (e) => toggle_play());
  debugger_start_stop_button.addEventListener("click", (e) => {
    if (PARSING)
      stop_parser();
    else
      start_parser();
  });
  debugger_entry_selection.addEventListener("change", (e) => {
    stop_parser();
  });
  stop_parser();
  return [
    ViewPlugin.fromClass(class {
      update(update) {
        if (update.transactions.find((e) => e.isUserEvent("debugger.start"))) {
          console.log("Started");
        } else if (update.docChanged) {
          stop_parser();
        }
      }
    }, {}),
    EditorView.updateListener.of(function(e) {
      set_input(e.state.doc.toString());
      view = e.view;
    }),
    StateField.define({
      create() {
        return Decoration.none;
      },
      update(value, tr) {
        value = value.map(tr.changes);
        for (let effect of tr.effects) {
          if (effect.is(highlight_effect))
            value = value.update({ add: effect.value, sort: true });
          else if (effect.is(filter_effects))
            value = value.update({ filter: effect.value });
        }
        return value;
      },
      provide(f) {
        return EditorView.decorations.from(f);
      }
    })
  ];
}

// ns-hugo:/home/runner/work/sherpa/sherpa/src/web/doc/assets/js/lab/docs_handler.ts
function docs_handler_default(docs_iframe, docs_host) {
  if (docs_iframe.tagName == "IFRAME") {
    let handler = new ScrollHandler(docs_iframe, docs_host);
    let hash = document.location.hash;
    if (hash.slice(0, 6) == "#page:") {
      docs_iframe.src = hash.slice(6).replace("/%2f/g", "/");
      docs_host.classList.add("loading");
      docs_host.classList.add("active");
    }
    log("Configuring docs integration");
    docs_iframe.addEventListener("load", (w) => {
      let docs_doc = docs_iframe.contentDocument;
      if (docs_doc) {
        let html_element = docs_doc.documentElement;
        docs_doc.body.classList.add("lab-iframe");
        html_element.style.overflow = "hidden";
        handler.set_target(html_element);
        for (const anchor of Array.from(docs_doc.getElementsByTagName("a"))) {
          anchor.addEventListener("click", (e) => {
            e.preventDefault();
            return false;
          });
        }
        docs_host.classList.remove("loading");
      }
    });
  } else {
    alert("Docs frame not correctly connected, cannot integrate docs");
  }
}

// <stdin>
async function stdin_default({
  codemirror_grammar_host,
  codemirror_parser_host,
  disassembly_output,
  debugger_start_stop_button,
  debugger_step_button,
  debugger_into_button,
  debugger_out_button,
  debugger_output,
  debugger_entry_selection,
  debugger_optimize_checkbox
}) {
  try {
    await sherpa_wasm_default();
    log("Sherpa WASM Runtime initialized");
  } catch {
    alert("Sherpa Failed to Load");
  }
  const ctx = new GrammarContext();
  const parser_editor = new EditorView({
    doc: get_input(),
    extensions: [basicSetup, parserHost(ctx, {
      debugger_start_stop_button,
      debugger_step_button,
      debugger_into_button,
      debugger_out_button,
      debugger_output,
      debugger_entry_selection,
      debugger_optimize_checkbox
    })],
    parent: codemirror_parser_host
  });
  const grammar_editor = new EditorView({
    doc: get_grammar(),
    extensions: [
      basicSetup,
      sherpaLang(ctx),
      EditorView.editorAttributes.of({ class: "Codemirror" })
    ],
    parent: codemirror_grammar_host
  });
}
export {
  ScrollHandler,
  stdin_default as default,
  docs_handler_default as docs_handler
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibnMtaHVnbzovaG9tZS9ydW5uZXIvd29yay9zaGVycGEvc2hlcnBhL3NyYy93ZWIvZG9jL2Fzc2V0cy9qcy9zaGVycGEvc2hlcnBhX3dhc20uanMiLCAibm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3N0YXRlL2Rpc3QvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3N0eWxlLW1vZC9zcmMvc3R5bGUtbW9kLmpzIiwgIm5vZGVfbW9kdWxlcy93M2Mta2V5bmFtZS9pbmRleC5lcy5qcyIsICJub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BsZXplci9oaWdobGlnaHQvZGlzdC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvY3JlbHQvaW5kZXguZXMuanMiLCAibm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3NlYXJjaC9kaXN0L2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9hdXRvY29tcGxldGUvZGlzdC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGludC9kaXN0L2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2Rpc3QvaW5kZXguanMiLCAibnMtaHVnbzovaG9tZS9ydW5uZXIvd29yay9zaGVycGEvc2hlcnBhL3NyYy93ZWIvZG9jL2Fzc2V0cy9qcy9sYWIvbG9nZ2VyLnRzIiwgIm5zLWh1Z286L2hvbWUvcnVubmVyL3dvcmsvc2hlcnBhL3NoZXJwYS9zcmMvd2ViL2RvYy9hc3NldHMvanMvY29udHJvbHMvc2Nyb2xsLnRzIiwgIm5zLWh1Z286L2hvbWUvcnVubmVyL3dvcmsvc2hlcnBhL3NoZXJwYS9zcmMvd2ViL2RvYy9hc3NldHMvanMvbGFiL3Nlc3Npb25fc3RvcmFnZS50cyIsICJucy1odWdvOi9ob21lL3J1bm5lci93b3JrL3NoZXJwYS9zaGVycGEvc3JjL3dlYi9kb2MvYXNzZXRzL2pzL2xhYi9zaGVycGFfbGFuZy50cyIsICJucy1odWdvOi9ob21lL3J1bm5lci93b3JrL3NoZXJwYS9zaGVycGEvc3JjL3dlYi9kb2MvYXNzZXRzL2pzL2xhYi9ncmFtbWFyX2NvbnRleHQudHMiLCAibnMtaHVnbzovaG9tZS9ydW5uZXIvd29yay9zaGVycGEvc2hlcnBhL3NyYy93ZWIvZG9jL2Fzc2V0cy9qcy9sYWIvcGFyc2VyLnRzIiwgIm5zLWh1Z286L2hvbWUvcnVubmVyL3dvcmsvc2hlcnBhL3NoZXJwYS9zcmMvd2ViL2RvYy9hc3NldHMvanMvbGFiL2RvY3NfaGFuZGxlci50cyIsICI8c3RkaW4+Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJsZXQgd2FzbTtcblxuY29uc3QgY2FjaGVkVGV4dERlY29kZXIgPSAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGlnbm9yZUJPTTogdHJ1ZSwgZmF0YWw6IHRydWUgfSkgOiB7IGRlY29kZTogKCkgPT4geyB0aHJvdyBFcnJvcignVGV4dERlY29kZXIgbm90IGF2YWlsYWJsZScpIH0gfSApO1xuXG5pZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykgeyBjYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoKTsgfTtcblxubGV0IGNhY2hlZFVpbnQ4TWVtb3J5MCA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldFVpbnQ4TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkVWludDhNZW1vcnkwID09PSBudWxsIHx8IGNhY2hlZFVpbnQ4TWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhY2hlZFVpbnQ4TWVtb3J5MCA9IG5ldyBVaW50OEFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRVaW50OE1lbW9yeTA7XG59XG5cbmZ1bmN0aW9uIGdldFN0cmluZ0Zyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICByZXR1cm4gY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKGdldFVpbnQ4TWVtb3J5MCgpLnN1YmFycmF5KHB0ciwgcHRyICsgbGVuKSk7XG59XG5cbmNvbnN0IGhlYXAgPSBuZXcgQXJyYXkoMTI4KS5maWxsKHVuZGVmaW5lZCk7XG5cbmhlYXAucHVzaCh1bmRlZmluZWQsIG51bGwsIHRydWUsIGZhbHNlKTtcblxubGV0IGhlYXBfbmV4dCA9IGhlYXAubGVuZ3RoO1xuXG5mdW5jdGlvbiBhZGRIZWFwT2JqZWN0KG9iaikge1xuICAgIGlmIChoZWFwX25leHQgPT09IGhlYXAubGVuZ3RoKSBoZWFwLnB1c2goaGVhcC5sZW5ndGggKyAxKTtcbiAgICBjb25zdCBpZHggPSBoZWFwX25leHQ7XG4gICAgaGVhcF9uZXh0ID0gaGVhcFtpZHhdO1xuXG4gICAgaGVhcFtpZHhdID0gb2JqO1xuICAgIHJldHVybiBpZHg7XG59XG5cbmZ1bmN0aW9uIGdldE9iamVjdChpZHgpIHsgcmV0dXJuIGhlYXBbaWR4XTsgfVxuXG5mdW5jdGlvbiBkcm9wT2JqZWN0KGlkeCkge1xuICAgIGlmIChpZHggPCAxMzIpIHJldHVybjtcbiAgICBoZWFwW2lkeF0gPSBoZWFwX25leHQ7XG4gICAgaGVhcF9uZXh0ID0gaWR4O1xufVxuXG5mdW5jdGlvbiB0YWtlT2JqZWN0KGlkeCkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChpZHgpO1xuICAgIGRyb3BPYmplY3QoaWR4KTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkZWJ1Z1N0cmluZyh2YWwpIHtcbiAgICAvLyBwcmltaXRpdmUgdHlwZXNcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbDtcbiAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdib29sZWFuJyB8fCB2YWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIGAke3ZhbH1gO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYFwiJHt2YWx9XCJgO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSAnc3ltYm9sJykge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbC5kZXNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnU3ltYm9sJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgU3ltYm9sKCR7ZGVzY3JpcHRpb259KWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBuYW1lID0gdmFsLm5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyAmJiBuYW1lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBgRnVuY3Rpb24oJHtuYW1lfSlgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdGdW5jdGlvbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb2JqZWN0c1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdmFsLmxlbmd0aDtcbiAgICAgICAgbGV0IGRlYnVnID0gJ1snO1xuICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVidWcgKz0gZGVidWdTdHJpbmcodmFsWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRlYnVnICs9ICcsICcgKyBkZWJ1Z1N0cmluZyh2YWxbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnICs9ICddJztcbiAgICAgICAgcmV0dXJuIGRlYnVnO1xuICAgIH1cbiAgICAvLyBUZXN0IGZvciBidWlsdC1pblxuICAgIGNvbnN0IGJ1aWx0SW5NYXRjaGVzID0gL1xcW29iamVjdCAoW15cXF1dKylcXF0vLmV4ZWModG9TdHJpbmcuY2FsbCh2YWwpKTtcbiAgICBsZXQgY2xhc3NOYW1lO1xuICAgIGlmIChidWlsdEluTWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IGJ1aWx0SW5NYXRjaGVzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhaWxlZCB0byBtYXRjaCB0aGUgc3RhbmRhcmQgJ1tvYmplY3QgQ2xhc3NOYW1lXSdcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKTtcbiAgICB9XG4gICAgaWYgKGNsYXNzTmFtZSA9PSAnT2JqZWN0Jykge1xuICAgICAgICAvLyB3ZSdyZSBhIHVzZXIgZGVmaW5lZCBjbGFzcyBvciBPYmplY3RcbiAgICAgICAgLy8gSlNPTi5zdHJpbmdpZnkgYXZvaWRzIHByb2JsZW1zIHdpdGggY3ljbGVzLCBhbmQgaXMgZ2VuZXJhbGx5IG11Y2hcbiAgICAgICAgLy8gZWFzaWVyIHRoYW4gbG9vcGluZyB0aHJvdWdoIG93blByb3BlcnRpZXMgb2YgYHZhbGAuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gJ09iamVjdCgnICsgSlNPTi5zdHJpbmdpZnkodmFsKSArICcpJztcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuICdPYmplY3QnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVycm9yc1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gYCR7dmFsLm5hbWV9OiAke3ZhbC5tZXNzYWdlfVxcbiR7dmFsLnN0YWNrfWA7XG4gICAgfVxuICAgIC8vIFRPRE8gd2UgY291bGQgdGVzdCBmb3IgbW9yZSB0aGluZ3MgaGVyZSwgbGlrZSBgU2V0YHMgYW5kIGBNYXBgcy5cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xufVxuXG5sZXQgV0FTTV9WRUNUT1JfTEVOID0gMDtcblxuY29uc3QgY2FjaGVkVGV4dEVuY29kZXIgPSAodHlwZW9mIFRleHRFbmNvZGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RW5jb2RlcigndXRmLTgnKSA6IHsgZW5jb2RlOiAoKSA9PiB7IHRocm93IEVycm9yKCdUZXh0RW5jb2RlciBub3QgYXZhaWxhYmxlJykgfSB9ICk7XG5cbmNvbnN0IGVuY29kZVN0cmluZyA9ICh0eXBlb2YgY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlSW50byA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZnVuY3Rpb24gKGFyZywgdmlldykge1xuICAgIHJldHVybiBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGVJbnRvKGFyZywgdmlldyk7XG59XG4gICAgOiBmdW5jdGlvbiAoYXJnLCB2aWV3KSB7XG4gICAgY29uc3QgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG4gICAgdmlldy5zZXQoYnVmKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWFkOiBhcmcubGVuZ3RoLFxuICAgICAgICB3cml0dGVuOiBidWYubGVuZ3RoXG4gICAgfTtcbn0pO1xuXG5mdW5jdGlvbiBwYXNzU3RyaW5nVG9XYXNtMChhcmcsIG1hbGxvYywgcmVhbGxvYykge1xuXG4gICAgaWYgKHJlYWxsb2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBidWYgPSBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGUoYXJnKTtcbiAgICAgICAgY29uc3QgcHRyID0gbWFsbG9jKGJ1Zi5sZW5ndGgsIDEpID4+PiAwO1xuICAgICAgICBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIsIHB0ciArIGJ1Zi5sZW5ndGgpLnNldChidWYpO1xuICAgICAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBidWYubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGxldCBsZW4gPSBhcmcubGVuZ3RoO1xuICAgIGxldCBwdHIgPSBtYWxsb2MobGVuLCAxKSA+Pj4gMDtcblxuICAgIGNvbnN0IG1lbSA9IGdldFVpbnQ4TWVtb3J5MCgpO1xuXG4gICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKDsgb2Zmc2V0IDwgbGVuOyBvZmZzZXQrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gYXJnLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgaWYgKGNvZGUgPiAweDdGKSBicmVhaztcbiAgICAgICAgbWVtW3B0ciArIG9mZnNldF0gPSBjb2RlO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXQgIT09IGxlbikge1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBwdHIgPSByZWFsbG9jKHB0ciwgbGVuLCBsZW4gPSBvZmZzZXQgKyBhcmcubGVuZ3RoICogMywgMSkgPj4+IDA7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIgKyBvZmZzZXQsIHB0ciArIGxlbik7XG4gICAgICAgIGNvbnN0IHJldCA9IGVuY29kZVN0cmluZyhhcmcsIHZpZXcpO1xuXG4gICAgICAgIG9mZnNldCArPSByZXQud3JpdHRlbjtcbiAgICB9XG5cbiAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHB0cjtcbn1cblxubGV0IGNhY2hlZEludDMyTWVtb3J5MCA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldEludDMyTWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkSW50MzJNZW1vcnkwID09PSBudWxsIHx8IGNhY2hlZEludDMyTWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhY2hlZEludDMyTWVtb3J5MCA9IG5ldyBJbnQzMkFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRJbnQzMk1lbW9yeTA7XG59XG4vKipcbiogQ3JlYXRlcyBhbiBlbXB0eSBncmFtbWFyIHNvdXAgb2JqZWN0LlxuKiBVc2Ugc291cCBtb2RpZmllcnMgdG8gYWRkIGdyYW1tYXJzIGFuZCBwcm9kdWN0aW9uc1xuKlxuKiBQYXNzIHNvdXAgdG8gcGFyc2VyIGNvbXBpbGVyIGZ1bmN0aW9ucyB0byBjcmVhdGUgcGFyc2VycywgZ2VuZXJhdGUgYnl0ZWNvZGUsXG4qIGFuZCBjb25zdHJ1Y3QgQVNDcmlwdCBBU1QgYW5kIENTVCBzdHJ1Y3R1cmVzLlxuKiBAcmV0dXJucyB7SlNTb3VwfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfc291cCgpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgd2FzbS5jcmVhdGVfc291cChyZXRwdHIpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU1NvdXAuX193cmFwKHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2Fzc2VydENsYXNzKGluc3RhbmNlLCBrbGFzcykge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2Yga2xhc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgaW5zdGFuY2Ugb2YgJHtrbGFzcy5uYW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2UucHRyO1xufVxuLyoqXG4qIENyZWF0ZXMgYSBwYXJzZXIgZGIgZnJvbSBhIHNvdXAgYW5kIGEgcm9vdCBncmFtbWFyLCBvciByZXR1cm5zIHNlbWFudGljXG4qIGVycm9ycy5cbiogQHBhcmFtIHtzdHJpbmd9IGdyYW1tYXJfaWRcbiogQHBhcmFtIHtKU1NvdXB9IHNvdXBcbiogQHJldHVybnMge0pTUGFyc2VyREJ9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9wYXJzZV9kYihncmFtbWFyX2lkLCBzb3VwKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChncmFtbWFyX2lkLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzb3VwLCBKU1NvdXApO1xuICAgICAgICB3YXNtLmNyZWF0ZV9wYXJzZV9kYihyZXRwdHIsIHB0cjAsIGxlbjAsIHNvdXAuX193YmdfcHRyKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNQYXJzZXJEQi5fX3dyYXAocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogVGVtcG9yYXJ5IHNpbXBsZSBBU1Qgb3V0cHV0IGltcGxlbWVudGF0aW9uLlxuKiBAcGFyYW0ge0pTUGFyc2VyREJ9IGpzX2RiXG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9ydXN0X2FzdF9vdXRwdXQoanNfZGIpIHtcbiAgICBsZXQgZGVmZXJyZWQyXzA7XG4gICAgbGV0IGRlZmVycmVkMl8xO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoanNfZGIsIEpTUGFyc2VyREIpO1xuICAgICAgICB3YXNtLmNyZWF0ZV9ydXN0X2FzdF9vdXRwdXQocmV0cHRyLCBqc19kYi5fX3diZ19wdHIpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICB2YXIgcjMgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgM107XG4gICAgICAgIHZhciBwdHIxID0gcjA7XG4gICAgICAgIHZhciBsZW4xID0gcjE7XG4gICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgcHRyMSA9IDA7IGxlbjEgPSAwO1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmZXJyZWQyXzAgPSBwdHIxO1xuICAgICAgICBkZWZlcnJlZDJfMSA9IGxlbjE7XG4gICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMSwgbGVuMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQyXzAsIGRlZmVycmVkMl8xLCAxKTtcbiAgICB9XG59XG5cbi8qKlxuKiBUZW1wb3Jhcnkgc2ltcGxlIEFTVCBvdXRwdXQgaW1wbGVtZW50YXRpb24uXG4qIEBwYXJhbSB7SlNQYXJzZXJEQn0ganNfZGJcbiogQHBhcmFtIHtib29sZWFufSBvcHRpbWl6ZV9zdGF0ZXNcbiogQHJldHVybnMge0pTUGFyc2VTdGF0ZXN9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9wYXJzZXJfc3RhdGVzKGpzX2RiLCBvcHRpbWl6ZV9zdGF0ZXMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGpzX2RiLCBKU1BhcnNlckRCKTtcbiAgICAgICAgd2FzbS5jcmVhdGVfcGFyc2VyX3N0YXRlcyhyZXRwdHIsIGpzX2RiLl9fd2JnX3B0ciwgb3B0aW1pemVfc3RhdGVzKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNQYXJzZVN0YXRlcy5fX3dyYXAocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogVGVtcG9yYXJ5IHNpbXBsZSBkaXNhc3NlbWJseSBpbXBsZW1lbnRhdGlvbi5cbiogQHBhcmFtIHtKU1BhcnNlckRCfSBqc19kYlxuKiBAcGFyYW0ge0pTUGFyc2VTdGF0ZXN9IHN0YXRlc1xuKiBAcmV0dXJucyB7SlNCeXRlY29kZX1cbiovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2J5dGVjb2RlKGpzX2RiLCBzdGF0ZXMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGpzX2RiLCBKU1BhcnNlckRCKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHN0YXRlcywgSlNQYXJzZVN0YXRlcyk7XG4gICAgICAgIHdhc20uY3JlYXRlX2J5dGVjb2RlKHJldHB0ciwganNfZGIuX193YmdfcHRyLCBzdGF0ZXMuX193YmdfcHRyKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNCeXRlY29kZS5fX3dyYXAocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogVGVtcG9yYXJ5IHNpbXBsZSBkaXNhc3NlbWJseSBpbXBsZW1lbnRhdGlvbi5cbiogQHBhcmFtIHtKU0J5dGVjb2RlfSBieXRlY29kZVxuKiBAcmV0dXJucyB7c3RyaW5nfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfYnl0ZWNvZGVfZGlzYXNzZW1ibHkoYnl0ZWNvZGUpIHtcbiAgICBsZXQgZGVmZXJyZWQyXzA7XG4gICAgbGV0IGRlZmVycmVkMl8xO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYnl0ZWNvZGUsIEpTQnl0ZWNvZGUpO1xuICAgICAgICB3YXNtLmNyZWF0ZV9ieXRlY29kZV9kaXNhc3NlbWJseShyZXRwdHIsIGJ5dGVjb2RlLl9fd2JnX3B0cik7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgdmFyIHB0cjEgPSByMDtcbiAgICAgICAgdmFyIGxlbjEgPSByMTtcbiAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICBwdHIxID0gMDsgbGVuMSA9IDA7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZlcnJlZDJfMCA9IHB0cjE7XG4gICAgICAgIGRlZmVycmVkMl8xID0gbGVuMTtcbiAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIxLCBsZW4xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDJfMCwgZGVmZXJyZWQyXzEsIDEpO1xuICAgIH1cbn1cblxuLyoqXG4qIFRlbXBvcmFyeSBzaW1wbGUgZGlzYXNzZW1ibHkgb2YgYSBzaW5nbGUgaW5zdHJ1Y3Rpb25cbiogQHBhcmFtIHtudW1iZXJ9IGFkZHJlc3NcbiogQHBhcmFtIHtKU0J5dGVjb2RlfSBieXRlY29kZVxuKiBAcmV0dXJucyB7c3RyaW5nfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfaW5zdHJ1Y3Rpb25fZGlzYXNzZW1ibHkoYWRkcmVzcywgYnl0ZWNvZGUpIHtcbiAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgbGV0IGRlZmVycmVkMV8xO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYnl0ZWNvZGUsIEpTQnl0ZWNvZGUpO1xuICAgICAgICB3YXNtLmNyZWF0ZV9pbnN0cnVjdGlvbl9kaXNhc3NlbWJseShyZXRwdHIsIGFkZHJlc3MsIGJ5dGVjb2RlLl9fd2JnX3B0cik7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICB9XG59XG5cbi8qKlxuKiBSZXR1cm4gYSBsaXN0IG9mIHN5bWJvbHMgaWRzIGlmIHRoZSBvcGNvZGUgb2YgdGhlIGluc3RydWN0aW9uIGlzXG4qIE9wOjpEZWJ1Z0V4cGVjdGVkU3ltYm9sc1xuKiBAcGFyYW0ge251bWJlcn0gYWRkcmVzc1xuKiBAcGFyYW0ge0pTQnl0ZWNvZGV9IGJ5dGVjb2RlXG4qIEByZXR1cm5zIHthbnl9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9kZWJ1Z19zeW1ib2xfaWRzKGFkZHJlc3MsIGJ5dGVjb2RlKSB7XG4gICAgX2Fzc2VydENsYXNzKGJ5dGVjb2RlLCBKU0J5dGVjb2RlKTtcbiAgICBjb25zdCByZXQgPSB3YXNtLmdldF9kZWJ1Z19zeW1ib2xfaWRzKGFkZHJlc3MsIGJ5dGVjb2RlLl9fd2JnX3B0cik7XG4gICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbn1cblxuLyoqXG4qIFJldHVybiBhIGxpc3Qgb2Ygc3ltYm9scyBpZHMgaWYgdGhlIG9wY29kZSBvZiB0aGUgaW5zdHJ1Y3Rpb24gaXNcbiogT3A6OkRlYnVnRXhwZWN0ZWRTeW1ib2xzXG4qIEBwYXJhbSB7bnVtYmVyfSBhZGRyZXNzXG4qIEBwYXJhbSB7SlNCeXRlY29kZX0gYnl0ZWNvZGVcbiogQHJldHVybnMge2FueX1cbiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2RlYnVnX3N0YXRlX25hbWUoYWRkcmVzcywgYnl0ZWNvZGUpIHtcbiAgICBfYXNzZXJ0Q2xhc3MoYnl0ZWNvZGUsIEpTQnl0ZWNvZGUpO1xuICAgIGNvbnN0IHJldCA9IHdhc20uZ2V0X2RlYnVnX3N0YXRlX25hbWUoYWRkcmVzcywgYnl0ZWNvZGUuX193YmdfcHRyKTtcbiAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xufVxuXG4vKipcbiogUmV0dXJuIGEgbGlzdCBvZiBzeW1ib2xzIGlkcyBpZiB0aGUgb3Bjb2RlIG9mIHRoZSBpbnN0cnVjdGlvbiBpc1xuKiBPcDo6RGVidWdFeHBlY3RlZFN5bWJvbHNcbiogQHBhcmFtIHtudW1iZXJ9IGFkZHJlc3NcbiogQHBhcmFtIHtKU0J5dGVjb2RlfSBieXRlY29kZVxuKiBAcmV0dXJucyB7YW55fVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfZGVidWdfdG9rX29mZnNldHMoYWRkcmVzcywgYnl0ZWNvZGUpIHtcbiAgICBfYXNzZXJ0Q2xhc3MoYnl0ZWNvZGUsIEpTQnl0ZWNvZGUpO1xuICAgIGNvbnN0IHJldCA9IHdhc20uZ2V0X2RlYnVnX3Rva19vZmZzZXRzKGFkZHJlc3MsIGJ5dGVjb2RlLl9fd2JnX3B0cik7XG4gICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4qIEBwYXJhbSB7SlNQYXJzZVN0YXRlc30gc3RhdGVzXG4qIEBwYXJhbSB7SlNQYXJzZXJEQn0gZGJcbiogQHJldHVybnMge2FueX1cbiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3N0YXRlX3NvdXJjZV9zdHJpbmcobmFtZSwgc3RhdGVzLCBkYikge1xuICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChuYW1lLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICBfYXNzZXJ0Q2xhc3Moc3RhdGVzLCBKU1BhcnNlU3RhdGVzKTtcbiAgICBfYXNzZXJ0Q2xhc3MoZGIsIEpTUGFyc2VyREIpO1xuICAgIGNvbnN0IHJldCA9IHdhc20uZ2V0X3N0YXRlX3NvdXJjZV9zdHJpbmcocHRyMCwgbGVuMCwgc3RhdGVzLl9fd2JnX3B0ciwgZGIuX193YmdfcHRyKTtcbiAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xufVxuXG4vKipcbiogR2l2aW4gYW4gc3ltYm9sIGluZGV4LCByZXR1cm5zIHRoZSBzeW1ib2wncyBmcmllbmRseSBuYW1lLlxuKiBAcGFyYW0ge251bWJlcn0gaWRcbiogQHBhcmFtIHtKU1BhcnNlckRCfSBkYlxuKiBAcmV0dXJucyB7YW55fVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfc3ltYm9sX25hbWVfZnJvbV9pZChpZCwgZGIpIHtcbiAgICBfYXNzZXJ0Q2xhc3MoZGIsIEpTUGFyc2VyREIpO1xuICAgIGNvbnN0IHJldCA9IHdhc20uZ2V0X3N5bWJvbF9uYW1lX2Zyb21faWQoaWQsIGRiLl9fd2JnX3B0cik7XG4gICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbn1cblxuLyoqXG4qIFJldHVybnMgYSBsaXN0IG9mIGVudHJ5cG9pbnQgbmFtZXNcbiogQHBhcmFtIHtKU1BhcnNlckRCfSBkYlxuKiBAcmV0dXJucyB7YW55fVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfZW50cnlfbmFtZXMoZGIpIHtcbiAgICBfYXNzZXJ0Q2xhc3MoZGIsIEpTUGFyc2VyREIpO1xuICAgIGNvbnN0IHJldCA9IHdhc20uZ2V0X2VudHJ5X25hbWVzKGRiLl9fd2JnX3B0cik7XG4gICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbn1cblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuKiBAcmV0dXJucyB7YW55fVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfY29kZW1pcnJvcl9wYXJzZV90cmVlKGlucHV0KSB7XG4gICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGlucHV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICBjb25zdCByZXQgPSB3YXNtLmdldF9jb2RlbWlycm9yX3BhcnNlX3RyZWUocHRyMCwgbGVuMCk7XG4gICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbn1cblxuLyoqXG4qIEByZXR1cm5zIHthbnl9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9wcm9kdWN0aW9uX25hbWVzKCkge1xuICAgIGNvbnN0IHJldCA9IHdhc20uZ2V0X3Byb2R1Y3Rpb25fbmFtZXMoKTtcbiAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xufVxuXG4vKipcbiogQSBzdGVwLWFibGUgcGFyc2VyXG4qL1xuZXhwb3J0IGNsYXNzIEpTQnl0ZUNvZGVQYXJzZXIge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEpTQnl0ZUNvZGVQYXJzZXIucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcblxuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfanNieXRlY29kZXBhcnNlcl9mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gICAgKiBAcGFyYW0ge0pTQnl0ZWNvZGV9IGJ5dGVjb2RlXG4gICAgKiBAcmV0dXJucyB7SlNCeXRlQ29kZVBhcnNlcn1cbiAgICAqL1xuICAgIHN0YXRpYyBuZXcoaW5wdXQsIGJ5dGVjb2RlKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChpbnB1dCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYnl0ZWNvZGUsIEpTQnl0ZWNvZGUpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmpzYnl0ZWNvZGVwYXJzZXJfbmV3KHB0cjAsIGxlbjAsIGJ5dGVjb2RlLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBKU0J5dGVDb2RlUGFyc2VyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRyeV9uYW1lXG4gICAgKiBAcGFyYW0ge0pTQnl0ZWNvZGV9IGJ5dGVjb2RlXG4gICAgKiBAcGFyYW0ge0pTUGFyc2VyREJ9IGRiXG4gICAgKi9cbiAgICBpbml0KGVudHJ5X25hbWUsIGJ5dGVjb2RlLCBkYikge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoZW50cnlfbmFtZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYnl0ZWNvZGUsIEpTQnl0ZWNvZGUpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZGIsIEpTUGFyc2VyREIpO1xuICAgICAgICB3YXNtLmpzYnl0ZWNvZGVwYXJzZXJfaW5pdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgYnl0ZWNvZGUuX193YmdfcHRyLCBkYi5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmpzYnl0ZWNvZGVwYXJzZXJfbmV4dCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxufVxuLyoqXG4qIEJ5dGVjb2RlIHByb2R1Y2VkIGZyb20gcGFyc2Ugc3RhdGVzXG4qL1xuZXhwb3J0IGNsYXNzIEpTQnl0ZWNvZGUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEpTQnl0ZWNvZGUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcblxuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfanNieXRlY29kZV9mcmVlKHB0cik7XG4gICAgfVxufVxuLyoqXG4qIEEgR3JhbW1hciBJZGVudGl0eVxuKi9cbmV4cG9ydCBjbGFzcyBKU0dyYW1tYXJJZGVudGl0aWVzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShKU0dyYW1tYXJJZGVudGl0aWVzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2pzZ3JhbW1hcmlkZW50aXRpZXNfZnJlZShwdHIpO1xuICAgIH1cbn1cbi8qKlxuKiBBIHN0ZXBhYmxlIHBhcnNlciBmb3IgdGhlIHNoZXJwYSBncmFtbWFyXG4qL1xuZXhwb3J0IGNsYXNzIEpTR3JhbW1hclBhcnNlciB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoSlNHcmFtbWFyUGFyc2VyLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2pzZ3JhbW1hcnBhcnNlcl9mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gICAgKiBAcmV0dXJucyB7SlNHcmFtbWFyUGFyc2VyfVxuICAgICovXG4gICAgc3RhdGljIG5ldyhpbnB1dCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoaW5wdXQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5qc2dyYW1tYXJwYXJzZXJfbmV3KHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gSlNHcmFtbWFyUGFyc2VyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqL1xuICAgIGluaXQoKSB7XG4gICAgICAgIHdhc20uanNncmFtbWFycGFyc2VyX2luaXQodGhpcy5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmpzZ3JhbW1hcnBhcnNlcl9uZXh0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG59XG4vKipcbiogUGFyc2VyIHN0YXRlcyBnZW5lcmF0ZWQgZnJvbSB0aGUgY29tcGlsYXRpb24gb2YgcGFyc2VyIGRiXG4qL1xuZXhwb3J0IGNsYXNzIEpTUGFyc2VTdGF0ZXMge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEpTUGFyc2VTdGF0ZXMucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcblxuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfanNwYXJzZXN0YXRlc19mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGdldCBudW1fb2Zfc3RhdGVzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9qc3BhcnNlc3RhdGVzX251bV9vZl9zdGF0ZXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmcwXG4gICAgKi9cbiAgICBzZXQgbnVtX29mX3N0YXRlcyhhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzcGFyc2VzdGF0ZXNfbnVtX29mX3N0YXRlcyh0aGlzLl9fd2JnX3B0ciwgYXJnMCk7XG4gICAgfVxufVxuLyoqXG4qIEEgUGFyc2VyIGRhdGFiYXNlIGRlcml2ZWQgZnJvbSBncmFtbWFyIGRlZmluZWQgaW4gYSBKU1NvdXBcbiovXG5leHBvcnQgY2xhc3MgSlNQYXJzZXJEQiB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoSlNQYXJzZXJEQi5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuXG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19qc3BhcnNlcmRiX2ZyZWUocHRyKTtcbiAgICB9XG59XG4vKipcbiovXG5leHBvcnQgY2xhc3MgSlNTaGVycGFTb3VyY2VFcnJvciB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoSlNTaGVycGFTb3VyY2VFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuXG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19qc3NoZXJwYXNvdXJjZWVycm9yX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgZ2V0IGxpbmUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2pzc2hlcnBhc291cmNlZXJyb3JfbGluZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGFyZzBcbiAgICAqL1xuICAgIHNldCBsaW5lKGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzaGVycGFzb3VyY2VlcnJvcl9saW5lKHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgZ2V0IGNvbCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfanNzaGVycGFzb3VyY2VlcnJvcl9jb2wodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmcwXG4gICAgKi9cbiAgICBzZXQgY29sKGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzaGVycGFzb3VyY2VlcnJvcl9jb2wodGhpcy5fX3diZ19wdHIsIGFyZzApO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBnZXQgbGVuKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9qc3NoZXJwYXNvdXJjZWVycm9yX2xlbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGFyZzBcbiAgICAqL1xuICAgIHNldCBsZW4oYXJnMCkge1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3NoZXJwYXNvdXJjZWVycm9yX2xlbih0aGlzLl9fd2JnX3B0ciwgYXJnMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGdldCBzdGFydF9vZmZzZXQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2pzc2hlcnBhc291cmNlZXJyb3Jfc3RhcnRfb2Zmc2V0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gYXJnMFxuICAgICovXG4gICAgc2V0IHN0YXJ0X29mZnNldChhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc2hlcnBhc291cmNlZXJyb3Jfc3RhcnRfb2Zmc2V0KHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgZ2V0IGVuZF9vZmZzZXQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2pzc2hlcnBhc291cmNlZXJyb3JfZW5kX29mZnNldCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGFyZzBcbiAgICAqL1xuICAgIHNldCBlbmRfb2Zmc2V0KGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzaGVycGFzb3VyY2VlcnJvcl9lbmRfb2Zmc2V0KHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICovXG4gICAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmpzc2hlcnBhc291cmNlZXJyb3JfbWVzc2FnZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiogQW4gYXJiaXRyYXJ5IGNvbGxlY3Rpb24gb2YgZ3JhbW1hcnNcbiovXG5leHBvcnQgY2xhc3MgSlNTb3VwIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShKU1NvdXAucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcblxuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfanNzb3VwX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBZGRzIG9yIHJlcGxhY2VzIGdyYW1tYXIgaW4gdGhlIHNvdXAsIG9yIHRocm93cyBhbiBlcnJvclxuICAgICogaWYgdGhlIGdyYW1tYXIgaXMgaW52YWxpZC4gUmV0dXJucyB0aGUgZ3JhbW1hclxuICAgICogaWQgaWYgc3VjY2Vzc2Z1bC5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBncmFtbWFyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICAgICogQHJldHVybnMge0pTR3JhbW1hcklkZW50aXRpZXN9XG4gICAgKi9cbiAgICBhZGRfZ3JhbW1hcihncmFtbWFyLCBwYXRoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChncmFtbWFyLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHBhdGgsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmpzc291cF9hZGRfZ3JhbW1hcihyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEpTR3JhbW1hcklkZW50aXRpZXMuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBBZGRzIGEgcHJvZHVjdGlvbiB0YXJnZXRpbmcgYSBzcGVjaWZpYyBncmFtbWFyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JhbW1hcl9uYW1lXG4gICAgKi9cbiAgICBhZGRfcHJvZHVjdGlvbihncmFtbWFyX25hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGdyYW1tYXJfbmFtZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uanNzb3VwX2FkZF9wcm9kdWN0aW9uKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIFBvc2l0aW9uZWRFcnJvcnMge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFBvc2l0aW9uZWRFcnJvcnMucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcblxuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcG9zaXRpb25lZGVycm9yc19mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucG9zaXRpb25lZGVycm9yc19sZW5ndGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICogQHJldHVybnMge0pTU2hlcnBhU291cmNlRXJyb3IgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBnZXRfZXJyb3JfYXQoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wb3NpdGlvbmVkZXJyb3JzX2dldF9lcnJvcl9hdCh0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogSlNTaGVycGFTb3VyY2VFcnJvci5fX3dyYXAocmV0KTtcbiAgICB9XG59XG4vKipcbiovXG5leHBvcnQgY2xhc3MgVG9rZW5PZmZzZXRzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUb2tlbk9mZnNldHMucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcblxuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdG9rZW5vZmZzZXRzX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgZ2V0IHN0YXJ0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF90b2tlbm9mZnNldHNfc3RhcnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmcwXG4gICAgKi9cbiAgICBzZXQgc3RhcnQoYXJnMCkge1xuICAgICAgICB3YXNtLl9fd2JnX3NldF90b2tlbm9mZnNldHNfc3RhcnQodGhpcy5fX3diZ19wdHIsIGFyZzApO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBnZXQgZW5kKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9qc3BhcnNlc3RhdGVzX251bV9vZl9zdGF0ZXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmcwXG4gICAgKi9cbiAgICBzZXQgZW5kKGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNwYXJzZXN0YXRlc19udW1fb2Zfc3RhdGVzKHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9fd2JnX2xvYWQobW9kdWxlLCBpbXBvcnRzKSB7XG4gICAgaWYgKHR5cGVvZiBSZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJyAmJiBtb2R1bGUgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhtb2R1bGUsIGltcG9ydHMpO1xuXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgIT0gJ2FwcGxpY2F0aW9uL3dhc20nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcImBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ2AgZmFpbGVkIGJlY2F1c2UgeW91ciBzZXJ2ZXIgZG9lcyBub3Qgc2VydmUgd2FzbSB3aXRoIGBhcHBsaWNhdGlvbi93YXNtYCBNSU1FIHR5cGUuIEZhbGxpbmcgYmFjayB0byBgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVgIHdoaWNoIGlzIHNsb3dlci4gT3JpZ2luYWwgZXJyb3I6XFxuXCIsIGUpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBieXRlcyA9IGF3YWl0IG1vZHVsZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYnl0ZXMsIGltcG9ydHMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShtb2R1bGUsIGltcG9ydHMpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lkluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpbnN0YW5jZSwgbW9kdWxlIH07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gX193YmdfZ2V0X2ltcG9ydHMoKSB7XG4gICAgY29uc3QgaW1wb3J0cyA9IHt9O1xuICAgIGltcG9ydHMud2JnID0ge307XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9zdHJpbmdfbmV3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX251bWJlcl9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGFyZzA7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19wb3NpdGlvbmVkZXJyb3JzX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gUG9zaXRpb25lZEVycm9ycy5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190b2tlbm9mZnNldHNfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBUb2tlbk9mZnNldHMuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIHRha2VPYmplY3QoYXJnMCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX29iamVjdF9jbG9uZV9yZWYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fZXJyb3JfbmV3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fYmlnaW50X2Zyb21fdTY0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBCaWdJbnQuYXNVaW50Tig2NCwgYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfODQxYWM1N2NmZjNkNjcyYiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApW3Rha2VPYmplY3QoYXJnMSldID0gdGFrZU9iamVjdChhcmcyKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld184OThhNjgxNTBmMjI1ZjJlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBBcnJheSgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3X2I1MTU4NWRlMWIyMzRhZmYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IE9iamVjdCgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0XzUwMmQyOTA3MGVhMTg1NTcgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKVthcmcxID4+PiAwXSA9IHRha2VPYmplY3QoYXJnMik7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19wdXNoX2NhMWMyNjA2N2VmOTA3YWMgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5wdXNoKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2RlYnVnX3N0cmluZyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZGVidWdTdHJpbmcoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDFdID0gbGVuMTtcbiAgICAgICAgZ2V0SW50MzJNZW1vcnkwKClbYXJnMCAvIDQgKyAwXSA9IHB0cjE7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX3Rocm93ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGltcG9ydHM7XG59XG5cbmZ1bmN0aW9uIF9fd2JnX2luaXRfbWVtb3J5KGltcG9ydHMsIG1heWJlX21lbW9yeSkge1xuXG59XG5cbmZ1bmN0aW9uIF9fd2JnX2ZpbmFsaXplX2luaXQoaW5zdGFuY2UsIG1vZHVsZSkge1xuICAgIHdhc20gPSBpbnN0YW5jZS5leHBvcnRzO1xuICAgIF9fd2JnX2luaXQuX193YmluZGdlbl93YXNtX21vZHVsZSA9IG1vZHVsZTtcbiAgICBjYWNoZWRJbnQzMk1lbW9yeTAgPSBudWxsO1xuICAgIGNhY2hlZFVpbnQ4TWVtb3J5MCA9IG51bGw7XG5cblxuICAgIHJldHVybiB3YXNtO1xufVxuXG5mdW5jdGlvbiBpbml0U3luYyhtb2R1bGUpIHtcbiAgICBpZiAod2FzbSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gd2FzbTtcblxuICAgIGNvbnN0IGltcG9ydHMgPSBfX3diZ19nZXRfaW1wb3J0cygpO1xuXG4gICAgX193YmdfaW5pdF9tZW1vcnkoaW1wb3J0cyk7XG5cbiAgICBpZiAoIShtb2R1bGUgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5Nb2R1bGUpKSB7XG4gICAgICAgIG1vZHVsZSA9IG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobW9kdWxlKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShtb2R1bGUsIGltcG9ydHMpO1xuXG4gICAgcmV0dXJuIF9fd2JnX2ZpbmFsaXplX2luaXQoaW5zdGFuY2UsIG1vZHVsZSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9fd2JnX2luaXQoaW5wdXQpIHtcbiAgICBpZiAod2FzbSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gd2FzbTtcblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlucHV0ID0gbmV3IFVSTCgnc2hlcnBhX3dhc21fYmcud2FzbScsIGltcG9ydC5tZXRhLnVybCk7XG4gICAgfVxuICAgIGNvbnN0IGltcG9ydHMgPSBfX3diZ19nZXRfaW1wb3J0cygpO1xuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgKHR5cGVvZiBSZXF1ZXN0ID09PSAnZnVuY3Rpb24nICYmIGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkgfHwgKHR5cGVvZiBVUkwgPT09ICdmdW5jdGlvbicgJiYgaW5wdXQgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIGlucHV0ID0gZmV0Y2goaW5wdXQpO1xuICAgIH1cblxuICAgIF9fd2JnX2luaXRfbWVtb3J5KGltcG9ydHMpO1xuXG4gICAgY29uc3QgeyBpbnN0YW5jZSwgbW9kdWxlIH0gPSBhd2FpdCBfX3diZ19sb2FkKGF3YWl0IGlucHV0LCBpbXBvcnRzKTtcblxuICAgIHJldHVybiBfX3diZ19maW5hbGl6ZV9pbml0KGluc3RhbmNlLCBtb2R1bGUpO1xufVxuXG5leHBvcnQgeyBpbml0U3luYyB9XG5leHBvcnQgZGVmYXVsdCBfX3diZ19pbml0O1xuIiwgIi8qKlxuVGhlIGRhdGEgc3RydWN0dXJlIGZvciBkb2N1bWVudHMuIEBub25hYnN0cmFjdFxuKi9cbmNsYXNzIFRleHQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGxpbmUgZGVzY3JpcHRpb24gYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGxpbmVBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IDAgfHwgcG9zID4gdGhpcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBwb3NpdGlvbiAke3Bvc30gaW4gZG9jdW1lbnQgb2YgbGVuZ3RoICR7dGhpcy5sZW5ndGh9YCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVJbm5lcihwb3MsIGZhbHNlLCAxLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBkZXNjcmlwdGlvbiBmb3IgdGhlIGdpdmVuICgxLWJhc2VkKSBsaW5lIG51bWJlci5cbiAgICAqL1xuICAgIGxpbmUobikge1xuICAgICAgICBpZiAobiA8IDEgfHwgbiA+IHRoaXMubGluZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBsaW5lIG51bWJlciAke259IGluICR7dGhpcy5saW5lc30tbGluZSBkb2N1bWVudGApO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5uZXIobiwgdHJ1ZSwgMSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgYSByYW5nZSBvZiB0aGUgdGV4dCB3aXRoIHRoZSBnaXZlbiBjb250ZW50LlxuICAgICovXG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UoMCwgZnJvbSwgcGFydHMsIDIgLyogT3Blbi5UbyAqLyk7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRleHQuZGVjb21wb3NlKDAsIHRleHQubGVuZ3RoLCBwYXJ0cywgMSAvKiBPcGVuLkZyb20gKi8gfCAyIC8qIE9wZW4uVG8gKi8pO1xuICAgICAgICB0aGlzLmRlY29tcG9zZSh0bywgdGhpcy5sZW5ndGgsIHBhcnRzLCAxIC8qIE9wZW4uRnJvbSAqLyk7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKHBhcnRzLCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBlbmQgYW5vdGhlciBkb2N1bWVudCB0byB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMubGVuZ3RoLCB0aGlzLmxlbmd0aCwgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdGV4dCBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludHMuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLmRlY29tcG9zZShmcm9tLCB0bywgcGFydHMsIDApO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShwYXJ0cywgdG8gLSBmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgdGV4dCBpcyBlcXVhbCB0byBhbm90aGVyIGluc3RhbmNlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG90aGVyLmxlbmd0aCAhPSB0aGlzLmxlbmd0aCB8fCBvdGhlci5saW5lcyAhPSB0aGlzLmxpbmVzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnNjYW5JZGVudGljYWwob3RoZXIsIDEpLCBlbmQgPSB0aGlzLmxlbmd0aCAtIHRoaXMuc2NhbklkZW50aWNhbChvdGhlciwgLTEpO1xuICAgICAgICBsZXQgYSA9IG5ldyBSYXdUZXh0Q3Vyc29yKHRoaXMpLCBiID0gbmV3IFJhd1RleHRDdXJzb3Iob3RoZXIpO1xuICAgICAgICBmb3IgKGxldCBza2lwID0gc3RhcnQsIHBvcyA9IHN0YXJ0OzspIHtcbiAgICAgICAgICAgIGEubmV4dChza2lwKTtcbiAgICAgICAgICAgIGIubmV4dChza2lwKTtcbiAgICAgICAgICAgIHNraXAgPSAwO1xuICAgICAgICAgICAgaWYgKGEubGluZUJyZWFrICE9IGIubGluZUJyZWFrIHx8IGEuZG9uZSAhPSBiLmRvbmUgfHwgYS52YWx1ZSAhPSBiLnZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHBvcyArPSBhLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChhLmRvbmUgfHwgcG9zID49IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHRleHQuIFdoZW4gYGRpcmAgaXMgYC0xYCwgaXRlcmF0aW9uIGhhcHBlbnNcbiAgICBmcm9tIGVuZCB0byBzdGFydC4gVGhpcyB3aWxsIHJldHVybiBsaW5lcyBhbmQgdGhlIGJyZWFrcyBiZXR3ZWVuXG4gICAgdGhlbSBhcyBzZXBhcmF0ZSBzdHJpbmdzLlxuICAgICovXG4gICAgaXRlcihkaXIgPSAxKSB7IHJldHVybiBuZXcgUmF3VGV4dEN1cnNvcih0aGlzLCBkaXIpOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIGEgcmFuZ2Ugb2YgdGhlIHRleHQuIFdoZW4gYGZyb21gID4gYHRvYCwgdGhlXG4gICAgaXRlcmF0b3Igd2lsbCBydW4gaW4gcmV2ZXJzZS5cbiAgICAqL1xuICAgIGl0ZXJSYW5nZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7IHJldHVybiBuZXcgUGFydGlhbFRleHRDdXJzb3IodGhpcywgZnJvbSwgdG8pOyB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgY3Vyc29yIHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgbGluZXMsXG4gICAgX3dpdGhvdXRfIHJldHVybmluZyB0aGUgbGluZSBicmVha3MgYmV0d2VlbiwgYW5kIHlpZWxkaW5nIGVtcHR5XG4gICAgc3RyaW5ncyBmb3IgZW1wdHkgbGluZXMuXG4gICAgXG4gICAgV2hlbiBgZnJvbWAgYW5kIGB0b2AgYXJlIGdpdmVuLCB0aGV5IHNob3VsZCBiZSAxLWJhc2VkIGxpbmUgbnVtYmVycy5cbiAgICAqL1xuICAgIGl0ZXJMaW5lcyhmcm9tLCB0bykge1xuICAgICAgICBsZXQgaW5uZXI7XG4gICAgICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgIGlubmVyID0gdGhpcy5pdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0byA9IHRoaXMubGluZXMgKyAxO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5saW5lKGZyb20pLmZyb207XG4gICAgICAgICAgICBpbm5lciA9IHRoaXMuaXRlclJhbmdlKHN0YXJ0LCBNYXRoLm1heChzdGFydCwgdG8gPT0gdGhpcy5saW5lcyArIDEgPyB0aGlzLmxlbmd0aCA6IHRvIDw9IDEgPyAwIDogdGhpcy5saW5lKHRvIC0gMSkudG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpbmVDdXJzb3IoaW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5zbGljZVN0cmluZygwKTsgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhlIGRvY3VtZW50IHRvIGFuIGFycmF5IG9mIGxpbmVzICh3aGljaCBjYW4gYmVcbiAgICBkZXNlcmlhbGl6ZWQgYWdhaW4gdmlhIFtgVGV4dC5vZmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dF5vZikpLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mbGF0dGVuKGxpbmVzKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBgVGV4dGAgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiBsaW5lcy5cbiAgICAqL1xuICAgIHN0YXRpYyBvZih0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBIGRvY3VtZW50IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbGluZVwiKTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09IDEgJiYgIXRleHRbMF0pXG4gICAgICAgICAgICByZXR1cm4gVGV4dC5lbXB0eTtcbiAgICAgICAgcmV0dXJuIHRleHQubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovID8gbmV3IFRleHRMZWFmKHRleHQpIDogVGV4dE5vZGUuZnJvbShUZXh0TGVhZi5zcGxpdCh0ZXh0LCBbXSkpO1xuICAgIH1cbn1cbi8vIExlYXZlcyBzdG9yZSBhbiBhcnJheSBvZiBsaW5lIHN0cmluZ3MuIFRoZXJlIGFyZSBhbHdheXMgbGluZSBicmVha3Ncbi8vIGJldHdlZW4gdGhlc2Ugc3RyaW5ncy4gTGVhdmVzIGFyZSBsaW1pdGVkIGluIHNpemUgYW5kIGhhdmUgdG8gYmVcbi8vIGNvbnRhaW5lZCBpbiBUZXh0Tm9kZSBpbnN0YW5jZXMgZm9yIGJpZ2dlciBkb2N1bWVudHMuXG5jbGFzcyBUZXh0TGVhZiBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIGxlbmd0aCA9IHRleHRMZW5ndGgodGV4dCkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuICAgIGdldCBsaW5lcygpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiBudWxsOyB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdHJpbmcgPSB0aGlzLnRleHRbaV0sIGVuZCA9IG9mZnNldCArIHN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGxpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpbmUob2Zmc2V0LCBlbmQsIGxpbmUsIHN0cmluZyk7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQgKyAxO1xuICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29tcG9zZShmcm9tLCB0bywgdGFyZ2V0LCBvcGVuKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gZnJvbSA8PSAwICYmIHRvID49IHRoaXMubGVuZ3RoID8gdGhpc1xuICAgICAgICAgICAgOiBuZXcgVGV4dExlYWYoc2xpY2VUZXh0KHRoaXMudGV4dCwgZnJvbSwgdG8pLCBNYXRoLm1pbih0bywgdGhpcy5sZW5ndGgpIC0gTWF0aC5tYXgoMCwgZnJvbSkpO1xuICAgICAgICBpZiAob3BlbiAmIDEgLyogT3Blbi5Gcm9tICovKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHRhcmdldC5wb3AoKTtcbiAgICAgICAgICAgIGxldCBqb2luZWQgPSBhcHBlbmRUZXh0KHRleHQudGV4dCwgcHJldi50ZXh0LnNsaWNlKCksIDAsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChqb2luZWQubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKGpvaW5lZCwgcHJldi5sZW5ndGggKyB0ZXh0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1pZCA9IGpvaW5lZC5sZW5ndGggPj4gMTtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYoam9pbmVkLnNsaWNlKDAsIG1pZCkpLCBuZXcgVGV4dExlYWYoam9pbmVkLnNsaWNlKG1pZCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgaWYgKCEodGV4dCBpbnN0YW5jZW9mIFRleHRMZWFmKSlcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKGZyb20sIHRvLCB0ZXh0KTtcbiAgICAgICAgbGV0IGxpbmVzID0gYXBwZW5kVGV4dCh0aGlzLnRleHQsIGFwcGVuZFRleHQodGV4dC50ZXh0LCBzbGljZVRleHQodGhpcy50ZXh0LCAwLCBmcm9tKSksIHRvKTtcbiAgICAgICAgbGV0IG5ld0xlbiA9IHRoaXMubGVuZ3RoICsgdGV4dC5sZW5ndGggLSAodG8gLSBmcm9tKTtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLylcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlYWYobGluZXMsIG5ld0xlbik7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKFRleHRMZWFmLnNwbGl0KGxpbmVzLCBbXSksIG5ld0xlbik7XG4gICAgfVxuICAgIHNsaWNlU3RyaW5nKGZyb20sIHRvID0gdGhpcy5sZW5ndGgsIGxpbmVTZXAgPSBcIlxcblwiKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgcG9zIDw9IHRvICYmIGkgPCB0aGlzLnRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdGhpcy50ZXh0W2ldLCBlbmQgPSBwb3MgKyBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tICYmIGkpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmVTZXA7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IGVuZCAmJiB0byA+IHBvcylcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZS5zbGljZShNYXRoLm1heCgwLCBmcm9tIC0gcG9zKSwgdG8gLSBwb3MpO1xuICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmbGF0dGVuKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMudGV4dClcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGxpbmUpO1xuICAgIH1cbiAgICBzY2FuSWRlbnRpY2FsKCkgeyByZXR1cm4gMDsgfVxuICAgIHN0YXRpYyBzcGxpdCh0ZXh0LCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IHBhcnQgPSBbXSwgbGVuID0gLTE7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGV4dCkge1xuICAgICAgICAgICAgcGFydC5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgbGVuICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PSAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihwYXJ0LCBsZW4pKTtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gW107XG4gICAgICAgICAgICAgICAgbGVuID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA+IC0xKVxuICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKHBhcnQsIGxlbikpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbn1cbi8vIE5vZGVzIHByb3ZpZGUgdGhlIHRyZWUgc3RydWN0dXJlIG9mIHRoZSBgVGV4dGAgdHlwZS4gVGhleSBzdG9yZSBhXG4vLyBudW1iZXIgb2Ygb3RoZXIgbm9kZXMgb3IgbGVhdmVzLCB0YWtpbmcgY2FyZSB0byBiYWxhbmNlIHRoZW1zZWx2ZXNcbi8vIG9uIGNoYW5nZXMuIFRoZXJlIGFyZSBpbXBsaWVkIGxpbmUgYnJlYWtzIF9iZXR3ZWVuXyB0aGUgY2hpbGRyZW4gb2Zcbi8vIGEgbm9kZSAoYnV0IG5vdCBiZWZvcmUgdGhlIGZpcnN0IG9yIGFmdGVyIHRoZSBsYXN0IGNoaWxkKS5cbmNsYXNzIFRleHROb2RlIGV4dGVuZHMgVGV4dCB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4sIGxlbmd0aCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmxpbmVzID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICB0aGlzLmxpbmVzICs9IGNoaWxkLmxpbmVzO1xuICAgIH1cbiAgICBsaW5lSW5uZXIodGFyZ2V0LCBpc0xpbmUsIGxpbmUsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQubGVuZ3RoLCBlbmRMaW5lID0gbGluZSArIGNoaWxkLmxpbmVzIC0gMTtcbiAgICAgICAgICAgIGlmICgoaXNMaW5lID8gZW5kTGluZSA6IGVuZCkgPj0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5saW5lSW5uZXIodGFyZ2V0LCBpc0xpbmUsIGxpbmUsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQgKyAxO1xuICAgICAgICAgICAgbGluZSA9IGVuZExpbmUgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29tcG9zZShmcm9tLCB0bywgdGFyZ2V0LCBvcGVuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBwb3MgPD0gdG8gJiYgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChmcm9tIDw9IGVuZCAmJiB0byA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRPcGVuID0gb3BlbiAmICgocG9zIDw9IGZyb20gPyAxIC8qIE9wZW4uRnJvbSAqLyA6IDApIHwgKGVuZCA+PSB0byA/IDIgLyogT3Blbi5UbyAqLyA6IDApKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zID49IGZyb20gJiYgZW5kIDw9IHRvICYmICFjaGlsZE9wZW4pXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlY29tcG9zZShmcm9tIC0gcG9zLCB0byAtIHBvcywgdGFyZ2V0LCBjaGlsZE9wZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0LmxpbmVzIDwgdGhpcy5saW5lcylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGg6IGlmIHRoZSBjaGFuZ2Ugb25seSBhZmZlY3RzIG9uZSBjaGlsZCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQncyBzaXplIHJlbWFpbnMgaW4gdGhlIGFjY2VwdGFibGUgcmFuZ2UsIG9ubHkgdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBjaGlsZFxuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IHBvcyAmJiB0byA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWQgPSBjaGlsZC5yZXBsYWNlKGZyb20gLSBwb3MsIHRvIC0gcG9zLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsTGluZXMgPSB0aGlzLmxpbmVzIC0gY2hpbGQubGluZXMgKyB1cGRhdGVkLmxpbmVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZC5saW5lcyA8ICh0b3RhbExpbmVzID4+ICg1IC8qIFRyZWUuQnJhbmNoU2hpZnQgKi8gLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQubGluZXMgPiAodG90YWxMaW5lcyA+PiAoNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29weSA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlbaV0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZShjb3B5LCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKHBvcywgZW5kLCB1cGRhdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UoZnJvbSwgdG8sIHRleHQpO1xuICAgIH1cbiAgICBzbGljZVN0cmluZyhmcm9tLCB0byA9IHRoaXMubGVuZ3RoLCBsaW5lU2VwID0gXCJcXG5cIikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiBwb3MgPD0gdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgaSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZVNlcDtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgZW5kICYmIHRvID4gcG9zKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjaGlsZC5zbGljZVN0cmluZyhmcm9tIC0gcG9zLCB0byAtIHBvcywgbGluZVNlcCk7XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZsYXR0ZW4odGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICBjaGlsZC5mbGF0dGVuKHRhcmdldCk7XG4gICAgfVxuICAgIHNjYW5JZGVudGljYWwob3RoZXIsIGRpcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFRleHROb2RlKSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IFtpQSwgaUIsIGVBLCBlQl0gPSBkaXIgPiAwID8gWzAsIDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoLCBvdGhlci5jaGlsZHJlbi5sZW5ndGhdXG4gICAgICAgICAgICA6IFt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEsIG90aGVyLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCAtMV07XG4gICAgICAgIGZvciAoOzsgaUEgKz0gZGlyLCBpQiArPSBkaXIpIHtcbiAgICAgICAgICAgIGlmIChpQSA9PSBlQSB8fCBpQiA9PSBlQilcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGNoQSA9IHRoaXMuY2hpbGRyZW5baUFdLCBjaEIgPSBvdGhlci5jaGlsZHJlbltpQl07XG4gICAgICAgICAgICBpZiAoY2hBICE9IGNoQilcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoICsgY2hBLnNjYW5JZGVudGljYWwoY2hCLCBkaXIpO1xuICAgICAgICAgICAgbGVuZ3RoICs9IGNoQS5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGNoaWxkcmVuLCBsZW5ndGggPSBjaGlsZHJlbi5yZWR1Y2UoKGwsIGNoKSA9PiBsICsgY2gubGVuZ3RoICsgMSwgLTEpKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgbGluZXMgKz0gY2gubGluZXM7XG4gICAgICAgIGlmIChsaW5lcyA8IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICBsZXQgZmxhdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2guZmxhdHRlbihmbGF0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlYWYoZmxhdCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2h1bmsgPSBNYXRoLm1heCgzMiAvKiBUcmVlLkJyYW5jaCAqLywgbGluZXMgPj4gNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovKSwgbWF4Q2h1bmsgPSBjaHVuayA8PCAxLCBtaW5DaHVuayA9IGNodW5rID4+IDE7XG4gICAgICAgIGxldCBjaHVua2VkID0gW10sIGN1cnJlbnRMaW5lcyA9IDAsIGN1cnJlbnRMZW4gPSAtMSwgY3VycmVudENodW5rID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGFkZChjaGlsZCkge1xuICAgICAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGluZXMgPiBtYXhDaHVuayAmJiBjaGlsZCBpbnN0YW5jZW9mIFRleHROb2RlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBjaGlsZC5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgYWRkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQubGluZXMgPiBtaW5DaHVuayAmJiAoY3VycmVudExpbmVzID4gbWluQ2h1bmsgfHwgIWN1cnJlbnRMaW5lcykpIHtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGNodW5rZWQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRleHRMZWFmICYmIGN1cnJlbnRMaW5lcyAmJlxuICAgICAgICAgICAgICAgIChsYXN0ID0gY3VycmVudENodW5rW2N1cnJlbnRDaHVuay5sZW5ndGggLSAxXSkgaW5zdGFuY2VvZiBUZXh0TGVhZiAmJlxuICAgICAgICAgICAgICAgIGNoaWxkLmxpbmVzICsgbGFzdC5saW5lcyA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lcyArPSBjaGlsZC5saW5lcztcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuICs9IGNoaWxkLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgY3VycmVudENodW5rW2N1cnJlbnRDaHVuay5sZW5ndGggLSAxXSA9IG5ldyBUZXh0TGVhZihsYXN0LnRleHQuY29uY2F0KGNoaWxkLnRleHQpLCBsYXN0Lmxlbmd0aCArIDEgKyBjaGlsZC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lcyArIGNoaWxkLmxpbmVzID4gY2h1bmspXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmVzICs9IGNoaWxkLmxpbmVzO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW4gKz0gY2hpbGQubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmsucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudExpbmVzID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2h1bmtlZC5wdXNoKGN1cnJlbnRDaHVuay5sZW5ndGggPT0gMSA/IGN1cnJlbnRDaHVua1swXSA6IFRleHROb2RlLmZyb20oY3VycmVudENodW5rLCBjdXJyZW50TGVuKSk7XG4gICAgICAgICAgICBjdXJyZW50TGVuID0gLTE7XG4gICAgICAgICAgICBjdXJyZW50TGluZXMgPSBjdXJyZW50Q2h1bmsubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGFkZChjaGlsZCk7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgICAgIHJldHVybiBjaHVua2VkLmxlbmd0aCA9PSAxID8gY2h1bmtlZFswXSA6IG5ldyBUZXh0Tm9kZShjaHVua2VkLCBsZW5ndGgpO1xuICAgIH1cbn1cblRleHQuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IFRleHRMZWFmKFtcIlwiXSwgMCk7XG5mdW5jdGlvbiB0ZXh0TGVuZ3RoKHRleHQpIHtcbiAgICBsZXQgbGVuZ3RoID0gLTE7XG4gICAgZm9yIChsZXQgbGluZSBvZiB0ZXh0KVxuICAgICAgICBsZW5ndGggKz0gbGluZS5sZW5ndGggKyAxO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG5mdW5jdGlvbiBhcHBlbmRUZXh0KHRleHQsIHRhcmdldCwgZnJvbSA9IDAsIHRvID0gMWU5KSB7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDAsIGZpcnN0ID0gdHJ1ZTsgaSA8IHRleHQubGVuZ3RoICYmIHBvcyA8PSB0bzsgaSsrKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGV4dFtpXSwgZW5kID0gcG9zICsgbGluZS5sZW5ndGg7XG4gICAgICAgIGlmIChlbmQgPj0gZnJvbSkge1xuICAgICAgICAgICAgaWYgKGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKGZyb20gLSBwb3MpO1xuICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3RhcmdldC5sZW5ndGggLSAxXSArPSBsaW5lO1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHNsaWNlVGV4dCh0ZXh0LCBmcm9tLCB0bykge1xuICAgIHJldHVybiBhcHBlbmRUZXh0KHRleHQsIFtcIlwiXSwgZnJvbSwgdG8pO1xufVxuY2xhc3MgUmF3VGV4dEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgZGlyID0gMSkge1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGluZUJyZWFrID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLm5vZGVzID0gW3RleHRdO1xuICAgICAgICB0aGlzLm9mZnNldHMgPSBbZGlyID4gMCA/IDEgOiAodGV4dCBpbnN0YW5jZW9mIFRleHRMZWFmID8gdGV4dC50ZXh0Lmxlbmd0aCA6IHRleHQuY2hpbGRyZW4ubGVuZ3RoKSA8PCAxXTtcbiAgICB9XG4gICAgbmV4dElubmVyKHNraXAsIGRpcikge1xuICAgICAgICB0aGlzLmRvbmUgPSB0aGlzLmxpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLm5vZGVzW2xhc3RdLCBvZmZzZXRWYWx1ZSA9IHRoaXMub2Zmc2V0c1tsYXN0XSwgb2Zmc2V0ID0gb2Zmc2V0VmFsdWUgPj4gMTtcbiAgICAgICAgICAgIGxldCBzaXplID0gdG9wIGluc3RhbmNlb2YgVGV4dExlYWYgPyB0b3AudGV4dC5sZW5ndGggOiB0b3AuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSAoZGlyID4gMCA/IHNpemUgOiAwKSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3QgLSAxXSsrO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKG9mZnNldFZhbHVlICYgMSkgPT0gKGRpciA+IDAgPyAwIDogMSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xuICAgICAgICAgICAgICAgIGlmIChza2lwID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXAtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvcCBpbnN0YW5jZW9mIFRleHRMZWFmKSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0byB0aGUgbmV4dCBzdHJpbmdcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC50ZXh0W29mZnNldCArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5sZW5ndGggPiBNYXRoLm1heCgwLCBza2lwKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gc2tpcCA9PSAwID8gbmV4dCA6IGRpciA+IDAgPyBuZXh0LnNsaWNlKHNraXApIDogbmV4dC5zbGljZSgwLCBuZXh0Lmxlbmd0aCAtIHNraXApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2tpcCAtPSBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW29mZnNldCArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICAgICAgaWYgKHNraXAgPiBuZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBza2lwIC09IG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0tLTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHMucHVzaChkaXIgPiAwID8gMSA6IChuZXh0IGluc3RhbmNlb2YgVGV4dExlYWYgPyBuZXh0LnRleHQubGVuZ3RoIDogbmV4dC5jaGlsZHJlbi5sZW5ndGgpIDw8IDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGlmIChza2lwIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0SW5uZXIoLXNraXAsICgtdGhpcy5kaXIpKTtcbiAgICAgICAgICAgIHNraXAgPSB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0SW5uZXIoc2tpcCwgdGhpcy5kaXIpO1xuICAgIH1cbn1cbmNsYXNzIFBhcnRpYWxUZXh0Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBuZXcgUmF3VGV4dEN1cnNvcih0ZXh0LCBzdGFydCA+IGVuZCA/IC0xIDogMSk7XG4gICAgICAgIHRoaXMucG9zID0gc3RhcnQgPiBlbmQgPyB0ZXh0Lmxlbmd0aCA6IDA7XG4gICAgICAgIHRoaXMuZnJvbSA9IE1hdGgubWluKHN0YXJ0LCBlbmQpO1xuICAgICAgICB0aGlzLnRvID0gTWF0aC5tYXgoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIG5leHRJbm5lcihza2lwLCBkaXIpIHtcbiAgICAgICAgaWYgKGRpciA8IDAgPyB0aGlzLnBvcyA8PSB0aGlzLmZyb20gOiB0aGlzLnBvcyA+PSB0aGlzLnRvKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBza2lwICs9IE1hdGgubWF4KDAsIGRpciA8IDAgPyB0aGlzLnBvcyAtIHRoaXMudG8gOiB0aGlzLmZyb20gLSB0aGlzLnBvcyk7XG4gICAgICAgIGxldCBsaW1pdCA9IGRpciA8IDAgPyB0aGlzLnBvcyAtIHRoaXMuZnJvbSA6IHRoaXMudG8gLSB0aGlzLnBvcztcbiAgICAgICAgaWYgKHNraXAgPiBsaW1pdClcbiAgICAgICAgICAgIHNraXAgPSBsaW1pdDtcbiAgICAgICAgbGltaXQgLT0gc2tpcDtcbiAgICAgICAgbGV0IHsgdmFsdWUgfSA9IHRoaXMuY3Vyc29yLm5leHQoc2tpcCk7XG4gICAgICAgIHRoaXMucG9zICs9ICh2YWx1ZS5sZW5ndGggKyBza2lwKSAqIGRpcjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlLmxlbmd0aCA8PSBsaW1pdCA/IHZhbHVlIDogZGlyIDwgMCA/IHZhbHVlLnNsaWNlKHZhbHVlLmxlbmd0aCAtIGxpbWl0KSA6IHZhbHVlLnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgICAgdGhpcy5kb25lID0gIXRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGlmIChza2lwIDwgMClcbiAgICAgICAgICAgIHNraXAgPSBNYXRoLm1heChza2lwLCB0aGlzLmZyb20gLSB0aGlzLnBvcyk7XG4gICAgICAgIGVsc2UgaWYgKHNraXAgPiAwKVxuICAgICAgICAgICAgc2tpcCA9IE1hdGgubWluKHNraXAsIHRoaXMudG8gLSB0aGlzLnBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRJbm5lcihza2lwLCB0aGlzLmN1cnNvci5kaXIpO1xuICAgIH1cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gdGhpcy5jdXJzb3IubGluZUJyZWFrICYmIHRoaXMudmFsdWUgIT0gXCJcIjsgfVxufVxuY2xhc3MgTGluZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoaW5uZXIpIHtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSB0cnVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgfVxuICAgIG5leHQoc2tpcCA9IDApIHtcbiAgICAgICAgbGV0IHsgZG9uZSwgbGluZUJyZWFrLCB2YWx1ZSB9ID0gdGhpcy5pbm5lci5uZXh0KHNraXApO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbmVCcmVhaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWZ0ZXJCcmVhaykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICBUZXh0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pdGVyKCk7IH07XG4gICAgUmF3VGV4dEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IFBhcnRpYWxUZXh0Q3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID1cbiAgICAgICAgTGluZUN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG59XG4vKipcblRoaXMgdHlwZSBkZXNjcmliZXMgYSBsaW5lIGluIHRoZSBkb2N1bWVudC4gSXQgaXMgY3JlYXRlZFxub24tZGVtYW5kIHdoZW4gbGluZXMgYXJlIFtxdWVyaWVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRleHQubGluZUF0KS5cbiovXG5jbGFzcyBMaW5lIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGluZSAoX2JlZm9yZV8gdGhlIGxpbmUgYnJlYWssXG4gICAgb3IgYXQgdGhlIGVuZCBvZiBkb2N1bWVudCBmb3IgdGhlIGxhc3QgbGluZSkuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhpcyBsaW5lJ3MgbGluZSBudW1iZXIgKDEtYmFzZWQpLlxuICAgICovXG4gICAgbnVtYmVyLCBcbiAgICAvKipcbiAgICBUaGUgbGluZSdzIGNvbnRlbnQuXG4gICAgKi9cbiAgICB0ZXh0KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5udW1iZXIgPSBudW1iZXI7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGxpbmUgKG5vdCBpbmNsdWRpbmcgYW55IGxpbmUgYnJlYWsgYWZ0ZXIgaXQpLlxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudG8gLSB0aGlzLmZyb207IH1cbn1cblxuLy8gQ29tcHJlc3NlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgR3JhcGhlbWVfQ2x1c3Rlcl9CcmVhaz1FeHRlbmRcbi8vIGluZm9ybWF0aW9uIGZyb21cbi8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvUHVibGljLzEzLjAuMC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtQcm9wZXJ0eS50eHQuXG4vLyBFYWNoIHBhaXIgb2YgZWxlbWVudHMgcmVwcmVzZW50cyBhIHJhbmdlLCBhcyBhbiBvZmZldCBmcm9tIHRoZVxuLy8gcHJldmlvdXMgcmFuZ2UgYW5kIGEgbGVuZ3RoLiBOdW1iZXJzIGFyZSBpbiBiYXNlLTM2LCB3aXRoIHRoZSBlbXB0eVxuLy8gc3RyaW5nIGJlaW5nIGEgc2hvcnRoYW5kIGZvciAxLlxubGV0IGV4dGVuZCA9IC8qQF9fUFVSRV9fKi9cImxjLDM0LDduLDcsN2IsMTksLCwsMiwsMiwsLDIwLGIsMWMsbCxnLCwydCw3LDIsNiwyLDIsLDQseiwsdSxyLDJqLGIsMW0sOSw5LCxvLDQsLDksLDMsLDUsMTcsMywzYixmLCx3LDFqLCwsLDQsOCw0LCwzLDcsYSwyLHQsLDFtLCwsLDIsNCw4LCw5LCxhLDIscSwsMiwyLDFsLCw0LDIsNCwyLDIsMywzLCx1LDIsMywsYiwyLDFsLCw0LDUsLDIsNCwsaywyLG0sNiwsLDFtLCwsMiwsNCw4LCw3LDMsYSwyLHUsLDFuLCwsLGMsLDksLDE0LCwzLCwxbCwzLDUsMywsNCw3LDIsYiwyLHQsLDFtLCwyLCwyLCwzLCw1LDIsNywyLGIsMixzLDIsMWwsMiwsLDIsNCw4LCw5LCxhLDIsdCwsMjAsLDQsLDIsMywsLDgsLDI5LCwyLDcsYyw4LDJxLCwyLDksYiw2LDIyLDIsciwsLCwsLDFqLGUsLDUsLDIsNSxiLCwxMCw5LCwydSw0LCw2LCwyLDIsMixwLDIsNCwzLGcsNCxkLCwyLDIsNiwsZiwsamosMyxxYSwzLHQsMyx0LDIsdSwyLDFzLDIsLDcsOCwsMixiLDksLDE5LDMsM2IsMix5LCwzYSwzLDQsMiw5LCw2LDMsNjMsMiwyLCwxbSwsLDcsLCwsLDIsOCw2LGEsMiwsMWMsaCwxciw0LDFjLDcsLCw1LCwxNCw5LGMsMix3LDQsMiwyLCwzLDFrLCwsMiwzLCwsMywxbSw4LDIsMiw0OCwzLCxkLCw3LDQsLDYsLDMsMiw1aSwxbSwsNSxlaywsNWYseCwyZGEsMywzeCwsMm8sdyxmZSw2LDJ4LDIsbjl3LDQsLGEsdywyLDI4LDIsN2ssLDMsLDQsLHAsMiw1LCw0NywyLHEsaSxkLCwxMiw4LHAsYiwxYSwzLDFjLCwyLDQsMiwyLDEzLCwxdiw2LDIsMiwyLDIsYywsOCwsMWIsLDFmLCwsMywyLDIsNSwyLCwsMTYsMiw4LCw2bSwsMiwsNCwsZm40LCxraCxnLGcsZyxhNiwyLGd0LCw2YSwsNDUsNSwxYWUsMywsMiw1LDQsMTQsMyw0LCw0bCwyLGZ4LDQsYXIsMiw0OSxiLDR3LCwxaSxmLDFrLDMsMWQsNCwyLDIsMXgsMywxMCw1LCw4LDFxLCxjLDIsMWcsOSxhLDQsMiwsMm4sMywyLCwsMiw2LCw0ZywsMyw4LGwsMiwxbCwyLCwsLCxtLCxlLDcsMyw1LDVmLDgsMiwzLCwsbiwsMjksLDIsNiwsLDIsLCwyLCwyLDZqLCwyLDQsNiwyLCwyLHIsMiwyZCw4LDIsLCwyLDJ5LCwsLDIsNiwsLDJ0LDMsMiw0LCw1LDc3LDksLDIsNnQsLGEsMiwsLDQsLDQwLDQsMiwyLDQsLHcsYSwxNCw2LDIsNCw4LCw5LDYsMiwzLDFhLGQsLDIsYmEsNywsNiwsLDJhLG0sMiw3LCwyLCwyLDNlLDYsMywsLDIsLDcsLCwyMCwyLDMsLCwsOW4sMixmMGIsNSwxbiw3LHQ0LCwxciw0LDI5LCxmNWssMiw0M3EsLCwzLDQsNSw4LDgsMiw3LHUsNCw0NCwzLDFpeiwxaiw0LDFlLDgsLGUsLG0sNSwsZiwxMXMsNywsaCwyLDcsLDIsLDUsNzksNyxjNSw0LDE1cyw3LDMxLDcsMjQwLDUsZ3g3aywybywzayw2b1wiLnNwbGl0KFwiLFwiKS5tYXAocyA9PiBzID8gcGFyc2VJbnQocywgMzYpIDogMSk7XG4vLyBDb252ZXJ0IG9mZnNldHMgaW50byBhYnNvbHV0ZSB2YWx1ZXNcbmZvciAobGV0IGkgPSAxOyBpIDwgZXh0ZW5kLmxlbmd0aDsgaSsrKVxuICAgIGV4dGVuZFtpXSArPSBleHRlbmRbaSAtIDFdO1xuZnVuY3Rpb24gaXNFeHRlbmRpbmdDaGFyKGNvZGUpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGV4dGVuZC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgaWYgKGV4dGVuZFtpXSA+IGNvZGUpXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kW2kgLSAxXSA8PSBjb2RlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzUmVnaW9uYWxJbmRpY2F0b3IoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IDB4MUYxRTYgJiYgY29kZSA8PSAweDFGMUZGO1xufVxuY29uc3QgWldKID0gMHgyMDBkO1xuLyoqXG5SZXR1cm5zIGEgbmV4dCBncmFwaGVtZSBjbHVzdGVyIGJyZWFrIF9hZnRlcl8gKG5vdCBlcXVhbCB0bylcbmBwb3NgLCBpZiBgZm9yd2FyZGAgaXMgdHJ1ZSwgb3IgYmVmb3JlIG90aGVyd2lzZS4gUmV0dXJucyBgcG9zYFxuaXRzZWxmIGlmIG5vIGZ1cnRoZXIgY2x1c3RlciBicmVhayBpcyBhdmFpbGFibGUgaW4gdGhlIHN0cmluZy5cbk1vdmVzIGFjcm9zcyBzdXJyb2dhdGUgcGFpcnMsIGV4dGVuZGluZyBjaGFyYWN0ZXJzICh3aGVuXG5gaW5jbHVkZUV4dGVuZGluZ2AgaXMgdHJ1ZSksIGNoYXJhY3RlcnMgam9pbmVkIHdpdGggemVyby13aWR0aFxuam9pbmVycywgYW5kIGZsYWcgZW1vamkuXG4qL1xuZnVuY3Rpb24gZmluZENsdXN0ZXJCcmVhayhzdHIsIHBvcywgZm9yd2FyZCA9IHRydWUsIGluY2x1ZGVFeHRlbmRpbmcgPSB0cnVlKSB7XG4gICAgcmV0dXJuIChmb3J3YXJkID8gbmV4dENsdXN0ZXJCcmVhayA6IHByZXZDbHVzdGVyQnJlYWspKHN0ciwgcG9zLCBpbmNsdWRlRXh0ZW5kaW5nKTtcbn1cbmZ1bmN0aW9uIG5leHRDbHVzdGVyQnJlYWsoc3RyLCBwb3MsIGluY2x1ZGVFeHRlbmRpbmcpIHtcbiAgICBpZiAocG9zID09IHN0ci5sZW5ndGgpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgLy8gSWYgcG9zIGlzIGluIHRoZSBtaWRkbGUgb2YgYSBzdXJyb2dhdGUgcGFpciwgbW92ZSB0byBpdHMgc3RhcnRcbiAgICBpZiAocG9zICYmIHN1cnJvZ2F0ZUxvdyhzdHIuY2hhckNvZGVBdChwb3MpKSAmJiBzdXJyb2dhdGVIaWdoKHN0ci5jaGFyQ29kZUF0KHBvcyAtIDEpKSlcbiAgICAgICAgcG9zLS07XG4gICAgbGV0IHByZXYgPSBjb2RlUG9pbnRBdChzdHIsIHBvcyk7XG4gICAgcG9zICs9IGNvZGVQb2ludFNpemUocHJldik7XG4gICAgd2hpbGUgKHBvcyA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG5leHQgPSBjb2RlUG9pbnRBdChzdHIsIHBvcyk7XG4gICAgICAgIGlmIChwcmV2ID09IFpXSiB8fCBuZXh0ID09IFpXSiB8fCBpbmNsdWRlRXh0ZW5kaW5nICYmIGlzRXh0ZW5kaW5nQ2hhcihuZXh0KSkge1xuICAgICAgICAgICAgcG9zICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICBwcmV2ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JlZ2lvbmFsSW5kaWNhdG9yKG5leHQpKSB7XG4gICAgICAgICAgICBsZXQgY291bnRCZWZvcmUgPSAwLCBpID0gcG9zIC0gMjtcbiAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgaXNSZWdpb25hbEluZGljYXRvcihjb2RlUG9pbnRBdChzdHIsIGkpKSkge1xuICAgICAgICAgICAgICAgIGNvdW50QmVmb3JlKys7XG4gICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50QmVmb3JlICUgMiA9PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbn1cbmZ1bmN0aW9uIHByZXZDbHVzdGVyQnJlYWsoc3RyLCBwb3MsIGluY2x1ZGVFeHRlbmRpbmcpIHtcbiAgICB3aGlsZSAocG9zID4gMCkge1xuICAgICAgICBsZXQgZm91bmQgPSBuZXh0Q2x1c3RlckJyZWFrKHN0ciwgcG9zIC0gMiwgaW5jbHVkZUV4dGVuZGluZyk7XG4gICAgICAgIGlmIChmb3VuZCA8IHBvcylcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgcG9zLS07XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gc3Vycm9nYXRlTG93KGNoKSB7IHJldHVybiBjaCA+PSAweERDMDAgJiYgY2ggPCAweEUwMDA7IH1cbmZ1bmN0aW9uIHN1cnJvZ2F0ZUhpZ2goY2gpIHsgcmV0dXJuIGNoID49IDB4RDgwMCAmJiBjaCA8IDB4REMwMDsgfVxuLyoqXG5GaW5kIHRoZSBjb2RlIHBvaW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBpbiBhIHN0cmluZyAobGlrZSB0aGVcbltgY29kZVBvaW50QXRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvY29kZVBvaW50QXQpXG5zdHJpbmcgbWV0aG9kKS5cbiovXG5mdW5jdGlvbiBjb2RlUG9pbnRBdChzdHIsIHBvcykge1xuICAgIGxldCBjb2RlMCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKCFzdXJyb2dhdGVIaWdoKGNvZGUwKSB8fCBwb3MgKyAxID09IHN0ci5sZW5ndGgpXG4gICAgICAgIHJldHVybiBjb2RlMDtcbiAgICBsZXQgY29kZTEgPSBzdHIuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICBpZiAoIXN1cnJvZ2F0ZUxvdyhjb2RlMSkpXG4gICAgICAgIHJldHVybiBjb2RlMDtcbiAgICByZXR1cm4gKChjb2RlMCAtIDB4ZDgwMCkgPDwgMTApICsgKGNvZGUxIC0gMHhkYzAwKSArIDB4MTAwMDA7XG59XG4vKipcbkdpdmVuIGEgVW5pY29kZSBjb2RlcG9pbnQsIHJldHVybiB0aGUgSmF2YVNjcmlwdCBzdHJpbmcgdGhhdFxucmVzcHJlc2VudHMgaXQgKGxpa2VcbltgU3RyaW5nLmZyb21Db2RlUG9pbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZnJvbUNvZGVQb2ludCkpLlxuKi9cbmZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoY29kZSkge1xuICAgIGlmIChjb2RlIDw9IDB4ZmZmZilcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgY29kZSAtPSAweDEwMDAwO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlID4+IDEwKSArIDB4ZDgwMCwgKGNvZGUgJiAxMDIzKSArIDB4ZGMwMCk7XG59XG4vKipcblRoZSBhbW91bnQgb2YgcG9zaXRpb25zIGEgY2hhcmFjdGVyIHRha2VzIHVwIGEgSmF2YVNjcmlwdCBzdHJpbmcuXG4qL1xuZnVuY3Rpb24gY29kZVBvaW50U2l6ZShjb2RlKSB7IHJldHVybiBjb2RlIDwgMHgxMDAwMCA/IDEgOiAyOyB9XG5cbmNvbnN0IERlZmF1bHRTcGxpdCA9IC9cXHJcXG4/fFxcbi87XG4vKipcbkRpc3Rpbmd1aXNoZXMgZGlmZmVyZW50IHdheXMgaW4gd2hpY2ggcG9zaXRpb25zIGNhbiBiZSBtYXBwZWQuXG4qL1xudmFyIE1hcE1vZGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChNYXBNb2RlKSB7XG4gICAgLyoqXG4gICAgTWFwIGEgcG9zaXRpb24gdG8gYSB2YWxpZCBuZXcgcG9zaXRpb24sIGV2ZW4gd2hlbiBpdHMgY29udGV4dFxuICAgIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiU2ltcGxlXCJdID0gMF0gPSBcIlNpbXBsZVwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIGRlbGV0aW9uIGhhcHBlbnMgYWNyb3NzIHRoZSBwb3NpdGlvbi5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrRGVsXCJdID0gMV0gPSBcIlRyYWNrRGVsXCI7XG4gICAgLyoqXG4gICAgUmV0dXJuIG51bGwgaWYgdGhlIGNoYXJhY3RlciBfYmVmb3JlXyB0aGUgcG9zaXRpb24gaXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrQmVmb3JlXCJdID0gMl0gPSBcIlRyYWNrQmVmb3JlXCI7XG4gICAgLyoqXG4gICAgUmV0dXJuIG51bGwgaWYgdGhlIGNoYXJhY3RlciBfYWZ0ZXJfIHRoZSBwb3NpdGlvbiBpcyBkZWxldGVkLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiVHJhY2tBZnRlclwiXSA9IDNdID0gXCJUcmFja0FmdGVyXCI7XG5yZXR1cm4gTWFwTW9kZX0pKE1hcE1vZGUgfHwgKE1hcE1vZGUgPSB7fSkpO1xuLyoqXG5BIGNoYW5nZSBkZXNjcmlwdGlvbiBpcyBhIHZhcmlhbnQgb2YgW2NoYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0KVxudGhhdCBkb2Vzbid0IHN0b3JlIHRoZSBpbnNlcnRlZCB0ZXh0LiBBcyBzdWNoLCBpdCBjYW4ndCBiZVxuYXBwbGllZCwgYnV0IGlzIGNoZWFwZXIgdG8gc3RvcmUgYW5kIG1hbmlwdWxhdGUuXG4qL1xuY2xhc3MgQ2hhbmdlRGVzYyB7XG4gICAgLy8gU2VjdGlvbnMgYXJlIGVuY29kZWQgYXMgcGFpcnMgb2YgaW50ZWdlcnMuIFRoZSBmaXJzdCBpcyB0aGVcbiAgICAvLyBsZW5ndGggaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQsIGFuZCB0aGUgc2Vjb25kIGlzIC0xIGZvclxuICAgIC8vIHVuYWZmZWN0ZWQgc2VjdGlvbnMsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZSByZXBsYWNlbWVudCBjb250ZW50XG4gICAgLy8gb3RoZXJ3aXNlLiBTbyBhbiBpbnNlcnRpb24gd291bGQgYmUgKDAsIG4+MCksIGEgZGVsZXRpb24gKG4+MCxcbiAgICAvLyAwKSwgYW5kIGEgcmVwbGFjZW1lbnQgdHdvIHBvc2l0aXZlIG51bWJlcnMuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNlY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuc2VjdGlvbnMgPSBzZWN0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuc2VjdGlvbnNbaV07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGFmdGVyIHRoZSBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgbmV3TGVuZ3RoKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgaW5zID0gdGhpcy5zZWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICByZXN1bHQgKz0gaW5zIDwgMCA/IHRoaXMuc2VjdGlvbnNbaV0gOiBpbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmFsc2Ugd2hlbiB0aGVyZSBhcmUgYWN0dWFsIGNoYW5nZXMgaW4gdGhpcyBzZXQuXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PSAwIHx8IHRoaXMuc2VjdGlvbnMubGVuZ3RoID09IDIgJiYgdGhpcy5zZWN0aW9uc1sxXSA8IDA7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHVuY2hhbmdlZCBwYXJ0cyBsZWZ0IGJ5IHRoZXNlIGNoYW5nZXMuIGBwb3NBYFxuICAgIHByb3ZpZGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcmFuZ2UgaW4gdGhlIG9sZCBkb2N1bWVudCwgYHBvc0JgXG4gICAgdGhlIG5ldyBwb3NpdGlvbiBpbiB0aGUgY2hhbmdlZCBkb2N1bWVudC5cbiAgICAqL1xuICAgIGl0ZXJHYXBzKGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvc0EgPSAwLCBwb3NCID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApIHtcbiAgICAgICAgICAgICAgICBmKHBvc0EsIHBvc0IsIGxlbik7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3NCICs9IGlucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc0EgKz0gbGVuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIGNoYW5nZWQgYnkgdGhlc2UgY2hhbmdlcy4gKFNlZVxuICAgIFtgQ2hhbmdlU2V0Lml0ZXJDaGFuZ2VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQuaXRlckNoYW5nZXMpIGZvciBhXG4gICAgdmFyaWFudCB0aGF0IGFsc28gcHJvdmlkZXMgeW91IHdpdGggdGhlIGluc2VydGVkIHRleHQuKVxuICAgIGBmcm9tQWAvYHRvQWAgcHJvdmlkZXMgdGhlIGV4dGVudCBvZiB0aGUgY2hhbmdlIGluIHRoZSBzdGFydGluZ1xuICAgIGRvY3VtZW50LCBgZnJvbUJgL2B0b0JgIHRoZSBleHRlbnQgb2YgdGhlIHJlcGxhY2VtZW50IGluIHRoZVxuICAgIGNoYW5nZWQgZG9jdW1lbnQuXG4gICAgXG4gICAgV2hlbiBgaW5kaXZpZHVhbGAgaXMgdHJ1ZSwgYWRqYWNlbnQgY2hhbmdlcyAod2hpY2ggYXJlIGtlcHRcbiAgICBzZXBhcmF0ZSBmb3IgW3Bvc2l0aW9uIG1hcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlRGVzYy5tYXBQb3MpKSBhcmVcbiAgICByZXBvcnRlZCBzZXBhcmF0ZWx5LlxuICAgICovXG4gICAgaXRlckNoYW5nZWRSYW5nZXMoZiwgaW5kaXZpZHVhbCA9IGZhbHNlKSB7XG4gICAgICAgIGl0ZXJDaGFuZ2VzKHRoaXMsIGYsIGluZGl2aWR1YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBkZXNjcmlwdGlvbiBvZiB0aGUgaW52ZXJ0ZWQgZm9ybSBvZiB0aGVzZSBjaGFuZ2VzLlxuICAgICovXG4gICAgZ2V0IGludmVydGVkRGVzYygpIHtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICBpZiAoaW5zIDwgMClcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKGxlbiwgaW5zKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKGlucywgbGVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZURlc2Moc2VjdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wdXRlIHRoZSBjb21iaW5lZCBlZmZlY3Qgb2YgYXBwbHlpbmcgYW5vdGhlciBzZXQgb2YgY2hhbmdlc1xuICAgIGFmdGVyIHRoaXMgb25lLiBUaGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBhZnRlciB0aGlzIHNldCBzaG91bGRcbiAgICBtYXRjaCB0aGUgbGVuZ3RoIGJlZm9yZSBgb3RoZXJgLlxuICAgICovXG4gICAgY29tcG9zZURlc2Mob3RoZXIpIHsgcmV0dXJuIHRoaXMuZW1wdHkgPyBvdGhlciA6IG90aGVyLmVtcHR5ID8gdGhpcyA6IGNvbXBvc2VTZXRzKHRoaXMsIG90aGVyKTsgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIGRlc2NyaXB0aW9uLCB3aGljaCBzaG91bGQgc3RhcnQgd2l0aCB0aGUgc2FtZSBkb2N1bWVudFxuICAgIGFzIGBvdGhlcmAsIG92ZXIgYW5vdGhlciBzZXQgb2YgY2hhbmdlcywgc28gdGhhdCBpdCBjYW4gYmVcbiAgICBhcHBsaWVkIGFmdGVyIGl0LiBXaGVuIGBiZWZvcmVgIGlzIHRydWUsIG1hcCBhcyBpZiB0aGUgY2hhbmdlc1xuICAgIGluIGBvdGhlcmAgaGFwcGVuZWQgYmVmb3JlIHRoZSBvbmVzIGluIGB0aGlzYC5cbiAgICAqL1xuICAgIG1hcERlc2Mob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBvdGhlci5lbXB0eSA/IHRoaXMgOiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSk7IH1cbiAgICBtYXBQb3MocG9zLCBhc3NvYyA9IC0xLCBtb2RlID0gTWFwTW9kZS5TaW1wbGUpIHtcbiAgICAgICAgbGV0IHBvc0EgPSAwLCBwb3NCID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgZW5kQSA9IHBvc0EgKyBsZW47XG4gICAgICAgICAgICBpZiAoaW5zIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmRBID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zQiArIChwb3MgLSBwb3NBKTtcbiAgICAgICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlICE9IE1hcE1vZGUuU2ltcGxlICYmIGVuZEEgPj0gcG9zICYmXG4gICAgICAgICAgICAgICAgICAgIChtb2RlID09IE1hcE1vZGUuVHJhY2tEZWwgJiYgcG9zQSA8IHBvcyAmJiBlbmRBID4gcG9zIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID09IE1hcE1vZGUuVHJhY2tCZWZvcmUgJiYgcG9zQSA8IHBvcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9PSBNYXBNb2RlLlRyYWNrQWZ0ZXIgJiYgZW5kQSA+IHBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChlbmRBID4gcG9zIHx8IGVuZEEgPT0gcG9zICYmIGFzc29jIDwgMCAmJiAhbGVuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zID09IHBvc0EgfHwgYXNzb2MgPCAwID8gcG9zQiA6IHBvc0IgKyBpbnM7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NBID0gZW5kQTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID4gcG9zQSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQb3NpdGlvbiAke3Bvc30gaXMgb3V0IG9mIHJhbmdlIGZvciBjaGFuZ2VzZXQgb2YgbGVuZ3RoICR7cG9zQX1gKTtcbiAgICAgICAgcmV0dXJuIHBvc0I7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhlc2UgY2hhbmdlcyB0b3VjaCBhIGdpdmVuIHJhbmdlLiBXaGVuIG9uZSBvZiB0aGVcbiAgICBjaGFuZ2VzIGVudGlyZWx5IGNvdmVycyB0aGUgcmFuZ2UsIHRoZSBzdHJpbmcgYFwiY292ZXJcImAgaXNcbiAgICByZXR1cm5lZC5cbiAgICAqL1xuICAgIHRvdWNoZXNSYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aCAmJiBwb3MgPD0gdG87KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK10sIGVuZCA9IHBvcyArIGxlbjtcbiAgICAgICAgICAgIGlmIChpbnMgPj0gMCAmJiBwb3MgPD0gdG8gJiYgZW5kID49IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcyA8IGZyb20gJiYgZW5kID4gdG8gPyBcImNvdmVyXCIgOiB0cnVlO1xuICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICByZXN1bHQgKz0gKHJlc3VsdCA/IFwiIFwiIDogXCJcIikgKyBsZW4gKyAoaW5zID49IDAgPyBcIjpcIiArIGlucyA6IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIGNoYW5nZSBkZXNjIHRvIGEgSlNPTi1yZXByZXNlbnRhYmxlIHZhbHVlLlxuICAgICovXG4gICAgdG9KU09OKCkgeyByZXR1cm4gdGhpcy5zZWN0aW9uczsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZSBkZXNjIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gKGFzIHByb2R1Y2VkXG4gICAgYnkgW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MudG9KU09OKS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSB8fCBqc29uLmxlbmd0aCAlIDIgfHwganNvbi5zb21lKGEgPT4gdHlwZW9mIGEgIT0gXCJudW1iZXJcIikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VEZXNjXCIpO1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZURlc2MoanNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShzZWN0aW9ucykgeyByZXR1cm4gbmV3IENoYW5nZURlc2Moc2VjdGlvbnMpOyB9XG59XG4vKipcbkEgY2hhbmdlIHNldCByZXByZXNlbnRzIGEgZ3JvdXAgb2YgbW9kaWZpY2F0aW9ucyB0byBhIGRvY3VtZW50LiBJdFxuc3RvcmVzIHRoZSBkb2N1bWVudCBsZW5ndGgsIGFuZCBjYW4gb25seSBiZSBhcHBsaWVkIHRvIGRvY3VtZW50c1xud2l0aCBleGFjdGx5IHRoYXQgbGVuZ3RoLlxuKi9cbmNsYXNzIENoYW5nZVNldCBleHRlbmRzIENoYW5nZURlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHNlY3Rpb25zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGluc2VydGVkKSB7XG4gICAgICAgIHN1cGVyKHNlY3Rpb25zKTtcbiAgICAgICAgdGhpcy5pbnNlcnRlZCA9IGluc2VydGVkO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBseSB0aGUgY2hhbmdlcyB0byBhIGRvY3VtZW50LCByZXR1cm5pbmcgdGhlIG1vZGlmaWVkXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9IGRvYy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFwcGx5aW5nIGNoYW5nZSBzZXQgdG8gYSBkb2N1bWVudCB3aXRoIHRoZSB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgIGl0ZXJDaGFuZ2VzKHRoaXMsIChmcm9tQSwgdG9BLCBmcm9tQiwgX3RvQiwgdGV4dCkgPT4gZG9jID0gZG9jLnJlcGxhY2UoZnJvbUIsIGZyb21CICsgKHRvQSAtIGZyb21BKSwgdGV4dCksIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG4gICAgbWFwRGVzYyhvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEdpdmVuIHRoZSBkb2N1bWVudCBhcyBpdCBleGlzdGVkIF9iZWZvcmVfIHRoZSBjaGFuZ2VzLCByZXR1cm4gYVxuICAgIGNoYW5nZSBzZXQgdGhhdCByZXByZXNlbnRzIHRoZSBpbnZlcnNlIG9mIHRoaXMgc2V0LCB3aGljaCBjb3VsZFxuICAgIGJlIHVzZWQgdG8gZ28gZnJvbSB0aGUgZG9jdW1lbnQgY3JlYXRlZCBieSB0aGUgY2hhbmdlcyBiYWNrIHRvXG4gICAgdGhlIGRvY3VtZW50IGFzIGl0IGV4aXN0ZWQgYmVmb3JlIHRoZSBjaGFuZ2VzLlxuICAgICovXG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSB0aGlzLnNlY3Rpb25zLnNsaWNlKCksIGluc2VydGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSBzZWN0aW9uc1tpXSwgaW5zID0gc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKGlucyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnNbaV0gPSBpbnM7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnNbaSArIDFdID0gbGVuO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGkgPj4gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5zZXJ0ZWQubGVuZ3RoIDwgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2goVGV4dC5lbXB0eSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaChsZW4gPyBkb2Muc2xpY2UocG9zLCBwb3MgKyBsZW4pIDogVGV4dC5lbXB0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbWJpbmUgdHdvIHN1YnNlcXVlbnQgY2hhbmdlIHNldHMgaW50byBhIHNpbmdsZSBzZXQuIGBvdGhlcmBcbiAgICBtdXN0IHN0YXJ0IGluIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSBgdGhpc2AuIElmIGB0aGlzYCBnb2VzXG4gICAgYGRvY0FgIFx1MjE5MiBgZG9jQmAgYW5kIGBvdGhlcmAgcmVwcmVzZW50cyBgZG9jQmAgXHUyMTkyIGBkb2NDYCwgdGhlXG4gICAgcmV0dXJuZWQgdmFsdWUgd2lsbCByZXByZXNlbnQgdGhlIGNoYW5nZSBgZG9jQWAgXHUyMTkyIGBkb2NDYC5cbiAgICAqL1xuICAgIGNvbXBvc2Uob3RoZXIpIHsgcmV0dXJuIHRoaXMuZW1wdHkgPyBvdGhlciA6IG90aGVyLmVtcHR5ID8gdGhpcyA6IGNvbXBvc2VTZXRzKHRoaXMsIG90aGVyLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEdpdmVuIGFub3RoZXIgY2hhbmdlIHNldCBzdGFydGluZyBpbiB0aGUgc2FtZSBkb2N1bWVudCwgbWFwcyB0aGlzXG4gICAgY2hhbmdlIHNldCBvdmVyIHRoZSBvdGhlciwgcHJvZHVjaW5nIGEgbmV3IGNoYW5nZSBzZXQgdGhhdCBjYW4gYmVcbiAgICBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSBhcHBseWluZyBgb3RoZXJgLiBXaGVuXG4gICAgYGJlZm9yZWAgaXMgYHRydWVgLCBvcmRlciBjaGFuZ2VzIGFzIGlmIGB0aGlzYCBjb21lcyBiZWZvcmVcbiAgICBgb3RoZXJgLCBvdGhlcndpc2UgKHRoZSBkZWZhdWx0KSB0cmVhdCBgb3RoZXJgIGFzIGNvbWluZyBmaXJzdC5cbiAgICBcbiAgICBHaXZlbiB0d28gY2hhbmdlcyBgQWAgYW5kIGBCYCwgYEEuY29tcG9zZShCLm1hcChBKSlgIGFuZFxuICAgIGBCLmNvbXBvc2UoQS5tYXAoQiwgdHJ1ZSkpYCB3aWxsIHByb2R1Y2UgdGhlIHNhbWUgZG9jdW1lbnQuIFRoaXNcbiAgICBwcm92aWRlcyBhIGJhc2ljIGZvcm0gb2YgW29wZXJhdGlvbmFsXG4gICAgdHJhbnNmb3JtYXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09wZXJhdGlvbmFsX3RyYW5zZm9ybWF0aW9uKSxcbiAgICBhbmQgY2FuIGJlIHVzZWQgZm9yIGNvbGxhYm9yYXRpdmUgZWRpdGluZy5cbiAgICAqL1xuICAgIG1hcChvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG90aGVyLmVtcHR5ID8gdGhpcyA6IG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgY2hhbmdlZCByYW5nZXMgaW4gdGhlIGRvY3VtZW50LCBjYWxsaW5nIGBmYCBmb3JcbiAgICBlYWNoLCB3aXRoIHRoZSByYW5nZSBpbiB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgKGBmcm9tQWAtYHRvQWApXG4gICAgYW5kIHRoZSByYW5nZSB0aGF0IHJlcGxhY2VzIGl0IGluIHRoZSBuZXcgZG9jdW1lbnRcbiAgICAoYGZyb21CYC1gdG9CYCkuXG4gICAgXG4gICAgV2hlbiBgaW5kaXZpZHVhbGAgaXMgdHJ1ZSwgYWRqYWNlbnQgY2hhbmdlcyBhcmUgcmVwb3J0ZWRcbiAgICBzZXBhcmF0ZWx5LlxuICAgICovXG4gICAgaXRlckNoYW5nZXMoZiwgaW5kaXZpZHVhbCA9IGZhbHNlKSB7XG4gICAgICAgIGl0ZXJDaGFuZ2VzKHRoaXMsIGYsIGluZGl2aWR1YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbY2hhbmdlIGRlc2NyaXB0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MpIGZvciB0aGlzIGNoYW5nZVxuICAgIHNldC5cbiAgICAqL1xuICAgIGdldCBkZXNjKCkgeyByZXR1cm4gQ2hhbmdlRGVzYy5jcmVhdGUodGhpcy5zZWN0aW9ucyk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbHRlcihyYW5nZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdFNlY3Rpb25zID0gW10sIHJlc3VsdEluc2VydGVkID0gW10sIGZpbHRlcmVkU2VjdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IGl0ZXIgPSBuZXcgU2VjdGlvbkl0ZXIodGhpcyk7XG4gICAgICAgIGRvbmU6IGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA9PSByYW5nZXMubGVuZ3RoID8gMWU5IDogcmFuZ2VzW2krK107XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgbmV4dCB8fCBwb3MgPT0gbmV4dCAmJiBpdGVyLmxlbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZG9uZTtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oaXRlci5sZW4sIG5leHQgLSBwb3MpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oZmlsdGVyZWRTZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICAgICAgbGV0IGlucyA9IGl0ZXIuaW5zID09IC0xID8gLTEgOiBpdGVyLm9mZiA9PSAwID8gaXRlci5pbnMgOiAwO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24ocmVzdWx0U2VjdGlvbnMsIGxlbiwgaW5zKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zID4gMClcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KHJlc3VsdEluc2VydGVkLCByZXN1bHRTZWN0aW9ucywgaXRlci50ZXh0KTtcbiAgICAgICAgICAgICAgICBpdGVyLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVuZCA9IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGRvbmU7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGl0ZXIubGVuLCBlbmQgLSBwb3MpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24ocmVzdWx0U2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oZmlsdGVyZWRTZWN0aW9ucywgbGVuLCBpdGVyLmlucyA9PSAtMSA/IC0xIDogaXRlci5vZmYgPT0gMCA/IGl0ZXIuaW5zIDogMCk7XG4gICAgICAgICAgICAgICAgaXRlci5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBuZXcgQ2hhbmdlU2V0KHJlc3VsdFNlY3Rpb25zLCByZXN1bHRJbnNlcnRlZCksXG4gICAgICAgICAgICBmaWx0ZXJlZDogQ2hhbmdlRGVzYy5jcmVhdGUoZmlsdGVyZWRTZWN0aW9ucykgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgY2hhbmdlIHNldCB0byBhIEpTT04tcmVwcmVzZW50YWJsZSB2YWx1ZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaV0sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChsZW4pO1xuICAgICAgICAgICAgZWxzZSBpZiAoaW5zID09IDApXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChbbGVuXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChbbGVuXS5jb25jYXQodGhpcy5pbnNlcnRlZFtpID4+IDFdLnRvSlNPTigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2Ugc2V0IGZvciB0aGUgZ2l2ZW4gY2hhbmdlcywgZm9yIGEgZG9jdW1lbnQgb2YgdGhlXG4gICAgZ2l2ZW4gbGVuZ3RoLCB1c2luZyBgbGluZVNlcGAgYXMgbGluZSBzZXBhcmF0b3IuXG4gICAgKi9cbiAgICBzdGF0aWMgb2YoY2hhbmdlcywgbGVuZ3RoLCBsaW5lU2VwKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnRlZCA9IFtdLCBwb3MgPSAwO1xuICAgICAgICBsZXQgdG90YWwgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBmbHVzaChmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoIWZvcmNlICYmICFzZWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGxlbmd0aClcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW5ndGggLSBwb3MsIC0xKTtcbiAgICAgICAgICAgIGxldCBzZXQgPSBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgICAgICAgICB0b3RhbCA9IHRvdGFsID8gdG90YWwuY29tcG9zZShzZXQubWFwKHRvdGFsKSkgOiBzZXQ7XG4gICAgICAgICAgICBzZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBbXTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHJvY2VzcyhzcGVjKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzcGVjKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHN1YiBvZiBzcGVjKVxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKHN1Yik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzcGVjIGluc3RhbmNlb2YgQ2hhbmdlU2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWMubGVuZ3RoICE9IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGggKGdvdCAke3NwZWMubGVuZ3RofSwgZXhwZWN0ZWQgJHtsZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgdG90YWwgPSB0b3RhbCA/IHRvdGFsLmNvbXBvc2Uoc3BlYy5tYXAodG90YWwpKSA6IHNwZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byA9IGZyb20sIGluc2VydCB9ID0gc3BlYztcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IHRvIHx8IGZyb20gPCAwIHx8IHRvID4gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjaGFuZ2UgcmFuZ2UgJHtmcm9tfSB0byAke3RvfSAoaW4gZG9jIG9mIGxlbmd0aCAke2xlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgbGV0IGluc1RleHQgPSAhaW5zZXJ0ID8gVGV4dC5lbXB0eSA6IHR5cGVvZiBpbnNlcnQgPT0gXCJzdHJpbmdcIiA/IFRleHQub2YoaW5zZXJ0LnNwbGl0KGxpbmVTZXAgfHwgRGVmYXVsdFNwbGl0KSkgOiBpbnNlcnQ7XG4gICAgICAgICAgICAgICAgbGV0IGluc0xlbiA9IGluc1RleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID09IHRvICYmIGluc0xlbiA9PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGZyb20gLSBwb3MsIC0xKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCB0byAtIGZyb20sIGluc0xlbik7XG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydGVkLCBzZWN0aW9ucywgaW5zVGV4dCk7XG4gICAgICAgICAgICAgICAgcG9zID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2VzcyhjaGFuZ2VzKTtcbiAgICAgICAgZmx1c2goIXRvdGFsKTtcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZW1wdHkgY2hhbmdlc2V0IG9mIHRoZSBnaXZlbiBsZW5ndGguXG4gICAgKi9cbiAgICBzdGF0aWMgZW1wdHkobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KGxlbmd0aCA/IFtsZW5ndGgsIC0xXSA6IFtdLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZXNldCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIChhcyBwcm9kdWNlZCBieVxuICAgIFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQudG9KU09OKS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZVNldFwiKTtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhcnQgPSBqc29uW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnQsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHBhcnQpIHx8IHR5cGVvZiBwYXJ0WzBdICE9IFwibnVtYmVyXCIgfHwgcGFydC5zb21lKChlLCBpKSA9PiBpICYmIHR5cGVvZiBlICE9IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlU2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFydC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydFswXSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5zZXJ0ZWQubGVuZ3RoIDwgaSlcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgICAgICAgICBpbnNlcnRlZFtpXSA9IFRleHQub2YocGFydC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0WzBdLCBpbnNlcnRlZFtpXS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGlucywgZm9yY2VKb2luID0gZmFsc2UpIHtcbiAgICBpZiAobGVuID09IDAgJiYgaW5zIDw9IDApXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbGFzdCA9IHNlY3Rpb25zLmxlbmd0aCAtIDI7XG4gICAgaWYgKGxhc3QgPj0gMCAmJiBpbnMgPD0gMCAmJiBpbnMgPT0gc2VjdGlvbnNbbGFzdCArIDFdKVxuICAgICAgICBzZWN0aW9uc1tsYXN0XSArPSBsZW47XG4gICAgZWxzZSBpZiAobGVuID09IDAgJiYgc2VjdGlvbnNbbGFzdF0gPT0gMClcbiAgICAgICAgc2VjdGlvbnNbbGFzdCArIDFdICs9IGlucztcbiAgICBlbHNlIGlmIChmb3JjZUpvaW4pIHtcbiAgICAgICAgc2VjdGlvbnNbbGFzdF0gKz0gbGVuO1xuICAgICAgICBzZWN0aW9uc1tsYXN0ICsgMV0gKz0gaW5zO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHNlY3Rpb25zLnB1c2gobGVuLCBpbnMpO1xufVxuZnVuY3Rpb24gYWRkSW5zZXJ0KHZhbHVlcywgc2VjdGlvbnMsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGluZGV4ID0gKHNlY3Rpb25zLmxlbmd0aCAtIDIpID4+IDE7XG4gICAgaWYgKGluZGV4IDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXS5hcHBlbmQodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2hpbGUgKHZhbHVlcy5sZW5ndGggPCBpbmRleClcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKFRleHQuZW1wdHkpO1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXRlckNoYW5nZXMoZGVzYywgZiwgaW5kaXZpZHVhbCkge1xuICAgIGxldCBpbnNlcnRlZCA9IGRlc2MuaW5zZXJ0ZWQ7XG4gICAgZm9yIChsZXQgcG9zQSA9IDAsIHBvc0IgPSAwLCBpID0gMDsgaSA8IGRlc2Muc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICBsZXQgbGVuID0gZGVzYy5zZWN0aW9uc1tpKytdLCBpbnMgPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICBwb3NBICs9IGxlbjtcbiAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGVuZEEgPSBwb3NBLCBlbmRCID0gcG9zQiwgdGV4dCA9IFRleHQuZW1wdHk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgZW5kQSArPSBsZW47XG4gICAgICAgICAgICAgICAgZW5kQiArPSBpbnM7XG4gICAgICAgICAgICAgICAgaWYgKGlucyAmJiBpbnNlcnRlZClcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuYXBwZW5kKGluc2VydGVkWyhpIC0gMikgPj4gMV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmRpdmlkdWFsIHx8IGkgPT0gZGVzYy5zZWN0aW9ucy5sZW5ndGggfHwgZGVzYy5zZWN0aW9uc1tpICsgMV0gPCAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZW4gPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICAgICAgaW5zID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZihwb3NBLCBlbmRBLCBwb3NCLCBlbmRCLCB0ZXh0KTtcbiAgICAgICAgICAgIHBvc0EgPSBlbmRBO1xuICAgICAgICAgICAgcG9zQiA9IGVuZEI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXBTZXQoc2V0QSwgc2V0QiwgYmVmb3JlLCBta1NldCA9IGZhbHNlKSB7XG4gICAgLy8gUHJvZHVjZSBhIGNvcHkgb2Ygc2V0QSB0aGF0IGFwcGxpZXMgdG8gdGhlIGRvY3VtZW50IGFmdGVyIHNldEJcbiAgICAvLyBoYXMgYmVlbiBhcHBsaWVkIChhc3N1bWluZyBib3RoIHN0YXJ0IGF0IHRoZSBzYW1lIGRvY3VtZW50KS5cbiAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ID0gbWtTZXQgPyBbXSA6IG51bGw7XG4gICAgbGV0IGEgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0QSksIGIgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0Qik7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGJvdGggc2V0cyBpbiBwYXJhbGxlbC4gaW5zZXJ0ZWQgdHJhY2tzLCBmb3IgY2hhbmdlc1xuICAgIC8vIGluIEEgdGhhdCBoYXZlIHRvIGJlIHByb2Nlc3NlZCBwaWVjZS1ieS1waWVjZSwgd2hldGhlciB0aGVpclxuICAgIC8vIGNvbnRlbnQgaGFzIGJlZW4gaW5zZXJ0ZWQgYWxyZWFkeSwgYW5kIHJlZmVycyB0byB0aGUgc2VjdGlvblxuICAgIC8vIGluZGV4LlxuICAgIGZvciAobGV0IGluc2VydGVkID0gLTE7Oykge1xuICAgICAgICBpZiAoYS5pbnMgPT0gLTEgJiYgYi5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIE1vdmUgYWNyb3NzIHJhbmdlcyBza2lwcGVkIGJ5IGJvdGggc2V0cy5cbiAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihhLmxlbiwgYi5sZW4pO1xuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICBhLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgIGIuZm9yd2FyZChsZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIuaW5zID49IDAgJiYgKGEuaW5zIDwgMCB8fCBpbnNlcnRlZCA9PSBhLmkgfHwgYS5vZmYgPT0gMCAmJiAoYi5sZW4gPCBhLmxlbiB8fCBiLmxlbiA9PSBhLmxlbiAmJiAhYmVmb3JlKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBjaGFuZ2UgaW4gQiB0aGF0IGNvbWVzIGJlZm9yZSB0aGUgbmV4dCBjaGFuZ2UgaW5cbiAgICAgICAgICAgIC8vIEEgKG9yZGVyZWQgYnkgc3RhcnQgcG9zLCB0aGVuIGxlbiwgdGhlbiBiZWZvcmUgZmxhZyksIHNraXBcbiAgICAgICAgICAgIC8vIHRoYXQgKGFuZCBwcm9jZXNzIGFueSBjaGFuZ2VzIGluIEEgaXQgY292ZXJzKS5cbiAgICAgICAgICAgIGxldCBsZW4gPSBiLmxlbjtcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGIuaW5zLCAtMSk7XG4gICAgICAgICAgICB3aGlsZSAobGVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBpZWNlID0gTWF0aC5taW4oYS5sZW4sIGxlbik7XG4gICAgICAgICAgICAgICAgaWYgKGEuaW5zID49IDAgJiYgaW5zZXJ0ZWQgPCBhLmkgJiYgYS5sZW4gPD0gcGllY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgMCwgYS5pbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGEudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkID0gYS5pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhLmZvcndhcmQocGllY2UpO1xuICAgICAgICAgICAgICAgIGxlbiAtPSBwaWVjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaW5zID49IDApIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHBhcnQgb2YgYSBjaGFuZ2UgaW4gQSB1cCB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHRcbiAgICAgICAgICAgIC8vIG5vbi1kZWxldGlvbiBjaGFuZ2UgaW4gQiAoaWYgb3ZlcmxhcHBpbmcpLlxuICAgICAgICAgICAgbGV0IGxlbiA9IDAsIGxlZnQgPSBhLmxlbjtcbiAgICAgICAgICAgIHdoaWxlIChsZWZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGIuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaWVjZSA9IE1hdGgubWluKGxlZnQsIGIubGVuKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IHBpZWNlO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IHBpZWNlO1xuICAgICAgICAgICAgICAgICAgICBiLmZvcndhcmQocGllY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiLmlucyA9PSAwICYmIGIubGVuIDwgbGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IGIubGVuO1xuICAgICAgICAgICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgaW5zZXJ0ZWQgPCBhLmkgPyBhLmlucyA6IDApO1xuICAgICAgICAgICAgaWYgKGluc2VydCAmJiBpbnNlcnRlZCA8IGEuaSlcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0KTtcbiAgICAgICAgICAgIGluc2VydGVkID0gYS5pO1xuICAgICAgICAgICAgYS5mb3J3YXJkKGEubGVuIC0gbGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kb25lICYmIGIuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydCA/IENoYW5nZVNldC5jcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydCkgOiBDaGFuZ2VEZXNjLmNyZWF0ZShzZWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3Roc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VTZXRzKHNldEEsIHNldEIsIG1rU2V0ID0gZmFsc2UpIHtcbiAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICBsZXQgaW5zZXJ0ID0gbWtTZXQgPyBbXSA6IG51bGw7XG4gICAgbGV0IGEgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0QSksIGIgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0Qik7XG4gICAgZm9yIChsZXQgb3BlbiA9IGZhbHNlOzspIHtcbiAgICAgICAgaWYgKGEuZG9uZSAmJiBiLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQgPyBDaGFuZ2VTZXQuY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnQpIDogQ2hhbmdlRGVzYy5jcmVhdGUoc2VjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaW5zID09IDApIHsgLy8gRGVsZXRpb24gaW4gQVxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5sZW4sIDAsIG9wZW4pO1xuICAgICAgICAgICAgYS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYi5sZW4gPT0gMCAmJiAhYi5kb25lKSB7IC8vIEluc2VydGlvbiBpbiBCXG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCAwLCBiLmlucywgb3Blbik7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kb25lIHx8IGIuZG9uZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oYS5sZW4yLCBiLmxlbiksIHNlY3Rpb25MZW4gPSBzZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYS5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zQiA9IGIuaW5zID09IC0xID8gLTEgOiBiLm9mZiA/IDAgOiBiLmlucztcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGluc0IsIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgaW5zQilcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEub2ZmID8gMCA6IGEubGVuLCBsZW4sIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHRCaXQobGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLm9mZiA/IDAgOiBhLmxlbiwgYi5vZmYgPyAwIDogYi5pbnMsIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgIWIub2ZmKVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wZW4gPSAoYS5pbnMgPiBsZW4gfHwgYi5pbnMgPj0gMCAmJiBiLmxlbiA+IGxlbikgJiYgKG9wZW4gfHwgc2VjdGlvbnMubGVuZ3RoID4gc2VjdGlvbkxlbik7XG4gICAgICAgICAgICBhLmZvcndhcmQyKGxlbik7XG4gICAgICAgICAgICBiLmZvcndhcmQobGVuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNlY3Rpb25JdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXQpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBsZXQgeyBzZWN0aW9ucyB9ID0gdGhpcy5zZXQ7XG4gICAgICAgIGlmICh0aGlzLmkgPCBzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubGVuID0gc2VjdGlvbnNbdGhpcy5pKytdO1xuICAgICAgICAgICAgdGhpcy5pbnMgPSBzZWN0aW9uc1t0aGlzLmkrK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlbiA9IDA7XG4gICAgICAgICAgICB0aGlzLmlucyA9IC0yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2ZmID0gMDtcbiAgICB9XG4gICAgZ2V0IGRvbmUoKSB7IHJldHVybiB0aGlzLmlucyA9PSAtMjsgfVxuICAgIGdldCBsZW4yKCkgeyByZXR1cm4gdGhpcy5pbnMgPCAwID8gdGhpcy5sZW4gOiB0aGlzLmluczsgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICBsZXQgeyBpbnNlcnRlZCB9ID0gdGhpcy5zZXQsIGluZGV4ID0gKHRoaXMuaSAtIDIpID4+IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSBpbnNlcnRlZC5sZW5ndGggPyBUZXh0LmVtcHR5IDogaW5zZXJ0ZWRbaW5kZXhdO1xuICAgIH1cbiAgICB0ZXh0Qml0KGxlbikge1xuICAgICAgICBsZXQgeyBpbnNlcnRlZCB9ID0gdGhpcy5zZXQsIGluZGV4ID0gKHRoaXMuaSAtIDIpID4+IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSBpbnNlcnRlZC5sZW5ndGggJiYgIWxlbiA/IFRleHQuZW1wdHlcbiAgICAgICAgICAgIDogaW5zZXJ0ZWRbaW5kZXhdLnNsaWNlKHRoaXMub2ZmLCBsZW4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRoaXMub2ZmICsgbGVuKTtcbiAgICB9XG4gICAgZm9yd2FyZChsZW4pIHtcbiAgICAgICAgaWYgKGxlbiA9PSB0aGlzLmxlbilcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGVuIC09IGxlbjtcbiAgICAgICAgICAgIHRoaXMub2ZmICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3J3YXJkMihsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zID09IC0xKVxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PSB0aGlzLmlucylcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5zIC09IGxlbjtcbiAgICAgICAgICAgIHRoaXMub2ZmICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG5BIHNpbmdsZSBzZWxlY3Rpb24gcmFuZ2UuIFdoZW5cbltgYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKVxuaXMgZW5hYmxlZCwgYSBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclNlbGVjdGlvbikgbWF5IGhvbGRcbm11bHRpcGxlIHJhbmdlcy4gQnkgZGVmYXVsdCwgc2VsZWN0aW9ucyBob2xkIGV4YWN0bHkgb25lIHJhbmdlLlxuKi9cbmNsYXNzIFNlbGVjdGlvblJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbG93ZXIgYm91bmRhcnkgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBmbGFncykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGFuY2hvciBvZiB0aGUgcmFuZ2VcdTIwMTR0aGUgc2lkZSB0aGF0IGRvZXNuJ3QgbW92ZSB3aGVuIHlvdVxuICAgIGV4dGVuZCBpdC5cbiAgICAqL1xuICAgIGdldCBhbmNob3IoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMTYgLyogUmFuZ2VGbGFnLkludmVydGVkICovID8gdGhpcy50byA6IHRoaXMuZnJvbTsgfVxuICAgIC8qKlxuICAgIFRoZSBoZWFkIG9mIHRoZSByYW5nZSwgd2hpY2ggaXMgbW92ZWQgd2hlbiB0aGUgcmFuZ2UgaXNcbiAgICBbZXh0ZW5kZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UuZXh0ZW5kKS5cbiAgICAqL1xuICAgIGdldCBoZWFkKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDE2IC8qIFJhbmdlRmxhZy5JbnZlcnRlZCAqLyA/IHRoaXMuZnJvbSA6IHRoaXMudG87IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gYGFuY2hvcmAgYW5kIGBoZWFkYCBhcmUgYXQgdGhlIHNhbWUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLmZyb20gPT0gdGhpcy50bzsgfVxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgYSBjdXJzb3IgdGhhdCBpcyBleHBsaWNpdGx5IGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICBjaGFyYWN0ZXIgb24gb25lIG9mIGl0cyBzaWRlcywgdGhpcyByZXR1cm5zIHRoZSBzaWRlLiAtMSBtZWFuc1xuICAgIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIGl0cyBwb3NpdGlvbiwgMSB0aGUgY2hhcmFjdGVyIGFmdGVyLCBhbmQgMFxuICAgIG1lYW5zIG5vIGFzc29jaWF0aW9uLlxuICAgICovXG4gICAgZ2V0IGFzc29jKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDQgLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovID8gLTEgOiB0aGlzLmZsYWdzICYgOCAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLyA/IDEgOiAwOyB9XG4gICAgLyoqXG4gICAgVGhlIGJpZGlyZWN0aW9uYWwgdGV4dCBsZXZlbCBhc3NvY2lhdGVkIHdpdGggdGhpcyBjdXJzb3IsIGlmXG4gICAgYW55LlxuICAgICovXG4gICAgZ2V0IGJpZGlMZXZlbCgpIHtcbiAgICAgICAgbGV0IGxldmVsID0gdGhpcy5mbGFncyAmIDMgLyogUmFuZ2VGbGFnLkJpZGlMZXZlbE1hc2sgKi87XG4gICAgICAgIHJldHVybiBsZXZlbCA9PSAzID8gbnVsbCA6IGxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZ29hbCBjb2x1bW4gKHN0b3JlZCB2ZXJ0aWNhbCBvZmZzZXQpIGFzc29jaWF0ZWQgd2l0aCBhXG4gICAgY3Vyc29yLiBUaGlzIGlzIHVzZWQgdG8gcHJlc2VydmUgdGhlIHZlcnRpY2FsIHBvc2l0aW9uIHdoZW5cbiAgICBbbW92aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlVmVydGljYWxseSkgYWNyb3NzXG4gICAgbGluZXMgb2YgZGlmZmVyZW50IGxlbmd0aC5cbiAgICAqL1xuICAgIGdldCBnb2FsQ29sdW1uKCkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmZsYWdzID4+IDUgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi87XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSAzMzU1NDQzMSAvKiBSYW5nZUZsYWcuTm9Hb2FsQ29sdW1uICovID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIHJhbmdlIHRocm91Z2ggYSBjaGFuZ2UsIHByb2R1Y2luZyBhIHZhbGlkIHJhbmdlIGluIHRoZVxuICAgIHVwZGF0ZWQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlLCBhc3NvYyA9IC0xKSB7XG4gICAgICAgIGxldCBmcm9tLCB0bztcbiAgICAgICAgaWYgKHRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgIGZyb20gPSB0byA9IGNoYW5nZS5tYXBQb3ModGhpcy5mcm9tLCBhc3NvYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gY2hhbmdlLm1hcFBvcyh0aGlzLmZyb20sIDEpO1xuICAgICAgICAgICAgdG8gPSBjaGFuZ2UubWFwUG9zKHRoaXMudG8sIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbSA9PSB0aGlzLmZyb20gJiYgdG8gPT0gdGhpcy50byA/IHRoaXMgOiBuZXcgU2VsZWN0aW9uUmFuZ2UoZnJvbSwgdG8sIHRoaXMuZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRlbmQgdGhpcyByYW5nZSB0byBjb3ZlciBhdCBsZWFzdCBgZnJvbWAgdG8gYHRvYC5cbiAgICAqL1xuICAgIGV4dGVuZChmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKGZyb20gPD0gdGhpcy5hbmNob3IgJiYgdG8gPj0gdGhpcy5hbmNob3IpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IGhlYWQgPSBNYXRoLmFicyhmcm9tIC0gdGhpcy5hbmNob3IpID4gTWF0aC5hYnModG8gLSB0aGlzLmFuY2hvcikgPyBmcm9tIDogdG87XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodGhpcy5hbmNob3IsIGhlYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgcmFuZ2UgdG8gYW5vdGhlciByYW5nZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuY2hvciA9PSBvdGhlci5hbmNob3IgJiYgdGhpcy5oZWFkID09IG90aGVyLmhlYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJhbmdlLlxuICAgICovXG4gICAgdG9KU09OKCkgeyByZXR1cm4geyBhbmNob3I6IHRoaXMuYW5jaG9yLCBoZWFkOiB0aGlzLmhlYWQgfTsgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgcmFuZ2UgdG8gYSBgU2VsZWN0aW9uUmFuZ2VgXG4gICAgaW5zdGFuY2UuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgdHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaGVhZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIFNlbGVjdGlvblJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGpzb24uYW5jaG9yLCBqc29uLmhlYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZnJvbSwgdG8sIGZsYWdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uUmFuZ2UoZnJvbSwgdG8sIGZsYWdzKTtcbiAgICB9XG59XG4vKipcbkFuIGVkaXRvciBzZWxlY3Rpb24gaG9sZHMgb25lIG9yIG1vcmUgc2VsZWN0aW9uIHJhbmdlcy5cbiovXG5jbGFzcyBFZGl0b3JTZWxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByYW5nZXMgaW4gdGhlIHNlbGVjdGlvbiwgc29ydGVkIGJ5IHBvc2l0aW9uLiBSYW5nZXMgY2Fubm90XG4gICAgb3ZlcmxhcCAoYnV0IHRoZXkgbWF5IHRvdWNoLCBpZiB0aGV5IGFyZW4ndCBlbXB0eSkuXG4gICAgKi9cbiAgICByYW5nZXMsIFxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBvZiB0aGUgX21haW5fIHJhbmdlIGluIHRoZSBzZWxlY3Rpb24gKHdoaWNoIGlzXG4gICAgdXN1YWxseSB0aGUgcmFuZ2UgdGhhdCB3YXMgYWRkZWQgbGFzdCkuXG4gICAgKi9cbiAgICBtYWluSW5kZXgpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMubWFpbkluZGV4ID0gbWFpbkluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBzZWxlY3Rpb24gdGhyb3VnaCBhIGNoYW5nZS4gVXNlZCB0byBhZGp1c3QgdGhlIHNlbGVjdGlvblxuICAgIHBvc2l0aW9uIGZvciBjaGFuZ2VzLlxuICAgICovXG4gICAgbWFwKGNoYW5nZSwgYXNzb2MgPSAtMSkge1xuICAgICAgICBpZiAoY2hhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHRoaXMucmFuZ2VzLm1hcChyID0+IHIubWFwKGNoYW5nZSwgYXNzb2MpKSwgdGhpcy5tYWluSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgc2VsZWN0aW9uIHRvIGFub3RoZXIgc2VsZWN0aW9uLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VzLmxlbmd0aCAhPSBvdGhlci5yYW5nZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLm1haW5JbmRleCAhPSBvdGhlci5tYWluSW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMucmFuZ2VzW2ldLmVxKG90aGVyLnJhbmdlc1tpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwcmltYXJ5IHNlbGVjdGlvbiByYW5nZS4gVXN1YWxseSwgeW91IHNob3VsZCBtYWtlIHN1cmVcbiAgICB5b3VyIGNvZGUgYXBwbGllcyB0byBfYWxsXyByYW5nZXMsIGJ5IHVzaW5nIG1ldGhvZHMgbGlrZVxuICAgIFtgY2hhbmdlQnlSYW5nZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhbmdlQnlSYW5nZSkuXG4gICAgKi9cbiAgICBnZXQgbWFpbigpIHsgcmV0dXJuIHRoaXMucmFuZ2VzW3RoaXMubWFpbkluZGV4XTsgfVxuICAgIC8qKlxuICAgIE1ha2Ugc3VyZSB0aGUgc2VsZWN0aW9uIG9ubHkgaGFzIG9uZSByYW5nZS4gUmV0dXJucyBhIHNlbGVjdGlvblxuICAgIGhvbGRpbmcgb25seSB0aGUgbWFpbiByYW5nZSBmcm9tIHRoaXMgc2VsZWN0aW9uLlxuICAgICovXG4gICAgYXNTaW5nbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlcy5sZW5ndGggPT0gMSA/IHRoaXMgOiBuZXcgRWRpdG9yU2VsZWN0aW9uKFt0aGlzLm1haW5dLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0ZW5kIHRoaXMgc2VsZWN0aW9uIHdpdGggYW4gZXh0cmEgcmFuZ2UuXG4gICAgKi9cbiAgICBhZGRSYW5nZShyYW5nZSwgbWFpbiA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW3JhbmdlXS5jb25jYXQodGhpcy5yYW5nZXMpLCBtYWluID8gMCA6IHRoaXMubWFpbkluZGV4ICsgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgYSBnaXZlbiByYW5nZSB3aXRoIGFub3RoZXIgcmFuZ2UsIGFuZCB0aGVuIG5vcm1hbGl6ZSB0aGVcbiAgICBzZWxlY3Rpb24gdG8gbWVyZ2UgYW5kIHNvcnQgcmFuZ2VzIGlmIG5lY2Vzc2FyeS5cbiAgICAqL1xuICAgIHJlcGxhY2VSYW5nZShyYW5nZSwgd2hpY2ggPSB0aGlzLm1haW5JbmRleCkge1xuICAgICAgICBsZXQgcmFuZ2VzID0gdGhpcy5yYW5nZXMuc2xpY2UoKTtcbiAgICAgICAgcmFuZ2VzW3doaWNoXSA9IHJhbmdlO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHRoaXMubWFpbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGlzIHNlbGVjdGlvbiB0byBhbiBvYmplY3QgdGhhdCBjYW4gYmUgc2VyaWFsaXplZCB0b1xuICAgIEpTT04uXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlczogdGhpcy5yYW5nZXMubWFwKHIgPT4gci50b0pTT04oKSksIG1haW46IHRoaXMubWFpbkluZGV4IH07XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiBmcm9tIGEgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbiB8fCAhQXJyYXkuaXNBcnJheShqc29uLnJhbmdlcykgfHwgdHlwZW9mIGpzb24ubWFpbiAhPSBcIm51bWJlclwiIHx8IGpzb24ubWFpbiA+PSBqc29uLnJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgRWRpdG9yU2VsZWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihqc29uLnJhbmdlcy5tYXAoKHIpID0+IFNlbGVjdGlvblJhbmdlLmZyb21KU09OKHIpKSwganNvbi5tYWluKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VsZWN0aW9uIGhvbGRpbmcgYSBzaW5nbGUgcmFuZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgc2luZ2xlKGFuY2hvciwgaGVhZCA9IGFuY2hvcikge1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihbRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGFuY2hvciwgaGVhZCldLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgU29ydCBhbmQgbWVyZ2UgdGhlIGdpdmVuIHNldCBvZiByYW5nZXMsIGNyZWF0aW5nIGEgdmFsaWRcbiAgICBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHJhbmdlcywgbWFpbkluZGV4ID0gMCkge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBIHNlbGVjdGlvbiBuZWVkcyBhdCBsZWFzdCBvbmUgcmFuZ2VcIik7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgPyByYW5nZS5mcm9tIDw9IHBvcyA6IHJhbmdlLmZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5ub3JtYWxpemVkKHJhbmdlcy5zbGljZSgpLCBtYWluSW5kZXgpO1xuICAgICAgICAgICAgcG9zID0gcmFuZ2UudG87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24ocmFuZ2VzLCBtYWluSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjdXJzb3Igc2VsZWN0aW9uIHJhbmdlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gWW91IGNhblxuICAgIHNhZmVseSBpZ25vcmUgdGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBpbiBtb3N0IHNpdHVhdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgY3Vyc29yKHBvcywgYXNzb2MgPSAwLCBiaWRpTGV2ZWwsIGdvYWxDb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIFNlbGVjdGlvblJhbmdlLmNyZWF0ZShwb3MsIHBvcywgKGFzc29jID09IDAgPyAwIDogYXNzb2MgPCAwID8gNCAvKiBSYW5nZUZsYWcuQXNzb2NCZWZvcmUgKi8gOiA4IC8qIFJhbmdlRmxhZy5Bc3NvY0FmdGVyICovKSB8XG4gICAgICAgICAgICAoYmlkaUxldmVsID09IG51bGwgPyAzIDogTWF0aC5taW4oMiwgYmlkaUxldmVsKSkgfFxuICAgICAgICAgICAgKChnb2FsQ29sdW1uICE9PSBudWxsICYmIGdvYWxDb2x1bW4gIT09IHZvaWQgMCA/IGdvYWxDb2x1bW4gOiAzMzU1NDQzMSAvKiBSYW5nZUZsYWcuTm9Hb2FsQ29sdW1uICovKSA8PCA1IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyByYW5nZShhbmNob3IsIGhlYWQsIGdvYWxDb2x1bW4sIGJpZGlMZXZlbCkge1xuICAgICAgICBsZXQgZmxhZ3MgPSAoKGdvYWxDb2x1bW4gIT09IG51bGwgJiYgZ29hbENvbHVtbiAhPT0gdm9pZCAwID8gZ29hbENvbHVtbiA6IDMzNTU0NDMxIC8qIFJhbmdlRmxhZy5Ob0dvYWxDb2x1bW4gKi8pIDw8IDUgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi8pIHxcbiAgICAgICAgICAgIChiaWRpTGV2ZWwgPT0gbnVsbCA/IDMgOiBNYXRoLm1pbigyLCBiaWRpTGV2ZWwpKTtcbiAgICAgICAgcmV0dXJuIGhlYWQgPCBhbmNob3IgPyBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoaGVhZCwgYW5jaG9yLCAxNiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gfCA4IC8qIFJhbmdlRmxhZy5Bc3NvY0FmdGVyICovIHwgZmxhZ3MpXG4gICAgICAgICAgICA6IFNlbGVjdGlvblJhbmdlLmNyZWF0ZShhbmNob3IsIGhlYWQsIChoZWFkID4gYW5jaG9yID8gNCAvKiBSYW5nZUZsYWcuQXNzb2NCZWZvcmUgKi8gOiAwKSB8IGZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgbm9ybWFsaXplZChyYW5nZXMsIG1haW5JbmRleCA9IDApIHtcbiAgICAgICAgbGV0IG1haW4gPSByYW5nZXNbbWFpbkluZGV4XTtcbiAgICAgICAgcmFuZ2VzLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG4gICAgICAgIG1haW5JbmRleCA9IHJhbmdlcy5pbmRleE9mKG1haW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldLCBwcmV2ID0gcmFuZ2VzW2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSA/IHJhbmdlLmZyb20gPD0gcHJldi50byA6IHJhbmdlLmZyb20gPCBwcmV2LnRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBwcmV2LmZyb20sIHRvID0gTWF0aC5tYXgocmFuZ2UudG8sIHByZXYudG8pO1xuICAgICAgICAgICAgICAgIGlmIChpIDw9IG1haW5JbmRleClcbiAgICAgICAgICAgICAgICAgICAgbWFpbkluZGV4LS07XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnNwbGljZSgtLWksIDIsIHJhbmdlLmFuY2hvciA+IHJhbmdlLmhlYWQgPyBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodG8sIGZyb20pIDogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24ocmFuZ2VzLCBtYWluSW5kZXgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgZG9jTGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc2VsZWN0aW9uLnJhbmdlcylcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZG9jTGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTZWxlY3Rpb24gcG9pbnRzIG91dHNpZGUgb2YgZG9jdW1lbnRcIik7XG59XG5cbmxldCBuZXh0SUQgPSAwO1xuLyoqXG5BIGZhY2V0IGlzIGEgbGFiZWxlZCB2YWx1ZSB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCBhbiBlZGl0b3JcbnN0YXRlLiBJdCB0YWtlcyBpbnB1dHMgZnJvbSBhbnkgbnVtYmVyIG9mIGV4dGVuc2lvbnMsIGFuZCBjb21iaW5lc1xudGhvc2UgaW50byBhIHNpbmdsZSBvdXRwdXQgdmFsdWUuXG5cbkV4YW1wbGVzIG9mIHVzZXMgb2YgZmFjZXRzIGFyZSB0aGUgW3RhYlxuc2l6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSwgW2VkaXRvclxuYXR0cmlidXRlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZWRpdG9yQXR0cmlidXRlcyksIGFuZCBbdXBkYXRlXG5saXN0ZW5lcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnVwZGF0ZUxpc3RlbmVyKS5cbiovXG5jbGFzcyBGYWNldCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21iaW5lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmVJbnB1dCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlLCBpc1N0YXRpYywgZW5hYmxlcykge1xuICAgICAgICB0aGlzLmNvbWJpbmUgPSBjb21iaW5lO1xuICAgICAgICB0aGlzLmNvbXBhcmVJbnB1dCA9IGNvbXBhcmVJbnB1dDtcbiAgICAgICAgdGhpcy5jb21wYXJlID0gY29tcGFyZTtcbiAgICAgICAgdGhpcy5pc1N0YXRpYyA9IGlzU3RhdGljO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBuZXh0SUQrKztcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gY29tYmluZShbXSk7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHR5cGVvZiBlbmFibGVzID09IFwiZnVuY3Rpb25cIiA/IGVuYWJsZXModGhpcykgOiBlbmFibGVzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgZmFjZXQuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXQoY29uZmlnLmNvbWJpbmUgfHwgKChhKSA9PiBhKSwgY29uZmlnLmNvbXBhcmVJbnB1dCB8fCAoKGEsIGIpID0+IGEgPT09IGIpLCBjb25maWcuY29tcGFyZSB8fCAoIWNvbmZpZy5jb21iaW5lID8gc2FtZUFycmF5IDogKGEsIGIpID0+IGEgPT09IGIpLCAhIWNvbmZpZy5zdGF0aWMsIGNvbmZpZy5lbmFibGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBhZGRzIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGlzIGZhY2V0LlxuICAgICovXG4gICAgb2YodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKFtdLCB0aGlzLCAwIC8qIFByb3ZpZGVyLlN0YXRpYyAqLywgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29tcHV0ZXMgYSB2YWx1ZSBmb3IgdGhlIGZhY2V0IGZyb20gYVxuICAgIHN0YXRlLiBZb3UgbXVzdCB0YWtlIGNhcmUgdG8gZGVjbGFyZSB0aGUgcGFydHMgb2YgdGhlIHN0YXRlIHRoYXRcbiAgICB0aGlzIHZhbHVlIGRlcGVuZHMgb24sIHNpbmNlIHlvdXIgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgYWdhaW5cbiAgICBmb3IgYSBuZXcgc3RhdGUgd2hlbiBvbmUgb2YgdGhvc2UgcGFydHMgY2hhbmdlZC5cbiAgICBcbiAgICBJbiBjYXNlcyB3aGVyZSB5b3VyIHZhbHVlIGRlcGVuZHMgb25seSBvbiBhIHNpbmdsZSBmaWVsZCwgeW91J2xsXG4gICAgd2FudCB0byB1c2UgdGhlIFtgZnJvbWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRmFjZXQuZnJvbSkgbWV0aG9kIGluc3RlYWQuXG4gICAgKi9cbiAgICBjb21wdXRlKGRlcHMsIGdldCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0YXRpYylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbXB1dGUgYSBzdGF0aWMgZmFjZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihkZXBzLCB0aGlzLCAxIC8qIFByb3ZpZGVyLlNpbmdsZSAqLywgZ2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbXB1dGVzIHplcm8gb3IgbW9yZSB2YWx1ZXMgZm9yIHRoaXNcbiAgICBmYWNldCBmcm9tIGEgc3RhdGUuXG4gICAgKi9cbiAgICBjb21wdXRlTihkZXBzLCBnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0aWMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb21wdXRlIGEgc3RhdGljIGZhY2V0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoZGVwcywgdGhpcywgMiAvKiBQcm92aWRlci5NdWx0aSAqLywgZ2V0KTtcbiAgICB9XG4gICAgZnJvbShmaWVsZCwgZ2V0KSB7XG4gICAgICAgIGlmICghZ2V0KVxuICAgICAgICAgICAgZ2V0ID0geCA9PiB4O1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlKFtmaWVsZF0sIHN0YXRlID0+IGdldChzdGF0ZS5maWVsZChmaWVsZCkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lQXJyYXkoYSwgYikge1xuICAgIHJldHVybiBhID09IGIgfHwgYS5sZW5ndGggPT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoZSwgaSkgPT4gZSA9PT0gYltpXSk7XG59XG5jbGFzcyBGYWNldFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkZXBlbmRlbmNpZXMsIGZhY2V0LCB0eXBlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbiAgICAgICAgdGhpcy5mYWNldCA9IGZhY2V0O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0SUQrKztcbiAgICB9XG4gICAgZHluYW1pY1Nsb3QoYWRkcmVzc2VzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGdldHRlciA9IHRoaXMudmFsdWU7XG4gICAgICAgIGxldCBjb21wYXJlID0gdGhpcy5mYWNldC5jb21wYXJlSW5wdXQ7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuaWQsIGlkeCA9IGFkZHJlc3Nlc1tpZF0gPj4gMSwgbXVsdGkgPSB0aGlzLnR5cGUgPT0gMiAvKiBQcm92aWRlci5NdWx0aSAqLztcbiAgICAgICAgbGV0IGRlcERvYyA9IGZhbHNlLCBkZXBTZWwgPSBmYWxzZSwgZGVwQWRkcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZGVwIG9mIHRoaXMuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBpZiAoZGVwID09IFwiZG9jXCIpXG4gICAgICAgICAgICAgICAgZGVwRG9jID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGRlcCA9PSBcInNlbGVjdGlvblwiKVxuICAgICAgICAgICAgICAgIGRlcFNlbCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmICgoKChfYSA9IGFkZHJlc3Nlc1tkZXAuaWRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxKSAmIDEpID09IDApXG4gICAgICAgICAgICAgICAgZGVwQWRkcnMucHVzaChhZGRyZXNzZXNbZGVwLmlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gZ2V0dGVyKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlKHN0YXRlLCB0cikge1xuICAgICAgICAgICAgICAgIGlmICgoZGVwRG9jICYmIHRyLmRvY0NoYW5nZWQpIHx8IChkZXBTZWwgJiYgKHRyLmRvY0NoYW5nZWQgfHwgdHIuc2VsZWN0aW9uKSkgfHwgZW5zdXJlQWxsKHN0YXRlLCBkZXBBZGRycykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1ZhbCA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aSA/ICFjb21wYXJlQXJyYXkobmV3VmFsLCBzdGF0ZS52YWx1ZXNbaWR4XSwgY29tcGFyZSkgOiAhY29tcGFyZShuZXdWYWwsIHN0YXRlLnZhbHVlc1tpZHhdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBuZXdWYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjb25maWd1cmU6IChzdGF0ZSwgb2xkU3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3VmFsLCBvbGRBZGRyID0gb2xkU3RhdGUuY29uZmlnLmFkZHJlc3NbaWRdO1xuICAgICAgICAgICAgICAgIGlmIChvbGRBZGRyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9sZFZhbCA9IGdldEFkZHIob2xkU3RhdGUsIG9sZEFkZHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXBlbmRlbmNpZXMuZXZlcnkoZGVwID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXAgaW5zdGFuY2VvZiBGYWNldCA/IG9sZFN0YXRlLmZhY2V0KGRlcCkgPT09IHN0YXRlLmZhY2V0KGRlcCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcCBpbnN0YW5jZW9mIFN0YXRlRmllbGQgPyBvbGRTdGF0ZS5maWVsZChkZXAsIGZhbHNlKSA9PSBzdGF0ZS5maWVsZChkZXAsIGZhbHNlKSA6IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pIHx8IChtdWx0aSA/IGNvbXBhcmVBcnJheShuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpLCBvbGRWYWwsIGNvbXBhcmUpIDogY29tcGFyZShuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpLCBvbGRWYWwpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBvbGRWYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsID0gZ2V0dGVyKHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBuZXdWYWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmVBcnJheShhLCBiLCBjb21wYXJlKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWNvbXBhcmUoYVtpXSwgYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBlbnN1cmVBbGwoc3RhdGUsIGFkZHJzKSB7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBhZGRyIG9mIGFkZHJzKVxuICAgICAgICBpZiAoZW5zdXJlQWRkcihzdGF0ZSwgYWRkcikgJiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLylcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIHJldHVybiBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gZHluYW1pY0ZhY2V0U2xvdChhZGRyZXNzZXMsIGZhY2V0LCBwcm92aWRlcnMpIHtcbiAgICBsZXQgcHJvdmlkZXJBZGRycyA9IHByb3ZpZGVycy5tYXAocCA9PiBhZGRyZXNzZXNbcC5pZF0pO1xuICAgIGxldCBwcm92aWRlclR5cGVzID0gcHJvdmlkZXJzLm1hcChwID0+IHAudHlwZSk7XG4gICAgbGV0IGR5bmFtaWMgPSBwcm92aWRlckFkZHJzLmZpbHRlcihwID0+ICEocCAmIDEpKTtcbiAgICBsZXQgaWR4ID0gYWRkcmVzc2VzW2ZhY2V0LmlkXSA+PiAxO1xuICAgIGZ1bmN0aW9uIGdldChzdGF0ZSkge1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvdmlkZXJBZGRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0QWRkcihzdGF0ZSwgcHJvdmlkZXJBZGRyc1tpXSk7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXJUeXBlc1tpXSA9PSAyIC8qIFByb3ZpZGVyLk11bHRpICovKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHZhbCBvZiB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhY2V0LmNvbWJpbmUodmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBhZGRyIG9mIHByb3ZpZGVyQWRkcnMpXG4gICAgICAgICAgICAgICAgZW5zdXJlQWRkcihzdGF0ZSwgYWRkcik7XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IGdldChzdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZShzdGF0ZSwgdHIpIHtcbiAgICAgICAgICAgIGlmICghZW5zdXJlQWxsKHN0YXRlLCBkeW5hbWljKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGdldChzdGF0ZSk7XG4gICAgICAgICAgICBpZiAoZmFjZXQuY29tcGFyZSh2YWx1ZSwgc3RhdGUudmFsdWVzW2lkeF0pKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgfSxcbiAgICAgICAgcmVjb25maWd1cmUoc3RhdGUsIG9sZFN0YXRlKSB7XG4gICAgICAgICAgICBsZXQgZGVwQ2hhbmdlZCA9IGVuc3VyZUFsbChzdGF0ZSwgcHJvdmlkZXJBZGRycyk7XG4gICAgICAgICAgICBsZXQgb2xkUHJvdmlkZXJzID0gb2xkU3RhdGUuY29uZmlnLmZhY2V0c1tmYWNldC5pZF0sIG9sZFZhbHVlID0gb2xkU3RhdGUuZmFjZXQoZmFjZXQpO1xuICAgICAgICAgICAgaWYgKG9sZFByb3ZpZGVycyAmJiAhZGVwQ2hhbmdlZCAmJiBzYW1lQXJyYXkocHJvdmlkZXJzLCBvbGRQcm92aWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBvbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGdldChzdGF0ZSk7XG4gICAgICAgICAgICBpZiAoZmFjZXQuY29tcGFyZSh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBvbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3QgaW5pdEZpZWxkID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IHN0YXRpYzogdHJ1ZSB9KTtcbi8qKlxuRmllbGRzIGNhbiBzdG9yZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGluIGFuIGVkaXRvciBzdGF0ZSwgYW5kXG5rZWVwIGl0IGluIHN5bmMgd2l0aCB0aGUgcmVzdCBvZiB0aGUgc3RhdGUuXG4qL1xuY2xhc3MgU3RhdGVGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpZCwgY3JlYXRlRiwgdXBkYXRlRiwgY29tcGFyZUYsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuY3JlYXRlRiA9IGNyZWF0ZUY7XG4gICAgICAgIHRoaXMudXBkYXRlRiA9IHVwZGF0ZUY7XG4gICAgICAgIHRoaXMuY29tcGFyZUYgPSBjb21wYXJlRjtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3ZpZGVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBzdGF0ZSBmaWVsZC5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY29uZmlnKSB7XG4gICAgICAgIGxldCBmaWVsZCA9IG5ldyBTdGF0ZUZpZWxkKG5leHRJRCsrLCBjb25maWcuY3JlYXRlLCBjb25maWcudXBkYXRlLCBjb25maWcuY29tcGFyZSB8fCAoKGEsIGIpID0+IGEgPT09IGIpLCBjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3ZpZGUpXG4gICAgICAgICAgICBmaWVsZC5wcm92aWRlcyA9IGNvbmZpZy5wcm92aWRlKGZpZWxkKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgIH1cbiAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgbGV0IGluaXQgPSBzdGF0ZS5mYWNldChpbml0RmllbGQpLmZpbmQoaSA9PiBpLmZpZWxkID09IHRoaXMpO1xuICAgICAgICByZXR1cm4gKChpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuY3JlYXRlKSB8fCB0aGlzLmNyZWF0ZUYpKHN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzbG90KGFkZHJlc3Nlcykge1xuICAgICAgICBsZXQgaWR4ID0gYWRkcmVzc2VzW3RoaXMuaWRdID4+IDE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGU6IChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdGhpcy5jcmVhdGUoc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGU6IChzdGF0ZSwgdHIpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgb2xkVmFsID0gc3RhdGUudmFsdWVzW2lkeF07XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy51cGRhdGVGKG9sZFZhbCwgdHIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmVGKG9sZFZhbCwgdmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWNvbmZpZ3VyZTogKHN0YXRlLCBvbGRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvbGRTdGF0ZS5jb25maWcuYWRkcmVzc1t0aGlzLmlkXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkU3RhdGUuZmllbGQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHRoaXMuY3JlYXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyB0aGlzIGZpZWxkIGFuZCBvdmVycmlkZXMgdGhlXG4gICAgd2F5IGl0IGlzIGluaXRpYWxpemVkLiBDYW4gYmUgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gcHJvdmlkZSBhXG4gICAgbm9uLWRlZmF1bHQgc3RhcnRpbmcgdmFsdWUgZm9yIHRoZSBmaWVsZC5cbiAgICAqL1xuICAgIGluaXQoY3JlYXRlKSB7XG4gICAgICAgIHJldHVybiBbdGhpcywgaW5pdEZpZWxkLm9mKHsgZmllbGQ6IHRoaXMsIGNyZWF0ZSB9KV07XG4gICAgfVxuICAgIC8qKlxuICAgIFN0YXRlIGZpZWxkIGluc3RhbmNlcyBjYW4gYmUgdXNlZCBhc1xuICAgIFtgRXh0ZW5zaW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FeHRlbnNpb24pIHZhbHVlcyB0byBlbmFibGUgdGhlIGZpZWxkIGluIGFcbiAgICBnaXZlbiBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBleHRlbnNpb24oKSB7IHJldHVybiB0aGlzOyB9XG59XG5jb25zdCBQcmVjXyA9IHsgbG93ZXN0OiA0LCBsb3c6IDMsIGRlZmF1bHQ6IDIsIGhpZ2g6IDEsIGhpZ2hlc3Q6IDAgfTtcbmZ1bmN0aW9uIHByZWModmFsdWUpIHtcbiAgICByZXR1cm4gKGV4dCkgPT4gbmV3IFByZWNFeHRlbnNpb24oZXh0LCB2YWx1ZSk7XG59XG4vKipcbkJ5IGRlZmF1bHQgZXh0ZW5zaW9ucyBhcmUgcmVnaXN0ZXJlZCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgZm91bmRcbmluIHRoZSBmbGF0dGVuZWQgZm9ybSBvZiBuZXN0ZWQgYXJyYXkgdGhhdCB3YXMgcHJvdmlkZWQuXG5JbmRpdmlkdWFsIGV4dGVuc2lvbiB2YWx1ZXMgY2FuIGJlIGFzc2lnbmVkIGEgcHJlY2VkZW5jZSB0b1xub3ZlcnJpZGUgdGhpcy4gRXh0ZW5zaW9ucyB0aGF0IGRvIG5vdCBoYXZlIGEgcHJlY2VkZW5jZSBzZXQgZ2V0XG50aGUgcHJlY2VkZW5jZSBvZiB0aGUgbmVhcmVzdCBwYXJlbnQgd2l0aCBhIHByZWNlZGVuY2UsIG9yXG5bYGRlZmF1bHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlByZWMuZGVmYXVsdCkgaWYgdGhlcmUgaXMgbm8gc3VjaCBwYXJlbnQuIFRoZVxuZmluYWwgb3JkZXJpbmcgb2YgZXh0ZW5zaW9ucyBpcyBkZXRlcm1pbmVkIGJ5IGZpcnN0IHNvcnRpbmcgYnlcbnByZWNlZGVuY2UgYW5kIHRoZW4gYnkgb3JkZXIgd2l0aGluIGVhY2ggcHJlY2VkZW5jZS5cbiovXG5jb25zdCBQcmVjID0ge1xuICAgIC8qKlxuICAgIFRoZSBoaWdoZXN0IHByZWNlZGVuY2UgbGV2ZWwsIGZvciBleHRlbnNpb25zIHRoYXQgc2hvdWxkIGVuZCB1cFxuICAgIG5lYXIgdGhlIHN0YXJ0IG9mIHRoZSBwcmVjZWRlbmNlIG9yZGVyaW5nLlxuICAgICovXG4gICAgaGlnaGVzdDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uaGlnaGVzdCksXG4gICAgLyoqXG4gICAgQSBoaWdoZXItdGhhbi1kZWZhdWx0IHByZWNlZGVuY2UsIGZvciBleHRlbnNpb25zIHRoYXQgc2hvdWxkXG4gICAgY29tZSBiZWZvcmUgdGhvc2Ugd2l0aCBkZWZhdWx0IHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBoaWdoOiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5oaWdoKSxcbiAgICAvKipcbiAgICBUaGUgZGVmYXVsdCBwcmVjZWRlbmNlLCB3aGljaCBpcyBhbHNvIHVzZWQgZm9yIGV4dGVuc2lvbnNcbiAgICB3aXRob3V0IGFuIGV4cGxpY2l0IHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBkZWZhdWx0OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5kZWZhdWx0KSxcbiAgICAvKipcbiAgICBBIGxvd2VyLXRoYW4tZGVmYXVsdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgbG93OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5sb3cpLFxuICAgIC8qKlxuICAgIFRoZSBsb3dlc3QgcHJlY2VkZW5jZSBsZXZlbC4gTWVhbnQgZm9yIHRoaW5ncyB0aGF0IHNob3VsZCBlbmQgdXBcbiAgICBuZWFyIHRoZSBlbmQgb2YgdGhlIGV4dGVuc2lvbiBvcmRlci5cbiAgICAqL1xuICAgIGxvd2VzdDogLypAX19QVVJFX18qL3ByZWMoUHJlY18ubG93ZXN0KVxufTtcbmNsYXNzIFByZWNFeHRlbnNpb24ge1xuICAgIGNvbnN0cnVjdG9yKGlubmVyLCBwcmVjKSB7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICAgICAgdGhpcy5wcmVjID0gcHJlYztcbiAgICB9XG59XG4vKipcbkV4dGVuc2lvbiBjb21wYXJ0bWVudHMgY2FuIGJlIHVzZWQgdG8gbWFrZSBhIGNvbmZpZ3VyYXRpb25cbmR5bmFtaWMuIEJ5IFt3cmFwcGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5vZikgcGFydCBvZiB5b3VyXG5jb25maWd1cmF0aW9uIGluIGEgY29tcGFydG1lbnQsIHlvdSBjYW4gbGF0ZXJcbltyZXBsYWNlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50LnJlY29uZmlndXJlKSB0aGF0IHBhcnQgdGhyb3VnaCBhXG50cmFuc2FjdGlvbi5cbiovXG5jbGFzcyBDb21wYXJ0bWVudCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY29tcGFydG1lbnQgdG8gYWRkIHRvIHlvdXIgW3N0YXRlXG4gICAgY29uZmlndXJhdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZUNvbmZpZy5leHRlbnNpb25zKS5cbiAgICAqL1xuICAgIG9mKGV4dCkgeyByZXR1cm4gbmV3IENvbXBhcnRtZW50SW5zdGFuY2UodGhpcywgZXh0KTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBbZWZmZWN0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSB0aGF0XG4gICAgcmVjb25maWd1cmVzIHRoaXMgY29tcGFydG1lbnQuXG4gICAgKi9cbiAgICByZWNvbmZpZ3VyZShjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBDb21wYXJ0bWVudC5yZWNvbmZpZ3VyZS5vZih7IGNvbXBhcnRtZW50OiB0aGlzLCBleHRlbnNpb246IGNvbnRlbnQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY3VycmVudCBjb250ZW50IG9mIHRoZSBjb21wYXJ0bWVudCBpbiB0aGUgc3RhdGUsIG9yXG4gICAgYHVuZGVmaW5lZGAgaWYgaXQgaXNuJ3QgcHJlc2VudC5cbiAgICAqL1xuICAgIGdldChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gc3RhdGUuY29uZmlnLmNvbXBhcnRtZW50cy5nZXQodGhpcyk7XG4gICAgfVxufVxuY2xhc3MgQ29tcGFydG1lbnRJbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3IoY29tcGFydG1lbnQsIGlubmVyKSB7XG4gICAgICAgIHRoaXMuY29tcGFydG1lbnQgPSBjb21wYXJ0bWVudDtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgIH1cbn1cbmNsYXNzIENvbmZpZ3VyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGJhc2UsIGNvbXBhcnRtZW50cywgZHluYW1pY1Nsb3RzLCBhZGRyZXNzLCBzdGF0aWNWYWx1ZXMsIGZhY2V0cykge1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLmNvbXBhcnRtZW50cyA9IGNvbXBhcnRtZW50cztcbiAgICAgICAgdGhpcy5keW5hbWljU2xvdHMgPSBkeW5hbWljU2xvdHM7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIHRoaXMuc3RhdGljVmFsdWVzID0gc3RhdGljVmFsdWVzO1xuICAgICAgICB0aGlzLmZhY2V0cyA9IGZhY2V0cztcbiAgICAgICAgdGhpcy5zdGF0dXNUZW1wbGF0ZSA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5zdGF0dXNUZW1wbGF0ZS5sZW5ndGggPCBkeW5hbWljU2xvdHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5zdGF0dXNUZW1wbGF0ZS5wdXNoKDAgLyogU2xvdFN0YXR1cy5VbnJlc29sdmVkICovKTtcbiAgICB9XG4gICAgc3RhdGljRmFjZXQoZmFjZXQpIHtcbiAgICAgICAgbGV0IGFkZHIgPSB0aGlzLmFkZHJlc3NbZmFjZXQuaWRdO1xuICAgICAgICByZXR1cm4gYWRkciA9PSBudWxsID8gZmFjZXQuZGVmYXVsdCA6IHRoaXMuc3RhdGljVmFsdWVzW2FkZHIgPj4gMV07XG4gICAgfVxuICAgIHN0YXRpYyByZXNvbHZlKGJhc2UsIGNvbXBhcnRtZW50cywgb2xkU3RhdGUpIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IFtdO1xuICAgICAgICBsZXQgZmFjZXRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IG5ld0NvbXBhcnRtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgZXh0IG9mIGZsYXR0ZW4oYmFzZSwgY29tcGFydG1lbnRzLCBuZXdDb21wYXJ0bWVudHMpKSB7XG4gICAgICAgICAgICBpZiAoZXh0IGluc3RhbmNlb2YgU3RhdGVGaWVsZClcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChleHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIChmYWNldHNbZXh0LmZhY2V0LmlkXSB8fCAoZmFjZXRzW2V4dC5mYWNldC5pZF0gPSBbXSkpLnB1c2goZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWRkcmVzcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBzdGF0aWNWYWx1ZXMgPSBbXTtcbiAgICAgICAgbGV0IGR5bmFtaWNTbG90cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGFkZHJlc3NbZmllbGQuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBmaWVsZC5zbG90KGEpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb2xkRmFjZXRzID0gb2xkU3RhdGUgPT09IG51bGwgfHwgb2xkU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFN0YXRlLmNvbmZpZy5mYWNldHM7XG4gICAgICAgIGZvciAobGV0IGlkIGluIGZhY2V0cykge1xuICAgICAgICAgICAgbGV0IHByb3ZpZGVycyA9IGZhY2V0c1tpZF0sIGZhY2V0ID0gcHJvdmlkZXJzWzBdLmZhY2V0O1xuICAgICAgICAgICAgbGV0IG9sZFByb3ZpZGVycyA9IG9sZEZhY2V0cyAmJiBvbGRGYWNldHNbaWRdIHx8IFtdO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVycy5ldmVyeShwID0+IHAudHlwZSA9PSAwIC8qIFByb3ZpZGVyLlN0YXRpYyAqLykpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzW2ZhY2V0LmlkXSA9IChzdGF0aWNWYWx1ZXMubGVuZ3RoIDw8IDEpIHwgMTtcbiAgICAgICAgICAgICAgICBpZiAoc2FtZUFycmF5KG9sZFByb3ZpZGVycywgcHJvdmlkZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNWYWx1ZXMucHVzaChvbGRTdGF0ZS5mYWNldChmYWNldCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZmFjZXQuY29tYmluZShwcm92aWRlcnMubWFwKHAgPT4gcC52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNWYWx1ZXMucHVzaChvbGRTdGF0ZSAmJiBmYWNldC5jb21wYXJlKHZhbHVlLCBvbGRTdGF0ZS5mYWNldChmYWNldCkpID8gb2xkU3RhdGUuZmFjZXQoZmFjZXQpIDogdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgb2YgcHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnR5cGUgPT0gMCAvKiBQcm92aWRlci5TdGF0aWMgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NbcC5pZF0gPSAoc3RhdGljVmFsdWVzLmxlbmd0aCA8PCAxKSB8IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNWYWx1ZXMucHVzaChwLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NbcC5pZF0gPSBkeW5hbWljU2xvdHMubGVuZ3RoIDw8IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IHAuZHluYW1pY1Nsb3QoYSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZHJlc3NbZmFjZXQuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gZHluYW1pY0ZhY2V0U2xvdChhLCBmYWNldCwgcHJvdmlkZXJzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGR5bmFtaWMgPSBkeW5hbWljU2xvdHMubWFwKGYgPT4gZihhZGRyZXNzKSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29uZmlndXJhdGlvbihiYXNlLCBuZXdDb21wYXJ0bWVudHMsIGR5bmFtaWMsIGFkZHJlc3MsIHN0YXRpY1ZhbHVlcywgZmFjZXRzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmbGF0dGVuKGV4dGVuc2lvbiwgY29tcGFydG1lbnRzLCBuZXdDb21wYXJ0bWVudHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gW1tdLCBbXSwgW10sIFtdLCBbXV07XG4gICAgbGV0IHNlZW4gPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gaW5uZXIoZXh0LCBwcmVjKSB7XG4gICAgICAgIGxldCBrbm93biA9IHNlZW4uZ2V0KGV4dCk7XG4gICAgICAgIGlmIChrbm93biAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoa25vd24gPD0gcHJlYylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgZm91bmQgPSByZXN1bHRba25vd25dLmluZGV4T2YoZXh0KTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrbm93bl0uc3BsaWNlKGZvdW5kLCAxKTtcbiAgICAgICAgICAgIGlmIChleHQgaW5zdGFuY2VvZiBDb21wYXJ0bWVudEluc3RhbmNlKVxuICAgICAgICAgICAgICAgIG5ld0NvbXBhcnRtZW50cy5kZWxldGUoZXh0LmNvbXBhcnRtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBzZWVuLnNldChleHQsIHByZWMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleHQpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBlIG9mIGV4dClcbiAgICAgICAgICAgICAgICBpbm5lcihlLCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBDb21wYXJ0bWVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAobmV3Q29tcGFydG1lbnRzLmhhcyhleHQuY29tcGFydG1lbnQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBEdXBsaWNhdGUgdXNlIG9mIGNvbXBhcnRtZW50IGluIGV4dGVuc2lvbnNgKTtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gY29tcGFydG1lbnRzLmdldChleHQuY29tcGFydG1lbnQpIHx8IGV4dC5pbm5lcjtcbiAgICAgICAgICAgIG5ld0NvbXBhcnRtZW50cy5zZXQoZXh0LmNvbXBhcnRtZW50LCBjb250ZW50KTtcbiAgICAgICAgICAgIGlubmVyKGNvbnRlbnQsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIFByZWNFeHRlbnNpb24pIHtcbiAgICAgICAgICAgIGlubmVyKGV4dC5pbm5lciwgZXh0LnByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIFN0YXRlRmllbGQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcmVjXS5wdXNoKGV4dCk7XG4gICAgICAgICAgICBpZiAoZXh0LnByb3ZpZGVzKVxuICAgICAgICAgICAgICAgIGlubmVyKGV4dC5wcm92aWRlcywgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgRmFjZXRQcm92aWRlcikge1xuICAgICAgICAgICAgcmVzdWx0W3ByZWNdLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGlmIChleHQuZmFjZXQuZXh0ZW5zaW9ucylcbiAgICAgICAgICAgICAgICBpbm5lcihleHQuZmFjZXQuZXh0ZW5zaW9ucywgUHJlY18uZGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IGV4dC5leHRlbnNpb247XG4gICAgICAgICAgICBpZiAoIWNvbnRlbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgZXh0ZW5zaW9uIHZhbHVlIGluIGV4dGVuc2lvbiBzZXQgKCR7ZXh0fSkuIFRoaXMgc29tZXRpbWVzIGhhcHBlbnMgYmVjYXVzZSBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgQGNvZGVtaXJyb3Ivc3RhdGUgYXJlIGxvYWRlZCwgYnJlYWtpbmcgaW5zdGFuY2VvZiBjaGVja3MuYCk7XG4gICAgICAgICAgICBpbm5lcihjb250ZW50LCBwcmVjKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbm5lcihleHRlbnNpb24sIFByZWNfLmRlZmF1bHQpO1xuICAgIHJldHVybiByZXN1bHQucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSk7XG59XG5mdW5jdGlvbiBlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKSB7XG4gICAgaWYgKGFkZHIgJiAxKVxuICAgICAgICByZXR1cm4gMiAvKiBTbG90U3RhdHVzLkNvbXB1dGVkICovO1xuICAgIGxldCBpZHggPSBhZGRyID4+IDE7XG4gICAgbGV0IHN0YXR1cyA9IHN0YXRlLnN0YXR1c1tpZHhdO1xuICAgIGlmIChzdGF0dXMgPT0gNCAvKiBTbG90U3RhdHVzLkNvbXB1dGluZyAqLylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGljIGRlcGVuZGVuY3kgYmV0d2VlbiBmaWVsZHMgYW5kL29yIGZhY2V0c1wiKTtcbiAgICBpZiAoc3RhdHVzICYgMiAvKiBTbG90U3RhdHVzLkNvbXB1dGVkICovKVxuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIHN0YXRlLnN0YXR1c1tpZHhdID0gNCAvKiBTbG90U3RhdHVzLkNvbXB1dGluZyAqLztcbiAgICBsZXQgY2hhbmdlZCA9IHN0YXRlLmNvbXB1dGVTbG90KHN0YXRlLCBzdGF0ZS5jb25maWcuZHluYW1pY1Nsb3RzW2lkeF0pO1xuICAgIHJldHVybiBzdGF0ZS5zdGF0dXNbaWR4XSA9IDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLyB8IGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBnZXRBZGRyKHN0YXRlLCBhZGRyKSB7XG4gICAgcmV0dXJuIGFkZHIgJiAxID8gc3RhdGUuY29uZmlnLnN0YXRpY1ZhbHVlc1thZGRyID4+IDFdIDogc3RhdGUudmFsdWVzW2FkZHIgPj4gMV07XG59XG5cbmNvbnN0IGxhbmd1YWdlRGF0YSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHYgPT4gdiksXG4gICAgc3RhdGljOiB0cnVlXG59KTtcbmNvbnN0IGxpbmVTZXBhcmF0b3IgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IHVuZGVmaW5lZCxcbiAgICBzdGF0aWM6IHRydWVcbn0pO1xuY29uc3QgY2hhbmdlRmlsdGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgdHJhbnNhY3Rpb25GaWx0ZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCB0cmFuc2FjdGlvbkV4dGVuZGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgcmVhZE9ubHkgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IGZhbHNlXG59KTtcblxuLyoqXG5Bbm5vdGF0aW9ucyBhcmUgdGFnZ2VkIHZhbHVlcyB0aGF0IGFyZSB1c2VkIHRvIGFkZCBtZXRhZGF0YSB0b1xudHJhbnNhY3Rpb25zIGluIGFuIGV4dGVuc2libGUgd2F5LiBUaGV5IHNob3VsZCBiZSB1c2VkIHRvIG1vZGVsXG50aGluZ3MgdGhhdCBlZmZlY3QgdGhlIGVudGlyZSB0cmFuc2FjdGlvbiAoc3VjaCBhcyBpdHMgW3RpbWVcbnN0YW1wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uXnRpbWUpIG9yIGluZm9ybWF0aW9uIGFib3V0IGl0c1xuW29yaWdpbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl51c2VyRXZlbnQpKS4gRm9yIGVmZmVjdHMgdGhhdCBoYXBwZW5cbl9hbG9uZ3NpZGVfIHRoZSBvdGhlciBjaGFuZ2VzIG1hZGUgYnkgdGhlIHRyYW5zYWN0aW9uLCBbc3RhdGVcbmVmZmVjdHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QpIGFyZSBtb3JlIGFwcHJvcHJpYXRlLlxuKi9cbmNsYXNzIEFubm90YXRpb24ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGFubm90YXRpb24gdHlwZS5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoZSB2YWx1ZSBvZiB0aGlzIGFubm90YXRpb24uXG4gICAgKi9cbiAgICB2YWx1ZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyB0eXBlIG9mIGFubm90YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKCkgeyByZXR1cm4gbmV3IEFubm90YXRpb25UeXBlKCk7IH1cbn1cbi8qKlxuTWFya2VyIHRoYXQgaWRlbnRpZmllcyBhIHR5cGUgb2YgW2Fubm90YXRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQW5ub3RhdGlvbikuXG4qL1xuY2xhc3MgQW5ub3RhdGlvblR5cGUge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGFubm90YXRpb24uXG4gICAgKi9cbiAgICBvZih2YWx1ZSkgeyByZXR1cm4gbmV3IEFubm90YXRpb24odGhpcywgdmFsdWUpOyB9XG59XG4vKipcblJlcHJlc2VudGF0aW9uIG9mIGEgdHlwZSBvZiBzdGF0ZSBlZmZlY3QuIERlZmluZWQgd2l0aFxuW2BTdGF0ZUVmZmVjdC5kZWZpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XmRlZmluZSkuXG4qL1xuY2xhc3MgU3RhdGVFZmZlY3RUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSBgYW55YCB0eXBlcyBpbiB0aGVzZSBmdW5jdGlvbiB0eXBlcyBhcmUgdGhlcmUgdG8gd29ya1xuICAgIC8vIGFyb3VuZCBUeXBlU2NyaXB0IGlzc3VlICMzNzYzMSwgd2hlcmUgdGhlIHR5cGUgZ3VhcmQgb25cbiAgICAvLyBgU3RhdGVFZmZlY3QuaXNgIG15c3RlcmlvdXNseSBzdG9wcyB3b3JraW5nIHdoZW4gdGhlc2UgcHJvcGVybHlcbiAgICAvLyBoYXZlIHR5cGUgYFZhbHVlYC5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hcCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3N0YXRlIGVmZmVjdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdCkgaW5zdGFuY2Ugb2YgdGhpc1xuICAgIHR5cGUuXG4gICAgKi9cbiAgICBvZih2YWx1ZSkgeyByZXR1cm4gbmV3IFN0YXRlRWZmZWN0KHRoaXMsIHZhbHVlKTsgfVxufVxuLyoqXG5TdGF0ZSBlZmZlY3RzIGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCBhZGRpdGlvbmFsIGVmZmVjdHNcbmFzc29jaWF0ZWQgd2l0aCBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5lZmZlY3RzKS4gVGhleVxuYXJlIG9mdGVuIHVzZWZ1bCB0byBtb2RlbCBjaGFuZ2VzIHRvIGN1c3RvbSBbc3RhdGVcbmZpZWxkc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUZpZWxkKSwgd2hlbiB0aG9zZSBjaGFuZ2VzIGFyZW4ndCBpbXBsaWNpdCBpblxuZG9jdW1lbnQgb3Igc2VsZWN0aW9uIGNoYW5nZXMuXG4qL1xuY2xhc3MgU3RhdGVFZmZlY3Qge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgb2YgdGhpcyBlZmZlY3QuXG4gICAgKi9cbiAgICB2YWx1ZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIGVmZmVjdCB0aHJvdWdoIGEgcG9zaXRpb24gbWFwcGluZy4gV2lsbCByZXR1cm5cbiAgICBgdW5kZWZpbmVkYCB3aGVuIHRoYXQgZW5kcyB1cCBkZWxldGluZyB0aGUgZWZmZWN0LlxuICAgICovXG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IG1hcHBlZCA9IHRoaXMudHlwZS5tYXAodGhpcy52YWx1ZSwgbWFwcGluZyk7XG4gICAgICAgIHJldHVybiBtYXBwZWQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG1hcHBlZCA9PSB0aGlzLnZhbHVlID8gdGhpcyA6IG5ldyBTdGF0ZUVmZmVjdCh0aGlzLnR5cGUsIG1hcHBlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoaXMgZWZmZWN0IG9iamVjdCBpcyBvZiBhIGdpdmVuXG4gICAgW3R5cGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3RUeXBlKS5cbiAgICAqL1xuICAgIGlzKHR5cGUpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSB0eXBlOyB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IGVmZmVjdCB0eXBlLiBUaGUgdHlwZSBwYXJhbWV0ZXIgaW5kaWNhdGVzIHRoZSB0eXBlXG4gICAgb2YgdmFsdWVzIHRoYXQgaGlzIGVmZmVjdCBob2xkcy5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlYyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdGVFZmZlY3RUeXBlKHNwZWMubWFwIHx8ICh2ID0+IHYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGFuIGFycmF5IG9mIGVmZmVjdHMgdGhyb3VnaCBhIGNoYW5nZSBzZXQuXG4gICAgKi9cbiAgICBzdGF0aWMgbWFwRWZmZWN0cyhlZmZlY3RzLCBtYXBwaW5nKSB7XG4gICAgICAgIGlmICghZWZmZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZWZmZWN0cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IGVmZmVjdC5tYXAobWFwcGluZyk7XG4gICAgICAgICAgICBpZiAobWFwcGVkKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1hcHBlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcblRoaXMgZWZmZWN0IGNhbiBiZSB1c2VkIHRvIHJlY29uZmlndXJlIHRoZSByb290IGV4dGVuc2lvbnMgb2ZcbnRoZSBlZGl0b3IuIERvaW5nIHRoaXMgd2lsbCBkaXNjYXJkIGFueSBleHRlbnNpb25zXG5bYXBwZW5kZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3ReYXBwZW5kQ29uZmlnKSwgYnV0IGRvZXMgbm90IHJlc2V0XG50aGUgY29udGVudCBvZiBbcmVjb25maWd1cmVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50LnJlY29uZmlndXJlKVxuY29tcGFydG1lbnRzLlxuKi9cblN0YXRlRWZmZWN0LnJlY29uZmlndXJlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5BcHBlbmQgZXh0ZW5zaW9ucyB0byB0aGUgdG9wLWxldmVsIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGVkaXRvci5cbiovXG5TdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vKipcbkNoYW5nZXMgdG8gdGhlIGVkaXRvciBzdGF0ZSBhcmUgZ3JvdXBlZCBpbnRvIHRyYW5zYWN0aW9ucy5cblR5cGljYWxseSwgYSB1c2VyIGFjdGlvbiBjcmVhdGVzIGEgc2luZ2xlIHRyYW5zYWN0aW9uLCB3aGljaCBtYXlcbmNvbnRhaW4gYW55IG51bWJlciBvZiBkb2N1bWVudCBjaGFuZ2VzLCBtYXkgY2hhbmdlIHRoZSBzZWxlY3Rpb24sXG5vciBoYXZlIG90aGVyIGVmZmVjdHMuIENyZWF0ZSBhIHRyYW5zYWN0aW9uIGJ5IGNhbGxpbmdcbltgRWRpdG9yU3RhdGUudXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpLCBvciBpbW1lZGlhdGVseVxuZGlzcGF0Y2ggb25lIGJ5IGNhbGxpbmdcbltgRWRpdG9yVmlldy5kaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKS5cbiovXG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXRlIGZyb20gd2hpY2ggdGhlIHRyYW5zYWN0aW9uIHN0YXJ0cy5cbiAgICAqL1xuICAgIHN0YXJ0U3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSBkb2N1bWVudCBjaGFuZ2VzIG1hZGUgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGNoYW5nZXMsIFxuICAgIC8qKlxuICAgIFRoZSBzZWxlY3Rpb24gc2V0IGJ5IHRoaXMgdHJhbnNhY3Rpb24sIG9yIHVuZGVmaW5lZCBpZiBpdFxuICAgIGRvZXNuJ3QgZXhwbGljaXRseSBzZXQgYSBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzZWxlY3Rpb24sIFxuICAgIC8qKlxuICAgIFRoZSBlZmZlY3RzIGFkZGVkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGVmZmVjdHMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYW5ub3RhdGlvbnMsIFxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgc2Nyb2xsZWQgaW50byB2aWV3IGFmdGVyIHRoaXNcbiAgICB0cmFuc2FjdGlvbiBpcyBkaXNwYXRjaGVkLlxuICAgICovXG4gICAgc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlID0gc3RhcnRTdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMuZWZmZWN0cyA9IGVmZmVjdHM7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3O1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX2RvYyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKVxuICAgICAgICAgICAgY2hlY2tTZWxlY3Rpb24oc2VsZWN0aW9uLCBjaGFuZ2VzLm5ld0xlbmd0aCk7XG4gICAgICAgIGlmICghYW5ub3RhdGlvbnMuc29tZSgoYSkgPT4gYS50eXBlID09IFRyYW5zYWN0aW9uLnRpbWUpKVxuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmNvbmNhdChUcmFuc2FjdGlvbi50aW1lLm9mKERhdGUubm93KCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHN0YXJ0U3RhdGUsIGNoYW5nZXMsIHNlbGVjdGlvbiwgZWZmZWN0cywgYW5ub3RhdGlvbnMsIHNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oc3RhcnRTdGF0ZSwgY2hhbmdlcywgc2VsZWN0aW9uLCBlZmZlY3RzLCBhbm5vdGF0aW9ucywgc2Nyb2xsSW50b1ZpZXcpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbmV3IGRvY3VtZW50IHByb2R1Y2VkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gQ29udHJhcnkgdG9cbiAgICBbYC5zdGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc3RhdGUpYC5kb2NgLCBhY2Nlc3NpbmcgdGhpcyB3b24ndFxuICAgIGZvcmNlIHRoZSBlbnRpcmUgbmV3IHN0YXRlIHRvIGJlIGNvbXB1dGVkIHJpZ2h0IGF3YXksIHNvIGl0IGlzXG4gICAgcmVjb21tZW5kZWQgdGhhdCBbdHJhbnNhY3Rpb25cbiAgICBmaWx0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSB1c2UgdGhpcyBnZXR0ZXJcbiAgICB3aGVuIHRoZXkgbmVlZCB0byBsb29rIGF0IHRoZSBuZXcgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgbmV3RG9jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG9jIHx8ICh0aGlzLl9kb2MgPSB0aGlzLmNoYW5nZXMuYXBwbHkodGhpcy5zdGFydFN0YXRlLmRvYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbmV3IHNlbGVjdGlvbiBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb24uIElmXG4gICAgW2B0aGlzLnNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc2VsZWN0aW9uKSBpcyB1bmRlZmluZWQsXG4gICAgdGhpcyB3aWxsIFttYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU2VsZWN0aW9uLm1hcCkgdGhlIHN0YXJ0IHN0YXRlJ3NcbiAgICBjdXJyZW50IHNlbGVjdGlvbiB0aHJvdWdoIHRoZSBjaGFuZ2VzIG1hZGUgYnkgdGhlIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZ2V0IG5ld1NlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uIHx8IHRoaXMuc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFwKHRoaXMuY2hhbmdlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBuZXcgc3RhdGUgY3JlYXRlZCBieSB0aGUgdHJhbnNhY3Rpb24uIENvbXB1dGVkIG9uIGRlbWFuZFxuICAgIChidXQgcmV0YWluZWQgZm9yIHN1YnNlcXVlbnQgYWNjZXNzKSwgc28gaXQgaXMgcmVjb21tZW5kZWQgbm90IHRvXG4gICAgYWNjZXNzIGl0IGluIFt0cmFuc2FjdGlvblxuICAgIGZpbHRlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpIHdoZW4gcG9zc2libGUuXG4gICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3RhdGUpXG4gICAgICAgICAgICB0aGlzLnN0YXJ0U3RhdGUuYXBwbHlUcmFuc2FjdGlvbih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBhbm5vdGF0aW9uIHR5cGUsIGlmIGFueS5cbiAgICAqL1xuICAgIGFubm90YXRpb24odHlwZSkge1xuICAgICAgICBmb3IgKGxldCBhbm4gb2YgdGhpcy5hbm5vdGF0aW9ucylcbiAgICAgICAgICAgIGlmIChhbm4udHlwZSA9PSB0eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBhbm4udmFsdWU7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0cmFuc2FjdGlvbiBjaGFuZ2VkIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBkb2NDaGFuZ2VkKCkgeyByZXR1cm4gIXRoaXMuY2hhbmdlcy5lbXB0eTsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgdHJhbnNhY3Rpb24gcmVjb25maWd1cmVzIHRoZSBzdGF0ZVxuICAgICh0aHJvdWdoIGEgW2NvbmZpZ3VyYXRpb24gY29tcGFydG1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQpIG9yXG4gICAgd2l0aCBhIHRvcC1sZXZlbCBjb25maWd1cmF0aW9uXG4gICAgW2VmZmVjdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5yZWNvbmZpZ3VyZSkuXG4gICAgKi9cbiAgICBnZXQgcmVjb25maWd1cmVkKCkgeyByZXR1cm4gdGhpcy5zdGFydFN0YXRlLmNvbmZpZyAhPSB0aGlzLnN0YXRlLmNvbmZpZzsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIGEgW3VzZXJcbiAgICBldmVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl51c2VyRXZlbnQpIGFubm90YXRpb24gdGhhdCBpcyBlcXVhbCB0b1xuICAgIG9yIG1vcmUgc3BlY2lmaWMgdGhhbiBgZXZlbnRgLiBGb3IgZXhhbXBsZSwgaWYgdGhlIHRyYW5zYWN0aW9uXG4gICAgaGFzIGBcInNlbGVjdC5wb2ludGVyXCJgIGFzIHVzZXIgZXZlbnQsIGBcInNlbGVjdFwiYCBhbmRcbiAgICBgXCJzZWxlY3QucG9pbnRlclwiYCB3aWxsIG1hdGNoIGl0LlxuICAgICovXG4gICAgaXNVc2VyRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgbGV0IGUgPSB0aGlzLmFubm90YXRpb24oVHJhbnNhY3Rpb24udXNlckV2ZW50KTtcbiAgICAgICAgcmV0dXJuICEhKGUgJiYgKGUgPT0gZXZlbnQgfHwgZS5sZW5ndGggPiBldmVudC5sZW5ndGggJiYgZS5zbGljZSgwLCBldmVudC5sZW5ndGgpID09IGV2ZW50ICYmIGVbZXZlbnQubGVuZ3RoXSA9PSBcIi5cIikpO1xuICAgIH1cbn1cbi8qKlxuQW5ub3RhdGlvbiB1c2VkIHRvIHN0b3JlIHRyYW5zYWN0aW9uIHRpbWVzdGFtcHMuIEF1dG9tYXRpY2FsbHlcbmFkZGVkIHRvIGV2ZXJ5IHRyYW5zYWN0aW9uLCBob2xkaW5nIGBEYXRlLm5vdygpYC5cbiovXG5UcmFuc2FjdGlvbi50aW1lID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkFubm90YXRpb24gdXNlZCB0byBhc3NvY2lhdGUgYSB0cmFuc2FjdGlvbiB3aXRoIGEgdXNlciBpbnRlcmZhY2VcbmV2ZW50LiBIb2xkcyBhIHN0cmluZyBpZGVudGlmeWluZyB0aGUgZXZlbnQsIHVzaW5nIGFcbmRvdC1zZXBhcmF0ZWQgZm9ybWF0IHRvIHN1cHBvcnQgYXR0YWNoaW5nIG1vcmUgc3BlY2lmaWNcbmluZm9ybWF0aW9uLiBUaGUgZXZlbnRzIHVzZWQgYnkgdGhlIGNvcmUgbGlicmFyaWVzIGFyZTpcblxuIC0gYFwiaW5wdXRcImAgd2hlbiBjb250ZW50IGlzIGVudGVyZWRcbiAgIC0gYFwiaW5wdXQudHlwZVwiYCBmb3IgdHlwZWQgaW5wdXRcbiAgICAgLSBgXCJpbnB1dC50eXBlLmNvbXBvc2VcImAgZm9yIGNvbXBvc2l0aW9uXG4gICAtIGBcImlucHV0LnBhc3RlXCJgIGZvciBwYXN0ZWQgaW5wdXRcbiAgIC0gYFwiaW5wdXQuZHJvcFwiYCB3aGVuIGFkZGluZyBjb250ZW50IHdpdGggZHJhZy1hbmQtZHJvcFxuICAgLSBgXCJpbnB1dC5jb21wbGV0ZVwiYCB3aGVuIGF1dG9jb21wbGV0aW5nXG4gLSBgXCJkZWxldGVcImAgd2hlbiB0aGUgdXNlciBkZWxldGVzIGNvbnRlbnRcbiAgIC0gYFwiZGVsZXRlLnNlbGVjdGlvblwiYCB3aGVuIGRlbGV0aW5nIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwiZGVsZXRlLmZvcndhcmRcImAgd2hlbiBkZWxldGluZyBmb3J3YXJkIGZyb20gdGhlIHNlbGVjdGlvblxuICAgLSBgXCJkZWxldGUuYmFja3dhcmRcImAgd2hlbiBkZWxldGluZyBiYWNrd2FyZCBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwiZGVsZXRlLmN1dFwiYCB3aGVuIGN1dHRpbmcgdG8gdGhlIGNsaXBib2FyZFxuIC0gYFwibW92ZVwiYCB3aGVuIGNvbnRlbnQgaXMgbW92ZWRcbiAgIC0gYFwibW92ZS5kcm9wXCJgIHdoZW4gY29udGVudCBpcyBtb3ZlZCB3aXRoaW4gdGhlIGVkaXRvciB0aHJvdWdoIGRyYWctYW5kLWRyb3BcbiAtIGBcInNlbGVjdFwiYCB3aGVuIGV4cGxpY2l0bHkgY2hhbmdpbmcgdGhlIHNlbGVjdGlvblxuICAgLSBgXCJzZWxlY3QucG9pbnRlclwiYCB3aGVuIHNlbGVjdGluZyB3aXRoIGEgbW91c2Ugb3Igb3RoZXIgcG9pbnRpbmcgZGV2aWNlXG4gLSBgXCJ1bmRvXCJgIGFuZCBgXCJyZWRvXCJgIGZvciBoaXN0b3J5IGFjdGlvbnNcblxuVXNlIFtgaXNVc2VyRXZlbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLmlzVXNlckV2ZW50KSB0byBjaGVja1xud2hldGhlciB0aGUgYW5ub3RhdGlvbiBtYXRjaGVzIGEgZ2l2ZW4gZXZlbnQuXG4qL1xuVHJhbnNhY3Rpb24udXNlckV2ZW50ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkFubm90YXRpb24gaW5kaWNhdGluZyB3aGV0aGVyIGEgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIGFkZGVkIHRvXG50aGUgdW5kbyBoaXN0b3J5IG9yIG5vdC5cbiovXG5UcmFuc2FjdGlvbi5hZGRUb0hpc3RvcnkgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuQW5ub3RhdGlvbiBpbmRpY2F0aW5nICh3aGVuIHByZXNlbnQgYW5kIHRydWUpIHRoYXQgYSB0cmFuc2FjdGlvblxucmVwcmVzZW50cyBhIGNoYW5nZSBtYWRlIGJ5IHNvbWUgb3RoZXIgYWN0b3IsIG5vdCB0aGUgdXNlci4gVGhpc1xuaXMgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIHRhZyBvdGhlciBwZW9wbGUncyBjaGFuZ2VzIGluXG5jb2xsYWJvcmF0aXZlIGVkaXRpbmcuXG4qL1xuVHJhbnNhY3Rpb24ucmVtb3RlID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG5mdW5jdGlvbiBqb2luUmFuZ2VzKGEsIGIpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaUEgPSAwLCBpQiA9IDA7Oykge1xuICAgICAgICBsZXQgZnJvbSwgdG87XG4gICAgICAgIGlmIChpQSA8IGEubGVuZ3RoICYmIChpQiA9PSBiLmxlbmd0aCB8fCBiW2lCXSA+PSBhW2lBXSkpIHtcbiAgICAgICAgICAgIGZyb20gPSBhW2lBKytdO1xuICAgICAgICAgICAgdG8gPSBhW2lBKytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlCIDwgYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZyb20gPSBiW2lCKytdO1xuICAgICAgICAgICAgdG8gPSBiW2lCKytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCB8fCByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdIDwgZnJvbSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyb20sIHRvKTtcbiAgICAgICAgZWxzZSBpZiAocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA8IHRvKVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IHRvO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlVHJhbnNhY3Rpb24oYSwgYiwgc2VxdWVudGlhbCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgbWFwRm9yQSwgbWFwRm9yQiwgY2hhbmdlcztcbiAgICBpZiAoc2VxdWVudGlhbCkge1xuICAgICAgICBtYXBGb3JBID0gYi5jaGFuZ2VzO1xuICAgICAgICBtYXBGb3JCID0gQ2hhbmdlU2V0LmVtcHR5KGIuY2hhbmdlcy5sZW5ndGgpO1xuICAgICAgICBjaGFuZ2VzID0gYS5jaGFuZ2VzLmNvbXBvc2UoYi5jaGFuZ2VzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1hcEZvckEgPSBiLmNoYW5nZXMubWFwKGEuY2hhbmdlcyk7XG4gICAgICAgIG1hcEZvckIgPSBhLmNoYW5nZXMubWFwRGVzYyhiLmNoYW5nZXMsIHRydWUpO1xuICAgICAgICBjaGFuZ2VzID0gYS5jaGFuZ2VzLmNvbXBvc2UobWFwRm9yQSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHNlbGVjdGlvbjogYi5zZWxlY3Rpb24gPyBiLnNlbGVjdGlvbi5tYXAobWFwRm9yQikgOiAoX2EgPSBhLnNlbGVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcChtYXBGb3JBKSxcbiAgICAgICAgZWZmZWN0czogU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhhLmVmZmVjdHMsIG1hcEZvckEpLmNvbmNhdChTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGIuZWZmZWN0cywgbWFwRm9yQikpLFxuICAgICAgICBhbm5vdGF0aW9uczogYS5hbm5vdGF0aW9ucy5sZW5ndGggPyBhLmFubm90YXRpb25zLmNvbmNhdChiLmFubm90YXRpb25zKSA6IGIuYW5ub3RhdGlvbnMsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBhLnNjcm9sbEludG9WaWV3IHx8IGIuc2Nyb2xsSW50b1ZpZXdcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWMsIGRvY1NpemUpIHtcbiAgICBsZXQgc2VsID0gc3BlYy5zZWxlY3Rpb24sIGFubm90YXRpb25zID0gYXNBcnJheShzcGVjLmFubm90YXRpb25zKTtcbiAgICBpZiAoc3BlYy51c2VyRXZlbnQpXG4gICAgICAgIGFubm90YXRpb25zID0gYW5ub3RhdGlvbnMuY29uY2F0KFRyYW5zYWN0aW9uLnVzZXJFdmVudC5vZihzcGVjLnVzZXJFdmVudCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNoYW5nZXM6IHNwZWMuY2hhbmdlcyBpbnN0YW5jZW9mIENoYW5nZVNldCA/IHNwZWMuY2hhbmdlc1xuICAgICAgICAgICAgOiBDaGFuZ2VTZXQub2Yoc3BlYy5jaGFuZ2VzIHx8IFtdLCBkb2NTaXplLCBzdGF0ZS5mYWNldChsaW5lU2VwYXJhdG9yKSksXG4gICAgICAgIHNlbGVjdGlvbjogc2VsICYmIChzZWwgaW5zdGFuY2VvZiBFZGl0b3JTZWxlY3Rpb24gPyBzZWwgOiBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKHNlbC5hbmNob3IsIHNlbC5oZWFkKSksXG4gICAgICAgIGVmZmVjdHM6IGFzQXJyYXkoc3BlYy5lZmZlY3RzKSxcbiAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiAhIXNwZWMuc2Nyb2xsSW50b1ZpZXdcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zYWN0aW9uKHN0YXRlLCBzcGVjcywgZmlsdGVyKSB7XG4gICAgbGV0IHMgPSByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlY3MubGVuZ3RoID8gc3BlY3NbMF0gOiB7fSwgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgaWYgKHNwZWNzLmxlbmd0aCAmJiBzcGVjc1swXS5maWx0ZXIgPT09IGZhbHNlKVxuICAgICAgICBmaWx0ZXIgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNwZWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzcGVjc1tpXS5maWx0ZXIgPT09IGZhbHNlKVxuICAgICAgICAgICAgZmlsdGVyID0gZmFsc2U7XG4gICAgICAgIGxldCBzZXEgPSAhIXNwZWNzW2ldLnNlcXVlbnRpYWw7XG4gICAgICAgIHMgPSBtZXJnZVRyYW5zYWN0aW9uKHMsIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjc1tpXSwgc2VxID8gcy5jaGFuZ2VzLm5ld0xlbmd0aCA6IHN0YXRlLmRvYy5sZW5ndGgpLCBzZXEpO1xuICAgIH1cbiAgICBsZXQgdHIgPSBUcmFuc2FjdGlvbi5jcmVhdGUoc3RhdGUsIHMuY2hhbmdlcywgcy5zZWxlY3Rpb24sIHMuZWZmZWN0cywgcy5hbm5vdGF0aW9ucywgcy5zY3JvbGxJbnRvVmlldyk7XG4gICAgcmV0dXJuIGV4dGVuZFRyYW5zYWN0aW9uKGZpbHRlciA/IGZpbHRlclRyYW5zYWN0aW9uKHRyKSA6IHRyKTtcbn1cbi8vIEZpbmlzaCBhIHRyYW5zYWN0aW9uIGJ5IGFwcGx5aW5nIGZpbHRlcnMgaWYgbmVjZXNzYXJ5LlxuZnVuY3Rpb24gZmlsdGVyVHJhbnNhY3Rpb24odHIpIHtcbiAgICBsZXQgc3RhdGUgPSB0ci5zdGFydFN0YXRlO1xuICAgIC8vIENoYW5nZSBmaWx0ZXJzXG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG4gICAgZm9yIChsZXQgZmlsdGVyIG9mIHN0YXRlLmZhY2V0KGNoYW5nZUZpbHRlcikpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZmlsdGVyKHRyKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgPT09IHRydWUgPyB2YWx1ZSA6IGpvaW5SYW5nZXMocmVzdWx0LCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMsIGJhY2s7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBiYWNrID0gdHIuY2hhbmdlcy5pbnZlcnRlZERlc2M7XG4gICAgICAgICAgICBjaGFuZ2VzID0gQ2hhbmdlU2V0LmVtcHR5KHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZpbHRlcmVkID0gdHIuY2hhbmdlcy5maWx0ZXIocmVzdWx0KTtcbiAgICAgICAgICAgIGNoYW5nZXMgPSBmaWx0ZXJlZC5jaGFuZ2VzO1xuICAgICAgICAgICAgYmFjayA9IGZpbHRlcmVkLmZpbHRlcmVkLm1hcERlc2MoZmlsdGVyZWQuY2hhbmdlcykuaW52ZXJ0ZWREZXNjO1xuICAgICAgICB9XG4gICAgICAgIHRyID0gVHJhbnNhY3Rpb24uY3JlYXRlKHN0YXRlLCBjaGFuZ2VzLCB0ci5zZWxlY3Rpb24gJiYgdHIuc2VsZWN0aW9uLm1hcChiYWNrKSwgU3RhdGVFZmZlY3QubWFwRWZmZWN0cyh0ci5lZmZlY3RzLCBiYWNrKSwgdHIuYW5ub3RhdGlvbnMsIHRyLnNjcm9sbEludG9WaWV3KTtcbiAgICB9XG4gICAgLy8gVHJhbnNhY3Rpb24gZmlsdGVyc1xuICAgIGxldCBmaWx0ZXJzID0gc3RhdGUuZmFjZXQodHJhbnNhY3Rpb25GaWx0ZXIpO1xuICAgIGZvciAobGV0IGkgPSBmaWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBmaWx0ZXJlZCA9IGZpbHRlcnNbaV0odHIpO1xuICAgICAgICBpZiAoZmlsdGVyZWQgaW5zdGFuY2VvZiBUcmFuc2FjdGlvbilcbiAgICAgICAgICAgIHRyID0gZmlsdGVyZWQ7XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyZWQpICYmIGZpbHRlcmVkLmxlbmd0aCA9PSAxICYmIGZpbHRlcmVkWzBdIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pXG4gICAgICAgICAgICB0ciA9IGZpbHRlcmVkWzBdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ciA9IHJlc29sdmVUcmFuc2FjdGlvbihzdGF0ZSwgYXNBcnJheShmaWx0ZXJlZCksIGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyO1xufVxuZnVuY3Rpb24gZXh0ZW5kVHJhbnNhY3Rpb24odHIpIHtcbiAgICBsZXQgc3RhdGUgPSB0ci5zdGFydFN0YXRlLCBleHRlbmRlcnMgPSBzdGF0ZS5mYWNldCh0cmFuc2FjdGlvbkV4dGVuZGVyKSwgc3BlYyA9IHRyO1xuICAgIGZvciAobGV0IGkgPSBleHRlbmRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGV4dGVuc2lvbiA9IGV4dGVuZGVyc1tpXSh0cik7XG4gICAgICAgIGlmIChleHRlbnNpb24gJiYgT2JqZWN0LmtleXMoZXh0ZW5zaW9uKS5sZW5ndGgpXG4gICAgICAgICAgICBzcGVjID0gbWVyZ2VUcmFuc2FjdGlvbihzcGVjLCByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgZXh0ZW5zaW9uLCB0ci5jaGFuZ2VzLm5ld0xlbmd0aCksIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gc3BlYyA9PSB0ciA/IHRyIDogVHJhbnNhY3Rpb24uY3JlYXRlKHN0YXRlLCB0ci5jaGFuZ2VzLCB0ci5zZWxlY3Rpb24sIHNwZWMuZWZmZWN0cywgc3BlYy5hbm5vdGF0aW9ucywgc3BlYy5zY3JvbGxJbnRvVmlldyk7XG59XG5jb25zdCBub25lID0gW107XG5mdW5jdGlvbiBhc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBub25lIDogQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG59XG5cbi8qKlxuVGhlIGNhdGVnb3JpZXMgcHJvZHVjZWQgYnkgYSBbY2hhcmFjdGVyXG5jYXRlZ29yaXplcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpLiBUaGVzZSBhcmUgdXNlZFxuZG8gdGhpbmdzIGxpa2Ugc2VsZWN0aW5nIGJ5IHdvcmQuXG4qL1xudmFyIENoYXJDYXRlZ29yeSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENoYXJDYXRlZ29yeSkge1xuICAgIC8qKlxuICAgIFdvcmQgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJXb3JkXCJdID0gMF0gPSBcIldvcmRcIjtcbiAgICAvKipcbiAgICBXaGl0ZXNwYWNlLlxuICAgICovXG4gICAgQ2hhckNhdGVnb3J5W0NoYXJDYXRlZ29yeVtcIlNwYWNlXCJdID0gMV0gPSBcIlNwYWNlXCI7XG4gICAgLyoqXG4gICAgQW55dGhpbmcgZWxzZS5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJPdGhlclwiXSA9IDJdID0gXCJPdGhlclwiO1xucmV0dXJuIENoYXJDYXRlZ29yeX0pKENoYXJDYXRlZ29yeSB8fCAoQ2hhckNhdGVnb3J5ID0ge30pKTtcbmNvbnN0IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyID0gL1tcXHUwMGRmXFx1MDU4N1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTMwNDAtXFx1MzA5ZlxcdTMwYTAtXFx1MzBmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWFjMDAtXFx1ZDdhZl0vO1xubGV0IHdvcmRDaGFyO1xudHJ5IHtcbiAgICB3b3JkQ2hhciA9IC8qQF9fUFVSRV9fKi9uZXcgUmVnRXhwKFwiW1xcXFxwe0FscGhhYmV0aWN9XFxcXHB7TnVtYmVyfV9dXCIsIFwidVwiKTtcbn1cbmNhdGNoIChfKSB7IH1cbmZ1bmN0aW9uIGhhc1dvcmRDaGFyKHN0cikge1xuICAgIGlmICh3b3JkQ2hhcilcbiAgICAgICAgcmV0dXJuIHdvcmRDaGFyLnRlc3Qoc3RyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2ggPSBzdHJbaV07XG4gICAgICAgIGlmICgvXFx3Ly50ZXN0KGNoKSB8fCBjaCA+IFwiXFx4ODBcIiAmJiAoY2gudG9VcHBlckNhc2UoKSAhPSBjaC50b0xvd2VyQ2FzZSgpIHx8IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyLnRlc3QoY2gpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBtYWtlQ2F0ZWdvcml6ZXIod29yZENoYXJzKSB7XG4gICAgcmV0dXJuIChjaGFyKSA9PiB7XG4gICAgICAgIGlmICghL1xcUy8udGVzdChjaGFyKSlcbiAgICAgICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuU3BhY2U7XG4gICAgICAgIGlmIChoYXNXb3JkQ2hhcihjaGFyKSlcbiAgICAgICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuV29yZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQ2hhcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY2hhci5pbmRleE9mKHdvcmRDaGFyc1tpXSkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LldvcmQ7XG4gICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuT3RoZXI7XG4gICAgfTtcbn1cblxuLyoqXG5UaGUgZWRpdG9yIHN0YXRlIGNsYXNzIGlzIGEgcGVyc2lzdGVudCAoaW1tdXRhYmxlKSBkYXRhIHN0cnVjdHVyZS5cblRvIHVwZGF0ZSBhIHN0YXRlLCB5b3UgW2NyZWF0ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpIGFcblt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbiksIHdoaWNoIHByb2R1Y2VzIGEgX25ld18gc3RhdGVcbmluc3RhbmNlLCB3aXRob3V0IG1vZGlmeWluZyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuXG5BcyBzdWNoLCBfbmV2ZXJfIG11dGF0ZSBwcm9wZXJ0aWVzIG9mIGEgc3RhdGUgZGlyZWN0bHkuIFRoYXQnbGxcbmp1c3QgYnJlYWsgdGhpbmdzLlxuKi9cbmNsYXNzIEVkaXRvclN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbmZpZywgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBkb2MsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHNlbGVjdGlvbiwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB2YWx1ZXMsIGNvbXB1dGVTbG90LCB0cikge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBjb25maWcuc3RhdHVzVGVtcGxhdGUuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5jb21wdXRlU2xvdCA9IGNvbXB1dGVTbG90O1xuICAgICAgICAvLyBGaWxsIGluIHRoZSBjb21wdXRlZCBzdGF0ZSBpbW1lZGlhdGVseSwgc28gdGhhdCBmdXJ0aGVyIHF1ZXJpZXNcbiAgICAgICAgLy8gZm9yIGl0IG1hZGUgZHVyaW5nIHRoZSB1cGRhdGUgcmV0dXJuIHRoaXMgc3RhdGVcbiAgICAgICAgaWYgKHRyKVxuICAgICAgICAgICAgdHIuX3N0YXRlID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZy5keW5hbWljU2xvdHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBlbnN1cmVBZGRyKHRoaXMsIGkgPDwgMSk7XG4gICAgICAgIHRoaXMuY29tcHV0ZVNsb3QgPSBudWxsO1xuICAgIH1cbiAgICBmaWVsZChmaWVsZCwgcmVxdWlyZSA9IHRydWUpIHtcbiAgICAgICAgbGV0IGFkZHIgPSB0aGlzLmNvbmZpZy5hZGRyZXNzW2ZpZWxkLmlkXTtcbiAgICAgICAgaWYgKGFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJlcXVpcmUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJGaWVsZCBpcyBub3QgcHJlc2VudCBpbiB0aGlzIHN0YXRlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVBZGRyKHRoaXMsIGFkZHIpO1xuICAgICAgICByZXR1cm4gZ2V0QWRkcih0aGlzLCBhZGRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3RyYW5zYWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uKSB0aGF0IHVwZGF0ZXMgdGhpc1xuICAgIHN0YXRlLiBBbnkgbnVtYmVyIG9mIFt0cmFuc2FjdGlvbiBzcGVjc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMpXG4gICAgY2FuIGJlIHBhc3NlZC4gVW5sZXNzXG4gICAgW2BzZXF1ZW50aWFsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VxdWVudGlhbCkgaXMgc2V0LCB0aGVcbiAgICBbY2hhbmdlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuY2hhbmdlcykgKGlmIGFueSkgb2YgZWFjaCBzcGVjXG4gICAgYXJlIGFzc3VtZWQgdG8gc3RhcnQgaW4gdGhlIF9jdXJyZW50XyBkb2N1bWVudCAobm90IHRoZSBkb2N1bWVudFxuICAgIHByb2R1Y2VkIGJ5IHByZXZpb3VzIHNwZWNzKSwgYW5kIGl0c1xuICAgIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbikgYW5kXG4gICAgW2VmZmVjdHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIGFyZSBhc3N1bWVkIHRvIHJlZmVyXG4gICAgdG8gdGhlIGRvY3VtZW50IGNyZWF0ZWQgYnkgaXRzIF9vd25fIGNoYW5nZXMuIFRoZSByZXN1bHRpbmdcbiAgICB0cmFuc2FjdGlvbiBjb250YWlucyB0aGUgY29tYmluZWQgZWZmZWN0IG9mIGFsbCB0aGUgZGlmZmVyZW50XG4gICAgc3BlY3MuIEZvciBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZWxlY3Rpb24pLCBsYXRlclxuICAgIHNwZWNzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGVhcmxpZXIgb25lcy5cbiAgICAqL1xuICAgIHVwZGF0ZSguLi5zcGVjcykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZVRyYW5zYWN0aW9uKHRoaXMsIHNwZWNzLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhcHBseVRyYW5zYWN0aW9uKHRyKSB7XG4gICAgICAgIGxldCBjb25mID0gdGhpcy5jb25maWcsIHsgYmFzZSwgY29tcGFydG1lbnRzIH0gPSBjb25mO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhDb21wYXJ0bWVudC5yZWNvbmZpZ3VyZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZikge1xuICAgICAgICAgICAgICAgICAgICBjb21wYXJ0bWVudHMgPSBuZXcgTWFwO1xuICAgICAgICAgICAgICAgICAgICBjb25mLmNvbXBhcnRtZW50cy5mb3JFYWNoKCh2YWwsIGtleSkgPT4gY29tcGFydG1lbnRzLnNldChrZXksIHZhbCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tcGFydG1lbnRzLnNldChlZmZlY3QudmFsdWUuY29tcGFydG1lbnQsIGVmZmVjdC52YWx1ZS5leHRlbnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKFN0YXRlRWZmZWN0LnJlY29uZmlndXJlKSkge1xuICAgICAgICAgICAgICAgIGNvbmYgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJhc2UgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbmYgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJhc2UgPSBhc0FycmF5KGJhc2UpLmNvbmNhdChlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydFZhbHVlcztcbiAgICAgICAgaWYgKCFjb25mKSB7XG4gICAgICAgICAgICBjb25mID0gQ29uZmlndXJhdGlvbi5yZXNvbHZlKGJhc2UsIGNvbXBhcnRtZW50cywgdGhpcyk7XG4gICAgICAgICAgICBsZXQgaW50ZXJtZWRpYXRlU3RhdGUgPSBuZXcgRWRpdG9yU3RhdGUoY29uZiwgdGhpcy5kb2MsIHRoaXMuc2VsZWN0aW9uLCBjb25mLmR5bmFtaWNTbG90cy5tYXAoKCkgPT4gbnVsbCksIChzdGF0ZSwgc2xvdCkgPT4gc2xvdC5yZWNvbmZpZ3VyZShzdGF0ZSwgdGhpcyksIG51bGwpO1xuICAgICAgICAgICAgc3RhcnRWYWx1ZXMgPSBpbnRlcm1lZGlhdGVTdGF0ZS52YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydFZhbHVlcyA9IHRyLnN0YXJ0U3RhdGUudmFsdWVzLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3IEVkaXRvclN0YXRlKGNvbmYsIHRyLm5ld0RvYywgdHIubmV3U2VsZWN0aW9uLCBzdGFydFZhbHVlcywgKHN0YXRlLCBzbG90KSA9PiBzbG90LnVwZGF0ZShzdGF0ZSwgdHIpLCB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFt0cmFuc2FjdGlvbiBzcGVjXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYykgdGhhdFxuICAgIHJlcGxhY2VzIGV2ZXJ5IHNlbGVjdGlvbiByYW5nZSB3aXRoIHRoZSBnaXZlbiBjb250ZW50LlxuICAgICovXG4gICAgcmVwbGFjZVNlbGVjdGlvbih0ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGV4dCA9IHRoaXMudG9UZXh0KHRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+ICh7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IHRleHQgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyB0ZXh0Lmxlbmd0aCkgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgY2hhbmdlcyBhbmQgYSBuZXcgc2VsZWN0aW9uIGJ5IHJ1bm5pbmcgdGhlIGdpdmVuXG4gICAgZnVuY3Rpb24gZm9yIGVhY2ggcmFuZ2UgaW4gdGhlIGFjdGl2ZSBzZWxlY3Rpb24uIFRoZSBmdW5jdGlvblxuICAgIGNhbiByZXR1cm4gYW4gb3B0aW9uYWwgc2V0IG9mIGNoYW5nZXMgKGluIHRoZSBjb29yZGluYXRlIHNwYWNlXG4gICAgb2YgdGhlIHN0YXJ0IGRvY3VtZW50KSwgcGx1cyBhbiB1cGRhdGVkIHJhbmdlIChpbiB0aGUgY29vcmRpbmF0ZVxuICAgIHNwYWNlIG9mIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgY2FsbCdzIG93biBjaGFuZ2VzKS4gVGhpc1xuICAgIG1ldGhvZCB3aWxsIG1lcmdlIGFsbCB0aGUgY2hhbmdlcyBhbmQgcmFuZ2VzIGludG8gYSBzaW5nbGVcbiAgICBjaGFuZ2VzZXQgYW5kIHNlbGVjdGlvbiwgYW5kIHJldHVybiBpdCBhcyBhIFt0cmFuc2FjdGlvblxuICAgIHNwZWNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKSwgd2hpY2ggY2FuIGJlIHBhc3NlZCB0b1xuICAgIFtgdXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpLlxuICAgICovXG4gICAgY2hhbmdlQnlSYW5nZShmKSB7XG4gICAgICAgIGxldCBzZWwgPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJlc3VsdDEgPSBmKHNlbC5yYW5nZXNbMF0pO1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHRoaXMuY2hhbmdlcyhyZXN1bHQxLmNoYW5nZXMpLCByYW5nZXMgPSBbcmVzdWx0MS5yYW5nZV07XG4gICAgICAgIGxldCBlZmZlY3RzID0gYXNBcnJheShyZXN1bHQxLmVmZmVjdHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBmKHNlbC5yYW5nZXNbaV0pO1xuICAgICAgICAgICAgbGV0IG5ld0NoYW5nZXMgPSB0aGlzLmNoYW5nZXMocmVzdWx0LmNoYW5nZXMpLCBuZXdNYXBwZWQgPSBuZXdDaGFuZ2VzLm1hcChjaGFuZ2VzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaTsgaisrKVxuICAgICAgICAgICAgICAgIHJhbmdlc1tqXSA9IHJhbmdlc1tqXS5tYXAobmV3TWFwcGVkKTtcbiAgICAgICAgICAgIGxldCBtYXBCeSA9IGNoYW5nZXMubWFwRGVzYyhuZXdDaGFuZ2VzLCB0cnVlKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJlc3VsdC5yYW5nZS5tYXAobWFwQnkpKTtcbiAgICAgICAgICAgIGNoYW5nZXMgPSBjaGFuZ2VzLmNvbXBvc2UobmV3TWFwcGVkKTtcbiAgICAgICAgICAgIGVmZmVjdHMgPSBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGVmZmVjdHMsIG5ld01hcHBlZCkuY29uY2F0KFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYXNBcnJheShyZXN1bHQuZWZmZWN0cyksIG1hcEJ5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXMsXG4gICAgICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzZWwubWFpbkluZGV4KSxcbiAgICAgICAgICAgIGVmZmVjdHNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW2NoYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0KSBmcm9tIHRoZSBnaXZlbiBjaGFuZ2VcbiAgICBkZXNjcmlwdGlvbiwgdGFraW5nIHRoZSBzdGF0ZSdzIGRvY3VtZW50IGxlbmd0aCBhbmQgbGluZVxuICAgIHNlcGFyYXRvciBpbnRvIGFjY291bnQuXG4gICAgKi9cbiAgICBjaGFuZ2VzKHNwZWMgPSBbXSkge1xuICAgICAgICBpZiAoc3BlYyBpbnN0YW5jZW9mIENoYW5nZVNldClcbiAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICByZXR1cm4gQ2hhbmdlU2V0Lm9mKHNwZWMsIHRoaXMuZG9jLmxlbmd0aCwgdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVzaW5nIHRoZSBzdGF0ZSdzIFtsaW5lXG4gICAgc2VwYXJhdG9yXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxpbmVTZXBhcmF0b3IpLCBjcmVhdGUgYVxuICAgIFtgVGV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dCkgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgdG9UZXh0KHN0cmluZykge1xuICAgICAgICByZXR1cm4gVGV4dC5vZihzdHJpbmcuc3BsaXQodGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBEZWZhdWx0U3BsaXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSBnaXZlbiByYW5nZSBvZiB0aGUgZG9jdW1lbnQgYXMgYSBzdHJpbmcuXG4gICAgKi9cbiAgICBzbGljZURvYyhmcm9tID0gMCwgdG8gPSB0aGlzLmRvYy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvLCB0aGlzLmxpbmVCcmVhayk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgYSBzdGF0ZSBbZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRmFjZXQpLlxuICAgICovXG4gICAgZmFjZXQoZmFjZXQpIHtcbiAgICAgICAgbGV0IGFkZHIgPSB0aGlzLmNvbmZpZy5hZGRyZXNzW2ZhY2V0LmlkXTtcbiAgICAgICAgaWYgKGFkZHIgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWNldC5kZWZhdWx0O1xuICAgICAgICBlbnN1cmVBZGRyKHRoaXMsIGFkZHIpO1xuICAgICAgICByZXR1cm4gZ2V0QWRkcih0aGlzLCBhZGRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGlzIHN0YXRlIHRvIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0LiBXaGVuIGN1c3RvbVxuICAgIGZpZWxkcyBzaG91bGQgYmUgc2VyaWFsaXplZCwgeW91IGNhbiBwYXNzIHRoZW0gaW4gYXMgYW4gb2JqZWN0XG4gICAgbWFwcGluZyBwcm9wZXJ0eSBuYW1lcyAoaW4gdGhlIHJlc3VsdGluZyBvYmplY3QsIHdoaWNoIHNob3VsZFxuICAgIG5vdCB1c2UgYGRvY2Agb3IgYHNlbGVjdGlvbmApIHRvIGZpZWxkcy5cbiAgICAqL1xuICAgIHRvSlNPTihmaWVsZHMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGRvYzogdGhpcy5zbGljZURvYygpLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiB0aGlzLnNlbGVjdGlvbi50b0pTT04oKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZmllbGRzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBmaWVsZHNbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RhdGVGaWVsZCAmJiB0aGlzLmNvbmZpZy5hZGRyZXNzW3ZhbHVlLmlkXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSB2YWx1ZS5zcGVjLnRvSlNPTih0aGlzLmZpZWxkKGZpZWxkc1twcm9wXSksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHN0YXRlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFdoZW4gY3VzdG9tXG4gICAgZmllbGRzIHNob3VsZCBiZSBkZXNlcmlhbGl6ZWQsIHBhc3MgdGhlIHNhbWUgb2JqZWN0IHlvdSBwYXNzZWRcbiAgICB0byBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudG9KU09OKSB3aGVuIHNlcmlhbGl6aW5nIGFzXG4gICAgdGhpcmQgYXJndW1lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbiwgY29uZmlnID0ge30sIGZpZWxkcykge1xuICAgICAgICBpZiAoIWpzb24gfHwgdHlwZW9mIGpzb24uZG9jICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgRWRpdG9yU3RhdGVcIik7XG4gICAgICAgIGxldCBmaWVsZEluaXQgPSBbXTtcbiAgICAgICAgaWYgKGZpZWxkcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChqc29uLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmllbGQgPSBmaWVsZHNbcHJvcF0sIHZhbHVlID0ganNvbltwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbml0LnB1c2goZmllbGQuaW5pdChzdGF0ZSA9PiBmaWVsZC5zcGVjLmZyb21KU09OKHZhbHVlLCBzdGF0ZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgICAgICAgICAgZG9jOiBqc29uLmRvYyxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmZyb21KU09OKGpzb24uc2VsZWN0aW9uKSxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IGNvbmZpZy5leHRlbnNpb25zID8gZmllbGRJbml0LmNvbmNhdChbY29uZmlnLmV4dGVuc2lvbnNdKSA6IGZpZWxkSW5pdFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHN0YXRlLiBZb3UnbGwgdXN1YWxseSBvbmx5IG5lZWQgdGhpcyB3aGVuXG4gICAgaW5pdGlhbGl6aW5nIGFuIGVkaXRvclx1MjAxNHVwZGF0ZWQgc3RhdGVzIGFyZSBjcmVhdGVkIGJ5IGFwcGx5aW5nXG4gICAgdHJhbnNhY3Rpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcgPSB7fSkge1xuICAgICAgICBsZXQgY29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb24ucmVzb2x2ZShjb25maWcuZXh0ZW5zaW9ucyB8fCBbXSwgbmV3IE1hcCk7XG4gICAgICAgIGxldCBkb2MgPSBjb25maWcuZG9jIGluc3RhbmNlb2YgVGV4dCA/IGNvbmZpZy5kb2NcbiAgICAgICAgICAgIDogVGV4dC5vZigoY29uZmlnLmRvYyB8fCBcIlwiKS5zcGxpdChjb25maWd1cmF0aW9uLnN0YXRpY0ZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpIHx8IERlZmF1bHRTcGxpdCkpO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gIWNvbmZpZy5zZWxlY3Rpb24gPyBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKDApXG4gICAgICAgICAgICA6IGNvbmZpZy5zZWxlY3Rpb24gaW5zdGFuY2VvZiBFZGl0b3JTZWxlY3Rpb24gPyBjb25maWcuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgOiBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGNvbmZpZy5zZWxlY3Rpb24uYW5jaG9yLCBjb25maWcuc2VsZWN0aW9uLmhlYWQpO1xuICAgICAgICBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGRvYy5sZW5ndGgpO1xuICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb24uc3RhdGljRmFjZXQoYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpKVxuICAgICAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLmFzU2luZ2xlKCk7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU3RhdGUoY29uZmlndXJhdGlvbiwgZG9jLCBzZWxlY3Rpb24sIGNvbmZpZ3VyYXRpb24uZHluYW1pY1Nsb3RzLm1hcCgoKSA9PiBudWxsKSwgKHN0YXRlLCBzbG90KSA9PiBzbG90LmNyZWF0ZShzdGF0ZSksIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2l6ZSAoaW4gY29sdW1ucykgb2YgYSB0YWIgaW4gdGhlIGRvY3VtZW50LCBkZXRlcm1pbmVkIGJ5XG4gICAgdGhlIFtgdGFiU2l6ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSkgZmFjZXQuXG4gICAgKi9cbiAgICBnZXQgdGFiU2l6ZSgpIHsgcmV0dXJuIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUudGFiU2l6ZSk7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHByb3BlciBbbGluZS1icmVha10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5saW5lU2VwYXJhdG9yKVxuICAgIHN0cmluZyBmb3IgdGhpcyBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBsaW5lQnJlYWsoKSB7IHJldHVybiB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpIHx8IFwiXFxuXCI7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZWRpdG9yIGlzXG4gICAgW2NvbmZpZ3VyZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVecmVhZE9ubHkpIHRvIGJlIHJlYWQtb25seS5cbiAgICAqL1xuICAgIGdldCByZWFkT25seSgpIHsgcmV0dXJuIHRoaXMuZmFjZXQocmVhZE9ubHkpOyB9XG4gICAgLyoqXG4gICAgTG9vayB1cCBhIHRyYW5zbGF0aW9uIGZvciB0aGUgZ2l2ZW4gcGhyYXNlICh2aWEgdGhlXG4gICAgW2BwaHJhc2VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5waHJhc2VzKSBmYWNldCksIG9yIHJldHVybiB0aGVcbiAgICBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdHJhbnNsYXRpb24gaXMgZm91bmQuXG4gICAgXG4gICAgSWYgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHBhc3NlZCwgdGhleSB3aWxsIGJlIGluc2VydGVkIGluXG4gICAgcGxhY2Ugb2YgbWFya2VycyBsaWtlIGAkMWAgKGZvciB0aGUgZmlyc3QgdmFsdWUpIGFuZCBgJDJgLCBldGMuXG4gICAgQSBzaW5nbGUgYCRgIGlzIGVxdWl2YWxlbnQgdG8gYCQxYCwgYW5kIGAkJGAgd2lsbCBwcm9kdWNlIGFcbiAgICBsaXRlcmFsIGRvbGxhciBzaWduLlxuICAgICovXG4gICAgcGhyYXNlKHBocmFzZSwgLi4uaW5zZXJ0KSB7XG4gICAgICAgIGZvciAobGV0IG1hcCBvZiB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLnBocmFzZXMpKVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIHBocmFzZSkpIHtcbiAgICAgICAgICAgICAgICBwaHJhc2UgPSBtYXBbcGhyYXNlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGluc2VydC5sZW5ndGgpXG4gICAgICAgICAgICBwaHJhc2UgPSBwaHJhc2UucmVwbGFjZSgvXFwkKFxcJHxcXGQqKS9nLCAobSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpID09IFwiJFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgICAgICAgICAgbGV0IG4gPSArKGkgfHwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFuIHx8IG4gPiBpbnNlcnQubGVuZ3RoID8gbSA6IGluc2VydFtuIC0gMV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBocmFzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgdmFsdWVzIGZvciBhIGdpdmVuIGxhbmd1YWdlIGRhdGEgZmllbGQsIHByb3ZpZGVkIGJ5IHRoZVxuICAgIHRoZSBbYGxhbmd1YWdlRGF0YWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGFuZ3VhZ2VEYXRhKSBmYWNldC5cbiAgICBcbiAgICBFeGFtcGxlcyBvZiBsYW5ndWFnZSBkYXRhIGZpZWxkcyBhcmUuLi5cbiAgICBcbiAgICAtIFtgXCJjb21tZW50VG9rZW5zXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIGZvciBzcGVjaWZ5aW5nXG4gICAgICBjb21tZW50IHN5bnRheC5cbiAgICAtIFtgXCJhdXRvY29tcGxldGVcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmF1dG9jb21wbGV0aW9uXmNvbmZpZy5vdmVycmlkZSlcbiAgICAgIGZvciBwcm92aWRpbmcgbGFuZ3VhZ2Utc3BlY2lmaWMgY29tcGxldGlvbiBzb3VyY2VzLlxuICAgIC0gW2BcIndvcmRDaGFyc1wiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpIGZvciBhZGRpbmdcbiAgICAgIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgYmUgY29uc2lkZXJlZCBwYXJ0IG9mIHdvcmRzIGluIHRoaXNcbiAgICAgIGxhbmd1YWdlLlxuICAgIC0gW2BcImNsb3NlQnJhY2tldHNcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNsb3NlQnJhY2tldENvbmZpZykgY29udHJvbHNcbiAgICAgIGJyYWNrZXQgY2xvc2luZyBiZWhhdmlvci5cbiAgICAqL1xuICAgIGxhbmd1YWdlRGF0YUF0KG5hbWUsIHBvcywgc2lkZSA9IC0xKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcHJvdmlkZXIgb2YgdGhpcy5mYWNldChsYW5ndWFnZURhdGEpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCByZXN1bHQgb2YgcHJvdmlkZXIodGhpcywgcG9zLCBzaWRlKSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocmVzdWx0W25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBjYXRlZ29yaXplIHN0cmluZ3MgKGV4cGVjdGVkIHRvXG4gICAgcmVwcmVzZW50IGEgc2luZ2xlIFtncmFwaGVtZSBjbHVzdGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLmZpbmRDbHVzdGVyQnJlYWspKVxuICAgIGludG8gb25lIG9mOlxuICAgIFxuICAgICAtIFdvcmQgKGNvbnRhaW5zIGFuIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXIgb3IgYSBjaGFyYWN0ZXJcbiAgICAgICBleHBsaWNpdGx5IGxpc3RlZCBpbiB0aGUgbG9jYWwgbGFuZ3VhZ2UncyBgXCJ3b3JkQ2hhcnNcImBcbiAgICAgICBsYW5ndWFnZSBkYXRhLCB3aGljaCBzaG91bGQgYmUgYSBzdHJpbmcpXG4gICAgIC0gU3BhY2UgKGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZSlcbiAgICAgLSBPdGhlciAoYW55dGhpbmcgZWxzZSlcbiAgICAqL1xuICAgIGNoYXJDYXRlZ29yaXplcihhdCkge1xuICAgICAgICByZXR1cm4gbWFrZUNhdGVnb3JpemVyKHRoaXMubGFuZ3VhZ2VEYXRhQXQoXCJ3b3JkQ2hhcnNcIiwgYXQpLmpvaW4oXCJcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB3b3JkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgbWVhbmluZyB0aGUgcmFuZ2VcbiAgICBjb250YWluaW5nIGFsbCBbd29yZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCkgY2hhcmFjdGVyc1xuICAgIGFyb3VuZCBpdC4gSWYgbm8gd29yZCBjaGFyYWN0ZXJzIGFyZSBhZGphY2VudCB0byB0aGUgcG9zaXRpb24sXG4gICAgdGhpcyByZXR1cm5zIG51bGwuXG4gICAgKi9cbiAgICB3b3JkQXQocG9zKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20sIGxlbmd0aCB9ID0gdGhpcy5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCBjYXQgPSB0aGlzLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgICAgICBsZXQgc3RhcnQgPSBwb3MgLSBmcm9tLCBlbmQgPSBwb3MgLSBmcm9tO1xuICAgICAgICB3aGlsZSAoc3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGZpbmRDbHVzdGVyQnJlYWsodGV4dCwgc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChjYXQodGV4dC5zbGljZShwcmV2LCBzdGFydCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RhcnQgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChlbmQgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayh0ZXh0LCBlbmQpO1xuICAgICAgICAgICAgaWYgKGNhdCh0ZXh0LnNsaWNlKGVuZCwgbmV4dCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZW5kID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnQgPT0gZW5kID8gbnVsbCA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShzdGFydCArIGZyb20sIGVuZCArIGZyb20pO1xuICAgIH1cbn1cbi8qKlxuQSBmYWNldCB0aGF0LCB3aGVuIGVuYWJsZWQsIGNhdXNlcyB0aGUgZWRpdG9yIHRvIGFsbG93IG11bHRpcGxlXG5yYW5nZXMgdG8gYmUgc2VsZWN0ZWQuIEJlIGNhcmVmdWwgdGhvdWdoLCBiZWNhdXNlIGJ5IGRlZmF1bHQgdGhlXG5lZGl0b3IgcmVsaWVzIG9uIHRoZSBuYXRpdmUgRE9NIHNlbGVjdGlvbiwgd2hpY2ggY2Fubm90IGhhbmRsZVxubXVsdGlwbGUgc2VsZWN0aW9ucy4gQW4gZXh0ZW5zaW9uIGxpa2VcbltgZHJhd1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5kcmF3U2VsZWN0aW9uKSBjYW4gYmUgdXNlZCB0byBtYWtlXG5zZWNvbmRhcnkgc2VsZWN0aW9ucyB2aXNpYmxlIHRvIHRoZSB1c2VyLlxuKi9cbkVkaXRvclN0YXRlLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zID0gYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnM7XG4vKipcbkNvbmZpZ3VyZXMgdGhlIHRhYiBzaXplIHRvIHVzZSBpbiB0aGlzIHN0YXRlLiBUaGUgZmlyc3RcbihoaWdoZXN0LXByZWNlZGVuY2UpIHZhbHVlIG9mIHRoZSBmYWNldCBpcyB1c2VkLiBJZiBubyB2YWx1ZSBpc1xuZ2l2ZW4sIHRoaXMgZGVmYXVsdHMgdG8gNC5cbiovXG5FZGl0b3JTdGF0ZS50YWJTaXplID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiA0XG59KTtcbi8qKlxuVGhlIGxpbmUgc2VwYXJhdG9yIHRvIHVzZS4gQnkgZGVmYXVsdCwgYW55IG9mIGBcIlxcblwiYCwgYFwiXFxyXFxuXCJgXG5hbmQgYFwiXFxyXCJgIGlzIHRyZWF0ZWQgYXMgYSBzZXBhcmF0b3Igd2hlbiBzcGxpdHRpbmcgbGluZXMsIGFuZFxubGluZXMgYXJlIGpvaW5lZCB3aXRoIGBcIlxcblwiYC5cblxuV2hlbiB5b3UgY29uZmlndXJlIGEgdmFsdWUgaGVyZSwgb25seSB0aGF0IHByZWNpc2Ugc2VwYXJhdG9yXG53aWxsIGJlIHVzZWQsIGFsbG93aW5nIHlvdSB0byByb3VuZC10cmlwIGRvY3VtZW50cyB0aHJvdWdoIHRoZVxuZWRpdG9yIHdpdGhvdXQgbm9ybWFsaXppbmcgbGluZSBzZXBhcmF0b3JzLlxuKi9cbkVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IgPSBsaW5lU2VwYXJhdG9yO1xuLyoqXG5UaGlzIGZhY2V0IGNvbnRyb2xzIHRoZSB2YWx1ZSBvZiB0aGVcbltgcmVhZE9ubHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnJlYWRPbmx5KSBnZXR0ZXIsIHdoaWNoIGlzXG5jb25zdWx0ZWQgYnkgY29tbWFuZHMgYW5kIGV4dGVuc2lvbnMgdGhhdCBpbXBsZW1lbnQgZWRpdGluZ1xuZnVuY3Rpb25hbGl0eSB0byBkZXRlcm1pbmUgd2hldGhlciB0aGV5IHNob3VsZCBhcHBseS4gSXRcbmRlZmF1bHRzIHRvIGZhbHNlLCBidXQgd2hlbiBpdHMgaGlnaGVzdC1wcmVjZWRlbmNlIHZhbHVlIGlzXG5gdHJ1ZWAsIHN1Y2ggZnVuY3Rpb25hbGl0eSBkaXNhYmxlcyBpdHNlbGYuXG5cbk5vdCB0byBiZSBjb25mdXNlZCB3aXRoXG5bYEVkaXRvclZpZXcuZWRpdGFibGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15lZGl0YWJsZSksIHdoaWNoXG5jb250cm9scyB3aGV0aGVyIHRoZSBlZGl0b3IncyBET00gaXMgc2V0IHRvIGJlIGVkaXRhYmxlIChhbmRcbnRodXMgZm9jdXNhYmxlKS5cbiovXG5FZGl0b3JTdGF0ZS5yZWFkT25seSA9IHJlYWRPbmx5O1xuLyoqXG5SZWdpc3RlcnMgdHJhbnNsYXRpb24gcGhyYXNlcy4gVGhlXG5bYHBocmFzZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucGhyYXNlKSBtZXRob2Qgd2lsbCBsb29rIHRocm91Z2hcbmFsbCBvYmplY3RzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGZhY2V0IHRvIGZpbmQgdHJhbnNsYXRpb25zIGZvclxuaXRzIGFyZ3VtZW50LlxuKi9cbkVkaXRvclN0YXRlLnBocmFzZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21wYXJlKGEsIGIpIHtcbiAgICAgICAgbGV0IGtBID0gT2JqZWN0LmtleXMoYSksIGtCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrQS5sZW5ndGggPT0ga0IubGVuZ3RoICYmIGtBLmV2ZXJ5KGsgPT4gYVtrXSA9PSBiW2tdKTtcbiAgICB9XG59KTtcbi8qKlxuQSBmYWNldCB1c2VkIHRvIHJlZ2lzdGVyIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkgcHJvdmlkZXJzLlxuKi9cbkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YSA9IGxhbmd1YWdlRGF0YTtcbi8qKlxuRmFjZXQgdXNlZCB0byByZWdpc3RlciBjaGFuZ2UgZmlsdGVycywgd2hpY2ggYXJlIGNhbGxlZCBmb3IgZWFjaFxudHJhbnNhY3Rpb24gKHVubGVzcyBleHBsaWNpdGx5XG5bZGlzYWJsZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmZpbHRlcikpLCBhbmQgY2FuIHN1cHByZXNzXG5wYXJ0IG9mIHRoZSB0cmFuc2FjdGlvbidzIGNoYW5nZXMuXG5cblN1Y2ggYSBmdW5jdGlvbiBjYW4gcmV0dXJuIGB0cnVlYCB0byBpbmRpY2F0ZSB0aGF0IGl0IGRvZXNuJ3RcbndhbnQgdG8gZG8gYW55dGhpbmcsIGBmYWxzZWAgdG8gY29tcGxldGVseSBzdG9wIHRoZSBjaGFuZ2VzIGluXG50aGUgdHJhbnNhY3Rpb24sIG9yIGEgc2V0IG9mIHJhbmdlcyBpbiB3aGljaCBjaGFuZ2VzIHNob3VsZCBiZVxuc3VwcHJlc3NlZC4gU3VjaCByYW5nZXMgYXJlIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIG51bWJlcnMsXG53aXRoIGVhY2ggcGFpciBvZiB0d28gbnVtYmVycyBpbmRpY2F0aW5nIHRoZSBzdGFydCBhbmQgZW5kIG9mIGFcbnJhbmdlLiBTbyBmb3IgZXhhbXBsZSBgWzEwLCAyMCwgMTAwLCAxMTBdYCBzdXBwcmVzc2VzIGNoYW5nZXNcbmJldHdlZW4gMTAgYW5kIDIwLCBhbmQgYmV0d2VlbiAxMDAgYW5kIDExMC5cbiovXG5FZGl0b3JTdGF0ZS5jaGFuZ2VGaWx0ZXIgPSBjaGFuZ2VGaWx0ZXI7XG4vKipcbkZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgYSBob29rIHRoYXQgZ2V0cyBhIGNoYW5jZSB0byB1cGRhdGUgb3JcbnJlcGxhY2UgdHJhbnNhY3Rpb24gc3BlY3MgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQuIFRoaXMgd2lsbFxub25seSBiZSBhcHBsaWVkIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBkb24ndCBoYXZlXG5bYGZpbHRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmZpbHRlcikgc2V0IHRvIGBmYWxzZWAuIFlvdVxuY2FuIGVpdGhlciByZXR1cm4gYSBzaW5nbGUgdHJhbnNhY3Rpb24gc3BlYyAocG9zc2libHkgdGhlIGlucHV0XG50cmFuc2FjdGlvbiksIG9yIGFuIGFycmF5IG9mIHNwZWNzICh3aGljaCB3aWxsIGJlIGNvbWJpbmVkIGluXG50aGUgc2FtZSB3YXkgYXMgdGhlIGFyZ3VtZW50cyB0b1xuW2BFZGl0b3JTdGF0ZS51cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSkpLlxuXG5XaGVuIHBvc3NpYmxlLCBpdCBpcyByZWNvbW1lbmRlZCB0byBhdm9pZCBhY2Nlc3NpbmdcbltgVHJhbnNhY3Rpb24uc3RhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnN0YXRlKSBpbiBhIGZpbHRlcixcbnNpbmNlIGl0IHdpbGwgZm9yY2UgY3JlYXRpb24gb2YgYSBzdGF0ZSB0aGF0IHdpbGwgdGhlbiBiZVxuZGlzY2FyZGVkIGFnYWluLCBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYWN0dWFsbHkgZmlsdGVyZWQuXG5cbihUaGlzIGZ1bmN0aW9uYWxpdHkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjYXJlLiBJbmRpc2NyaW1pbmF0ZWx5XG5tb2RpZnlpbmcgdHJhbnNhY3Rpb24gaXMgbGlrZWx5IHRvIGJyZWFrIHNvbWV0aGluZyBvciBkZWdyYWRlXG50aGUgdXNlciBleHBlcmllbmNlLilcbiovXG5FZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkZpbHRlciA9IHRyYW5zYWN0aW9uRmlsdGVyO1xuLyoqXG5UaGlzIGlzIGEgbW9yZSBsaW1pdGVkIGZvcm0gb2ZcbltgdHJhbnNhY3Rpb25GaWx0ZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSxcbndoaWNoIGNhbiBvbmx5IGFkZFxuW2Fubm90YXRpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5hbm5vdGF0aW9ucykgYW5kXG5bZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykuIF9CdXRfLCB0aGlzIHR5cGVcbm9mIGZpbHRlciBydW5zIGV2ZW4gaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBkaXNhYmxlZCByZWd1bGFyXG5bZmlsdGVyaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpLCBtYWtpbmcgaXQgc3VpdGFibGVcbmZvciBlZmZlY3RzIHRoYXQgZG9uJ3QgbmVlZCB0byB0b3VjaCB0aGUgY2hhbmdlcyBvciBzZWxlY3Rpb24sXG5idXQgZG8gd2FudCB0byBwcm9jZXNzIGV2ZXJ5IHRyYW5zYWN0aW9uLlxuXG5FeHRlbmRlcnMgcnVuIF9hZnRlcl8gZmlsdGVycywgd2hlbiBib3RoIGFyZSBwcmVzZW50LlxuKi9cbkVkaXRvclN0YXRlLnRyYW5zYWN0aW9uRXh0ZW5kZXIgPSB0cmFuc2FjdGlvbkV4dGVuZGVyO1xuQ29tcGFydG1lbnQucmVjb25maWd1cmUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5cbi8qKlxuVXRpbGl0eSBmdW5jdGlvbiBmb3IgY29tYmluaW5nIGJlaGF2aW9ycyB0byBmaWxsIGluIGEgY29uZmlnXG5vYmplY3QgZnJvbSBhbiBhcnJheSBvZiBwcm92aWRlZCBjb25maWdzLiBgZGVmYXVsdHNgIHNob3VsZCBob2xkXG5kZWZhdWx0IHZhbHVlcyBmb3IgYWxsIG9wdGlvbmFsIGZpZWxkcyBpbiBgQ29uZmlnYC5cblxuVGhlIGZ1bmN0aW9uIHdpbGwsIGJ5IGRlZmF1bHQsIGVycm9yXG53aGVuIGEgZmllbGQgZ2V0cyB0d28gdmFsdWVzIHRoYXQgYXJlbid0IGA9PT1gLWVxdWFsLCBidXQgeW91IGNhblxucHJvdmlkZSBjb21iaW5lIGZ1bmN0aW9ucyBwZXIgZmllbGQgdG8gZG8gc29tZXRoaW5nIGVsc2UuXG4qL1xuZnVuY3Rpb24gY29tYmluZUNvbmZpZyhjb25maWdzLCBkZWZhdWx0cywgLy8gU2hvdWxkIGhvbGQgb25seSB0aGUgb3B0aW9uYWwgcHJvcGVydGllcyBvZiBDb25maWcsIGJ1dCBJIGhhdmVuJ3QgbWFuYWdlZCB0byBleHByZXNzIHRoYXRcbmNvbWJpbmUgPSB7fSkge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncylcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNvbmZpZ1trZXldLCBjdXJyZW50ID0gcmVzdWx0W2tleV07XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA7IC8vIE5vIGNvbmZsaWN0XG4gICAgICAgICAgICBlbHNlIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChjb21iaW5lLCBrZXkpKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gY29tYmluZVtrZXldKGN1cnJlbnQsIHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25maWcgbWVyZ2UgY29uZmxpY3QgZm9yIGZpZWxkIFwiICsga2V5KTtcbiAgICAgICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBkZWZhdWx0cylcbiAgICAgICAgaWYgKHJlc3VsdFtrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGRlZmF1bHRzW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG5FYWNoIHJhbmdlIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHZhbHVlLCB3aGljaCBtdXN0IGluaGVyaXQgZnJvbVxudGhpcyBjbGFzcy5cbiovXG5jbGFzcyBSYW5nZVZhbHVlIHtcbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgdmFsdWUgd2l0aCBhbm90aGVyIHZhbHVlLiBVc2VkIHdoZW4gY29tcGFyaW5nXG4gICAgcmFuZ2VzZXRzLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBjb21wYXJlcyBieSBpZGVudGl0eS5cbiAgICBVbmxlc3MgeW91IGFyZSBvbmx5IGNyZWF0aW5nIGEgZml4ZWQgbnVtYmVyIG9mIHVuaXF1ZSBpbnN0YW5jZXNcbiAgICBvZiB5b3VyIHZhbHVlIHR5cGUsIGl0IGlzIGEgZ29vZCBpZGVhIHRvIGltcGxlbWVudCB0aGlzXG4gICAgcHJvcGVybHkuXG4gICAgKi9cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcyA9PSBvdGhlcjsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtyYW5nZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSkgd2l0aCB0aGlzIHZhbHVlLlxuICAgICovXG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7IHJldHVybiBSYW5nZS5jcmVhdGUoZnJvbSwgdG8sIHRoaXMpOyB9XG59XG5SYW5nZVZhbHVlLnByb3RvdHlwZS5zdGFydFNpZGUgPSBSYW5nZVZhbHVlLnByb3RvdHlwZS5lbmRTaWRlID0gMDtcblJhbmdlVmFsdWUucHJvdG90eXBlLnBvaW50ID0gZmFsc2U7XG5SYW5nZVZhbHVlLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0RlbDtcbi8qKlxuQSByYW5nZSBhc3NvY2lhdGVzIGEgdmFsdWUgd2l0aCBhIHJhbmdlIG9mIHBvc2l0aW9ucy5cbiovXG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHJhbmdlJ3Mgc3RhcnQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBJdHMgZW5kIHBvc2l0aW9uLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyByYW5nZS5cbiAgICAqL1xuICAgIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UoZnJvbSwgdG8sIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbXBSYW5nZShhLCBiKSB7XG4gICAgcmV0dXJuIGEuZnJvbSAtIGIuZnJvbSB8fCBhLnZhbHVlLnN0YXJ0U2lkZSAtIGIudmFsdWUuc3RhcnRTaWRlO1xufVxuY2xhc3MgQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCB2YWx1ZSwgXG4gICAgLy8gQ2h1bmtzIGFyZSBtYXJrZWQgd2l0aCB0aGUgbGFyZ2VzdCBwb2ludCB0aGF0IG9jY3Vyc1xuICAgIC8vIGluIHRoZW0gKG9yIC0xIGZvciBubyBwb2ludHMpLCBzbyB0aGF0IHNjYW5zIHRoYXQgYXJlXG4gICAgLy8gb25seSBpbnRlcmVzdGVkIGluIHBvaW50cyAoc3VjaCBhcyB0aGVcbiAgICAvLyBoZWlnaHRtYXAtcmVsYXRlZCBsb2dpYykgY2FuIHNraXAgcmFuZ2Utb25seSBjaHVua3MuXG4gICAgbWF4UG9pbnQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSBtYXhQb2ludDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudG9bdGhpcy50by5sZW5ndGggLSAxXTsgfVxuICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZS4gVXNlIHRoZSByYW5nZXMnXG4gICAgLy8gYGZyb21gIHBvcyB3aGVuIGBlbmQgPT0gZmFsc2VgLCBgdG9gIHdoZW4gYGVuZCA9PSB0cnVlYC5cbiAgICBmaW5kSW5kZXgocG9zLCBzaWRlLCBlbmQsIHN0YXJ0QXQgPSAwKSB7XG4gICAgICAgIGxldCBhcnIgPSBlbmQgPyB0aGlzLnRvIDogdGhpcy5mcm9tO1xuICAgICAgICBmb3IgKGxldCBsbyA9IHN0YXJ0QXQsIGhpID0gYXJyLmxlbmd0aDs7KSB7XG4gICAgICAgICAgICBpZiAobG8gPT0gaGkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsbyArIGhpKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGRpZmYgPSBhcnJbbWlkXSAtIHBvcyB8fCAoZW5kID8gdGhpcy52YWx1ZVttaWRdLmVuZFNpZGUgOiB0aGlzLnZhbHVlW21pZF0uc3RhcnRTaWRlKSAtIHNpZGU7XG4gICAgICAgICAgICBpZiAobWlkID09IGxvKVxuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmID49IDAgPyBsbyA6IGhpO1xuICAgICAgICAgICAgaWYgKGRpZmYgPj0gMClcbiAgICAgICAgICAgICAgICBoaSA9IG1pZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmV0d2VlbihvZmZzZXQsIGZyb20sIHRvLCBmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZpbmRJbmRleChmcm9tLCAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLywgdHJ1ZSksIGUgPSB0aGlzLmZpbmRJbmRleCh0bywgMTAwMDAwMDAwMCAvKiBDLkZhciAqLywgZmFsc2UsIGkpOyBpIDwgZTsgaSsrKVxuICAgICAgICAgICAgaWYgKGYodGhpcy5mcm9tW2ldICsgb2Zmc2V0LCB0aGlzLnRvW2ldICsgb2Zmc2V0LCB0aGlzLnZhbHVlW2ldKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtYXAob2Zmc2V0LCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IFtdLCBmcm9tID0gW10sIHRvID0gW10sIG5ld1BvcyA9IC0xLCBtYXhQb2ludCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSB0aGlzLnZhbHVlW2ldLCBjdXJGcm9tID0gdGhpcy5mcm9tW2ldICsgb2Zmc2V0LCBjdXJUbyA9IHRoaXMudG9baV0gKyBvZmZzZXQsIG5ld0Zyb20sIG5ld1RvO1xuICAgICAgICAgICAgaWYgKGN1ckZyb20gPT0gY3VyVG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFwcGVkID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLnN0YXJ0U2lkZSwgdmFsLm1hcE1vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbmV3RnJvbSA9IG5ld1RvID0gbWFwcGVkO1xuICAgICAgICAgICAgICAgIGlmICh2YWwuc3RhcnRTaWRlICE9IHZhbC5lbmRTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1RvID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VG8gPCBuZXdGcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3RnJvbSA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5zdGFydFNpZGUpO1xuICAgICAgICAgICAgICAgIG5ld1RvID0gY2hhbmdlcy5tYXBQb3MoY3VyVG8sIHZhbC5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3RnJvbSA+IG5ld1RvIHx8IG5ld0Zyb20gPT0gbmV3VG8gJiYgdmFsLnN0YXJ0U2lkZSA+IDAgJiYgdmFsLmVuZFNpZGUgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG5ld1RvIC0gbmV3RnJvbSB8fCB2YWwuZW5kU2lkZSAtIHZhbC5zdGFydFNpZGUpIDwgMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChuZXdQb3MgPCAwKVxuICAgICAgICAgICAgICAgIG5ld1BvcyA9IG5ld0Zyb207XG4gICAgICAgICAgICBpZiAodmFsLnBvaW50KVxuICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIG5ld1RvIC0gbmV3RnJvbSk7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKHZhbCk7XG4gICAgICAgICAgICBmcm9tLnB1c2gobmV3RnJvbSAtIG5ld1Bvcyk7XG4gICAgICAgICAgICB0by5wdXNoKG5ld1RvIC0gbmV3UG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXBwZWQ6IHZhbHVlLmxlbmd0aCA/IG5ldyBDaHVuayhmcm9tLCB0bywgdmFsdWUsIG1heFBvaW50KSA6IG51bGwsIHBvczogbmV3UG9zIH07XG4gICAgfVxufVxuLyoqXG5BIHJhbmdlIHNldCBzdG9yZXMgYSBjb2xsZWN0aW9uIG9mIFtyYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpIGluIGFcbndheSB0aGF0IG1ha2VzIHRoZW0gZWZmaWNpZW50IHRvIFttYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQubWFwKSBhbmRcblt1cGRhdGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQudXBkYXRlKS4gVGhpcyBpcyBhbiBpbW11dGFibGUgZGF0YVxuc3RydWN0dXJlLlxuKi9cbmNsYXNzIFJhbmdlU2V0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNodW5rUG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNodW5rLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5leHRMYXllciwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXhQb2ludCkge1xuICAgICAgICB0aGlzLmNodW5rUG9zID0gY2h1bmtQb3M7XG4gICAgICAgIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgICAgICAgdGhpcy5uZXh0TGF5ZXIgPSBuZXh0TGF5ZXI7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSBtYXhQb2ludDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGNodW5rUG9zLCBjaHVuaywgbmV4dExheWVyLCBtYXhQb2ludCkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlU2V0KGNodW5rUG9zLCBjaHVuaywgbmV4dExheWVyLCBtYXhQb2ludCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNodW5rLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBsYXN0IDwgMCA/IDAgOiBNYXRoLm1heCh0aGlzLmNodW5rRW5kKGxhc3QpLCB0aGlzLm5leHRMYXllci5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIHJhbmdlcyBpbiB0aGUgc2V0LlxuICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLm5leHRMYXllci5zaXplO1xuICAgICAgICBmb3IgKGxldCBjaHVuayBvZiB0aGlzLmNodW5rKVxuICAgICAgICAgICAgc2l6ZSArPSBjaHVuay52YWx1ZS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNodW5rRW5kKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNodW5rUG9zW2luZGV4XSArIHRoaXMuY2h1bmtbaW5kZXhdLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSByYW5nZSBzZXQsIG9wdGlvbmFsbHkgYWRkaW5nIG5ldyByYW5nZXMgb3IgZmlsdGVyaW5nXG4gICAgb3V0IGV4aXN0aW5nIG9uZXMuXG4gICAgXG4gICAgKE5vdGU6IFRoZSB0eXBlIHBhcmFtZXRlciBpcyBqdXN0IHRoZXJlIGFzIGEga2x1ZGdlIHRvIHdvcmtcbiAgICBhcm91bmQgVHlwZVNjcmlwdCB2YXJpYW5jZSBpc3N1ZXMgdGhhdCBwcmV2ZW50ZWQgYFJhbmdlU2V0PFg+YFxuICAgIGZyb20gYmVpbmcgYSBzdWJ0eXBlIG9mIGBSYW5nZVNldDxZPmAgd2hlbiBgWGAgaXMgYSBzdWJ0eXBlIG9mXG4gICAgYFlgLilcbiAgICAqL1xuICAgIHVwZGF0ZSh1cGRhdGVTcGVjKSB7XG4gICAgICAgIGxldCB7IGFkZCA9IFtdLCBzb3J0ID0gZmFsc2UsIGZpbHRlckZyb20gPSAwLCBmaWx0ZXJUbyA9IHRoaXMubGVuZ3RoIH0gPSB1cGRhdGVTcGVjO1xuICAgICAgICBsZXQgZmlsdGVyID0gdXBkYXRlU3BlYy5maWx0ZXI7XG4gICAgICAgIGlmIChhZGQubGVuZ3RoID09IDAgJiYgIWZpbHRlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoc29ydClcbiAgICAgICAgICAgIGFkZCA9IGFkZC5zbGljZSgpLnNvcnQoY21wUmFuZ2UpO1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIGFkZC5sZW5ndGggPyBSYW5nZVNldC5vZihhZGQpIDogdGhpcztcbiAgICAgICAgbGV0IGN1ciA9IG5ldyBMYXllckN1cnNvcih0aGlzLCBudWxsLCAtMSkuZ290bygwKSwgaSA9IDAsIHNwaWxsID0gW107XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICB3aGlsZSAoY3VyLnZhbHVlIHx8IGkgPCBhZGQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSA8IGFkZC5sZW5ndGggJiYgKGN1ci5mcm9tIC0gYWRkW2ldLmZyb20gfHwgY3VyLnN0YXJ0U2lkZSAtIGFkZFtpXS52YWx1ZS5zdGFydFNpZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBhZGRbaSsrXTtcbiAgICAgICAgICAgICAgICBpZiAoIWJ1aWxkZXIuYWRkSW5uZXIocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgc3BpbGwucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXIucmFuZ2VJbmRleCA9PSAxICYmIGN1ci5jaHVua0luZGV4IDwgdGhpcy5jaHVuay5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAoaSA9PSBhZGQubGVuZ3RoIHx8IHRoaXMuY2h1bmtFbmQoY3VyLmNodW5rSW5kZXgpIDwgYWRkW2ldLmZyb20pICYmXG4gICAgICAgICAgICAgICAgKCFmaWx0ZXIgfHwgZmlsdGVyRnJvbSA+IHRoaXMuY2h1bmtFbmQoY3VyLmNodW5rSW5kZXgpIHx8IGZpbHRlclRvIDwgdGhpcy5jaHVua1Bvc1tjdXIuY2h1bmtJbmRleF0pICYmXG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGRDaHVuayh0aGlzLmNodW5rUG9zW2N1ci5jaHVua0luZGV4XSwgdGhpcy5jaHVua1tjdXIuY2h1bmtJbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgY3VyLm5leHRDaHVuaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyRnJvbSA+IGN1ci50byB8fCBmaWx0ZXJUbyA8IGN1ci5mcm9tIHx8IGZpbHRlcihjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYnVpbGRlci5hZGRJbm5lcihjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BpbGwucHVzaChSYW5nZS5jcmVhdGUoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoSW5uZXIodGhpcy5uZXh0TGF5ZXIuaXNFbXB0eSAmJiAhc3BpbGwubGVuZ3RoID8gUmFuZ2VTZXQuZW1wdHlcbiAgICAgICAgICAgIDogdGhpcy5uZXh0TGF5ZXIudXBkYXRlKHsgYWRkOiBzcGlsbCwgZmlsdGVyLCBmaWx0ZXJGcm9tLCBmaWx0ZXJUbyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIHJhbmdlIHNldCB0aHJvdWdoIGEgc2V0IG9mIGNoYW5nZXMsIHJldHVybiB0aGUgbmV3IHNldC5cbiAgICAqL1xuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmVtcHR5IHx8IHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgY2h1bmtzID0gW10sIGNodW5rUG9zID0gW10sIG1heFBvaW50ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jaHVua1Bvc1tpXSwgY2h1bmsgPSB0aGlzLmNodW5rW2ldO1xuICAgICAgICAgICAgbGV0IHRvdWNoID0gY2hhbmdlcy50b3VjaGVzUmFuZ2Uoc3RhcnQsIHN0YXJ0ICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICh0b3VjaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBjaHVuay5tYXhQb2ludCk7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIGNodW5rUG9zLnB1c2goY2hhbmdlcy5tYXBQb3Moc3RhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvdWNoID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbWFwcGVkLCBwb3MgfSA9IGNodW5rLm1hcChzdGFydCwgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBtYXBwZWQubWF4UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua1Bvcy5wdXNoKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5uZXh0TGF5ZXIubWFwKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4gY2h1bmtzLmxlbmd0aCA9PSAwID8gbmV4dCA6IG5ldyBSYW5nZVNldChjaHVua1BvcywgY2h1bmtzLCBuZXh0IHx8IFJhbmdlU2V0LmVtcHR5LCBtYXhQb2ludCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIHRoYXQgdG91Y2ggdGhlIHJlZ2lvbiBgZnJvbWAgdG8gYHRvYCxcbiAgICBjYWxsaW5nIGBmYCBmb3IgZWFjaC4gVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIHJhbmdlcyB3aWxsXG4gICAgYmUgcmVwb3J0ZWQgaW4gYW55IHNwZWNpZmljIG9yZGVyLiBXaGVuIHRoZSBjYWxsYmFjayByZXR1cm5zXG4gICAgYGZhbHNlYCwgaXRlcmF0aW9uIHN0b3BzLlxuICAgICovXG4gICAgYmV0d2Vlbihmcm9tLCB0bywgZikge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuY2h1bmtQb3NbaV0sIGNodW5rID0gdGhpcy5jaHVua1tpXTtcbiAgICAgICAgICAgIGlmICh0byA+PSBzdGFydCAmJiBmcm9tIDw9IHN0YXJ0ICsgY2h1bmsubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgY2h1bmsuYmV0d2VlbihzdGFydCwgZnJvbSAtIHN0YXJ0LCB0byAtIHN0YXJ0LCBmKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dExheWVyLmJldHdlZW4oZnJvbSwgdG8sIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBpbiB0aGlzIHNldCwgaW4gb3JkZXIsIGluY2x1ZGluZyBhbGxcbiAgICByYW5nZXMgdGhhdCBlbmQgYXQgb3IgYWZ0ZXIgYGZyb21gLlxuICAgICovXG4gICAgaXRlcihmcm9tID0gMCkge1xuICAgICAgICByZXR1cm4gSGVhcEN1cnNvci5mcm9tKFt0aGlzXSkuZ290byhmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaXNFbXB0eSgpIHsgcmV0dXJuIHRoaXMubmV4dExheWVyID09IHRoaXM7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBpbiBhIGNvbGxlY3Rpb24gb2Ygc2V0cywgaW4gb3JkZXIsXG4gICAgc3RhcnRpbmcgZnJvbSBgZnJvbWAuXG4gICAgKi9cbiAgICBzdGF0aWMgaXRlcihzZXRzLCBmcm9tID0gMCkge1xuICAgICAgICByZXR1cm4gSGVhcEN1cnNvci5mcm9tKHNldHMpLmdvdG8oZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0d28gZ3JvdXBzIG9mIHNldHMsIGNhbGxpbmcgbWV0aG9kcyBvbiBgY29tcGFyYXRvcmBcbiAgICB0byBub3RpZnkgaXQgb2YgcG9zc2libGUgZGlmZmVyZW5jZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZShvbGRTZXRzLCBuZXdTZXRzLCBcbiAgICAvKipcbiAgICBUaGlzIGluZGljYXRlcyBob3cgdGhlIHVuZGVybHlpbmcgZGF0YSBjaGFuZ2VkIGJldHdlZW4gdGhlc2VcbiAgICByYW5nZXMsIGFuZCBpcyBuZWVkZWQgdG8gc3luY2hyb25pemUgdGhlIGl0ZXJhdGlvbi4gYGZyb21gIGFuZFxuICAgIGB0b2AgYXJlIGNvb3JkaW5hdGVzIGluIHRoZSBfbmV3XyBzcGFjZSwgYWZ0ZXIgdGhlc2UgY2hhbmdlcy5cbiAgICAqL1xuICAgIHRleHREaWZmLCBjb21wYXJhdG9yLCBcbiAgICAvKipcbiAgICBDYW4gYmUgdXNlZCB0byBpZ25vcmUgYWxsIG5vbi1wb2ludCByYW5nZXMsIGFuZCBwb2ludHMgYmVsb3dcbiAgICB0aGUgZ2l2ZW4gc2l6ZS4gV2hlbiAtMSwgYWxsIHJhbmdlcyBhcmUgY29tcGFyZWQuXG4gICAgKi9cbiAgICBtaW5Qb2ludFNpemUgPSAtMSkge1xuICAgICAgICBsZXQgYSA9IG9sZFNldHMuZmlsdGVyKHNldCA9PiBzZXQubWF4UG9pbnQgPiAwIHx8ICFzZXQuaXNFbXB0eSAmJiBzZXQubWF4UG9pbnQgPj0gbWluUG9pbnRTaXplKTtcbiAgICAgICAgbGV0IGIgPSBuZXdTZXRzLmZpbHRlcihzZXQgPT4gc2V0Lm1heFBvaW50ID4gMCB8fCAhc2V0LmlzRW1wdHkgJiYgc2V0Lm1heFBvaW50ID49IG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBzaGFyZWRDaHVua3MgPSBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIsIHRleHREaWZmKTtcbiAgICAgICAgbGV0IHNpZGVBID0gbmV3IFNwYW5DdXJzb3IoYSwgc2hhcmVkQ2h1bmtzLCBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgc2lkZUIgPSBuZXcgU3BhbkN1cnNvcihiLCBzaGFyZWRDaHVua3MsIG1pblBvaW50U2l6ZSk7XG4gICAgICAgIHRleHREaWZmLml0ZXJHYXBzKChmcm9tQSwgZnJvbUIsIGxlbmd0aCkgPT4gY29tcGFyZShzaWRlQSwgZnJvbUEsIHNpZGVCLCBmcm9tQiwgbGVuZ3RoLCBjb21wYXJhdG9yKSk7XG4gICAgICAgIGlmICh0ZXh0RGlmZi5lbXB0eSAmJiB0ZXh0RGlmZi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGNvbXBhcmUoc2lkZUEsIDAsIHNpZGVCLCAwLCAwLCBjb21wYXJhdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGUgY29udGVudHMgb2YgdHdvIGdyb3VwcyBvZiByYW5nZSBzZXRzLCByZXR1cm5pbmcgdHJ1ZVxuICAgIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQgaW4gdGhlIGdpdmVuIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIGVxKG9sZFNldHMsIG5ld1NldHMsIGZyb20gPSAwLCB0bykge1xuICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgIHRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLyAtIDE7XG4gICAgICAgIGxldCBhID0gb2xkU2V0cy5maWx0ZXIoc2V0ID0+ICFzZXQuaXNFbXB0eSAmJiBuZXdTZXRzLmluZGV4T2Yoc2V0KSA8IDApO1xuICAgICAgICBsZXQgYiA9IG5ld1NldHMuZmlsdGVyKHNldCA9PiAhc2V0LmlzRW1wdHkgJiYgb2xkU2V0cy5pbmRleE9mKHNldCkgPCAwKTtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWEubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBzaGFyZWRDaHVua3MgPSBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIpO1xuICAgICAgICBsZXQgc2lkZUEgPSBuZXcgU3BhbkN1cnNvcihhLCBzaGFyZWRDaHVua3MsIDApLmdvdG8oZnJvbSksIHNpZGVCID0gbmV3IFNwYW5DdXJzb3IoYiwgc2hhcmVkQ2h1bmtzLCAwKS5nb3RvKGZyb20pO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoc2lkZUEudG8gIT0gc2lkZUIudG8gfHxcbiAgICAgICAgICAgICAgICAhc2FtZVZhbHVlcyhzaWRlQS5hY3RpdmUsIHNpZGVCLmFjdGl2ZSkgfHxcbiAgICAgICAgICAgICAgICBzaWRlQS5wb2ludCAmJiAoIXNpZGVCLnBvaW50IHx8ICFzaWRlQS5wb2ludC5lcShzaWRlQi5wb2ludCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzaWRlQS50byA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgc2lkZUEubmV4dCgpO1xuICAgICAgICAgICAgc2lkZUIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciBhIGdyb3VwIG9mIHJhbmdlIHNldHMgYXQgdGhlIHNhbWUgdGltZSwgbm90aWZ5aW5nXG4gICAgdGhlIGl0ZXJhdG9yIGFib3V0IHRoZSByYW5nZXMgY292ZXJpbmcgZXZlcnkgZ2l2ZW4gcGllY2Ugb2ZcbiAgICBjb250ZW50LiBSZXR1cm5zIHRoZSBvcGVuIGNvdW50IChzZWVcbiAgICBbYFNwYW5JdGVyYXRvci5zcGFuYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TcGFuSXRlcmF0b3Iuc3BhbikpIGF0IHRoZSBlbmRcbiAgICBvZiB0aGUgaXRlcmF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIHNwYW5zKHNldHMsIGZyb20sIHRvLCBpdGVyYXRvciwgXG4gICAgLyoqXG4gICAgV2hlbiBnaXZlbiBhbmQgZ3JlYXRlciB0aGFuIC0xLCBvbmx5IHBvaW50cyBvZiBhdCBsZWFzdCB0aGlzXG4gICAgc2l6ZSBhcmUgdGFrZW4gaW50byBhY2NvdW50LlxuICAgICovXG4gICAgbWluUG9pbnRTaXplID0gLTEpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBTcGFuQ3Vyc29yKHNldHMsIG51bGwsIG1pblBvaW50U2l6ZSkuZ290byhmcm9tKSwgcG9zID0gZnJvbTtcbiAgICAgICAgbGV0IG9wZW5SYW5nZXMgPSBjdXJzb3Iub3BlblN0YXJ0O1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgY3VyVG8gPSBNYXRoLm1pbihjdXJzb3IudG8sIHRvKTtcbiAgICAgICAgICAgIGlmIChjdXJzb3IucG9pbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gY3Vyc29yLmFjdGl2ZUZvclBvaW50KGN1cnNvci50byk7XG4gICAgICAgICAgICAgICAgbGV0IG9wZW5Db3VudCA9IGN1cnNvci5wb2ludEZyb20gPCBmcm9tID8gYWN0aXZlLmxlbmd0aCArIDEgOiBNYXRoLm1pbihhY3RpdmUubGVuZ3RoLCBvcGVuUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5wb2ludChwb3MsIGN1clRvLCBjdXJzb3IucG9pbnQsIGFjdGl2ZSwgb3BlbkNvdW50LCBjdXJzb3IucG9pbnRSYW5rKTtcbiAgICAgICAgICAgICAgICBvcGVuUmFuZ2VzID0gTWF0aC5taW4oY3Vyc29yLm9wZW5FbmQoY3VyVG8pLCBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1clRvID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iuc3Bhbihwb3MsIGN1clRvLCBjdXJzb3IuYWN0aXZlLCBvcGVuUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICBvcGVuUmFuZ2VzID0gY3Vyc29yLm9wZW5FbmQoY3VyVG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvci50byA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcGVuUmFuZ2VzICsgKGN1cnNvci5wb2ludCAmJiBjdXJzb3IudG8gPiB0byA/IDEgOiAwKTtcbiAgICAgICAgICAgIHBvcyA9IGN1cnNvci50bztcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmFuZ2Ugc2V0IGZvciB0aGUgZ2l2ZW4gcmFuZ2Ugb3IgYXJyYXkgb2YgcmFuZ2VzLiBCeVxuICAgIGRlZmF1bHQsIHRoaXMgZXhwZWN0cyB0aGUgcmFuZ2VzIHRvIGJlIF9zb3J0ZWRfIChieSBzdGFydFxuICAgIHBvc2l0aW9uIGFuZCwgaWYgdHdvIHN0YXJ0IGF0IHRoZSBzYW1lIHBvc2l0aW9uLFxuICAgIGB2YWx1ZS5zdGFydFNpZGVgKS4gWW91IGNhbiBwYXNzIGB0cnVlYCBhcyBzZWNvbmQgYXJndW1lbnQgdG9cbiAgICBjYXVzZSB0aGUgbWV0aG9kIHRvIHNvcnQgdGhlbS5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihyYW5nZXMsIHNvcnQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgYnVpbGQgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IHJhbmdlIG9mIHJhbmdlcyBpbnN0YW5jZW9mIFJhbmdlID8gW3Jhbmdlc10gOiBzb3J0ID8gbGF6eVNvcnQocmFuZ2VzKSA6IHJhbmdlcylcbiAgICAgICAgICAgIGJ1aWxkLmFkZChyYW5nZS5mcm9tLCByYW5nZS50bywgcmFuZ2UudmFsdWUpO1xuICAgICAgICByZXR1cm4gYnVpbGQuZmluaXNoKCk7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIHJhbmdlcy5cbiovXG5SYW5nZVNldC5lbXB0eSA9IC8qQF9fUFVSRV9fKi9uZXcgUmFuZ2VTZXQoW10sIFtdLCBudWxsLCAtMSk7XG5mdW5jdGlvbiBsYXp5U29ydChyYW5nZXMpIHtcbiAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEpXG4gICAgICAgIGZvciAobGV0IHByZXYgPSByYW5nZXNbMF0sIGkgPSAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKGNtcFJhbmdlKHByZXYsIGN1cikgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZXMuc2xpY2UoKS5zb3J0KGNtcFJhbmdlKTtcbiAgICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuUmFuZ2VTZXQuZW1wdHkubmV4dExheWVyID0gUmFuZ2VTZXQuZW1wdHk7XG4vKipcbkEgcmFuZ2Ugc2V0IGJ1aWxkZXIgaXMgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGhlbHBzIGJ1aWxkIHVwIGFcbltyYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQpIGRpcmVjdGx5LCB3aXRob3V0IGZpcnN0IGFsbG9jYXRpbmdcbmFuIGFycmF5IG9mIFtgUmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSBvYmplY3RzLlxuKi9cbmNsYXNzIFJhbmdlU2V0QnVpbGRlciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGVtcHR5IGJ1aWxkZXIuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmxhc3RUbyA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmZyb20gPSBbXTtcbiAgICAgICAgdGhpcy50byA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSAtMTtcbiAgICAgICAgdGhpcy5zZXRNYXhQb2ludCA9IC0xO1xuICAgICAgICB0aGlzLm5leHRMYXllciA9IG51bGw7XG4gICAgfVxuICAgIGZpbmlzaENodW5rKG5ld0FycmF5cykge1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBDaHVuayh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMudmFsdWUsIHRoaXMubWF4UG9pbnQpKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRoaXMuY2h1bmtTdGFydCk7XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5zZXRNYXhQb2ludCwgdGhpcy5tYXhQb2ludCk7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSAtMTtcbiAgICAgICAgaWYgKG5ld0FycmF5cykge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gW107XG4gICAgICAgICAgICB0aGlzLnRvID0gW107XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgcmFuZ2UuIFJhbmdlcyBzaG91bGQgYmUgYWRkZWQgaW4gc29ydGVkIChieSBgZnJvbWAgYW5kXG4gICAgYHZhbHVlLnN0YXJ0U2lkZWApIG9yZGVyLlxuICAgICovXG4gICAgYWRkKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWRkSW5uZXIoZnJvbSwgdG8sIHZhbHVlKSlcbiAgICAgICAgICAgICh0aGlzLm5leHRMYXllciB8fCAodGhpcy5uZXh0TGF5ZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKSkuYWRkKGZyb20sIHRvLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkSW5uZXIoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIGxldCBkaWZmID0gZnJvbSAtIHRoaXMubGFzdFRvIHx8IHZhbHVlLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5lbmRTaWRlO1xuICAgICAgICBpZiAoZGlmZiA8PSAwICYmIChmcm9tIC0gdGhpcy5sYXN0RnJvbSB8fCB2YWx1ZS5zdGFydFNpZGUgLSB0aGlzLmxhc3Quc3RhcnRTaWRlKSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZXMgbXVzdCBiZSBhZGRlZCBzb3J0ZWQgYnkgYGZyb21gIHBvc2l0aW9uIGFuZCBgc3RhcnRTaWRlYFwiKTtcbiAgICAgICAgaWYgKGRpZmYgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aCA9PSAyNTAgLyogQy5DaHVua1NpemUgKi8pXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKHRydWUpO1xuICAgICAgICBpZiAodGhpcy5jaHVua1N0YXJ0IDwgMClcbiAgICAgICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IGZyb207XG4gICAgICAgIHRoaXMuZnJvbS5wdXNoKGZyb20gLSB0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLnRvLnB1c2godG8gLSB0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLmxhc3QgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMubGFzdFRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZS5wb2ludClcbiAgICAgICAgICAgIHRoaXMubWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLm1heFBvaW50LCB0byAtIGZyb20pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRDaHVuayhmcm9tLCBjaHVuaykge1xuICAgICAgICBpZiAoKGZyb20gLSB0aGlzLmxhc3RUbyB8fCBjaHVuay52YWx1ZVswXS5zdGFydFNpZGUgLSB0aGlzLmxhc3QuZW5kU2lkZSkgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsodHJ1ZSk7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLnNldE1heFBvaW50LCBjaHVuay5tYXhQb2ludCk7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2goZnJvbSk7XG4gICAgICAgIGxldCBsYXN0ID0gY2h1bmsudmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5sYXN0ID0gY2h1bmsudmFsdWVbbGFzdF07XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSBjaHVuay5mcm9tW2xhc3RdICsgZnJvbTtcbiAgICAgICAgdGhpcy5sYXN0VG8gPSBjaHVuay50b1tsYXN0XSArIGZyb207XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5pc2ggdGhlIHJhbmdlIHNldC4gUmV0dXJucyB0aGUgbmV3IHNldC4gVGhlIGJ1aWxkZXIgY2FuJ3QgYmVcbiAgICB1c2VkIGFueW1vcmUgYWZ0ZXIgdGhpcyBoYXMgYmVlbiBjYWxsZWQuXG4gICAgKi9cbiAgICBmaW5pc2goKSB7IHJldHVybiB0aGlzLmZpbmlzaElubmVyKFJhbmdlU2V0LmVtcHR5KTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluaXNoSW5uZXIobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFJhbmdlU2V0LmNyZWF0ZSh0aGlzLmNodW5rUG9zLCB0aGlzLmNodW5rcywgdGhpcy5uZXh0TGF5ZXIgPyB0aGlzLm5leHRMYXllci5maW5pc2hJbm5lcihuZXh0KSA6IG5leHQsIHRoaXMuc2V0TWF4UG9pbnQpO1xuICAgICAgICB0aGlzLmZyb20gPSBudWxsOyAvLyBNYWtlIHN1cmUgZnVydGhlciBgYWRkYCBjYWxscyBwcm9kdWNlIGVycm9yc1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRTaGFyZWRDaHVua3MoYSwgYiwgdGV4dERpZmYpIHtcbiAgICBsZXQgaW5BID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IHNldCBvZiBhKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaHVuay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXQuY2h1bmtbaV0ubWF4UG9pbnQgPD0gMClcbiAgICAgICAgICAgICAgICBpbkEuc2V0KHNldC5jaHVua1tpXSwgc2V0LmNodW5rUG9zW2ldKTtcbiAgICBsZXQgc2hhcmVkID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IHNldCBvZiBiKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGtub3duID0gaW5BLmdldChzZXQuY2h1bmtbaV0pO1xuICAgICAgICAgICAgaWYgKGtub3duICE9IG51bGwgJiYgKHRleHREaWZmID8gdGV4dERpZmYubWFwUG9zKGtub3duKSA6IGtub3duKSA9PSBzZXQuY2h1bmtQb3NbaV0gJiZcbiAgICAgICAgICAgICAgICAhKHRleHREaWZmID09PSBudWxsIHx8IHRleHREaWZmID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0RGlmZi50b3VjaGVzUmFuZ2Uoa25vd24sIGtub3duICsgc2V0LmNodW5rW2ldLmxlbmd0aCkpKVxuICAgICAgICAgICAgICAgIHNoYXJlZC5hZGQoc2V0LmNodW5rW2ldKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBzaGFyZWQ7XG59XG5jbGFzcyBMYXllckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IobGF5ZXIsIHNraXAsIG1pblBvaW50LCByYW5rID0gMCkge1xuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuc2tpcCA9IHNraXA7XG4gICAgICAgIHRoaXMubWluUG9pbnQgPSBtaW5Qb2ludDtcbiAgICAgICAgdGhpcy5yYW5rID0gcmFuaztcbiAgICB9XG4gICAgZ2V0IHN0YXJ0U2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLnN0YXJ0U2lkZSA6IDA7IH1cbiAgICBnZXQgZW5kU2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLmVuZFNpZGUgOiAwOyB9XG4gICAgZ290byhwb3MsIHNpZGUgPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLykge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXggPSB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLmdvdG9Jbm5lcihwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdvdG9Jbm5lcihwb3MsIHNpZGUsIGZvcndhcmQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XTtcbiAgICAgICAgICAgIGlmICghKHRoaXMuc2tpcCAmJiB0aGlzLnNraXAuaGFzKG5leHQpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5sYXllci5jaHVua0VuZCh0aGlzLmNodW5rSW5kZXgpIDwgcG9zIHx8XG4gICAgICAgICAgICAgICAgbmV4dC5tYXhQb2ludCA8IHRoaXMubWluUG9pbnQpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICBmb3J3YXJkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VJbmRleCA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XS5maW5kSW5kZXgocG9zIC0gdGhpcy5sYXllci5jaHVua1Bvc1t0aGlzLmNodW5rSW5kZXhdLCBzaWRlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghZm9yd2FyZCB8fCB0aGlzLnJhbmdlSW5kZXggPCByYW5nZUluZGV4KVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJbmRleChyYW5nZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgZm9yd2FyZChwb3MsIHNpZGUpIHtcbiAgICAgICAgaWYgKCh0aGlzLnRvIC0gcG9zIHx8IHRoaXMuZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMuZ290b0lubmVyKHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNodW5rSW5kZXggPT0gdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSB0aGlzLnRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjaHVua1BvcyA9IHRoaXMubGF5ZXIuY2h1bmtQb3NbdGhpcy5jaHVua0luZGV4XSwgY2h1bmsgPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF07XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaHVua1BvcyArIGNodW5rLmZyb21bdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSBjaHVua1BvcyArIGNodW5rLnRvW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGNodW5rLnZhbHVlW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZUluZGV4KHRoaXMucmFuZ2VJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pblBvaW50IDwgMCB8fCB0aGlzLnZhbHVlLnBvaW50ICYmIHRoaXMudG8gLSB0aGlzLmZyb20gPj0gdGhpcy5taW5Qb2ludClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UmFuZ2VJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoICYmIHRoaXMuc2tpcC5oYXModGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dENodW5rKCkge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbSAtIG90aGVyLmZyb20gfHwgdGhpcy5zdGFydFNpZGUgLSBvdGhlci5zdGFydFNpZGUgfHwgdGhpcy5yYW5rIC0gb3RoZXIucmFuayB8fFxuICAgICAgICAgICAgdGhpcy50byAtIG90aGVyLnRvIHx8IHRoaXMuZW5kU2lkZSAtIG90aGVyLmVuZFNpZGU7XG4gICAgfVxufVxuY2xhc3MgSGVhcEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoaGVhcCkge1xuICAgICAgICB0aGlzLmhlYXAgPSBoZWFwO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShzZXRzLCBza2lwID0gbnVsbCwgbWluUG9pbnQgPSAtMSkge1xuICAgICAgICBsZXQgaGVhcCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGN1ciA9IHNldHNbaV07ICFjdXIuaXNFbXB0eTsgY3VyID0gY3VyLm5leHRMYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChjdXIubWF4UG9pbnQgPj0gbWluUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGhlYXAucHVzaChuZXcgTGF5ZXJDdXJzb3IoY3VyLCBza2lwLCBtaW5Qb2ludCwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFwLmxlbmd0aCA9PSAxID8gaGVhcFswXSA6IG5ldyBIZWFwQ3Vyc29yKGhlYXApO1xuICAgIH1cbiAgICBnZXQgc3RhcnRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuc3RhcnRTaWRlIDogMDsgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcbiAgICAgICAgZm9yIChsZXQgY3VyIG9mIHRoaXMuaGVhcClcbiAgICAgICAgICAgIGN1ci5nb3RvKHBvcywgc2lkZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmhlYXAubGVuZ3RoID4+IDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIGkpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciBvZiB0aGlzLmhlYXApXG4gICAgICAgICAgICBjdXIuZm9yd2FyZChwb3MsIHNpZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFwLmxlbmd0aCA+PiAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCBpKTtcbiAgICAgICAgaWYgKCh0aGlzLnRvIC0gcG9zIHx8IHRoaXMudmFsdWUuZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5oZWFwLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSB0aGlzLnRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yYW5rID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5oZWFwWzBdO1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdG9wLmZyb207XG4gICAgICAgICAgICB0aGlzLnRvID0gdG9wLnRvO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRvcC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucmFuayA9IHRvcC5yYW5rO1xuICAgICAgICAgICAgaWYgKHRvcC52YWx1ZSlcbiAgICAgICAgICAgICAgICB0b3AubmV4dCgpO1xuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIDApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaGVhcEJ1YmJsZShoZWFwLCBpbmRleCkge1xuICAgIGZvciAobGV0IGN1ciA9IGhlYXBbaW5kZXhdOzspIHtcbiAgICAgICAgbGV0IGNoaWxkSW5kZXggPSAoaW5kZXggPDwgMSkgKyAxO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCA+PSBoZWFwLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgY2hpbGQgPSBoZWFwW2NoaWxkSW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCArIDEgPCBoZWFwLmxlbmd0aCAmJiBjaGlsZC5jb21wYXJlKGhlYXBbY2hpbGRJbmRleCArIDFdKSA+PSAwKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGhlYXBbY2hpbGRJbmRleCArIDFdO1xuICAgICAgICAgICAgY2hpbGRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXIuY29tcGFyZShjaGlsZCkgPCAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGhlYXBbY2hpbGRJbmRleF0gPSBjdXI7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gY2hpbGQ7XG4gICAgICAgIGluZGV4ID0gY2hpbGRJbmRleDtcbiAgICB9XG59XG5jbGFzcyBTcGFuQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzZXRzLCBza2lwLCBtaW5Qb2ludCkge1xuICAgICAgICB0aGlzLm1pblBvaW50ID0gbWluUG9pbnQ7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlVG8gPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVSYW5rID0gW107XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gLTE7XG4gICAgICAgIC8vIEEgY3VycmVudGx5IGFjdGl2ZSBwb2ludCByYW5nZSwgaWYgYW55XG4gICAgICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnBvaW50RnJvbSA9IDA7XG4gICAgICAgIHRoaXMucG9pbnRSYW5rID0gMDtcbiAgICAgICAgdGhpcy50byA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSAwO1xuICAgICAgICAvLyBUaGUgYW1vdW50IG9mIG9wZW4gYWN0aXZlIHJhbmdlcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAvLyBOb3QgaW5jbHVkaW5nIHBvaW50cy5cbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBIZWFwQ3Vyc29yLmZyb20oc2V0cywgc2tpcCwgbWluUG9pbnQpO1xuICAgIH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yLmdvdG8ocG9zLCBzaWRlKTtcbiAgICAgICAgdGhpcy5hY3RpdmUubGVuZ3RoID0gdGhpcy5hY3RpdmVUby5sZW5ndGggPSB0aGlzLmFjdGl2ZVJhbmsubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSAtMTtcbiAgICAgICAgdGhpcy50byA9IHBvcztcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gc2lkZTtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5taW5BY3RpdmUgPiAtMSAmJiAodGhpcy5hY3RpdmVUb1t0aGlzLm1pbkFjdGl2ZV0gLSBwb3MgfHwgdGhpcy5hY3RpdmVbdGhpcy5taW5BY3RpdmVdLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZSh0aGlzLm1pbkFjdGl2ZSk7XG4gICAgICAgIHRoaXMuY3Vyc29yLmZvcndhcmQocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgcmVtb3ZlQWN0aXZlKGluZGV4KSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLmFjdGl2ZSwgaW5kZXgpO1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVUbywgaW5kZXgpO1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVSYW5rLCBpbmRleCk7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gZmluZE1pbkluZGV4KHRoaXMuYWN0aXZlLCB0aGlzLmFjdGl2ZVRvKTtcbiAgICB9XG4gICAgYWRkQWN0aXZlKHRyYWNrT3Blbikge1xuICAgICAgICBsZXQgaSA9IDAsIHsgdmFsdWUsIHRvLCByYW5rIH0gPSB0aGlzLmN1cnNvcjtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmFjdGl2ZVJhbmsubGVuZ3RoICYmIHRoaXMuYWN0aXZlUmFua1tpXSA8PSByYW5rKVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICBpbnNlcnQodGhpcy5hY3RpdmUsIGksIHZhbHVlKTtcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlVG8sIGksIHRvKTtcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlUmFuaywgaSwgcmFuayk7XG4gICAgICAgIGlmICh0cmFja09wZW4pXG4gICAgICAgICAgICBpbnNlcnQodHJhY2tPcGVuLCBpLCB0aGlzLmN1cnNvci5mcm9tKTtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSBmaW5kTWluSW5kZXgodGhpcy5hY3RpdmUsIHRoaXMuYWN0aXZlVG8pO1xuICAgIH1cbiAgICAvLyBBZnRlciBjYWxsaW5nIHRoaXMsIGlmIGB0aGlzLnBvaW50YCAhPSBudWxsLCB0aGUgbmV4dCByYW5nZSBpcyBhXG4gICAgLy8gcG9pbnQuIE90aGVyd2lzZSwgaXQncyBhIHJlZ3VsYXIgcmFuZ2UsIGNvdmVyZWQgYnkgYHRoaXMuYWN0aXZlYC5cbiAgICBuZXh0KCkge1xuICAgICAgICBsZXQgZnJvbSA9IHRoaXMudG8sIHdhc1BvaW50ID0gdGhpcy5wb2ludDtcbiAgICAgICAgdGhpcy5wb2ludCA9IG51bGw7XG4gICAgICAgIGxldCB0cmFja09wZW4gPSB0aGlzLm9wZW5TdGFydCA8IDAgPyBbXSA6IG51bGw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBhID0gdGhpcy5taW5BY3RpdmU7XG4gICAgICAgICAgICBpZiAoYSA+IC0xICYmICh0aGlzLmFjdGl2ZVRvW2FdIC0gdGhpcy5jdXJzb3IuZnJvbSB8fCB0aGlzLmFjdGl2ZVthXS5lbmRTaWRlIC0gdGhpcy5jdXJzb3Iuc3RhcnRTaWRlKSA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVUb1thXSA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuYWN0aXZlVG9bYV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kU2lkZSA9IHRoaXMuYWN0aXZlW2FdLmVuZFNpZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZShhKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tPcGVuKVxuICAgICAgICAgICAgICAgICAgICByZW1vdmUodHJhY2tPcGVuLCBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmN1cnNvci52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmVuZFNpZGUgPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJzb3IuZnJvbSA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5jdXJzb3IuZnJvbTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSB0aGlzLmN1cnNvci5zdGFydFNpZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFZhbCA9IHRoaXMuY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghbmV4dFZhbC5wb2ludCkgeyAvLyBPcGVuaW5nIGEgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRBY3RpdmUodHJhY2tPcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3YXNQb2ludCAmJiB0aGlzLmN1cnNvci50byA9PSB0aGlzLnRvICYmIHRoaXMuY3Vyc29yLmZyb20gPCB0aGlzLmN1cnNvci50bykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYW55IG5vbi1lbXB0eSBwb2ludHMgdGhhdCBlbmQgcHJlY2lzZWx5IGF0IHRoZSBlbmQgb2YgdGhlIHByZXYgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gTmV3IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnQgPSBuZXh0VmFsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50RnJvbSA9IHRoaXMuY3Vyc29yLmZyb207XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRSYW5rID0gdGhpcy5jdXJzb3IucmFuaztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuY3Vyc29yLnRvO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSBuZXh0VmFsLmVuZFNpZGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkKHRoaXMudG8sIHRoaXMuZW5kU2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2tPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdHJhY2tPcGVuLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiB0cmFja09wZW5baV0gPCBmcm9tOyBpLS0pXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhY3RpdmVGb3JQb2ludCh0bykge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5hY3RpdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVJhbmtbaV0gPCB0aGlzLnBvaW50UmFuaylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVRvW2ldID4gdG8gfHwgdGhpcy5hY3RpdmVUb1tpXSA9PSB0byAmJiB0aGlzLmFjdGl2ZVtpXS5lbmRTaWRlID49IHRoaXMucG9pbnQuZW5kU2lkZSlcbiAgICAgICAgICAgICAgICBhY3RpdmUucHVzaCh0aGlzLmFjdGl2ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGl2ZS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIG9wZW5FbmQodG8pIHtcbiAgICAgICAgbGV0IG9wZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5hY3RpdmVUby5sZW5ndGggLSAxOyBpID49IDAgJiYgdGhpcy5hY3RpdmVUb1tpXSA+IHRvOyBpLS0pXG4gICAgICAgICAgICBvcGVuKys7XG4gICAgICAgIHJldHVybiBvcGVuO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgc3RhcnRBLCBiLCBzdGFydEIsIGxlbmd0aCwgY29tcGFyYXRvcikge1xuICAgIGEuZ290byhzdGFydEEpO1xuICAgIGIuZ290byhzdGFydEIpO1xuICAgIGxldCBlbmRCID0gc3RhcnRCICsgbGVuZ3RoO1xuICAgIGxldCBwb3MgPSBzdGFydEIsIGRQb3MgPSBzdGFydEIgLSBzdGFydEE7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgZGlmZiA9IChhLnRvICsgZFBvcykgLSBiLnRvIHx8IGEuZW5kU2lkZSAtIGIuZW5kU2lkZTtcbiAgICAgICAgbGV0IGVuZCA9IGRpZmYgPCAwID8gYS50byArIGRQb3MgOiBiLnRvLCBjbGlwRW5kID0gTWF0aC5taW4oZW5kLCBlbmRCKTtcbiAgICAgICAgaWYgKGEucG9pbnQgfHwgYi5wb2ludCkge1xuICAgICAgICAgICAgaWYgKCEoYS5wb2ludCAmJiBiLnBvaW50ICYmIChhLnBvaW50ID09IGIucG9pbnQgfHwgYS5wb2ludC5lcShiLnBvaW50KSkgJiZcbiAgICAgICAgICAgICAgICBzYW1lVmFsdWVzKGEuYWN0aXZlRm9yUG9pbnQoYS50byArIGRQb3MpLCBiLmFjdGl2ZUZvclBvaW50KGIudG8pKSkpXG4gICAgICAgICAgICAgICAgY29tcGFyYXRvci5jb21wYXJlUG9pbnQocG9zLCBjbGlwRW5kLCBhLnBvaW50LCBiLnBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjbGlwRW5kID4gcG9zICYmICFzYW1lVmFsdWVzKGEuYWN0aXZlLCBiLmFjdGl2ZSkpXG4gICAgICAgICAgICAgICAgY29tcGFyYXRvci5jb21wYXJlUmFuZ2UocG9zLCBjbGlwRW5kLCBhLmFjdGl2ZSwgYi5hY3RpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPiBlbmRCKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgaWYgKGRpZmYgPD0gMClcbiAgICAgICAgICAgIGEubmV4dCgpO1xuICAgICAgICBpZiAoZGlmZiA+PSAwKVxuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZVZhbHVlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYVtpXSAhPSBiW2ldICYmICFhW2ldLmVxKGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBpbmRleCkge1xuICAgIGZvciAobGV0IGkgPSBpbmRleCwgZSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPCBlOyBpKyspXG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSArIDFdO1xuICAgIGFycmF5LnBvcCgpO1xufVxuZnVuY3Rpb24gaW5zZXJ0KGFycmF5LCBpbmRleCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSBpbmRleDsgaS0tKVxuICAgICAgICBhcnJheVtpICsgMV0gPSBhcnJheVtpXTtcbiAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRNaW5JbmRleCh2YWx1ZSwgYXJyYXkpIHtcbiAgICBsZXQgZm91bmQgPSAtMSwgZm91bmRQb3MgPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICgoYXJyYXlbaV0gLSBmb3VuZFBvcyB8fCB2YWx1ZVtpXS5lbmRTaWRlIC0gdmFsdWVbZm91bmRdLmVuZFNpZGUpIDwgMCkge1xuICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgZm91bmRQb3MgPSBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cblxuLyoqXG5Db3VudCB0aGUgY29sdW1uIHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBvZmZzZXQgaW50byB0aGUgc3RyaW5nLFxudGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuXG4qL1xuZnVuY3Rpb24gY291bnRDb2x1bW4oc3RyaW5nLCB0YWJTaXplLCB0byA9IHN0cmluZy5sZW5ndGgpIHtcbiAgICBsZXQgbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0bzspIHtcbiAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkpIHtcbiAgICAgICAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuKys7XG4gICAgICAgICAgICBpID0gZmluZENsdXN0ZXJCcmVhayhzdHJpbmcsIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuLyoqXG5GaW5kIHRoZSBvZmZzZXQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gY29sdW1uIHBvc2l0aW9uIGluIGFcbnN0cmluZywgdGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuIEJ5XG5kZWZhdWx0LCB0aGUgc3RyaW5nIGxlbmd0aCBpcyByZXR1cm5lZCB3aGVuIGl0IGlzIHRvbyBzaG9ydCB0b1xucmVhY2ggdGhlIGNvbHVtbi4gUGFzcyBgc3RyaWN0YCB0cnVlIHRvIG1ha2UgaXQgcmV0dXJuIC0xIGluIHRoYXRcbnNpdHVhdGlvbi5cbiovXG5mdW5jdGlvbiBmaW5kQ29sdW1uKHN0cmluZywgY29sLCB0YWJTaXplLCBzdHJpY3QpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IDA7Oykge1xuICAgICAgICBpZiAobiA+PSBjb2wpXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgaWYgKGkgPT0gc3RyaW5nLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBuICs9IHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkgPyB0YWJTaXplIC0gKG4gJSB0YWJTaXplKSA6IDE7XG4gICAgICAgIGkgPSBmaW5kQ2x1c3RlckJyZWFrKHN0cmluZywgaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpY3QgPT09IHRydWUgPyAtMSA6IHN0cmluZy5sZW5ndGg7XG59XG5cbmV4cG9ydCB7IEFubm90YXRpb24sIEFubm90YXRpb25UeXBlLCBDaGFuZ2VEZXNjLCBDaGFuZ2VTZXQsIENoYXJDYXRlZ29yeSwgQ29tcGFydG1lbnQsIEVkaXRvclNlbGVjdGlvbiwgRWRpdG9yU3RhdGUsIEZhY2V0LCBMaW5lLCBNYXBNb2RlLCBQcmVjLCBSYW5nZSwgUmFuZ2VTZXQsIFJhbmdlU2V0QnVpbGRlciwgUmFuZ2VWYWx1ZSwgU2VsZWN0aW9uUmFuZ2UsIFN0YXRlRWZmZWN0LCBTdGF0ZUVmZmVjdFR5cGUsIFN0YXRlRmllbGQsIFRleHQsIFRyYW5zYWN0aW9uLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgY29tYmluZUNvbmZpZywgY291bnRDb2x1bW4sIGZpbmRDbHVzdGVyQnJlYWssIGZpbmRDb2x1bW4sIGZyb21Db2RlUG9pbnQgfTtcbiIsICJjb25zdCBDID0gXCJcXHUwMzdjXCJcbmNvbnN0IENPVU5UID0gdHlwZW9mIFN5bWJvbCA9PSBcInVuZGVmaW5lZFwiID8gXCJfX1wiICsgQyA6IFN5bWJvbC5mb3IoQylcbmNvbnN0IFNFVCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJ1bmRlZmluZWRcIiA/IFwiX19zdHlsZVNldFwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWU4KSA6IFN5bWJvbChcInN0eWxlU2V0XCIpXG5jb25zdCB0b3AgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9XG5cbi8vIDo6IC0gU3R5bGUgbW9kdWxlcyBlbmNhcHN1bGF0ZSBhIHNldCBvZiBDU1MgcnVsZXMgZGVmaW5lZCBmcm9tXG4vLyBKYXZhU2NyaXB0LiBUaGVpciBkZWZpbml0aW9ucyBhcmUgb25seSBhdmFpbGFibGUgaW4gYSBnaXZlbiBET01cbi8vIHJvb3QgYWZ0ZXIgaXQgaGFzIGJlZW4gX21vdW50ZWRfIHRoZXJlIHdpdGggYFN0eWxlTW9kdWxlLm1vdW50YC5cbi8vXG4vLyBTdHlsZSBtb2R1bGVzIHNob3VsZCBiZSBjcmVhdGVkIG9uY2UgYW5kIHN0b3JlZCBzb21ld2hlcmUsIGFzXG4vLyBvcHBvc2VkIHRvIHJlLWNyZWF0aW5nIHRoZW0gZXZlcnkgdGltZSB5b3UgbmVlZCB0aGVtLiBUaGUgYW1vdW50IG9mXG4vLyBDU1MgcnVsZXMgZ2VuZXJhdGVkIGZvciBhIGdpdmVuIERPTSByb290IGlzIGJvdW5kZWQgYnkgdGhlIGFtb3VudFxuLy8gb2Ygc3R5bGUgbW9kdWxlcyB0aGF0IHdlcmUgdXNlZC4gU28gdG8gYXZvaWQgbGVha2luZyBydWxlcywgZG9uJ3Rcbi8vIGNyZWF0ZSB0aGVzZSBkeW5hbWljYWxseSwgYnV0IHRyZWF0IHRoZW0gYXMgb25lLXRpbWUgYWxsb2NhdGlvbnMuXG5leHBvcnQgY2xhc3MgU3R5bGVNb2R1bGUge1xuICAvLyA6OiAoT2JqZWN0PFN0eWxlPiwgP3tmaW5pc2g6ID8oc3RyaW5nKSBcdTIxOTIgc3RyaW5nfSlcbiAgLy8gQ3JlYXRlIGEgc3R5bGUgbW9kdWxlIGZyb20gdGhlIGdpdmVuIHNwZWMuXG4gIC8vXG4gIC8vIFdoZW4gYGZpbmlzaGAgaXMgZ2l2ZW4sIGl0IGlzIGNhbGxlZCBvbiByZWd1bGFyIChub24tYEBgKVxuICAvLyBzZWxlY3RvcnMgKGFmdGVyIGAmYCBleHBhbnNpb24pIHRvIGNvbXB1dGUgdGhlIGZpbmFsIHNlbGVjdG9yLlxuICBjb25zdHJ1Y3RvcihzcGVjLCBvcHRpb25zKSB7XG4gICAgdGhpcy5ydWxlcyA9IFtdXG4gICAgbGV0IHtmaW5pc2h9ID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgZnVuY3Rpb24gc3BsaXRTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIC9eQC8udGVzdChzZWxlY3RvcikgPyBbc2VsZWN0b3JdIDogc2VsZWN0b3Iuc3BsaXQoLyxcXHMqLylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXIoc2VsZWN0b3JzLCBzcGVjLCB0YXJnZXQsIGlzS2V5ZnJhbWVzKSB7XG4gICAgICBsZXQgbG9jYWwgPSBbXSwgaXNBdCA9IC9eQChcXHcrKVxcYi8uZXhlYyhzZWxlY3RvcnNbMF0pLCBrZXlmcmFtZXMgPSBpc0F0ICYmIGlzQXRbMV0gPT0gXCJrZXlmcmFtZXNcIlxuICAgICAgaWYgKGlzQXQgJiYgc3BlYyA9PSBudWxsKSByZXR1cm4gdGFyZ2V0LnB1c2goc2VsZWN0b3JzWzBdICsgXCI7XCIpXG4gICAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gc3BlY1twcm9wXVxuICAgICAgICBpZiAoLyYvLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICByZW5kZXIocHJvcC5zcGxpdCgvLFxccyovKS5tYXAocGFydCA9PiBzZWxlY3RvcnMubWFwKHNlbCA9PiBwYXJ0LnJlcGxhY2UoLyYvLCBzZWwpKSkucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSksXG4gICAgICAgICAgICAgICAgIHZhbHVlLCB0YXJnZXQpXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBpZiAoIWlzQXQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgKFwiICsgcHJvcCArIFwiKSBzaG91bGQgYmUgYSBwcmltaXRpdmUgdmFsdWUuXCIpXG4gICAgICAgICAgcmVuZGVyKHNwbGl0U2VsZWN0b3IocHJvcCksIHZhbHVlLCBsb2NhbCwga2V5ZnJhbWVzKVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBsb2NhbC5wdXNoKHByb3AucmVwbGFjZSgvXy4qLywgXCJcIikucmVwbGFjZSgvW0EtWl0vZywgbCA9PiBcIi1cIiArIGwudG9Mb3dlckNhc2UoKSkgKyBcIjogXCIgKyB2YWx1ZSArIFwiO1wiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG9jYWwubGVuZ3RoIHx8IGtleWZyYW1lcykge1xuICAgICAgICB0YXJnZXQucHVzaCgoZmluaXNoICYmICFpc0F0ICYmICFpc0tleWZyYW1lcyA/IHNlbGVjdG9ycy5tYXAoZmluaXNoKSA6IHNlbGVjdG9ycykuam9pbihcIiwgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCIge1wiICsgbG9jYWwuam9pbihcIiBcIikgKyBcIn1cIilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpIHJlbmRlcihzcGxpdFNlbGVjdG9yKHByb3ApLCBzcGVjW3Byb3BdLCB0aGlzLnJ1bGVzKVxuICB9XG5cbiAgLy8gOjogKCkgXHUyMTkyIHN0cmluZ1xuICAvLyBSZXR1cm5zIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1vZHVsZSdzIENTUyBydWxlcy5cbiAgZ2V0UnVsZXMoKSB7IHJldHVybiB0aGlzLnJ1bGVzLmpvaW4oXCJcXG5cIikgfVxuXG4gIC8vIDo6ICgpIFx1MjE5MiBzdHJpbmdcbiAgLy8gR2VuZXJhdGUgYSBuZXcgdW5pcXVlIENTUyBjbGFzcyBuYW1lLlxuICBzdGF0aWMgbmV3TmFtZSgpIHtcbiAgICBsZXQgaWQgPSB0b3BbQ09VTlRdIHx8IDFcbiAgICB0b3BbQ09VTlRdID0gaWQgKyAxXG4gICAgcmV0dXJuIEMgKyBpZC50b1N0cmluZygzNilcbiAgfVxuXG4gIC8vIDo6ICh1bmlvbjxEb2N1bWVudCwgU2hhZG93Um9vdD4sIHVuaW9uPFtTdHlsZU1vZHVsZV0sIFN0eWxlTW9kdWxlPilcbiAgLy9cbiAgLy8gTW91bnQgdGhlIGdpdmVuIHNldCBvZiBtb2R1bGVzIGluIHRoZSBnaXZlbiBET00gcm9vdCwgd2hpY2ggZW5zdXJlc1xuICAvLyB0aGF0IHRoZSBDU1MgcnVsZXMgZGVmaW5lZCBieSB0aGUgbW9kdWxlIGFyZSBhdmFpbGFibGUgaW4gdGhhdFxuICAvLyBjb250ZXh0LlxuICAvL1xuICAvLyBSdWxlcyBhcmUgb25seSBhZGRlZCB0byB0aGUgZG9jdW1lbnQgb25jZSBwZXIgcm9vdC5cbiAgLy9cbiAgLy8gUnVsZSBvcmRlciB3aWxsIGZvbGxvdyB0aGUgb3JkZXIgb2YgdGhlIG1vZHVsZXMsIHNvIHRoYXQgcnVsZXMgZnJvbVxuICAvLyBtb2R1bGVzIGxhdGVyIGluIHRoZSBhcnJheSB0YWtlIHByZWNlZGVuY2Ugb2YgdGhvc2UgZnJvbSBlYXJsaWVyXG4gIC8vIG1vZHVsZXMuIElmIHlvdSBjYWxsIHRoaXMgZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMgZm9yIHRoZSBzYW1lIHJvb3RcbiAgLy8gaW4gYSB3YXkgdGhhdCBjaGFuZ2VzIHRoZSBvcmRlciBvZiBhbHJlYWR5IG1vdW50ZWQgbW9kdWxlcywgdGhlIG9sZFxuICAvLyBvcmRlciB3aWxsIGJlIGNoYW5nZWQuXG4gIHN0YXRpYyBtb3VudChyb290LCBtb2R1bGVzKSB7XG4gICAgKHJvb3RbU0VUXSB8fCBuZXcgU3R5bGVTZXQocm9vdCkpLm1vdW50KEFycmF5LmlzQXJyYXkobW9kdWxlcykgPyBtb2R1bGVzIDogW21vZHVsZXNdKVxuICB9XG59XG5cbmxldCBhZG9wdGVkU2V0ID0gbnVsbFxuXG5jbGFzcyBTdHlsZVNldCB7XG4gIGNvbnN0cnVjdG9yKHJvb3QpIHtcbiAgICBpZiAoIXJvb3QuaGVhZCAmJiByb290LmFkb3B0ZWRTdHlsZVNoZWV0cyAmJiB0eXBlb2YgQ1NTU3R5bGVTaGVldCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoYWRvcHRlZFNldCkge1xuICAgICAgICByb290LmFkb3B0ZWRTdHlsZVNoZWV0cyA9IFthZG9wdGVkU2V0LnNoZWV0XS5jb25jYXQocm9vdC5hZG9wdGVkU3R5bGVTaGVldHMpXG4gICAgICAgIHJldHVybiByb290W1NFVF0gPSBhZG9wdGVkU2V0XG4gICAgICB9XG4gICAgICB0aGlzLnNoZWV0ID0gbmV3IENTU1N0eWxlU2hlZXRcbiAgICAgIHJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzID0gW3RoaXMuc2hlZXRdLmNvbmNhdChyb290LmFkb3B0ZWRTdHlsZVNoZWV0cylcbiAgICAgIGFkb3B0ZWRTZXQgPSB0aGlzXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3R5bGVUYWcgPSAocm9vdC5vd25lckRvY3VtZW50IHx8IHJvb3QpLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKVxuICAgICAgbGV0IHRhcmdldCA9IHJvb3QuaGVhZCB8fCByb290XG4gICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuc3R5bGVUYWcsIHRhcmdldC5maXJzdENoaWxkKVxuICAgIH1cbiAgICB0aGlzLm1vZHVsZXMgPSBbXVxuICAgIHJvb3RbU0VUXSA9IHRoaXNcbiAgfVxuXG4gIG1vdW50KG1vZHVsZXMpIHtcbiAgICBsZXQgc2hlZXQgPSB0aGlzLnNoZWV0XG4gICAgbGV0IHBvcyA9IDAgLyogQ3VycmVudCBydWxlIG9mZnNldCAqLywgaiA9IDAgLyogSW5kZXggaW50byB0aGlzLm1vZHVsZXMgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBtb2QgPSBtb2R1bGVzW2ldLCBpbmRleCA9IHRoaXMubW9kdWxlcy5pbmRleE9mKG1vZClcbiAgICAgIGlmIChpbmRleCA8IGogJiYgaW5kZXggPiAtMSkgeyAvLyBPcmRlcmluZyBjb25mbGljdFxuICAgICAgICB0aGlzLm1vZHVsZXMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICBqLS1cbiAgICAgICAgaW5kZXggPSAtMVxuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICAgIHRoaXMubW9kdWxlcy5zcGxpY2UoaisrLCAwLCBtb2QpXG4gICAgICAgIGlmIChzaGVldCkgZm9yIChsZXQgayA9IDA7IGsgPCBtb2QucnVsZXMubGVuZ3RoOyBrKyspXG4gICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShtb2QucnVsZXNba10sIHBvcysrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGogPCBpbmRleCkgcG9zICs9IHRoaXMubW9kdWxlc1tqKytdLnJ1bGVzLmxlbmd0aFxuICAgICAgICBwb3MgKz0gbW9kLnJ1bGVzLmxlbmd0aFxuICAgICAgICBqKytcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNoZWV0KSB7XG4gICAgICBsZXQgdGV4dCA9IFwiXCJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tb2R1bGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICB0ZXh0ICs9IHRoaXMubW9kdWxlc1tpXS5nZXRSdWxlcygpICsgXCJcXG5cIlxuICAgICAgdGhpcy5zdHlsZVRhZy50ZXh0Q29udGVudCA9IHRleHRcbiAgICB9XG4gIH1cbn1cblxuLy8gU3R5bGU6Ok9iamVjdDx1bmlvbjxTdHlsZSxzdHJpbmc+PlxuLy9cbi8vIEEgc3R5bGUgaXMgYW4gb2JqZWN0IHRoYXQsIGluIHRoZSBzaW1wbGUgY2FzZSwgbWFwcyBDU1MgcHJvcGVydHlcbi8vIG5hbWVzIHRvIHN0cmluZ3MgaG9sZGluZyB0aGVpciB2YWx1ZXMsIGFzIGluIGB7Y29sb3I6IFwicmVkXCIsXG4vLyBmb250V2VpZ2h0OiBcImJvbGRcIn1gLiBUaGUgcHJvcGVydHkgbmFtZXMgY2FuIGJlIGdpdmVuIGluXG4vLyBjYW1lbC1jYXNlXHUyMDE0dGhlIGxpYnJhcnkgd2lsbCBpbnNlcnQgYSBkYXNoIGJlZm9yZSBjYXBpdGFsIGxldHRlcnNcbi8vIHdoZW4gY29udmVydGluZyB0aGVtIHRvIENTUy5cbi8vXG4vLyBJZiB5b3UgaW5jbHVkZSBhbiB1bmRlcnNjb3JlIGluIGEgcHJvcGVydHkgbmFtZSwgaXQgYW5kIGV2ZXJ5dGhpbmdcbi8vIGFmdGVyIGl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBvdXRwdXQsIHdoaWNoIGNhbiBiZSB1c2VmdWwgd2hlblxuLy8gcHJvdmlkaW5nIGEgcHJvcGVydHkgbXVsdGlwbGUgdGltZXMsIGZvciBicm93c2VyIGNvbXBhdGliaWxpdHlcbi8vIHJlYXNvbnMuXG4vL1xuLy8gQSBwcm9wZXJ0eSBpbiBhIHN0eWxlIG9iamVjdCBjYW4gYWxzbyBiZSBhIHN1Yi1zZWxlY3Rvciwgd2hpY2hcbi8vIGV4dGVuZHMgdGhlIGN1cnJlbnQgY29udGV4dCB0byBhZGQgYSBwc2V1ZG8tc2VsZWN0b3Igb3IgYSBjaGlsZFxuLy8gc2VsZWN0b3IuIFN1Y2ggYSBwcm9wZXJ0eSBzaG91bGQgY29udGFpbiBhIGAmYCBjaGFyYWN0ZXIsIHdoaWNoXG4vLyB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBjdXJyZW50IHNlbGVjdG9yLiBGb3IgZXhhbXBsZSBge1wiJjpiZWZvcmVcIjpcbi8vIHtjb250ZW50OiAnXCJoaVwiJ319YC4gU3ViLXNlbGVjdG9ycyBhbmQgcmVndWxhciBwcm9wZXJ0aWVzIGNhblxuLy8gZnJlZWx5IGJlIG1peGVkIGluIGEgZ2l2ZW4gb2JqZWN0LiBBbnkgcHJvcGVydHkgY29udGFpbmluZyBhIGAmYCBpc1xuLy8gYXNzdW1lZCB0byBiZSBhIHN1Yi1zZWxlY3Rvci5cbi8vXG4vLyBGaW5hbGx5LCBhIHByb3BlcnR5IGNhbiBzcGVjaWZ5IGFuIEAtYmxvY2sgdG8gYmUgd3JhcHBlZCBhcm91bmQgdGhlXG4vLyBzdHlsZXMgZGVmaW5lZCBpbnNpZGUgdGhlIG9iamVjdCB0aGF0J3MgdGhlIHByb3BlcnR5J3MgdmFsdWUuIEZvclxuLy8gZXhhbXBsZSB0byBjcmVhdGUgYSBtZWRpYSBxdWVyeSB5b3UgY2FuIGRvIGB7XCJAbWVkaWEgc2NyZWVuIGFuZFxuLy8gKG1pbi13aWR0aDogNDAwcHgpXCI6IHsuLi59fWAuXG4iLCAiZXhwb3J0IHZhciBiYXNlID0ge1xuICA4OiBcIkJhY2tzcGFjZVwiLFxuICA5OiBcIlRhYlwiLFxuICAxMDogXCJFbnRlclwiLFxuICAxMjogXCJOdW1Mb2NrXCIsXG4gIDEzOiBcIkVudGVyXCIsXG4gIDE2OiBcIlNoaWZ0XCIsXG4gIDE3OiBcIkNvbnRyb2xcIixcbiAgMTg6IFwiQWx0XCIsXG4gIDIwOiBcIkNhcHNMb2NrXCIsXG4gIDI3OiBcIkVzY2FwZVwiLFxuICAzMjogXCIgXCIsXG4gIDMzOiBcIlBhZ2VVcFwiLFxuICAzNDogXCJQYWdlRG93blwiLFxuICAzNTogXCJFbmRcIixcbiAgMzY6IFwiSG9tZVwiLFxuICAzNzogXCJBcnJvd0xlZnRcIixcbiAgMzg6IFwiQXJyb3dVcFwiLFxuICAzOTogXCJBcnJvd1JpZ2h0XCIsXG4gIDQwOiBcIkFycm93RG93blwiLFxuICA0NDogXCJQcmludFNjcmVlblwiLFxuICA0NTogXCJJbnNlcnRcIixcbiAgNDY6IFwiRGVsZXRlXCIsXG4gIDU5OiBcIjtcIixcbiAgNjE6IFwiPVwiLFxuICA5MTogXCJNZXRhXCIsXG4gIDkyOiBcIk1ldGFcIixcbiAgMTA2OiBcIipcIixcbiAgMTA3OiBcIitcIixcbiAgMTA4OiBcIixcIixcbiAgMTA5OiBcIi1cIixcbiAgMTEwOiBcIi5cIixcbiAgMTExOiBcIi9cIixcbiAgMTQ0OiBcIk51bUxvY2tcIixcbiAgMTQ1OiBcIlNjcm9sbExvY2tcIixcbiAgMTYwOiBcIlNoaWZ0XCIsXG4gIDE2MTogXCJTaGlmdFwiLFxuICAxNjI6IFwiQ29udHJvbFwiLFxuICAxNjM6IFwiQ29udHJvbFwiLFxuICAxNjQ6IFwiQWx0XCIsXG4gIDE2NTogXCJBbHRcIixcbiAgMTczOiBcIi1cIixcbiAgMTg2OiBcIjtcIixcbiAgMTg3OiBcIj1cIixcbiAgMTg4OiBcIixcIixcbiAgMTg5OiBcIi1cIixcbiAgMTkwOiBcIi5cIixcbiAgMTkxOiBcIi9cIixcbiAgMTkyOiBcImBcIixcbiAgMjE5OiBcIltcIixcbiAgMjIwOiBcIlxcXFxcIixcbiAgMjIxOiBcIl1cIixcbiAgMjIyOiBcIidcIlxufVxuXG5leHBvcnQgdmFyIHNoaWZ0ID0ge1xuICA0ODogXCIpXCIsXG4gIDQ5OiBcIiFcIixcbiAgNTA6IFwiQFwiLFxuICA1MTogXCIjXCIsXG4gIDUyOiBcIiRcIixcbiAgNTM6IFwiJVwiLFxuICA1NDogXCJeXCIsXG4gIDU1OiBcIiZcIixcbiAgNTY6IFwiKlwiLFxuICA1NzogXCIoXCIsXG4gIDU5OiBcIjpcIixcbiAgNjE6IFwiK1wiLFxuICAxNzM6IFwiX1wiLFxuICAxODY6IFwiOlwiLFxuICAxODc6IFwiK1wiLFxuICAxODg6IFwiPFwiLFxuICAxODk6IFwiX1wiLFxuICAxOTA6IFwiPlwiLFxuICAxOTE6IFwiP1wiLFxuICAxOTI6IFwiflwiLFxuICAyMTk6IFwie1wiLFxuICAyMjA6IFwifFwiLFxuICAyMjE6IFwifVwiLFxuICAyMjI6IFwiXFxcIlwiXG59XG5cbnZhciBjaHJvbWUgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL0Nocm9tZVxcLyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVxudmFyIGdlY2tvID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9HZWNrb1xcL1xcZCsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG52YXIgaWUgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01TSUUgXFxkfFRyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpXG52YXIgYnJva2VuTW9kaWZpZXJOYW1lcyA9IG1hYyB8fCBjaHJvbWUgJiYgK2Nocm9tZVsxXSA8IDU3XG5cbi8vIEZpbGwgaW4gdGhlIGRpZ2l0IGtleXNcbmZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykgYmFzZVs0OCArIGldID0gYmFzZVs5NiArIGldID0gU3RyaW5nKGkpXG5cbi8vIFRoZSBmdW5jdGlvbiBrZXlzXG5mb3IgKHZhciBpID0gMTsgaSA8PSAyNDsgaSsrKSBiYXNlW2kgKyAxMTFdID0gXCJGXCIgKyBpXG5cbi8vIEFuZCB0aGUgYWxwaGFiZXRpYyBrZXlzXG5mb3IgKHZhciBpID0gNjU7IGkgPD0gOTA7IGkrKykge1xuICBiYXNlW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpICsgMzIpXG4gIHNoaWZ0W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKVxufVxuXG4vLyBGb3IgZWFjaCBjb2RlIHRoYXQgZG9lc24ndCBoYXZlIGEgc2hpZnQtZXF1aXZhbGVudCwgY29weSB0aGUgYmFzZSBuYW1lXG5mb3IgKHZhciBjb2RlIGluIGJhc2UpIGlmICghc2hpZnQuaGFzT3duUHJvcGVydHkoY29kZSkpIHNoaWZ0W2NvZGVdID0gYmFzZVtjb2RlXVxuXG5leHBvcnQgZnVuY3Rpb24ga2V5TmFtZShldmVudCkge1xuICB2YXIgaWdub3JlS2V5ID0gYnJva2VuTW9kaWZpZXJOYW1lcyAmJiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSkgfHxcbiAgICBpZSAmJiBldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXkgJiYgZXZlbnQua2V5Lmxlbmd0aCA9PSAxIHx8XG4gICAgZXZlbnQua2V5ID09IFwiVW5pZGVudGlmaWVkXCJcbiAgdmFyIG5hbWUgPSAoIWlnbm9yZUtleSAmJiBldmVudC5rZXkpIHx8XG4gICAgKGV2ZW50LnNoaWZ0S2V5ID8gc2hpZnQgOiBiYXNlKVtldmVudC5rZXlDb2RlXSB8fFxuICAgIGV2ZW50LmtleSB8fCBcIlVuaWRlbnRpZmllZFwiXG4gIC8vIEVkZ2Ugc29tZXRpbWVzIHByb2R1Y2VzIHdyb25nIG5hbWVzIChJc3N1ZSAjMylcbiAgaWYgKG5hbWUgPT0gXCJFc2NcIikgbmFtZSA9IFwiRXNjYXBlXCJcbiAgaWYgKG5hbWUgPT0gXCJEZWxcIikgbmFtZSA9IFwiRGVsZXRlXCJcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvODg2MDU3MS9cbiAgaWYgKG5hbWUgPT0gXCJMZWZ0XCIpIG5hbWUgPSBcIkFycm93TGVmdFwiXG4gIGlmIChuYW1lID09IFwiVXBcIikgbmFtZSA9IFwiQXJyb3dVcFwiXG4gIGlmIChuYW1lID09IFwiUmlnaHRcIikgbmFtZSA9IFwiQXJyb3dSaWdodFwiXG4gIGlmIChuYW1lID09IFwiRG93blwiKSBuYW1lID0gXCJBcnJvd0Rvd25cIlxuICByZXR1cm4gbmFtZVxufVxuIiwgImltcG9ydCB7IFRleHQsIFJhbmdlU2V0LCBNYXBNb2RlLCBSYW5nZVZhbHVlLCBGYWNldCwgU3RhdGVFZmZlY3QsIENoYW5nZVNldCwgZmluZENsdXN0ZXJCcmVhaywgRWRpdG9yU2VsZWN0aW9uLCBFZGl0b3JTdGF0ZSwgZmluZENvbHVtbiwgQ2hhckNhdGVnb3J5LCBBbm5vdGF0aW9uLCBUcmFuc2FjdGlvbiwgUHJlYywgY29kZVBvaW50QXQsIGNvZGVQb2ludFNpemUsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQsIFJhbmdlU2V0QnVpbGRlciwgY291bnRDb2x1bW4gfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBTdHlsZU1vZHVsZSB9IGZyb20gJ3N0eWxlLW1vZCc7XG5pbXBvcnQgeyBrZXlOYW1lLCBiYXNlLCBzaGlmdCB9IGZyb20gJ3czYy1rZXluYW1lJztcblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKHJvb3QpIHtcbiAgICBsZXQgdGFyZ2V0O1xuICAgIC8vIEJyb3dzZXJzIGRpZmZlciBvbiB3aGV0aGVyIHNoYWRvdyByb290cyBoYXZlIGEgZ2V0U2VsZWN0aW9uXG4gICAgLy8gbWV0aG9kLiBJZiBpdCBleGlzdHMsIHVzZSB0aGF0LCBvdGhlcndpc2UsIGNhbGwgaXQgb24gdGhlXG4gICAgLy8gZG9jdW1lbnQuXG4gICAgaWYgKHJvb3Qubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgdGFyZ2V0ID0gcm9vdC5nZXRTZWxlY3Rpb24gPyByb290IDogcm9vdC5vd25lckRvY3VtZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFyZ2V0ID0gcm9vdDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldC5nZXRTZWxlY3Rpb24oKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zKGRvbSwgbm9kZSkge1xuICAgIHJldHVybiBub2RlID8gZG9tID09IG5vZGUgfHwgZG9tLmNvbnRhaW5zKG5vZGUubm9kZVR5cGUgIT0gMSA/IG5vZGUucGFyZW50Tm9kZSA6IG5vZGUpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBkZWVwQWN0aXZlRWxlbWVudChkb2MpIHtcbiAgICBsZXQgZWx0ID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgd2hpbGUgKGVsdCAmJiBlbHQuc2hhZG93Um9vdClcbiAgICAgICAgZWx0ID0gZWx0LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgICByZXR1cm4gZWx0O1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uKGRvbSwgc2VsZWN0aW9uKSB7XG4gICAgaWYgKCFzZWxlY3Rpb24uYW5jaG9yTm9kZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZpcmVmb3ggd2lsbCByYWlzZSAncGVybWlzc2lvbiBkZW5pZWQnIGVycm9ycyB3aGVuIGFjY2Vzc2luZ1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIG9mIGBzZWwuYW5jaG9yTm9kZWAgd2hlbiBpdCdzIGluIGEgZ2VuZXJhdGVkIENTU1xuICAgICAgICAvLyBlbGVtZW50LlxuICAgICAgICByZXR1cm4gY29udGFpbnMoZG9tLCBzZWxlY3Rpb24uYW5jaG9yTm9kZSk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGllbnRSZWN0c0Zvcihkb20pIHtcbiAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXG4gICAgICAgIHJldHVybiB0ZXh0UmFuZ2UoZG9tLCAwLCBkb20ubm9kZVZhbHVlLmxlbmd0aCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgcmV0dXJuIGRvbS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIFtdO1xufVxuLy8gU2NhbnMgZm9yd2FyZCBhbmQgYmFja3dhcmQgdGhyb3VnaCBET00gcG9zaXRpb25zIGVxdWl2YWxlbnQgdG8gdGhlXG4vLyBnaXZlbiBvbmUgdG8gc2VlIGlmIHRoZSB0d28gYXJlIGluIHRoZSBzYW1lIHBsYWNlIChpLmUuIGFmdGVyIGFcbi8vIHRleHQgbm9kZSB2cyBhdCB0aGUgZW5kIG9mIHRoYXQgdGV4dCBub2RlKVxuZnVuY3Rpb24gaXNFcXVpdmFsZW50UG9zaXRpb24obm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYpIHtcbiAgICByZXR1cm4gdGFyZ2V0Tm9kZSA/IChzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAtMSkgfHxcbiAgICAgICAgc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgMSkpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBkb21JbmRleChub2RlKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOzsgaW5kZXgrKykge1xuICAgICAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59XG5mdW5jdGlvbiBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCBkaXIpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlID09IHRhcmdldE5vZGUgJiYgb2ZmID09IHRhcmdldE9mZilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob2ZmID09IChkaXIgPCAwID8gMCA6IG1heE9mZnNldChub2RlKSkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiRElWXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRvbUluZGV4KG5vZGUpICsgKGRpciA8IDAgPyAwIDogMSk7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmYgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZGlyIDwgMCA/IG1heE9mZnNldChub2RlKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXhPZmZzZXQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuY29uc3QgUmVjdDAgPSB7IGxlZnQ6IDAsIHJpZ2h0OiAwLCB0b3A6IDAsIGJvdHRvbTogMCB9O1xuZnVuY3Rpb24gZmxhdHRlblJlY3QocmVjdCwgbGVmdCkge1xuICAgIGxldCB4ID0gbGVmdCA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQ7XG4gICAgcmV0dXJuIHsgbGVmdDogeCwgcmlnaHQ6IHgsIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC5ib3R0b20gfTtcbn1cbmZ1bmN0aW9uIHdpbmRvd1JlY3Qod2luKSB7XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IHdpbi5pbm5lcldpZHRoLFxuICAgICAgICB0b3A6IDAsIGJvdHRvbTogd2luLmlubmVySGVpZ2h0IH07XG59XG5mdW5jdGlvbiBzY3JvbGxSZWN0SW50b1ZpZXcoZG9tLCByZWN0LCBzaWRlLCB4LCB5LCB4TWFyZ2luLCB5TWFyZ2luLCBsdHIpIHtcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQsIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7KSB7XG4gICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSkgeyAvLyBFbGVtZW50XG4gICAgICAgICAgICBsZXQgYm91bmRpbmcsIHRvcCA9IGN1ciA9PSBkb2MuYm9keTtcbiAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICBib3VuZGluZyA9IHdpbmRvd1JlY3Qod2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXIuc2Nyb2xsSGVpZ2h0IDw9IGN1ci5jbGllbnRIZWlnaHQgJiYgY3VyLnNjcm9sbFdpZHRoIDw9IGN1ci5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSBjdXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHNjcm9sbGJhciB3aWR0aCBpc24ndCBpbmNsdWRlZCBpbiB0aGUgcmVjdGFuZ2xlXG4gICAgICAgICAgICAgICAgYm91bmRpbmcgPSB7IGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QubGVmdCArIGN1ci5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LnRvcCArIGN1ci5jbGllbnRIZWlnaHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtb3ZlWCA9IDAsIG1vdmVZID0gMDtcbiAgICAgICAgICAgIGlmICh5ID09IFwibmVhcmVzdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3QudG9wIDwgYm91bmRpbmcudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVZID0gLShib3VuZGluZy50b3AgLSByZWN0LnRvcCArIHlNYXJnaW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA+IDAgJiYgcmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20gKyBtb3ZlWSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyBtb3ZlWSArIHlNYXJnaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgJiYgKHJlY3QudG9wIC0gbW92ZVkpIDwgYm91bmRpbmcudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSAtKGJvdW5kaW5nLnRvcCArIG1vdmVZIC0gcmVjdC50b3AgKyB5TWFyZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdEhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3AsIGJvdW5kaW5nSGVpZ2h0ID0gYm91bmRpbmcuYm90dG9tIC0gYm91bmRpbmcudG9wO1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRUb3AgPSB5ID09IFwiY2VudGVyXCIgJiYgcmVjdEhlaWdodCA8PSBib3VuZGluZ0hlaWdodCA/IHJlY3QudG9wICsgcmVjdEhlaWdodCAvIDIgLSBib3VuZGluZ0hlaWdodCAvIDIgOlxuICAgICAgICAgICAgICAgICAgICB5ID09IFwic3RhcnRcIiB8fCB5ID09IFwiY2VudGVyXCIgJiYgc2lkZSA8IDAgPyByZWN0LnRvcCAtIHlNYXJnaW4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5ib3R0b20gLSBib3VuZGluZ0hlaWdodCArIHlNYXJnaW47XG4gICAgICAgICAgICAgICAgbW92ZVkgPSB0YXJnZXRUb3AgLSBib3VuZGluZy50b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA9PSBcIm5lYXJlc3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVYID0gLShib3VuZGluZy5sZWZ0IC0gcmVjdC5sZWZ0ICsgeE1hcmdpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlID4gMCAmJiByZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQgKyBtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgbW92ZVggKyB4TWFyZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVggPSByZWN0LnJpZ2h0IC0gYm91bmRpbmcucmlnaHQgKyB4TWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgJiYgcmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCArIG1vdmVYKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVggPSAtKGJvdW5kaW5nLmxlZnQgKyBtb3ZlWCAtIHJlY3QubGVmdCArIHhNYXJnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRMZWZ0ID0geCA9PSBcImNlbnRlclwiID8gcmVjdC5sZWZ0ICsgKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpIC8gMiAtIChib3VuZGluZy5yaWdodCAtIGJvdW5kaW5nLmxlZnQpIC8gMiA6XG4gICAgICAgICAgICAgICAgICAgICh4ID09IFwic3RhcnRcIikgPT0gbHRyID8gcmVjdC5sZWZ0IC0geE1hcmdpbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnJpZ2h0IC0gKGJvdW5kaW5nLnJpZ2h0IC0gYm91bmRpbmcubGVmdCkgKyB4TWFyZ2luO1xuICAgICAgICAgICAgICAgIG1vdmVYID0gdGFyZ2V0TGVmdCAtIGJvdW5kaW5nLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW92ZVggfHwgbW92ZVkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbi5zY3JvbGxCeShtb3ZlWCwgbW92ZVkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vdmVkWCA9IDAsIG1vdmVkWSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gY3VyLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxUb3AgKz0gbW92ZVk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZFkgPSBjdXIuc2Nyb2xsVG9wIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVYKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjdXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxMZWZ0ICs9IG1vdmVYO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWRYID0gY3VyLnNjcm9sbExlZnQgLSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiByZWN0LmxlZnQgLSBtb3ZlZFgsIHRvcDogcmVjdC50b3AgLSBtb3ZlZFksXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmVjdC5yaWdodCAtIG1vdmVkWCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIG1vdmVkWSB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZWRYICYmIE1hdGguYWJzKG1vdmVkWCAtIG1vdmVYKSA8IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gXCJuZWFyZXN0XCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlZFkgJiYgTWF0aC5hYnMobW92ZWRZIC0gbW92ZVkpIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBcIm5lYXJlc3RcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubm9kZVR5cGUgPT0gMTEpIHsgLy8gQSBzaGFkb3cgcm9vdFxuICAgICAgICAgICAgY3VyID0gY3VyLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNjcm9sbGFibGVQYXJlbnQoZG9tKSB7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50O1xuICAgIGZvciAobGV0IGN1ciA9IGRvbS5wYXJlbnROb2RlOyBjdXI7KSB7XG4gICAgICAgIGlmIChjdXIgPT0gZG9jLmJvZHkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBpZiAoY3VyLnNjcm9sbEhlaWdodCA+IGN1ci5jbGllbnRIZWlnaHQgfHwgY3VyLnNjcm9sbFdpZHRoID4gY3VyLmNsaWVudFdpZHRoKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxMSkge1xuICAgICAgICAgICAgY3VyID0gY3VyLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNsYXNzIERPTVNlbGVjdGlvblN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSAwO1xuICAgIH1cbiAgICBlcShkb21TZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yTm9kZSA9PSBkb21TZWwuYW5jaG9yTm9kZSAmJiB0aGlzLmFuY2hvck9mZnNldCA9PSBkb21TZWwuYW5jaG9yT2Zmc2V0ICYmXG4gICAgICAgICAgICB0aGlzLmZvY3VzTm9kZSA9PSBkb21TZWwuZm9jdXNOb2RlICYmIHRoaXMuZm9jdXNPZmZzZXQgPT0gZG9tU2VsLmZvY3VzT2Zmc2V0O1xuICAgIH1cbiAgICBzZXRSYW5nZShyYW5nZSkge1xuICAgICAgICB0aGlzLnNldChyYW5nZS5hbmNob3JOb2RlLCByYW5nZS5hbmNob3JPZmZzZXQsIHJhbmdlLmZvY3VzTm9kZSwgcmFuZ2UuZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgICBzZXQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IGFuY2hvck5vZGU7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gYW5jaG9yT2Zmc2V0O1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IGZvY3VzTm9kZTtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IGZvY3VzT2Zmc2V0O1xuICAgIH1cbn1cbmxldCBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gbnVsbDtcbi8vIEZlYXR1cmUtZGV0ZWN0cyBzdXBwb3J0IGZvciAuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KSwgYW5kIHVzZXNcbi8vIGEgZmFsbGJhY2sga2x1ZGdlIHdoZW4gbm90IHN1cHBvcnRlZC5cbmZ1bmN0aW9uIGZvY3VzUHJldmVudFNjcm9sbChkb20pIHtcbiAgICBpZiAoZG9tLnNldEFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGRvbS5zZXRBY3RpdmUoKTsgLy8gaW4gSUVcbiAgICBpZiAocHJldmVudFNjcm9sbFN1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKTtcbiAgICBsZXQgc3RhY2sgPSBbXTtcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgc3RhY2sucHVzaChjdXIsIGN1ci5zY3JvbGxUb3AsIGN1ci5zY3JvbGxMZWZ0KTtcbiAgICAgICAgaWYgKGN1ciA9PSBjdXIub3duZXJEb2N1bWVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCA9PSBudWxsID8ge1xuICAgICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSB7IHByZXZlbnRTY3JvbGw6IHRydWUgfTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCFwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB7XG4gICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZWx0ID0gc3RhY2tbaSsrXSwgdG9wID0gc3RhY2tbaSsrXSwgbGVmdCA9IHN0YWNrW2krK107XG4gICAgICAgICAgICBpZiAoZWx0LnNjcm9sbFRvcCAhPSB0b3ApXG4gICAgICAgICAgICAgICAgZWx0LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgICAgICAgIGlmIChlbHQuc2Nyb2xsTGVmdCAhPSBsZWZ0KVxuICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBzY3JhdGNoUmFuZ2U7XG5mdW5jdGlvbiB0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgbGV0IHJhbmdlID0gc2NyYXRjaFJhbmdlIHx8IChzY3JhdGNoUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpKTtcbiAgICByYW5nZS5zZXRFbmQobm9kZSwgdG8pO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGZyb20pO1xuICAgIHJldHVybiByYW5nZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoS2V5KGVsdCwgbmFtZSwgY29kZSkge1xuICAgIGxldCBvcHRpb25zID0geyBrZXk6IG5hbWUsIGNvZGU6IG5hbWUsIGtleUNvZGU6IGNvZGUsIHdoaWNoOiBjb2RlLCBjYW5jZWxhYmxlOiB0cnVlIH07XG4gICAgbGV0IGRvd24gPSBuZXcgS2V5Ym9hcmRFdmVudChcImtleWRvd25cIiwgb3B0aW9ucyk7XG4gICAgZG93bi5zeW50aGV0aWMgPSB0cnVlO1xuICAgIGVsdC5kaXNwYXRjaEV2ZW50KGRvd24pO1xuICAgIGxldCB1cCA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5dXBcIiwgb3B0aW9ucyk7XG4gICAgdXAuc3ludGhldGljID0gdHJ1ZTtcbiAgICBlbHQuZGlzcGF0Y2hFdmVudCh1cCk7XG4gICAgcmV0dXJuIGRvd24uZGVmYXVsdFByZXZlbnRlZCB8fCB1cC5kZWZhdWx0UHJldmVudGVkO1xufVxuZnVuY3Rpb24gZ2V0Um9vdChub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT0gOSB8fCBub2RlLm5vZGVUeXBlID09IDExICYmIG5vZGUuaG9zdCkpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuYXNzaWduZWRTbG90IHx8IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjbGVhckF0dHJpYnV0ZXMobm9kZSkge1xuICAgIHdoaWxlIChub2RlLmF0dHJpYnV0ZXMubGVuZ3RoKVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZU5vZGUobm9kZS5hdHRyaWJ1dGVzWzBdKTtcbn1cbmZ1bmN0aW9uIGF0RWxlbWVudFN0YXJ0KGRvYywgc2VsZWN0aW9uKSB7XG4gICAgbGV0IG5vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gICAgaWYgKCFub2RlIHx8IHNlbGVjdGlvbi5hbmNob3JOb2RlICE9IG5vZGUgfHwgc2VsZWN0aW9uLmFuY2hvck9mZnNldCAhPSBvZmZzZXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBpZiAocHJldi5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHByZXY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0KG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgPT0gZG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgRE9NUG9zIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBvZmZzZXQsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnByZWNpc2UgPSBwcmVjaXNlO1xuICAgIH1cbiAgICBzdGF0aWMgYmVmb3JlKGRvbSwgcHJlY2lzZSkgeyByZXR1cm4gbmV3IERPTVBvcyhkb20ucGFyZW50Tm9kZSwgZG9tSW5kZXgoZG9tKSwgcHJlY2lzZSk7IH1cbiAgICBzdGF0aWMgYWZ0ZXIoZG9tLCBwcmVjaXNlKSB7IHJldHVybiBuZXcgRE9NUG9zKGRvbS5wYXJlbnROb2RlLCBkb21JbmRleChkb20pICsgMSwgcHJlY2lzZSk7IH1cbn1cbmNvbnN0IG5vQ2hpbGRyZW4gPSBbXTtcbmNsYXNzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlydHkgPSAyIC8qIERpcnR5Lk5vZGUgKi87XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgZ2V0IHBvc0F0U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBvc0JlZm9yZSh0aGlzKSA6IDA7XG4gICAgfVxuICAgIGdldCBwb3NBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBwb3NCZWZvcmUodmlldykge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3NBdFN0YXJ0O1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT0gdmlldylcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgcG9zICs9IGNoaWxkLmxlbmd0aCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNoaWxkIGluIHBvc0JlZm9yZVwiKTtcbiAgICB9XG4gICAgcG9zQWZ0ZXIodmlldykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUodmlldykgKyB2aWV3Lmxlbmd0aDtcbiAgICB9XG4gICAgLy8gV2lsbCByZXR1cm4gYSByZWN0YW5nbGUgZGlyZWN0bHkgYmVmb3JlICh3aGVuIHNpZGUgPCAwKSwgYWZ0ZXJcbiAgICAvLyAoc2lkZSA+IDApIG9yIGRpcmVjdGx5IG9uICh3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIGl0KSB0aGVcbiAgICAvLyBnaXZlbiBwb3NpdGlvbi5cbiAgICBjb29yZHNBdChfcG9zLCBfc2lkZSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgJiAyIC8qIERpcnR5Lk5vZGUgKi8pIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmRvbTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbnVsbCwgbmV4dDtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5kb20gJiYgKG5leHQgPSBwcmV2ID8gcHJldi5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZW50VmlldyB8fCAhY29udGVudFZpZXcucGFyZW50ICYmIGNvbnRlbnRWaWV3LmNhblJldXNlRE9NKGNoaWxkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5yZXVzZURPTShuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5zeW5jKHZpZXcsIHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSAwIC8qIERpcnR5Lk5vdCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrICYmICF0cmFjay53cml0dGVuICYmIHRyYWNrLm5vZGUgPT0gcGFyZW50ICYmIG5leHQgIT0gY2hpbGQuZG9tKVxuICAgICAgICAgICAgICAgICAgICB0cmFjay53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0ICYmIG5leHQgIT0gY2hpbGQuZG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHJtJDEobmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLmRvbSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXYgPSBjaGlsZC5kb207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIHRyYWNrICYmIHRyYWNrLm5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQpXG4gICAgICAgICAgICAgICAgbmV4dCA9IHJtJDEobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXJ0eSAmIDEgLyogRGlydHkuQ2hpbGQgKi8pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN5bmModmlldywgdHJhY2spO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kaXJ0eSA9IDAgLyogRGlydHkuTm90ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXVzZURPTShfZG9tKSB7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBhZnRlcjtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgIGFmdGVyID0gdGhpcy5kb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJpYXMgPSBtYXhPZmZzZXQobm9kZSkgPT0gMCA/IDAgOiBvZmZzZXQgPT0gMCA/IC0xIDogMTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChiaWFzID09IDAgJiYgcGFyZW50LmZpcnN0Q2hpbGQgIT0gcGFyZW50Lmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpYXMgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYmlhcyA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmlhcyA8IDApXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBub2RlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFmdGVyID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZ0ZXIgPT0gdGhpcy5kb20uZmlyc3RDaGlsZClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB3aGlsZSAoYWZ0ZXIgJiYgIUNvbnRlbnRWaWV3LmdldChhZnRlcikpXG4gICAgICAgICAgICBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoIWFmdGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5kb20gPT0gYWZ0ZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjaGlsZC5sZW5ndGggKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZChmcm9tLCB0bywgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgZnJvbUkgPSAtMSwgZnJvbVN0YXJ0ID0gLTEsIHRvSSA9IC0xLCB0b0VuZCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gb2Zmc2V0LCBwcmV2RW5kID0gb2Zmc2V0OyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20gJiYgZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRvbUJvdW5kc0Fyb3VuZChmcm9tLCB0bywgcG9zKTtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gZnJvbSAmJiBmcm9tSSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGZyb21JID0gaTtcbiAgICAgICAgICAgICAgICBmcm9tU3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zID4gdG8gJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0b0kgPSBpO1xuICAgICAgICAgICAgICAgIHRvRW5kID0gcHJldkVuZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZFbmQgPSBlbmQ7XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyb206IGZyb21TdGFydCwgdG86IHRvRW5kIDwgMCA/IG9mZnNldCArIHRoaXMubGVuZ3RoIDogdG9FbmQsXG4gICAgICAgICAgICBzdGFydERPTTogKGZyb21JID8gdGhpcy5jaGlsZHJlbltmcm9tSSAtIDFdLmRvbS5uZXh0U2libGluZyA6IG51bGwpIHx8IHRoaXMuZG9tLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBlbmRET006IHRvSSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIHRvSSA+PSAwID8gdGhpcy5jaGlsZHJlblt0b0ldLmRvbSA6IG51bGwgfTtcbiAgICB9XG4gICAgbWFya0RpcnR5KGFuZFBhcmVudCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZGlydHkgfD0gMiAvKiBEaXJ0eS5Ob2RlICovO1xuICAgICAgICB0aGlzLm1hcmtQYXJlbnRzRGlydHkoYW5kUGFyZW50KTtcbiAgICB9XG4gICAgbWFya1BhcmVudHNEaXJ0eShjaGlsZExpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQ7IHBhcmVudDsgcGFyZW50ID0gcGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkTGlzdClcbiAgICAgICAgICAgICAgICBwYXJlbnQuZGlydHkgfD0gMiAvKiBEaXJ0eS5Ob2RlICovO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5kaXJ0eSAmIDEgLyogRGlydHkuQ2hpbGQgKi8pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcGFyZW50LmRpcnR5IHw9IDEgLyogRGlydHkuQ2hpbGQgKi87XG4gICAgICAgICAgICBjaGlsZExpc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAhPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlydHkpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrUGFyZW50c0RpcnR5KHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldERPTShkb20pIHtcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy5kb20uY21WaWV3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIGRvbS5jbVZpZXcgPSB0aGlzO1xuICAgIH1cbiAgICBnZXQgcm9vdFZpZXcoKSB7XG4gICAgICAgIGZvciAobGV0IHYgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB2LnBhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgdiA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlQ2hpbGRyZW4oZnJvbSwgdG8sIGNoaWxkcmVuID0gbm9DaGlsZHJlbikge1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ID09IHRoaXMpXG4gICAgICAgICAgICAgICAgY2hpbGQuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGZyb20sIHRvIC0gZnJvbSwgLi4uY2hpbGRyZW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgY2hpbGRyZW5baV0uc2V0UGFyZW50KHRoaXMpO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihfcmVjKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlnbm9yZUV2ZW50KF9ldmVudCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBjaGlsZEN1cnNvcihwb3MgPSB0aGlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IENoaWxkQ3Vyc29yKHRoaXMuY2hpbGRyZW4sIHBvcywgdGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH1cbiAgICBjaGlsZFBvcyhwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQ3Vyc29yKCkuZmluZFBvcyhwb3MsIGJpYXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IG5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWUucmVwbGFjZShcIlZpZXdcIiwgXCJcIik7XG4gICAgICAgIHJldHVybiBuYW1lICsgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyB0aGlzLmNoaWxkcmVuLmpvaW4oKSArIFwiKVwiIDpcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID8gXCJbXCIgKyAobmFtZSA9PSBcIlRleHRcIiA/IHRoaXMudGV4dCA6IHRoaXMubGVuZ3RoKSArIFwiXVwiIDogXCJcIikgK1xuICAgICAgICAgICAgKHRoaXMuYnJlYWtBZnRlciA/IFwiI1wiIDogXCJcIik7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQobm9kZSkgeyByZXR1cm4gbm9kZS5jbVZpZXc7IH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgaXNXaWRnZXQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBiZWNvbWUob3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgY2FuUmV1c2VET00ob3RoZXIpIHsgcmV0dXJuIG90aGVyLmNvbnN0cnVjdG9yID09IHRoaXMuY29uc3RydWN0b3I7IH1cbiAgICAvLyBXaGVuIHRoaXMgaXMgYSB6ZXJvLWxlbmd0aCB2aWV3IHdpdGggYSBzaWRlLCB0aGlzIHNob3VsZCByZXR1cm4gYVxuICAgIC8vIG51bWJlciA8PSAwIHRvIGluZGljYXRlIGl0IGlzIGJlZm9yZSBpdHMgcG9zaXRpb24sIG9yIGFcbiAgICAvLyBudW1iZXIgPiAwIHdoZW4gYWZ0ZXIgaXRzIHBvc2l0aW9uLlxuICAgIGdldFNpZGUoKSB7IHJldHVybiAwOyB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIH1cbn1cbkNvbnRlbnRWaWV3LnByb3RvdHlwZS5icmVha0FmdGVyID0gMDtcbi8vIFJlbW92ZSBhIERPTSBub2RlIGFuZCByZXR1cm4gaXRzIG5leHQgc2libGluZy5cbmZ1bmN0aW9uIHJtJDEoZG9tKSB7XG4gICAgbGV0IG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbmNsYXNzIENoaWxkQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbiwgcG9zLCBpKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuaSA9IGk7XG4gICAgICAgIHRoaXMub2ZmID0gMDtcbiAgICB9XG4gICAgZmluZFBvcyhwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChwb3MgPiB0aGlzLnBvcyB8fCBwb3MgPT0gdGhpcy5wb3MgJiZcbiAgICAgICAgICAgICAgICAoYmlhcyA+IDAgfHwgdGhpcy5pID09IDAgfHwgdGhpcy5jaGlsZHJlblt0aGlzLmkgLSAxXS5icmVha0FmdGVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmID0gcG9zIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuY2hpbGRyZW5bLS10aGlzLmldO1xuICAgICAgICAgICAgdGhpcy5wb3MgLT0gbmV4dC5sZW5ndGggKyBuZXh0LmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2UocGFyZW50LCBmcm9tSSwgZnJvbU9mZiwgdG9JLCB0b09mZiwgaW5zZXJ0LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGxldCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQ7XG4gICAgbGV0IGJlZm9yZSA9IGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuW2Zyb21JXSA6IG51bGw7XG4gICAgbGV0IGxhc3QgPSBpbnNlcnQubGVuZ3RoID8gaW5zZXJ0W2luc2VydC5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgbGV0IGJyZWFrQXRFbmQgPSBsYXN0ID8gbGFzdC5icmVha0FmdGVyIDogYnJlYWtBdFN0YXJ0O1xuICAgIC8vIENoYW5nZSB3aXRoaW4gYSBzaW5nbGUgY2hpbGRcbiAgICBpZiAoZnJvbUkgPT0gdG9JICYmIGJlZm9yZSAmJiAhYnJlYWtBdFN0YXJ0ICYmICFicmVha0F0RW5kICYmIGluc2VydC5sZW5ndGggPCAyICYmXG4gICAgICAgIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCB0b09mZiwgaW5zZXJ0Lmxlbmd0aCA/IGxhc3QgOiBudWxsLCBmcm9tT2ZmID09IDAsIG9wZW5TdGFydCwgb3BlbkVuZCkpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodG9JIDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGxldCBhZnRlciA9IGNoaWxkcmVuW3RvSV07XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZW5kIG9mIHRoZSBjaGlsZCBhZnRlciB0aGUgdXBkYXRlIGlzIHByZXNlcnZlZCBpbiBgYWZ0ZXJgXG4gICAgICAgIGlmIChhZnRlciAmJiB0b09mZiA8IGFmdGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgc3BsaXR0aW5nIGEgY2hpbGQsIHNlcGFyYXRlIHBhcnQgb2YgaXQgdG8gYXZvaWQgdGhhdFxuICAgICAgICAgICAgLy8gYmVpbmcgbWFuZ2xlZCB3aGVuIHVwZGF0aW5nIHRoZSBjaGlsZCBiZWZvcmUgdGhlIHVwZGF0ZS5cbiAgICAgICAgICAgIGlmIChmcm9tSSA9PSB0b0kpIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IGFmdGVyLnNwbGl0KHRvT2ZmKTtcbiAgICAgICAgICAgICAgICB0b09mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBhZnRlciB0aGUgcmVwbGFjZW1lbnQgc2hvdWxkIGJlIG1lcmdlZCB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgbGFzdCByZXBsYWNpbmcgZWxlbWVudCwgdXBkYXRlIGBjb250ZW50YFxuICAgICAgICAgICAgaWYgKCFicmVha0F0RW5kICYmIGxhc3QgJiYgYWZ0ZXIubWVyZ2UoMCwgdG9PZmYsIGxhc3QsIHRydWUsIDAsIG9wZW5FbmQpKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0W2luc2VydC5sZW5ndGggLSAxXSA9IGFmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzdGFydCBvZiB0aGUgYWZ0ZXIgZWxlbWVudCwgaWYgbmVjZXNzYXJ5LCBhbmRcbiAgICAgICAgICAgICAgICAvLyBhZGQgaXQgdG8gYGNvbnRlbnRgLlxuICAgICAgICAgICAgICAgIGlmICh0b09mZilcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIubWVyZ2UoMCwgdG9PZmYsIG51bGwsIGZhbHNlLCAwLCBvcGVuRW5kKTtcbiAgICAgICAgICAgICAgICBpbnNlcnQucHVzaChhZnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWZ0ZXIgPT09IG51bGwgfHwgYWZ0ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFmdGVyLmJyZWFrQWZ0ZXIpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGF0IGB0b0lgIGlzIGVudGlyZWx5IGNvdmVyZWQgYnkgdGhpcyByYW5nZS5cbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGl0cyBsaW5lIGJyZWFrLCBpZiBhbnkuXG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICBsYXN0LmJyZWFrQWZ0ZXIgPSAxO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrQXRTdGFydCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2Ugd2UndmUgaGFuZGxlZCB0aGUgbmV4dCBlbGVtZW50IGZyb20gdGhlIGN1cnJlbnQgZWxlbWVudHNcbiAgICAgICAgLy8gbm93LCBtYWtlIHN1cmUgYHRvSWAgcG9pbnRzIGFmdGVyIHRoYXQuXG4gICAgICAgIHRvSSsrO1xuICAgIH1cbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGJlZm9yZS5icmVha0FmdGVyID0gYnJlYWtBdFN0YXJ0O1xuICAgICAgICBpZiAoZnJvbU9mZiA+IDApIHtcbiAgICAgICAgICAgIGlmICghYnJlYWtBdFN0YXJ0ICYmIGluc2VydC5sZW5ndGggJiYgYmVmb3JlLm1lcmdlKGZyb21PZmYsIGJlZm9yZS5sZW5ndGgsIGluc2VydFswXSwgZmFsc2UsIG9wZW5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICBiZWZvcmUuYnJlYWtBZnRlciA9IGluc2VydC5zaGlmdCgpLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tT2ZmIDwgYmVmb3JlLmxlbmd0aCB8fCBiZWZvcmUuY2hpbGRyZW4ubGVuZ3RoICYmIGJlZm9yZS5jaGlsZHJlbltiZWZvcmUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBiZWZvcmUubWVyZ2UoZnJvbU9mZiwgYmVmb3JlLmxlbmd0aCwgbnVsbCwgZmFsc2UsIG9wZW5TdGFydCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tSSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRyeSB0byBtZXJnZSB3aWRnZXRzIG9uIHRoZSBib3VuZGFyaWVzIG9mIHRoZSByZXBsYWNlbWVudFxuICAgIHdoaWxlIChmcm9tSSA8IHRvSSAmJiBpbnNlcnQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChjaGlsZHJlblt0b0kgLSAxXS5iZWNvbWUoaW5zZXJ0W2luc2VydC5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgIHRvSS0tO1xuICAgICAgICAgICAgaW5zZXJ0LnBvcCgpO1xuICAgICAgICAgICAgb3BlbkVuZCA9IGluc2VydC5sZW5ndGggPyAwIDogb3BlblN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkcmVuW2Zyb21JXS5iZWNvbWUoaW5zZXJ0WzBdKSkge1xuICAgICAgICAgICAgZnJvbUkrKztcbiAgICAgICAgICAgIGluc2VydC5zaGlmdCgpO1xuICAgICAgICAgICAgb3BlblN0YXJ0ID0gaW5zZXJ0Lmxlbmd0aCA/IDAgOiBvcGVuRW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpbnNlcnQubGVuZ3RoICYmIGZyb21JICYmIHRvSSA8IGNoaWxkcmVuLmxlbmd0aCAmJiAhY2hpbGRyZW5bZnJvbUkgLSAxXS5icmVha0FmdGVyICYmXG4gICAgICAgIGNoaWxkcmVuW3RvSV0ubWVyZ2UoMCwgMCwgY2hpbGRyZW5bZnJvbUkgLSAxXSwgZmFsc2UsIG9wZW5TdGFydCwgb3BlbkVuZCkpXG4gICAgICAgIGZyb21JLS07XG4gICAgaWYgKGZyb21JIDwgdG9JIHx8IGluc2VydC5sZW5ndGgpXG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGRyZW4oZnJvbUksIHRvSSwgaW5zZXJ0KTtcbn1cbmZ1bmN0aW9uIG1lcmdlQ2hpbGRyZW5JbnRvKHBhcmVudCwgZnJvbSwgdG8sIGluc2VydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgbGV0IGN1ciA9IHBhcmVudC5jaGlsZEN1cnNvcigpO1xuICAgIGxldCB7IGk6IHRvSSwgb2ZmOiB0b09mZiB9ID0gY3VyLmZpbmRQb3ModG8sIDEpO1xuICAgIGxldCB7IGk6IGZyb21JLCBvZmY6IGZyb21PZmYgfSA9IGN1ci5maW5kUG9zKGZyb20sIC0xKTtcbiAgICBsZXQgZExlbiA9IGZyb20gLSB0bztcbiAgICBmb3IgKGxldCB2aWV3IG9mIGluc2VydClcbiAgICAgICAgZExlbiArPSB2aWV3Lmxlbmd0aDtcbiAgICBwYXJlbnQubGVuZ3RoICs9IGRMZW47XG4gICAgcmVwbGFjZVJhbmdlKHBhcmVudCwgZnJvbUksIGZyb21PZmYsIHRvSSwgdG9PZmYsIGluc2VydCwgMCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbn1cblxubGV0IG5hdiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IG5hdmlnYXRvciA6IHsgdXNlckFnZW50OiBcIlwiLCB2ZW5kb3I6IFwiXCIsIHBsYXRmb3JtOiBcIlwiIH07XG5sZXQgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHsgZG9jdW1lbnRFbGVtZW50OiB7IHN0eWxlOiB7fSB9IH07XG5jb25zdCBpZV9lZGdlID0gLypAX19QVVJFX18qLy9FZGdlXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWVfdXB0bzEwID0gLypAX19QVVJFX18qLy9NU0lFIFxcZC8udGVzdChuYXYudXNlckFnZW50KTtcbmNvbnN0IGllXzExdXAgPSAvKkBfX1BVUkVfXyovL1RyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWUgPSAhIShpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBpZV9lZGdlKTtcbmNvbnN0IGdlY2tvID0gIWllICYmIC8qQF9fUFVSRV9fKi8vZ2Vja29cXC8oXFxkKykvaS50ZXN0KG5hdi51c2VyQWdlbnQpO1xuY29uc3QgY2hyb21lID0gIWllICYmIC8qQF9fUFVSRV9fKi8vQ2hyb21lXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3Qgd2Via2l0ID0gXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmNvbnN0IHNhZmFyaSA9ICFpZSAmJiAvKkBfX1BVUkVfXyovL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdi52ZW5kb3IpO1xuY29uc3QgaW9zID0gc2FmYXJpICYmICgvKkBfX1BVUkVfXyovL01vYmlsZVxcL1xcdysvLnRlc3QobmF2LnVzZXJBZ2VudCkgfHwgbmF2Lm1heFRvdWNoUG9pbnRzID4gMik7XG52YXIgYnJvd3NlciA9IHtcbiAgICBtYWM6IGlvcyB8fCAvKkBfX1BVUkVfXyovL01hYy8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIHdpbmRvd3M6IC8qQF9fUFVSRV9fKi8vV2luLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgbGludXg6IC8qQF9fUFVSRV9fKi8vTGludXh8WDExLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgaWUsXG4gICAgaWVfdmVyc2lvbjogaWVfdXB0bzEwID8gZG9jLmRvY3VtZW50TW9kZSB8fCA2IDogaWVfMTF1cCA/ICtpZV8xMXVwWzFdIDogaWVfZWRnZSA/ICtpZV9lZGdlWzFdIDogMCxcbiAgICBnZWNrbyxcbiAgICBnZWNrb192ZXJzaW9uOiBnZWNrbyA/ICsoLypAX19QVVJFX18qLy9GaXJlZm94XFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwLFxuICAgIGNocm9tZTogISFjaHJvbWUsXG4gICAgY2hyb21lX3ZlcnNpb246IGNocm9tZSA/ICtjaHJvbWVbMV0gOiAwLFxuICAgIGlvcyxcbiAgICBhbmRyb2lkOiAvKkBfX1BVUkVfXyovL0FuZHJvaWRcXGIvLnRlc3QobmF2LnVzZXJBZ2VudCksXG4gICAgd2Via2l0LFxuICAgIHNhZmFyaSxcbiAgICB3ZWJraXRfdmVyc2lvbjogd2Via2l0ID8gKygvKkBfX1BVUkVfXyovL1xcYkFwcGxlV2ViS2l0XFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwLFxuICAgIHRhYlNpemU6IGRvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGUudGFiU2l6ZSAhPSBudWxsID8gXCJ0YWItc2l6ZVwiIDogXCItbW96LXRhYi1zaXplXCJcbn07XG5cbmNvbnN0IE1heEpvaW5MZW4gPSAyNTY7XG5jbGFzcyBUZXh0VmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgY3JlYXRlRE9NKHRleHRET00pIHtcbiAgICAgICAgdGhpcy5zZXRET00odGV4dERPTSB8fCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpKTtcbiAgICB9XG4gICAgc3luYyh2aWV3LCB0cmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVET00oKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tLm5vZGVWYWx1ZSAhPSB0aGlzLnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0cmFjayAmJiB0cmFjay5ub2RlID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb20ubm9kZVZhbHVlID0gdGhpcy50ZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldXNlRE9NKGRvbSkge1xuICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURPTShkb20pO1xuICAgIH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgVGV4dFZpZXcpIHx8IHRoaXMubGVuZ3RoIC0gKHRvIC0gZnJvbSkgKyBzb3VyY2UubGVuZ3RoID4gTWF4Sm9pbkxlbikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBmcm9tKSArIChzb3VyY2UgPyBzb3VyY2UudGV4dCA6IFwiXCIpICsgdGhpcy50ZXh0LnNsaWNlKHRvKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGZyb20pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBUZXh0Vmlldyh0aGlzLnRleHQuc2xpY2UoZnJvbSkpO1xuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgZnJvbSk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgPT0gdGhpcy5kb20gPyBvZmZzZXQgOiBvZmZzZXQgPyB0aGlzLnRleHQubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7IHJldHVybiBuZXcgRE9NUG9zKHRoaXMuZG9tLCBwb3MpOyB9XG4gICAgZG9tQm91bmRzQXJvdW5kKF9mcm9tLCBfdG8sIG9mZnNldCkge1xuICAgICAgICByZXR1cm4geyBmcm9tOiBvZmZzZXQsIHRvOiBvZmZzZXQgKyB0aGlzLmxlbmd0aCwgc3RhcnRET006IHRoaXMuZG9tLCBlbmRET006IHRoaXMuZG9tLm5leHRTaWJsaW5nIH07XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICByZXR1cm4gdGV4dENvb3Jkcyh0aGlzLmRvbSwgcG9zLCBzaWRlKTtcbiAgICB9XG59XG5jbGFzcyBNYXJrVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihtYXJrLCBjaGlsZHJlbiA9IFtdLCBsZW5ndGggPSAwKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgY2guc2V0UGFyZW50KHRoaXMpO1xuICAgIH1cbiAgICBzZXRBdHRycyhkb20pIHtcbiAgICAgICAgY2xlYXJBdHRyaWJ1dGVzKGRvbSk7XG4gICAgICAgIGlmICh0aGlzLm1hcmsuY2xhc3MpXG4gICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gdGhpcy5tYXJrLmNsYXNzO1xuICAgICAgICBpZiAodGhpcy5tYXJrLmF0dHJzKVxuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLm1hcmsuYXR0cnMpXG4gICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCB0aGlzLm1hcmsuYXR0cnNbbmFtZV0pO1xuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICByZXVzZURPTShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IHRoaXMubWFyay50YWdOYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSB8PSA0IC8qIERpcnR5LkF0dHJzICovIHwgMiAvKiBEaXJ0eS5Ob2RlICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKHRoaXMuc2V0QXR0cnMoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm1hcmsudGFnTmFtZSkpKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXJ0eSAmIDQgLyogRGlydHkuQXR0cnMgKi8pXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJzKHRoaXMuZG9tKTtcbiAgICAgICAgc3VwZXIuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIF9oYXNTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgc291cmNlLm1hcmsuZXEodGhpcy5tYXJrKSkgfHxcbiAgICAgICAgICAgIChmcm9tICYmIG9wZW5TdGFydCA8PSAwKSB8fCAodG8gPCB0aGlzLmxlbmd0aCAmJiBvcGVuRW5kIDw9IDApKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbWVyZ2VDaGlsZHJlbkludG8odGhpcywgZnJvbSwgdG8sIHNvdXJjZSA/IHNvdXJjZS5jaGlsZHJlbiA6IFtdLCBvcGVuU3RhcnQgLSAxLCBvcGVuRW5kIC0gMSk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzcGxpdChmcm9tKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgb2ZmID0gMCwgZGV0YWNoRnJvbSA9IC0xLCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgZWx0IG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBvZmYgKyBlbHQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2ZmIDwgZnJvbSA/IGVsdC5zcGxpdChmcm9tIC0gb2ZmKSA6IGVsdCk7XG4gICAgICAgICAgICBpZiAoZGV0YWNoRnJvbSA8IDAgJiYgb2ZmID49IGZyb20pXG4gICAgICAgICAgICAgICAgZGV0YWNoRnJvbSA9IGk7XG4gICAgICAgICAgICBvZmYgPSBlbmQ7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlbmd0aCA9IHRoaXMubGVuZ3RoIC0gZnJvbTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBmcm9tO1xuICAgICAgICBpZiAoZGV0YWNoRnJvbSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IGRldGFjaEZyb207XG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTWFya1ZpZXcodGhpcy5tYXJrLCByZXN1bHQsIGxlbmd0aCk7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gaW5saW5lRE9NQXRQb3ModGhpcywgcG9zKTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiBjb29yZHNJbkNoaWxkcmVuKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dENvb3Jkcyh0ZXh0LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgbGVuZ3RoID0gdGV4dC5ub2RlVmFsdWUubGVuZ3RoO1xuICAgIGlmIChwb3MgPiBsZW5ndGgpXG4gICAgICAgIHBvcyA9IGxlbmd0aDtcbiAgICBsZXQgZnJvbSA9IHBvcywgdG8gPSBwb3MsIGZsYXR0ZW4gPSAwO1xuICAgIGlmIChwb3MgPT0gMCAmJiBzaWRlIDwgMCB8fCBwb3MgPT0gbGVuZ3RoICYmIHNpZGUgPj0gMCkge1xuICAgICAgICBpZiAoIShicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmdlY2tvKSkgeyAvLyBUaGVzZSBicm93c2VycyByZWxpYWJseSByZXR1cm4gdmFsaWQgcmVjdGFuZ2xlcyBmb3IgZW1wdHkgcmFuZ2VzXG4gICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4gPSAxO1xuICAgICAgICAgICAgfSAvLyBGSVhNRSB0aGlzIGlzIHdyb25nIGluIFJUTCB0ZXh0XG4gICAgICAgICAgICBlbHNlIGlmICh0byA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgZmxhdHRlbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoc2lkZSA8IDApXG4gICAgICAgICAgICBmcm9tLS07XG4gICAgICAgIGVsc2UgaWYgKHRvIDwgbGVuZ3RoKVxuICAgICAgICAgICAgdG8rKztcbiAgICB9XG4gICAgbGV0IHJlY3RzID0gdGV4dFJhbmdlKHRleHQsIGZyb20sIHRvKS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGlmICghcmVjdHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gUmVjdDA7XG4gICAgbGV0IHJlY3QgPSByZWN0c1soZmxhdHRlbiA/IGZsYXR0ZW4gPCAwIDogc2lkZSA+PSAwKSA/IDAgOiByZWN0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAoYnJvd3Nlci5zYWZhcmkgJiYgIWZsYXR0ZW4gJiYgcmVjdC53aWR0aCA9PSAwKVxuICAgICAgICByZWN0ID0gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChyZWN0cywgciA9PiByLndpZHRoKSB8fCByZWN0O1xuICAgIHJldHVybiBmbGF0dGVuID8gZmxhdHRlblJlY3QocmVjdCwgZmxhdHRlbiA8IDApIDogcmVjdCB8fCBudWxsO1xufVxuLy8gQWxzbyB1c2VkIGZvciBjb2xsYXBzZWQgcmFuZ2VzIHRoYXQgZG9uJ3QgaGF2ZSBhIHBsYWNlaG9sZGVyIHdpZGdldCFcbmNsYXNzIFdpZGdldFZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3Iod2lkZ2V0LCBsZW5ndGgsIHNpZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xuICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHdpZGdldCwgbGVuZ3RoLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgKHdpZGdldC5jdXN0b21WaWV3IHx8IFdpZGdldFZpZXcpKHdpZGdldCwgbGVuZ3RoLCBzaWRlKTtcbiAgICB9XG4gICAgc3BsaXQoZnJvbSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gV2lkZ2V0Vmlldy5jcmVhdGUodGhpcy53aWRnZXQsIHRoaXMubGVuZ3RoIC0gZnJvbSwgdGhpcy5zaWRlKTtcbiAgICAgICAgdGhpcy5sZW5ndGggLT0gZnJvbTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3luYyh2aWV3KSB7XG4gICAgICAgIGlmICghdGhpcy5kb20gfHwgIXRoaXMud2lkZ2V0LnVwZGF0ZURPTSh0aGlzLmRvbSwgdmlldykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiB0aGlzLnByZXZXaWRnZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKHRoaXMud2lkZ2V0LnRvRE9NKHZpZXcpKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gdGhpcy5zaWRlOyB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIFdpZGdldFZpZXcpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHNvdXJjZS53aWRnZXQpIHx8XG4gICAgICAgICAgICBmcm9tID4gMCAmJiBvcGVuU3RhcnQgPD0gMCB8fCB0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbSArIChzb3VyY2UgPyBzb3VyY2UubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSB0byk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLmxlbmd0aCA9PSB0aGlzLmxlbmd0aCAmJiBvdGhlciBpbnN0YW5jZW9mIFdpZGdldFZpZXcgJiYgb3RoZXIuc2lkZSA9PSB0aGlzLnNpZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndpZGdldC5jb25zdHJ1Y3RvciA9PSBvdGhlci53aWRnZXQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMud2lkZ2V0LmVxKG90aGVyLndpZGdldCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiAhdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSB0aGlzLndpZGdldDtcbiAgICAgICAgICAgICAgICB0aGlzLndpZGdldCA9IG90aGVyLndpZGdldDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0aGlzLndpZGdldC5pZ25vcmVFdmVudChldmVudCk7IH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBUZXh0LmVtcHR5O1xuICAgICAgICBsZXQgdG9wID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHRvcC5wYXJlbnQpXG4gICAgICAgICAgICB0b3AgPSB0b3AucGFyZW50O1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0b3AsIHRleHQgPSB2aWV3ICYmIHZpZXcuc3RhdGUuZG9jLCBzdGFydCA9IHRoaXMucG9zQXRTdGFydDtcbiAgICAgICAgcmV0dXJuIHRleHQgPyB0ZXh0LnNsaWNlKHN0YXJ0LCBzdGFydCArIHRoaXMubGVuZ3RoKSA6IFRleHQuZW1wdHk7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zID09IDAgPyBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKSA6IERPTVBvcy5hZnRlcih0aGlzLmRvbSwgcG9zID09IHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgcmVjdHMgPSB0aGlzLmRvbS5nZXRDbGllbnRSZWN0cygpLCByZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gUmVjdDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3MgPiAwID8gcmVjdHMubGVuZ3RoIC0gMSA6IDA7OyBpICs9IChwb3MgPiAwID8gLTEgOiAxKSkge1xuICAgICAgICAgICAgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKHBvcyA+IDAgPyBpID09IDAgOiBpID09IHJlY3RzLmxlbmd0aCAtIDEgfHwgcmVjdC50b3AgPCByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPyByZWN0IDogZmxhdHRlblJlY3QocmVjdCwgdGhpcy5zaWRlID4gMCk7XG4gICAgfVxuICAgIGdldCBpc0VkaXRhYmxlKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaXNXaWRnZXQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLndpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICB9XG59XG5jbGFzcyBDb21wb3NpdGlvblZpZXcgZXh0ZW5kcyBXaWRnZXRWaWV3IHtcbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgbGV0IHsgdG9wVmlldywgdGV4dCB9ID0gdGhpcy53aWRnZXQ7XG4gICAgICAgIGlmICghdG9wVmlldylcbiAgICAgICAgICAgIHJldHVybiBuZXcgRE9NUG9zKHRleHQsIE1hdGgubWluKHBvcywgdGV4dC5ub2RlVmFsdWUubGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiBzY2FuQ29tcG9zaXRpb25UcmVlKHBvcywgMCwgdG9wVmlldywgdGV4dCwgKHYsIHApID0+IHYuZG9tQXRQb3MocCksIHAgPT4gbmV3IERPTVBvcyh0ZXh0LCBNYXRoLm1pbihwLCB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGgpKSk7XG4gICAgfVxuICAgIHN5bmMoKSB7IHRoaXMuc2V0RE9NKHRoaXMud2lkZ2V0LnRvRE9NKCkpOyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgeyB0b3BWaWV3LCB0ZXh0IH0gPSB0aGlzLndpZGdldDtcbiAgICAgICAgaWYgKCF0b3BWaWV3KVxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKG9mZnNldCwgdGhpcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gcG9zRnJvbURPTUluQ29tcG9zaXRpb25UcmVlKG5vZGUsIG9mZnNldCwgdG9wVmlldywgdGV4dCk7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyB0b3BWaWV3LCB0ZXh0IH0gPSB0aGlzLndpZGdldDtcbiAgICAgICAgaWYgKCF0b3BWaWV3KVxuICAgICAgICAgICAgcmV0dXJuIHRleHRDb29yZHModGV4dCwgcG9zLCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIHNjYW5Db21wb3NpdGlvblRyZWUocG9zLCBzaWRlLCB0b3BWaWV3LCB0ZXh0LCAodiwgcG9zLCBzaWRlKSA9PiB2LmNvb3Jkc0F0KHBvcywgc2lkZSksIChwb3MsIHNpZGUpID0+IHRleHRDb29yZHModGV4dCwgcG9zLCBzaWRlKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICAoX2EgPSB0aGlzLndpZGdldC50b3BWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgIH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBjYW5SZXVzZURPTSgpIHsgcmV0dXJuIHRydWU7IH1cbn1cbi8vIFVzZXMgdGhlIG9sZCBzdHJ1Y3R1cmUgb2YgYSBjaHVuayBvZiBjb250ZW50IHZpZXcgZnJvemVuIGZvclxuLy8gY29tcG9zaXRpb24gdG8gdHJ5IGFuZCBmaW5kIGEgcmVhc29uYWJsZSBET00gbG9jYXRpb24gZm9yIHRoZSBnaXZlblxuLy8gb2Zmc2V0LlxuZnVuY3Rpb24gc2NhbkNvbXBvc2l0aW9uVHJlZShwb3MsIHNpZGUsIHZpZXcsIHRleHQsIGVudGVyVmlldywgZnJvbVRleHQpIHtcbiAgICBpZiAodmlldyBpbnN0YW5jZW9mIE1hcmtWaWV3KSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gdmlldy5kb20uZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gQ29udGVudFZpZXcuZ2V0KGNoaWxkKTtcbiAgICAgICAgICAgIGlmICghZGVzYylcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbVRleHQocG9zLCBzaWRlKTtcbiAgICAgICAgICAgIGxldCBoYXNDb21wID0gY29udGFpbnMoY2hpbGQsIHRleHQpO1xuICAgICAgICAgICAgbGV0IGxlbiA9IGRlc2MubGVuZ3RoICsgKGhhc0NvbXAgPyB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGggOiAwKTtcbiAgICAgICAgICAgIGlmIChwb3MgPCBsZW4gfHwgcG9zID09IGxlbiAmJiBkZXNjLmdldFNpZGUoKSA8PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNDb21wID8gc2NhbkNvbXBvc2l0aW9uVHJlZShwb3MsIHNpZGUsIGRlc2MsIHRleHQsIGVudGVyVmlldywgZnJvbVRleHQpIDogZW50ZXJWaWV3KGRlc2MsIHBvcywgc2lkZSk7XG4gICAgICAgICAgICBwb3MgLT0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRlclZpZXcodmlldywgdmlldy5sZW5ndGgsIC0xKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmlldy5kb20gPT0gdGV4dCkge1xuICAgICAgICByZXR1cm4gZnJvbVRleHQocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBlbnRlclZpZXcodmlldywgcG9zLCBzaWRlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3NGcm9tRE9NSW5Db21wb3NpdGlvblRyZWUobm9kZSwgb2Zmc2V0LCB2aWV3LCB0ZXh0KSB7XG4gICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBNYXJrVmlldykge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB2aWV3LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gMCwgaGFzQ29tcCA9IGNvbnRhaW5zKGNoaWxkLmRvbSwgdGV4dCk7XG4gICAgICAgICAgICBpZiAoY29udGFpbnMoY2hpbGQuZG9tLCBub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zICsgKGhhc0NvbXAgPyBwb3NGcm9tRE9NSW5Db21wb3NpdGlvblRyZWUobm9kZSwgb2Zmc2V0LCBjaGlsZCwgdGV4dCkgOiBjaGlsZC5sb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSk7XG4gICAgICAgICAgICBwb3MgKz0gaGFzQ29tcCA/IHRleHQubm9kZVZhbHVlLmxlbmd0aCA6IGNoaWxkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2aWV3LmRvbSA9PSB0ZXh0KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihvZmZzZXQsIHRleHQubm9kZVZhbHVlLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3LmxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpO1xufVxuLy8gVGhlc2UgYXJlIGRyYXduIGFyb3VuZCB1bmVkaXRhYmxlIHdpZGdldHMgdG8gYXZvaWQgYSBudW1iZXIgb2Zcbi8vIGJyb3dzZXIgYnVncyB0aGF0IHNob3cgdXAgd2hlbiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IG5leHQgdG9cbi8vIHVuZWRpdGFibGUgaW5saW5lIGNvbnRlbnQuXG5jbGFzcyBXaWRnZXRCdWZmZXJWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHNpZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIDA7IH1cbiAgICBtZXJnZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgYmVjb21lKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFdpZGdldEJ1ZmZlclZpZXcgJiYgb3RoZXIuc2lkZSA9PSB0aGlzLnNpZGU7XG4gICAgfVxuICAgIHNwbGl0KCkgeyByZXR1cm4gbmV3IFdpZGdldEJ1ZmZlclZpZXcodGhpcy5zaWRlKTsgfVxuICAgIHN5bmMoKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiY20td2lkZ2V0QnVmZmVyXCI7XG4gICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXRET00oZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gdGhpcy5zaWRlOyB9XG4gICAgZG9tQXRQb3MocG9zKSB7IHJldHVybiBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKTsgfVxuICAgIGxvY2FsUG9zRnJvbURPTSgpIHsgcmV0dXJuIDA7IH1cbiAgICBkb21Cb3VuZHNBcm91bmQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgY29vcmRzQXQocG9zKSB7XG4gICAgICAgIGxldCBpbWdSZWN0ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIC8vIFNpbmNlIHRoZSA8aW1nPiBoZWlnaHQgZG9lc24ndCBjb3JyZXNwb25kIHRvIHRleHQgaGVpZ2h0LCB0cnlcbiAgICAgICAgLy8gdG8gYm9ycm93IHRoZSBoZWlnaHQgZnJvbSBzb21lIHNpYmxpbmcgbm9kZS5cbiAgICAgICAgbGV0IHNpYmxpbmdSZWN0ID0gaW5saW5lU2libGluZ1JlY3QodGhpcywgdGhpcy5zaWRlID4gMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBzaWJsaW5nUmVjdCAmJiBzaWJsaW5nUmVjdC50b3AgPCBpbWdSZWN0LmJvdHRvbSAmJiBzaWJsaW5nUmVjdC5ib3R0b20gPiBpbWdSZWN0LnRvcFxuICAgICAgICAgICAgPyB7IGxlZnQ6IGltZ1JlY3QubGVmdCwgcmlnaHQ6IGltZ1JlY3QucmlnaHQsIHRvcDogc2libGluZ1JlY3QudG9wLCBib3R0b206IHNpYmxpbmdSZWN0LmJvdHRvbSB9IDogaW1nUmVjdDtcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgfVxufVxuVGV4dFZpZXcucHJvdG90eXBlLmNoaWxkcmVuID0gV2lkZ2V0Vmlldy5wcm90b3R5cGUuY2hpbGRyZW4gPSBXaWRnZXRCdWZmZXJWaWV3LnByb3RvdHlwZS5jaGlsZHJlbiA9IG5vQ2hpbGRyZW47XG5mdW5jdGlvbiBpbmxpbmVTaWJsaW5nUmVjdCh2aWV3LCBzaWRlKSB7XG4gICAgbGV0IHBhcmVudCA9IHZpZXcucGFyZW50LCBpbmRleCA9IHBhcmVudCA/IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHZpZXcpIDogLTE7XG4gICAgd2hpbGUgKHBhcmVudCAmJiBpbmRleCA+PSAwKSB7XG4gICAgICAgIGlmIChzaWRlIDwgMCA/IGluZGV4ID4gMCA6IGluZGV4IDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBwYXJlbnQuY2hpbGRyZW5baW5kZXggKyBzaWRlXTtcbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVGV4dFZpZXcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFJlY3QgPSBuZXh0LmNvb3Jkc0F0KHNpZGUgPCAwID8gbmV4dC5sZW5ndGggOiAwLCBzaWRlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFJlY3QpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0UmVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ICs9IHNpZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyZW50IGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgcGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgaW5kZXggPSBwYXJlbnQucGFyZW50LmNoaWxkcmVuLmluZGV4T2YocGFyZW50KSArIChzaWRlIDwgMCA/IDAgOiAxKTtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHBhcmVudC5kb20ubGFzdENoaWxkO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC5ub2RlTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3QuZ2V0Q2xpZW50UmVjdHMoKVswXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpbmxpbmVET01BdFBvcyhwYXJlbnQsIHBvcykge1xuICAgIGxldCBkb20gPSBwYXJlbnQuZG9tLCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQsIGkgPSAwO1xuICAgIGZvciAobGV0IG9mZiA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICBpZiAoZW5kID09IG9mZiAmJiBjaGlsZC5nZXRTaWRlKCkgPD0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAocG9zID4gb2ZmICYmIHBvcyA8IGVuZCAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuZG9tQXRQb3MocG9zIC0gb2ZmKTtcbiAgICAgICAgaWYgKHBvcyA8PSBvZmYpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgb2ZmID0gZW5kO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaTsgaiA+IDA7IGotLSkge1xuICAgICAgICBsZXQgcHJldiA9IGNoaWxkcmVuW2ogLSAxXTtcbiAgICAgICAgaWYgKHByZXYuZG9tLnBhcmVudE5vZGUgPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIHByZXYuZG9tQXRQb3MocHJldi5sZW5ndGgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaTsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5bal07XG4gICAgICAgIGlmIChuZXh0LmRvbS5wYXJlbnROb2RlID09IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbUF0UG9zKDApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERPTVBvcyhkb20sIDApO1xufVxuLy8gQXNzdW1lcyBgdmlld2AsIGlmIGEgbWFyayB2aWV3LCBoYXMgcHJlY2lzZWx5IDEgY2hpbGQuXG5mdW5jdGlvbiBqb2luSW5saW5lSW50byhwYXJlbnQsIHZpZXcsIG9wZW4pIHtcbiAgICBsZXQgbGFzdCwgeyBjaGlsZHJlbiB9ID0gcGFyZW50O1xuICAgIGlmIChvcGVuID4gMCAmJiB2aWV3IGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgY2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIChsYXN0ID0gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0pIGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgbGFzdC5tYXJrLmVxKHZpZXcubWFyaykpIHtcbiAgICAgICAgam9pbklubGluZUludG8obGFzdCwgdmlldy5jaGlsZHJlblswXSwgb3BlbiAtIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaCh2aWV3KTtcbiAgICAgICAgdmlldy5zZXRQYXJlbnQocGFyZW50KTtcbiAgICB9XG4gICAgcGFyZW50Lmxlbmd0aCArPSB2aWV3Lmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNvb3Jkc0luQ2hpbGRyZW4odmlldywgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGJlZm9yZSA9IG51bGwsIGJlZm9yZVBvcyA9IC0xLCBhZnRlciA9IG51bGwsIGFmdGVyUG9zID0gLTE7XG4gICAgZnVuY3Rpb24gc2Nhbih2aWV3LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZiA9IDA7IGkgPCB2aWV3LmNoaWxkcmVuLmxlbmd0aCAmJiBvZmYgPD0gcG9zOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHZpZXcuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FuKGNoaWxkLCBwb3MgLSBvZmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYWZ0ZXIgJiYgKGVuZCA+IHBvcyB8fCBvZmYgPT0gZW5kICYmIGNoaWxkLmdldFNpZGUoKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyUG9zID0gcG9zIC0gb2ZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvZmYgPCBwb3MgfHwgKG9mZiA9PSBlbmQgJiYgY2hpbGQuZ2V0U2lkZSgpIDwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZVBvcyA9IHBvcyAtIG9mZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2Nhbih2aWV3LCBwb3MpO1xuICAgIGxldCB0YXJnZXQgPSAoc2lkZSA8IDAgPyBiZWZvcmUgOiBhZnRlcikgfHwgYmVmb3JlIHx8IGFmdGVyO1xuICAgIGlmICh0YXJnZXQpXG4gICAgICAgIHJldHVybiB0YXJnZXQuY29vcmRzQXQoTWF0aC5tYXgoMCwgdGFyZ2V0ID09IGJlZm9yZSA/IGJlZm9yZVBvcyA6IGFmdGVyUG9zKSwgc2lkZSk7XG4gICAgcmV0dXJuIGZhbGxiYWNrUmVjdCh2aWV3KTtcbn1cbmZ1bmN0aW9uIGZhbGxiYWNrUmVjdCh2aWV3KSB7XG4gICAgbGV0IGxhc3QgPSB2aWV3LmRvbS5sYXN0Q2hpbGQ7XG4gICAgaWYgKCFsYXN0KVxuICAgICAgICByZXR1cm4gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHJlY3RzID0gY2xpZW50UmVjdHNGb3IobGFzdCk7XG4gICAgcmV0dXJuIHJlY3RzW3JlY3RzLmxlbmd0aCAtIDFdIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVBdHRycyhzb3VyY2UsIHRhcmdldCkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwiY2xhc3NcIiAmJiB0YXJnZXQuY2xhc3MpXG4gICAgICAgICAgICB0YXJnZXQuY2xhc3MgKz0gXCIgXCIgKyBzb3VyY2UuY2xhc3M7XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJzdHlsZVwiICYmIHRhcmdldC5zdHlsZSlcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZSArPSBcIjtcIiArIHNvdXJjZS5zdHlsZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gYXR0cnNFcShhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFhIHx8ICFiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGtleXNBID0gT2JqZWN0LmtleXMoYSksIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgaWYgKGtleXNBLmxlbmd0aCAhPSBrZXlzQi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5c0EpIHtcbiAgICAgICAgaWYgKGtleXNCLmluZGV4T2Yoa2V5KSA9PSAtMSB8fCBhW2tleV0gIT09IGJba2V5XSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB1cGRhdGVBdHRycyhkb20sIHByZXYsIGF0dHJzKSB7XG4gICAgbGV0IGNoYW5nZWQgPSBudWxsO1xuICAgIGlmIChwcmV2KVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgICAgICBpZiAoIShhdHRycyAmJiBuYW1lIGluIGF0dHJzKSlcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKGNoYW5nZWQgPSBuYW1lKTtcbiAgICBpZiAoYXR0cnMpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICBpZiAoIShwcmV2ICYmIHByZXZbbmFtZV0gPT0gYXR0cnNbbmFtZV0pKVxuICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoY2hhbmdlZCA9IG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICByZXR1cm4gISFjaGFuZ2VkO1xufVxuXG4vKipcbldpZGdldHMgYWRkZWQgdG8gdGhlIGNvbnRlbnQgYXJlIGRlc2NyaWJlZCBieSBzdWJjbGFzc2VzIG9mIHRoaXNcbmNsYXNzLiBVc2luZyBhIGRlc2NyaXB0aW9uIG9iamVjdCBsaWtlIHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG9cbmRlbGF5IGNyZWF0aW5nIG9mIHRoZSBET00gc3RydWN0dXJlIGZvciBhIHdpZGdldCB1bnRpbCBpdCBpc1xubmVlZGVkLCBhbmQgdG8gYXZvaWQgcmVkcmF3aW5nIHdpZGdldHMgZXZlbiBpZiB0aGUgZGVjb3JhdGlvbnNcbnRoYXQgZGVmaW5lIHRoZW0gYXJlIHJlY3JlYXRlZC5cbiovXG5jbGFzcyBXaWRnZXRUeXBlIHtcbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgaW5zdGFuY2UgdG8gYW5vdGhlciBpbnN0YW5jZSBvZiB0aGUgc2FtZSB0eXBlLlxuICAgIChUeXBlU2NyaXB0IGNhbid0IGV4cHJlc3MgdGhpcywgYnV0IG9ubHkgaW5zdGFuY2VzIG9mIHRoZSBzYW1lXG4gICAgc3BlY2lmaWMgY2xhc3Mgd2lsbCBiZSBwYXNzZWQgdG8gdGhpcyBtZXRob2QuKSBUaGlzIGlzIHVzZWQgdG9cbiAgICBhdm9pZCByZWRyYXdpbmcgd2lkZ2V0cyB3aGVuIHRoZXkgYXJlIHJlcGxhY2VkIGJ5IGEgbmV3XG4gICAgZGVjb3JhdGlvbiBvZiB0aGUgc2FtZSB0eXBlLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBqdXN0XG4gICAgcmV0dXJucyBgZmFsc2VgLCB3aGljaCB3aWxsIGNhdXNlIG5ldyBpbnN0YW5jZXMgb2YgdGhlIHdpZGdldCB0b1xuICAgIGFsd2F5cyBiZSByZWRyYXduLlxuICAgICovXG4gICAgZXEod2lkZ2V0KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSBhIERPTSBlbGVtZW50IGNyZWF0ZWQgYnkgYSB3aWRnZXQgb2YgdGhlIHNhbWUgdHlwZSAoYnV0XG4gICAgZGlmZmVyZW50LCBub24tYGVxYCBjb250ZW50KSB0byByZWZsZWN0IHRoaXMgd2lkZ2V0LiBNYXkgcmV0dXJuXG4gICAgdHJ1ZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGNvdWxkIHVwZGF0ZSwgZmFsc2UgdG8gaW5kaWNhdGUgaXRcbiAgICBjb3VsZG4ndCAoaW4gd2hpY2ggY2FzZSB0aGUgd2lkZ2V0IHdpbGwgYmUgcmVkcmF3bikuIFRoZSBkZWZhdWx0XG4gICAgaW1wbGVtZW50YXRpb24ganVzdCByZXR1cm5zIGZhbHNlLlxuICAgICovXG4gICAgdXBkYXRlRE9NKGRvbSwgdmlldykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBvdGhlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmVxKG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVzdGltYXRlZCBoZWlnaHQgdGhpcyB3aWRnZXQgd2lsbCBoYXZlLCB0byBiZSB1c2VkIHdoZW5cbiAgICBlc3RpbWF0aW5nIHRoZSBoZWlnaHQgb2YgY29udGVudCB0aGF0IGhhc24ndCBiZWVuIGRyYXduLiBNYXlcbiAgICByZXR1cm4gLTEgdG8gaW5kaWNhdGUgeW91IGRvbid0IGtub3cuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgcmV0dXJucyAtMS5cbiAgICAqL1xuICAgIGdldCBlc3RpbWF0ZWRIZWlnaHQoKSB7IHJldHVybiAtMTsgfVxuICAgIC8qKlxuICAgIENhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB3aGljaCBraW5kcyBvZiBldmVudHMgaW5zaWRlIHRoZSB3aWRnZXRcbiAgICBzaG91bGQgYmUgaWdub3JlZCBieSB0aGUgZWRpdG9yLiBUaGUgZGVmYXVsdCBpcyB0byBpZ25vcmUgYWxsXG4gICAgZXZlbnRzLlxuICAgICovXG4gICAgaWdub3JlRXZlbnQoZXZlbnQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBjdXN0b21WaWV3KCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIGFuIGluc3RhbmNlIG9mIHRoZSB3aWRnZXQgaXMgcmVtb3ZlZFxuICAgIGZyb20gdGhlIGVkaXRvciB2aWV3LlxuICAgICovXG4gICAgZGVzdHJveShkb20pIHsgfVxufVxuLyoqXG5UaGUgZGlmZmVyZW50IHR5cGVzIG9mIGJsb2NrcyB0aGF0IGNhbiBvY2N1ciBpbiBhbiBlZGl0b3Igdmlldy5cbiovXG52YXIgQmxvY2tUeXBlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQmxvY2tUeXBlKSB7XG4gICAgLyoqXG4gICAgQSBsaW5lIG9mIHRleHQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiVGV4dFwiXSA9IDBdID0gXCJUZXh0XCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbiBhZnRlciBpdC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRCZWZvcmVcIl0gPSAxXSA9IFwiV2lkZ2V0QmVmb3JlXCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbiBiZWZvcmUgaXQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0QWZ0ZXJcIl0gPSAyXSA9IFwiV2lkZ2V0QWZ0ZXJcIjtcbiAgICAvKipcbiAgICBBIGJsb2NrIHdpZGdldCBbcmVwbGFjaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBhIHJhbmdlIG9mIGNvbnRlbnQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0UmFuZ2VcIl0gPSAzXSA9IFwiV2lkZ2V0UmFuZ2VcIjtcbnJldHVybiBCbG9ja1R5cGV9KShCbG9ja1R5cGUgfHwgKEJsb2NrVHlwZSA9IHt9KSk7XG4vKipcbkEgZGVjb3JhdGlvbiBwcm92aWRlcyBpbmZvcm1hdGlvbiBvbiBob3cgdG8gZHJhdyBvciBzdHlsZSBhIHBpZWNlXG5vZiBjb250ZW50LiBZb3UnbGwgdXN1YWxseSB1c2UgaXQgd3JhcHBlZCBpbiBhXG5bYFJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSksIHdoaWNoIGFkZHMgYSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uLlxuQG5vbmFic3RyYWN0XG4qL1xuY2xhc3MgRGVjb3JhdGlvbiBleHRlbmRzIFJhbmdlVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhcnRTaWRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVuZFNpZGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgd2lkZ2V0LCBcbiAgICAvKipcbiAgICBUaGUgY29uZmlnIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGlzIGRlY29yYXRpb24uIFlvdSBjYW5cbiAgICBpbmNsdWRlIGFkZGl0aW9uYWwgcHJvcGVydGllcyBpbiB0aGVyZSB0byBzdG9yZSBtZXRhZGF0YSBhYm91dFxuICAgIHlvdXIgZGVjb3JhdGlvbi5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydFNpZGUgPSBzdGFydFNpZGU7XG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IGVuZFNpZGU7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBoZWlnaHRSZWxldmFudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBkZWNvcmF0aW9uLCB3aGljaCBpbmZsdWVuY2VzIHRoZSBzdHlsaW5nIG9mIHRoZVxuICAgIGNvbnRlbnQgaW4gaXRzIHJhbmdlLiBOZXN0ZWQgbWFyayBkZWNvcmF0aW9ucyB3aWxsIGNhdXNlIG5lc3RlZFxuICAgIERPTSBlbGVtZW50cyB0byBiZSBjcmVhdGVkLiBOZXN0aW5nIG9yZGVyIGlzIGRldGVybWluZWQgYnlcbiAgICBwcmVjZWRlbmNlIG9mIHRoZSBbZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmRlY29yYXRpb25zKSwgd2l0aFxuICAgIHRoZSBoaWdoZXItcHJlY2VkZW5jZSBkZWNvcmF0aW9ucyBjcmVhdGluZyB0aGUgaW5uZXIgRE9NIG5vZGVzLlxuICAgIFN1Y2ggZWxlbWVudHMgYXJlIHNwbGl0IG9uIGxpbmUgYm91bmRhcmllcyBhbmQgb24gdGhlIGJvdW5kYXJpZXNcbiAgICBvZiBsb3dlci1wcmVjZWRlbmNlIGRlY29yYXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIG1hcmsoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcmtEZWNvcmF0aW9uKHNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggZGlzcGxheXMgYSBET00gZWxlbWVudCBhdCB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyB3aWRnZXQoc3BlYykge1xuICAgICAgICBsZXQgc2lkZSA9IHNwZWMuc2lkZSB8fCAwLCBibG9jayA9ICEhc3BlYy5ibG9jaztcbiAgICAgICAgc2lkZSArPSBibG9jayA/IChzaWRlID4gMCA/IDMwMDAwMDAwMCAvKiBTaWRlLkJsb2NrQWZ0ZXIgKi8gOiAtNDAwMDAwMDAwIC8qIFNpZGUuQmxvY2tCZWZvcmUgKi8pIDogKHNpZGUgPiAwID8gMTAwMDAwMDAwIC8qIFNpZGUuSW5saW5lQWZ0ZXIgKi8gOiAtMTAwMDAwMDAwIC8qIFNpZGUuSW5saW5lQmVmb3JlICovKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludERlY29yYXRpb24oc3BlYywgc2lkZSwgc2lkZSwgYmxvY2ssIHNwZWMud2lkZ2V0IHx8IG51bGwsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmVwbGFjZSBkZWNvcmF0aW9uIHdoaWNoIHJlcGxhY2VzIHRoZSBnaXZlbiByYW5nZSB3aXRoXG4gICAgYSB3aWRnZXQsIG9yIHNpbXBseSBoaWRlcyBpdC5cbiAgICAqL1xuICAgIHN0YXRpYyByZXBsYWNlKHNwZWMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gISFzcGVjLmJsb2NrLCBzdGFydFNpZGUsIGVuZFNpZGU7XG4gICAgICAgIGlmIChzcGVjLmlzQmxvY2tHYXApIHtcbiAgICAgICAgICAgIHN0YXJ0U2lkZSA9IC01MDAwMDAwMDAgLyogU2lkZS5HYXBTdGFydCAqLztcbiAgICAgICAgICAgIGVuZFNpZGUgPSA0MDAwMDAwMDAgLyogU2lkZS5HYXBFbmQgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYywgYmxvY2spO1xuICAgICAgICAgICAgc3RhcnRTaWRlID0gKHN0YXJ0ID8gKGJsb2NrID8gLTMwMDAwMDAwMCAvKiBTaWRlLkJsb2NrSW5jU3RhcnQgKi8gOiAtMSAvKiBTaWRlLklubGluZUluY1N0YXJ0ICovKSA6IDUwMDAwMDAwMCAvKiBTaWRlLk5vbkluY1N0YXJ0ICovKSAtIDE7XG4gICAgICAgICAgICBlbmRTaWRlID0gKGVuZCA/IChibG9jayA/IDIwMDAwMDAwMCAvKiBTaWRlLkJsb2NrSW5jRW5kICovIDogMSAvKiBTaWRlLklubGluZUluY0VuZCAqLykgOiAtNjAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jRW5kICovKSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludERlY29yYXRpb24oc3BlYywgc3RhcnRTaWRlLCBlbmRTaWRlLCBibG9jaywgc3BlYy53aWRnZXQgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxpbmUgZGVjb3JhdGlvbiwgd2hpY2ggY2FuIGFkZCBET00gYXR0cmlidXRlcyB0byB0aGVcbiAgICBsaW5lIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBsaW5lKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lRGVjb3JhdGlvbihzcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBbYERlY29yYXRpb25TZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvblNldCkgZnJvbSB0aGUgZ2l2ZW5cbiAgICBkZWNvcmF0ZWQgcmFuZ2Ugb3IgcmFuZ2VzLiBJZiB0aGUgcmFuZ2VzIGFyZW4ndCBhbHJlYWR5IHNvcnRlZCxcbiAgICBwYXNzIGB0cnVlYCBmb3IgYHNvcnRgIHRvIG1ha2UgdGhlIGxpYnJhcnkgc29ydCB0aGVtIGZvciB5b3UuXG4gICAgKi9cbiAgICBzdGF0aWMgc2V0KG9mLCBzb3J0ID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlU2V0Lm9mKG9mLCBzb3J0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBoYXNIZWlnaHQoKSB7IHJldHVybiB0aGlzLndpZGdldCA/IHRoaXMud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA+IC0xIDogZmFsc2U7IH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiBkZWNvcmF0aW9ucy5cbiovXG5EZWNvcmF0aW9uLm5vbmUgPSBSYW5nZVNldC5lbXB0eTtcbmNsYXNzIE1hcmtEZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYyk7XG4gICAgICAgIHN1cGVyKHN0YXJ0ID8gLTEgLyogU2lkZS5JbmxpbmVJbmNTdGFydCAqLyA6IDUwMDAwMDAwMCAvKiBTaWRlLk5vbkluY1N0YXJ0ICovLCBlbmQgPyAxIC8qIFNpZGUuSW5saW5lSW5jRW5kICovIDogLTYwMDAwMDAwMCAvKiBTaWRlLk5vbkluY0VuZCAqLywgbnVsbCwgc3BlYyk7XG4gICAgICAgIHRoaXMudGFnTmFtZSA9IHNwZWMudGFnTmFtZSB8fCBcInNwYW5cIjtcbiAgICAgICAgdGhpcy5jbGFzcyA9IHNwZWMuY2xhc3MgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5hdHRycyA9IHNwZWMuYXR0cmlidXRlcyB8fCBudWxsO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgb3RoZXIgaW5zdGFuY2VvZiBNYXJrRGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgICAgIHRoaXMudGFnTmFtZSA9PSBvdGhlci50YWdOYW1lICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzcyA9PSBvdGhlci5jbGFzcyAmJlxuICAgICAgICAgICAgICAgIGF0dHJzRXEodGhpcy5hdHRycywgb3RoZXIuYXR0cnMpO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdG8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1hcmsgZGVjb3JhdGlvbnMgbWF5IG5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5NYXJrRGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSBmYWxzZTtcbmNsYXNzIExpbmVEZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcigtMjAwMDAwMDAwIC8qIFNpZGUuTGluZSAqLywgLTIwMDAwMDAwMCAvKiBTaWRlLkxpbmUgKi8sIG51bGwsIHNwZWMpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBMaW5lRGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgdGhpcy5zcGVjLmNsYXNzID09IG90aGVyLnNwZWMuY2xhc3MgJiZcbiAgICAgICAgICAgIGF0dHJzRXEodGhpcy5zcGVjLmF0dHJpYnV0ZXMsIG90aGVyLnNwZWMuYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAodG8gIT0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTGluZSBkZWNvcmF0aW9uIHJhbmdlcyBtdXN0IGJlIHplcm8tbGVuZ3RoXCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbkxpbmVEZWNvcmF0aW9uLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0JlZm9yZTtcbkxpbmVEZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG5jbGFzcyBQb2ludERlY29yYXRpb24gZXh0ZW5kcyBEZWNvcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjLCBzdGFydFNpZGUsIGVuZFNpZGUsIGJsb2NrLCB3aWRnZXQsIGlzUmVwbGFjZSkge1xuICAgICAgICBzdXBlcihzdGFydFNpZGUsIGVuZFNpZGUsIHdpZGdldCwgc3BlYyk7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcbiAgICAgICAgdGhpcy5pc1JlcGxhY2UgPSBpc1JlcGxhY2U7XG4gICAgICAgIHRoaXMubWFwTW9kZSA9ICFibG9jayA/IE1hcE1vZGUuVHJhY2tEZWwgOiBzdGFydFNpZGUgPD0gMCA/IE1hcE1vZGUuVHJhY2tCZWZvcmUgOiBNYXBNb2RlLlRyYWNrQWZ0ZXI7XG4gICAgfVxuICAgIC8vIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGlzLmJsb2NrID09IHRydWVcbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRTaWRlIDwgdGhpcy5lbmRTaWRlID8gQmxvY2tUeXBlLldpZGdldFJhbmdlXG4gICAgICAgICAgICA6IHRoaXMuc3RhcnRTaWRlIDw9IDAgPyBCbG9ja1R5cGUuV2lkZ2V0QmVmb3JlIDogQmxvY2tUeXBlLldpZGdldEFmdGVyO1xuICAgIH1cbiAgICBnZXQgaGVpZ2h0UmVsZXZhbnQoKSB7IHJldHVybiB0aGlzLmJsb2NrIHx8ICEhdGhpcy53aWRnZXQgJiYgdGhpcy53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0ID49IDU7IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24gJiZcbiAgICAgICAgICAgIHdpZGdldHNFcSh0aGlzLndpZGdldCwgb3RoZXIud2lkZ2V0KSAmJlxuICAgICAgICAgICAgdGhpcy5ibG9jayA9PSBvdGhlci5ibG9jayAmJlxuICAgICAgICAgICAgdGhpcy5zdGFydFNpZGUgPT0gb3RoZXIuc3RhcnRTaWRlICYmIHRoaXMuZW5kU2lkZSA9PSBvdGhlci5lbmRTaWRlO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZXBsYWNlICYmIChmcm9tID4gdG8gfHwgKGZyb20gPT0gdG8gJiYgdGhpcy5zdGFydFNpZGUgPiAwICYmIHRoaXMuZW5kU2lkZSA8PSAwKSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcmFuZ2UgZm9yIHJlcGxhY2VtZW50IGRlY29yYXRpb25cIik7XG4gICAgICAgIGlmICghdGhpcy5pc1JlcGxhY2UgJiYgdG8gIT0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiV2lkZ2V0IGRlY29yYXRpb25zIGNhbiBvbmx5IGhhdmUgemVyby1sZW5ndGggcmFuZ2VzXCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cblBvaW50RGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSB0cnVlO1xuZnVuY3Rpb24gZ2V0SW5jbHVzaXZlKHNwZWMsIGJsb2NrID0gZmFsc2UpIHtcbiAgICBsZXQgeyBpbmNsdXNpdmVTdGFydDogc3RhcnQsIGluY2x1c2l2ZUVuZDogZW5kIH0gPSBzcGVjO1xuICAgIGlmIChzdGFydCA9PSBudWxsKVxuICAgICAgICBzdGFydCA9IHNwZWMuaW5jbHVzaXZlO1xuICAgIGlmIChlbmQgPT0gbnVsbClcbiAgICAgICAgZW5kID0gc3BlYy5pbmNsdXNpdmU7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0ICE9PSBudWxsICYmIHN0YXJ0ICE9PSB2b2lkIDAgPyBzdGFydCA6IGJsb2NrLCBlbmQ6IGVuZCAhPT0gbnVsbCAmJiBlbmQgIT09IHZvaWQgMCA/IGVuZCA6IGJsb2NrIH07XG59XG5mdW5jdGlvbiB3aWRnZXRzRXEoYSwgYikge1xuICAgIHJldHVybiBhID09IGIgfHwgISEoYSAmJiBiICYmIGEuY29tcGFyZShiKSk7XG59XG5mdW5jdGlvbiBhZGRSYW5nZShmcm9tLCB0bywgcmFuZ2VzLCBtYXJnaW4gPSAwKSB7XG4gICAgbGV0IGxhc3QgPSByYW5nZXMubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA+PSAwICYmIHJhbmdlc1tsYXN0XSArIG1hcmdpbiA+PSBmcm9tKVxuICAgICAgICByYW5nZXNbbGFzdF0gPSBNYXRoLm1heChyYW5nZXNbbGFzdF0sIHRvKTtcbiAgICBlbHNlXG4gICAgICAgIHJhbmdlcy5wdXNoKGZyb20sIHRvKTtcbn1cblxuY2xhc3MgTGluZVZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hdHRycyA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IDA7XG4gICAgfVxuICAgIC8vIENvbnN1bWVzIHNvdXJjZVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgTGluZVZpZXcpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgc291cmNlLnRyYW5zZmVyRE9NKHRoaXMpOyAvLyBSZXVzZSBzb3VyY2UuZG9tIHdoZW4gYXBwcm9wcmlhdGVcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzU3RhcnQpXG4gICAgICAgICAgICB0aGlzLnNldERlY28oc291cmNlID8gc291cmNlLmF0dHJzIDogbnVsbCk7XG4gICAgICAgIG1lcmdlQ2hpbGRyZW5JbnRvKHRoaXMsIGZyb20sIHRvLCBzb3VyY2UgPyBzb3VyY2UuY2hpbGRyZW4gOiBbXSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGF0KSB7XG4gICAgICAgIGxldCBlbmQgPSBuZXcgTGluZVZpZXc7XG4gICAgICAgIGVuZC5icmVha0FmdGVyID0gdGhpcy5icmVha0FmdGVyO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgIGxldCB7IGksIG9mZiB9ID0gdGhpcy5jaGlsZFBvcyhhdCk7XG4gICAgICAgIGlmIChvZmYpIHtcbiAgICAgICAgICAgIGVuZC5hcHBlbmQodGhpcy5jaGlsZHJlbltpXS5zcGxpdChvZmYpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ubWVyZ2Uob2ZmLCB0aGlzLmNoaWxkcmVuW2ldLmxlbmd0aCwgbnVsbCwgZmFsc2UsIDAsIDApO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGorKylcbiAgICAgICAgICAgIGVuZC5hcHBlbmQodGhpcy5jaGlsZHJlbltqXSwgMCk7XG4gICAgICAgIHdoaWxlIChpID4gMCAmJiB0aGlzLmNoaWxkcmVuW2kgLSAxXS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bLS1pXS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gaTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBhdDtcbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG4gICAgdHJhbnNmZXJET00ob3RoZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgb3RoZXIuc2V0RE9NKHRoaXMuZG9tKTtcbiAgICAgICAgb3RoZXIucHJldkF0dHJzID0gdGhpcy5wcmV2QXR0cnMgPT09IHVuZGVmaW5lZCA/IHRoaXMuYXR0cnMgOiB0aGlzLnByZXZBdHRycztcbiAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZG9tID0gbnVsbDtcbiAgICB9XG4gICAgc2V0RGVjbyhhdHRycykge1xuICAgICAgICBpZiAoIWF0dHJzRXEodGhpcy5hdHRycywgYXR0cnMpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBlbmQoY2hpbGQsIG9wZW5TdGFydCkge1xuICAgICAgICBqb2luSW5saW5lSW50byh0aGlzLCBjaGlsZCwgb3BlblN0YXJ0KTtcbiAgICB9XG4gICAgLy8gT25seSBjYWxsZWQgd2hlbiBidWlsZGluZyBhIGxpbmUgdmlldyBpbiBDb250ZW50QnVpbGRlclxuICAgIGFkZExpbmVEZWNvKGRlY28pIHtcbiAgICAgICAgbGV0IGF0dHJzID0gZGVjby5zcGVjLmF0dHJpYnV0ZXMsIGNscyA9IGRlY28uc3BlYy5jbGFzcztcbiAgICAgICAgaWYgKGF0dHJzKVxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGNvbWJpbmVBdHRycyhhdHRycywgdGhpcy5hdHRycyB8fCB7fSk7XG4gICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICB0aGlzLmF0dHJzID0gY29tYmluZUF0dHJzKHsgY2xhc3M6IGNscyB9LCB0aGlzLmF0dHJzIHx8IHt9KTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBpbmxpbmVET01BdFBvcyh0aGlzLCBwb3MpO1xuICAgIH1cbiAgICByZXVzZURPTShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiRElWXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSB8PSA0IC8qIERpcnR5LkF0dHJzICovIHwgMiAvKiBEaXJ0eS5Ob2RlICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICAgICAgICB0aGlzLnNldERPTShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRpcnR5ICYgNCAvKiBEaXJ0eS5BdHRycyAqLykge1xuICAgICAgICAgICAgY2xlYXJBdHRyaWJ1dGVzKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmV2QXR0cnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXBkYXRlQXR0cnModGhpcy5kb20sIHRoaXMucHJldkF0dHJzLCB0aGlzLmF0dHJzKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1saW5lXCIpO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5kb20ubGFzdENoaWxkO1xuICAgICAgICB3aGlsZSAobGFzdCAmJiBDb250ZW50Vmlldy5nZXQobGFzdCkgaW5zdGFuY2VvZiBNYXJrVmlldylcbiAgICAgICAgICAgIGxhc3QgPSBsYXN0Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFsYXN0IHx8ICF0aGlzLmxlbmd0aCB8fFxuICAgICAgICAgICAgbGFzdC5ub2RlTmFtZSAhPSBcIkJSXCIgJiYgKChfYSA9IENvbnRlbnRWaWV3LmdldChsYXN0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRWRpdGFibGUpID09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKCFicm93c2VyLmlvcyB8fCAhdGhpcy5jaGlsZHJlbi5zb21lKGNoID0+IGNoIGluc3RhbmNlb2YgVGV4dFZpZXcpKSkge1xuICAgICAgICAgICAgbGV0IGhhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiQlJcIik7XG4gICAgICAgICAgICBoYWNrLmNtSWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGhhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVUZXh0U2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgdGhpcy5sZW5ndGggPiAyMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdG90YWxXaWR0aCA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgVGV4dFZpZXcpIHx8IC9bXiAtfl0vLnRlc3QoY2hpbGQudGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihjaGlsZC5kb20pO1xuICAgICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aCAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdG90YWxXaWR0aCArPSByZWN0c1swXS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRvdGFsV2lkdGggPyBudWxsIDoge1xuICAgICAgICAgICAgbGluZUhlaWdodDogdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0LFxuICAgICAgICAgICAgY2hhcldpZHRoOiB0b3RhbFdpZHRoIC8gdGhpcy5sZW5ndGhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiBjb29yZHNJbkNoaWxkcmVuKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIGJlY29tZShfb3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBCbG9ja1R5cGUuVGV4dDsgfVxuICAgIHN0YXRpYyBmaW5kKGRvY1ZpZXcsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IGRvY1ZpZXcuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBibG9jayA9IGRvY1ZpZXcuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGJsb2NrLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrIGluc3RhbmNlb2YgTGluZVZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibG9jaztcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiA9IGVuZCArIGJsb2NrLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY2xhc3MgQmxvY2tXaWRnZXRWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHdpZGdldCwgbGVuZ3RoLCB0eXBlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5icmVha0FmdGVyID0gMDtcbiAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbDtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgX3Rha2VEZWNvLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHNvdXJjZS53aWRnZXQpIHx8XG4gICAgICAgICAgICBmcm9tID4gMCAmJiBvcGVuU3RhcnQgPD0gMCB8fCB0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbSArIChzb3VyY2UgPyBzb3VyY2UubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSB0byk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcyA9PSAwID8gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSkgOiBET01Qb3MuYWZ0ZXIodGhpcy5kb20sIHBvcyA9PSB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIHNwbGl0KGF0KSB7XG4gICAgICAgIGxldCBsZW4gPSB0aGlzLmxlbmd0aCAtIGF0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGF0O1xuICAgICAgICBsZXQgZW5kID0gbmV3IEJsb2NrV2lkZ2V0Vmlldyh0aGlzLndpZGdldCwgbGVuLCB0aGlzLnR5cGUpO1xuICAgICAgICBlbmQuYnJlYWtBZnRlciA9IHRoaXMuYnJlYWtBZnRlcjtcbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG4gICAgZ2V0IGNoaWxkcmVuKCkgeyByZXR1cm4gbm9DaGlsZHJlbjsgfVxuICAgIHN5bmModmlldykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLndpZGdldC51cGRhdGVET00odGhpcy5kb20sIHZpZXcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSh2aWV3KSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQudmlldy5zdGF0ZS5kb2Muc2xpY2UodGhpcy5wb3NBdFN0YXJ0LCB0aGlzLnBvc0F0RW5kKSA6IFRleHQuZW1wdHk7XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmIG90aGVyLnR5cGUgPT0gdGhpcy50eXBlICYmXG4gICAgICAgICAgICBvdGhlci53aWRnZXQuY29uc3RydWN0b3IgPT0gdGhpcy53aWRnZXQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICghb3RoZXIud2lkZ2V0LmVxKHRoaXMud2lkZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiAhdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IHRoaXMud2lkZ2V0O1xuICAgICAgICAgICAgdGhpcy53aWRnZXQgPSBvdGhlci53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG90aGVyLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IG90aGVyLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0aGlzLndpZGdldC5pZ25vcmVFdmVudChldmVudCk7IH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlzV2lkZ2V0KCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy53aWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgfVxufVxuXG5jbGFzcyBDb250ZW50QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoZG9jLCBwb3MsIGVuZCwgZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3IpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy5kaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvciA9IGRpc2FsbG93QmxvY2tFZmZlY3RzRm9yO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5icmVha0F0U3RhcnQgPSAwO1xuICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgdGhpcy5idWZmZXJNYXJrcyA9IFtdO1xuICAgICAgICAvLyBTZXQgdG8gZmFsc2UgZGlyZWN0bHkgYWZ0ZXIgYSB3aWRnZXQgdGhhdCBjb3ZlcnMgdGhlIHBvc2l0aW9uIGFmdGVyIGl0XG4gICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLm9wZW5FbmQgPSAtMTtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBkb2MuaXRlcigpO1xuICAgICAgICB0aGlzLnNraXAgPSBwb3M7XG4gICAgfVxuICAgIHBvc0NvdmVyZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuYnJlYWtBdFN0YXJ0ICYmIHRoaXMuZG9jLmxpbmVBdCh0aGlzLnBvcykuZnJvbSAhPSB0aGlzLnBvcztcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gIWxhc3QuYnJlYWtBZnRlciAmJiAhKGxhc3QgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiYgbGFzdC50eXBlID09IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUpO1xuICAgIH1cbiAgICBnZXRMaW5lKCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VyTGluZSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnB1c2godGhpcy5jdXJMaW5lID0gbmV3IExpbmVWaWV3KTtcbiAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmN1ckxpbmU7XG4gICAgfVxuICAgIGZsdXNoQnVmZmVyKGFjdGl2ZSA9IHRoaXMuYnVmZmVyTWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lLmFwcGVuZCh3cmFwTWFya3MobmV3IFdpZGdldEJ1ZmZlclZpZXcoLTEpLCBhY3RpdmUpLCBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEJsb2NrV2lkZ2V0KHZpZXcpIHtcbiAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRlbnQucHVzaCh2aWV3KTtcbiAgICB9XG4gICAgZmluaXNoKG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlciAmJiBvcGVuRW5kIDw9IHRoaXMuYnVmZmVyTWFya3MubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgaWYgKCF0aGlzLnBvc0NvdmVyZWQoKSlcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgIH1cbiAgICBidWlsZFRleHQobGVuZ3RoLCBhY3RpdmUsIG9wZW5TdGFydCkge1xuICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGV4dE9mZiA9PSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdmFsdWUsIGxpbmVCcmVhaywgZG9uZSB9ID0gdGhpcy5jdXJzb3IubmV4dCh0aGlzLnNraXApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbiBvdXQgb2YgdGV4dCBjb250ZW50IHdoZW4gZHJhd2luZyBpbmxpbmUgdmlld3NcIik7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVCcmVhaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucG9zQ292ZXJlZCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXS5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5icmVha0F0U3RhcnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGFrZSA9IE1hdGgubWluKHRoaXMudGV4dC5sZW5ndGggLSB0aGlzLnRleHRPZmYsIGxlbmd0aCwgNTEyIC8qIFQuQ2h1bmsgKi8pO1xuICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcihhY3RpdmUuc2xpY2UoYWN0aXZlLmxlbmd0aCAtIG9wZW5TdGFydCkpO1xuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCkuYXBwZW5kKHdyYXBNYXJrcyhuZXcgVGV4dFZpZXcodGhpcy50ZXh0LnNsaWNlKHRoaXMudGV4dE9mZiwgdGhpcy50ZXh0T2ZmICsgdGFrZSkpLCBhY3RpdmUpLCBvcGVuU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRleHRPZmYgKz0gdGFrZTtcbiAgICAgICAgICAgIGxlbmd0aCAtPSB0YWtlO1xuICAgICAgICAgICAgb3BlblN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzcGFuKGZyb20sIHRvLCBhY3RpdmUsIG9wZW5TdGFydCkge1xuICAgICAgICB0aGlzLmJ1aWxkVGV4dCh0byAtIGZyb20sIGFjdGl2ZSwgb3BlblN0YXJ0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICAgICAgaWYgKHRoaXMub3BlblN0YXJ0IDwgMClcbiAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0ID0gb3BlblN0YXJ0O1xuICAgIH1cbiAgICBwb2ludChmcm9tLCB0bywgZGVjbywgYWN0aXZlLCBvcGVuU3RhcnQsIGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FsbG93QmxvY2tFZmZlY3RzRm9yW2luZGV4XSAmJiBkZWNvIGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJsb2NrIGRlY29yYXRpb25zIG1heSBub3QgYmUgc3BlY2lmaWVkIHZpYSBwbHVnaW5zXCIpO1xuICAgICAgICAgICAgaWYgKHRvID4gdGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS50bylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRlY29yYXRpb25zIHRoYXQgcmVwbGFjZSBsaW5lIGJyZWFrcyBtYXkgbm90IGJlIHNwZWNpZmllZCB2aWEgcGx1Z2luc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuID0gdG8gLSBmcm9tO1xuICAgICAgICBpZiAoZGVjbyBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlIH0gPSBkZWNvO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IEJsb2NrVHlwZS5XaWRnZXRBZnRlciAmJiAhdGhpcy5wb3NDb3ZlcmVkKCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmxvY2tXaWRnZXQobmV3IEJsb2NrV2lkZ2V0VmlldyhkZWNvLndpZGdldCB8fCBuZXcgTnVsbFdpZGdldChcImRpdlwiKSwgbGVuLCB0eXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdmlldyA9IFdpZGdldFZpZXcuY3JlYXRlKGRlY28ud2lkZ2V0IHx8IG5ldyBOdWxsV2lkZ2V0KFwic3BhblwiKSwgbGVuLCBsZW4gPyAwIDogZGVjby5zdGFydFNpZGUpO1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3JCZWZvcmUgPSB0aGlzLmF0Q3Vyc29yUG9zICYmICF2aWV3LmlzRWRpdGFibGUgJiYgb3BlblN0YXJ0IDw9IGFjdGl2ZS5sZW5ndGggJiYgKGZyb20gPCB0byB8fCBkZWNvLnN0YXJ0U2lkZSA+IDApO1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3JBZnRlciA9ICF2aWV3LmlzRWRpdGFibGUgJiYgKGZyb20gPCB0byB8fCBvcGVuU3RhcnQgPiBhY3RpdmUubGVuZ3RoIHx8IGRlY28uc3RhcnRTaWRlIDw9IDApO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlciA9PSAyIC8qIEJ1Zi5JZkN1cnNvciAqLyAmJiAhY3Vyc29yQmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvckJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lLmFwcGVuZCh3cmFwTWFya3MobmV3IFdpZGdldEJ1ZmZlclZpZXcoMSksIGFjdGl2ZSksIG9wZW5TdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5TdGFydCA9IGFjdGl2ZS5sZW5ndGggKyBNYXRoLm1heCgwLCBvcGVuU3RhcnQgLSBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZS5hcHBlbmQod3JhcE1hcmtzKHZpZXcsIGFjdGl2ZSksIG9wZW5TdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IGN1cnNvckFmdGVyO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9ICFjdXJzb3JBZnRlciA/IDAgLyogQnVmLk5vICovIDogZnJvbSA8IHRvIHx8IG9wZW5TdGFydCA+IGFjdGl2ZS5sZW5ndGggPyAxIC8qIEJ1Zi5ZZXMgKi8gOiAyIC8qIEJ1Zi5JZkN1cnNvciAqLztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlck1hcmtzID0gYWN0aXZlLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS5mcm9tID09IHRoaXMucG9zKSB7IC8vIExpbmUgZGVjb3JhdGlvblxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCkuYWRkTGluZURlY28oZGVjbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgaXRlcmF0b3IgcGFzdCB0aGUgcmVwbGFjZWQgY29udGVudFxuICAgICAgICAgICAgaWYgKHRoaXMudGV4dE9mZiArIGxlbiA8PSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCArPSBsZW4gLSAodGhpcy50ZXh0Lmxlbmd0aCAtIHRoaXMudGV4dE9mZik7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcGVuU3RhcnQgPCAwKVxuICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSBvcGVuU3RhcnQ7XG4gICAgfVxuICAgIHN0YXRpYyBidWlsZCh0ZXh0LCBmcm9tLCB0bywgZGVjb3JhdGlvbnMsIGR5bmFtaWNEZWNvcmF0aW9uTWFwKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IENvbnRlbnRCdWlsZGVyKHRleHQsIGZyb20sIHRvLCBkeW5hbWljRGVjb3JhdGlvbk1hcCk7XG4gICAgICAgIGJ1aWxkZXIub3BlbkVuZCA9IFJhbmdlU2V0LnNwYW5zKGRlY29yYXRpb25zLCBmcm9tLCB0bywgYnVpbGRlcik7XG4gICAgICAgIGlmIChidWlsZGVyLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICBidWlsZGVyLm9wZW5TdGFydCA9IGJ1aWxkZXIub3BlbkVuZDtcbiAgICAgICAgYnVpbGRlci5maW5pc2goYnVpbGRlci5vcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JhcE1hcmtzKHZpZXcsIGFjdGl2ZSkge1xuICAgIGZvciAobGV0IG1hcmsgb2YgYWN0aXZlKVxuICAgICAgICB2aWV3ID0gbmV3IE1hcmtWaWV3KG1hcmssIFt2aWV3XSwgdmlldy5sZW5ndGgpO1xuICAgIHJldHVybiB2aWV3O1xufVxuY2xhc3MgTnVsbFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRhZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLnRhZyA9PSB0aGlzLnRhZzsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLnRhZyk7IH1cbiAgICB1cGRhdGVET00oZWx0KSB7IHJldHVybiBlbHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSB0aGlzLnRhZzsgfVxufVxuXG5jb25zdCBjbGlja0FkZHNTZWxlY3Rpb25SYW5nZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGRyYWdNb3Zlc1NlbGVjdGlvbiQxID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgbW91c2VTZWxlY3Rpb25TdHlsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGV4Y2VwdGlvblNpbmsgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCB1cGRhdGVMaXN0ZW5lciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGlucHV0SGFuZGxlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGZvY3VzQ2hhbmdlRWZmZWN0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgcGVyTGluZVRleHREaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG5jb25zdCBuYXRpdmVTZWxlY3Rpb25IaWRkZW4gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG5jbGFzcyBTY3JvbGxUYXJnZXQge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlLCB5ID0gXCJuZWFyZXN0XCIsIHggPSBcIm5lYXJlc3RcIiwgeU1hcmdpbiA9IDUsIHhNYXJnaW4gPSA1KSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55TWFyZ2luID0geU1hcmdpbjtcbiAgICAgICAgdGhpcy54TWFyZ2luID0geE1hcmdpbjtcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXMuZW1wdHkgPyB0aGlzIDogbmV3IFNjcm9sbFRhcmdldCh0aGlzLnJhbmdlLm1hcChjaGFuZ2VzKSwgdGhpcy55LCB0aGlzLngsIHRoaXMueU1hcmdpbiwgdGhpcy54TWFyZ2luKTtcbiAgICB9XG59XG5jb25zdCBzY3JvbGxJbnRvVmlldyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6ICh0LCBjaCkgPT4gdC5tYXAoY2gpIH0pO1xuLyoqXG5Mb2cgb3IgcmVwb3J0IGFuIHVuaGFuZGxlZCBleGNlcHRpb24gaW4gY2xpZW50IGNvZGUuIFNob3VsZFxucHJvYmFibHkgb25seSBiZSB1c2VkIGJ5IGV4dGVuc2lvbiBjb2RlIHRoYXQgYWxsb3dzIGNsaWVudCBjb2RlIHRvXG5wcm92aWRlIGZ1bmN0aW9ucywgYW5kIGNhbGxzIHRob3NlIGZ1bmN0aW9ucyBpbiBhIGNvbnRleHQgd2hlcmUgYW5cbmV4Y2VwdGlvbiBjYW4ndCBiZSBwcm9wYWdhdGVkIHRvIGNhbGxpbmcgY29kZSBpbiBhIHJlYXNvbmFibGUgd2F5XG4oZm9yIGV4YW1wbGUgd2hlbiBpbiBhbiBldmVudCBoYW5kbGVyKS5cblxuRWl0aGVyIGNhbGxzIGEgaGFuZGxlciByZWdpc3RlcmVkIHdpdGhcbltgRWRpdG9yVmlldy5leGNlcHRpb25TaW5rYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZXhjZXB0aW9uU2luayksXG5gd2luZG93Lm9uZXJyb3JgLCBpZiBkZWZpbmVkLCBvciBgY29uc29sZS5lcnJvcmAgKGluIHdoaWNoIGNhc2Vcbml0J2xsIHBhc3MgYGNvbnRleHRgLCB3aGVuIGdpdmVuLCBhcyBmaXJzdCBhcmd1bWVudCkuXG4qL1xuZnVuY3Rpb24gbG9nRXhjZXB0aW9uKHN0YXRlLCBleGNlcHRpb24sIGNvbnRleHQpIHtcbiAgICBsZXQgaGFuZGxlciA9IHN0YXRlLmZhY2V0KGV4Y2VwdGlvblNpbmspO1xuICAgIGlmIChoYW5kbGVyLmxlbmd0aClcbiAgICAgICAgaGFuZGxlclswXShleGNlcHRpb24pO1xuICAgIGVsc2UgaWYgKHdpbmRvdy5vbmVycm9yKVxuICAgICAgICB3aW5kb3cub25lcnJvcihTdHJpbmcoZXhjZXB0aW9uKSwgY29udGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGV4Y2VwdGlvbik7XG4gICAgZWxzZSBpZiAoY29udGV4dClcbiAgICAgICAgY29uc29sZS5lcnJvcihjb250ZXh0ICsgXCI6XCIsIGV4Y2VwdGlvbik7XG4gICAgZWxzZVxuICAgICAgICBjb25zb2xlLmVycm9yKGV4Y2VwdGlvbik7XG59XG5jb25zdCBlZGl0YWJsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IHRydWUgfSk7XG5sZXQgbmV4dFBsdWdpbklEID0gMDtcbmNvbnN0IHZpZXdQbHVnaW4gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcblZpZXcgcGx1Z2lucyBhc3NvY2lhdGUgc3RhdGVmdWwgdmFsdWVzIHdpdGggYSB2aWV3LiBUaGV5IGNhblxuaW5mbHVlbmNlIHRoZSB3YXkgdGhlIGNvbnRlbnQgaXMgZHJhd24sIGFuZCBhcmUgbm90aWZpZWQgb2YgdGhpbmdzXG50aGF0IGhhcHBlbiBpbiB0aGUgdmlldy5cbiovXG5jbGFzcyBWaWV3UGx1Z2luIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlkLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNyZWF0ZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkb21FdmVudEhhbmRsZXJzLCBidWlsZEV4dGVuc2lvbnMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgdGhpcy5kb21FdmVudEhhbmRsZXJzID0gZG9tRXZlbnRIYW5kbGVycztcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBidWlsZEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHBsdWdpbiBmcm9tIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZVxuICAgIHBsdWdpbidzIHZhbHVlLCBnaXZlbiBhbiBlZGl0b3Igdmlldy5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY3JlYXRlLCBzcGVjKSB7XG4gICAgICAgIGNvbnN0IHsgZXZlbnRIYW5kbGVycywgcHJvdmlkZSwgZGVjb3JhdGlvbnM6IGRlY28gfSA9IHNwZWMgfHwge307XG4gICAgICAgIHJldHVybiBuZXcgVmlld1BsdWdpbihuZXh0UGx1Z2luSUQrKywgY3JlYXRlLCBldmVudEhhbmRsZXJzLCBwbHVnaW4gPT4ge1xuICAgICAgICAgICAgbGV0IGV4dCA9IFt2aWV3UGx1Z2luLm9mKHBsdWdpbildO1xuICAgICAgICAgICAgaWYgKGRlY28pXG4gICAgICAgICAgICAgICAgZXh0LnB1c2goZGVjb3JhdGlvbnMub2YodmlldyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbHVnaW5JbnN0ID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbkluc3QgPyBkZWNvKHBsdWdpbkluc3QpIDogRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlKVxuICAgICAgICAgICAgICAgIGV4dC5wdXNoKHByb3ZpZGUocGx1Z2luKSk7XG4gICAgICAgICAgICByZXR1cm4gZXh0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luIGZvciBhIGNsYXNzIHdob3NlIGNvbnN0cnVjdG9yIHRha2VzIGEgc2luZ2xlXG4gICAgZWRpdG9yIHZpZXcgYXMgYXJndW1lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUNsYXNzKGNscywgc3BlYykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUodmlldyA9PiBuZXcgY2xzKHZpZXcpLCBzcGVjKTtcbiAgICB9XG59XG5jbGFzcyBQbHVnaW5JbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvLyBXaGVuIHN0YXJ0aW5nIGFuIHVwZGF0ZSwgYWxsIHBsdWdpbnMgaGF2ZSB0aGlzIGZpZWxkIHNldCB0byB0aGVcbiAgICAgICAgLy8gdXBkYXRlIG9iamVjdCwgaW5kaWNhdGluZyB0aGV5IG5lZWQgdG8gYmUgdXBkYXRlZC4gV2hlbiBmaW5pc2hlZFxuICAgICAgICAvLyB1cGRhdGluZywgaXQgaXMgc2V0IHRvIGBmYWxzZWAuIFJldHJpZXZpbmcgYSBwbHVnaW4gdGhhdCBuZWVkcyB0b1xuICAgICAgICAvLyBiZSB1cGRhdGVkIHdpdGggYHZpZXcucGx1Z2luYCBmb3JjZXMgYW4gZWFnZXIgdXBkYXRlLlxuICAgICAgICB0aGlzLm11c3RVcGRhdGUgPSBudWxsO1xuICAgICAgICAvLyBUaGlzIGlzIG51bGwgd2hlbiB0aGUgcGx1Z2luIGlzIGluaXRpYWxseSBjcmVhdGVkLCBidXRcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQgb24gdGhlIGZpcnN0IHVwZGF0ZS5cbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIHVwZGF0ZSh2aWV3KSB7XG4gICAgICAgIGlmICghdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3BlYykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnNwZWMuY3JlYXRlKHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tdXN0VXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgdXBkYXRlID0gdGhpcy5tdXN0VXBkYXRlO1xuICAgICAgICAgICAgdGhpcy5tdXN0VXBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih1cGRhdGUuc3RhdGUsIGUsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuZGVzdHJveSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVzdHJveSh2aWV3KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHRoaXMudmFsdWUgPSBudWxsO1xuICAgIH1cbn1cbmNvbnN0IGVkaXRvckF0dHJpYnV0ZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBjb250ZW50QXR0cmlidXRlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8vIFByb3ZpZGUgZGVjb3JhdGlvbnNcbmNvbnN0IGRlY29yYXRpb25zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgYXRvbWljUmFuZ2VzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3Qgc2Nyb2xsTWFyZ2lucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHN0eWxlTW9kdWxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY2xhc3MgQ2hhbmdlZFJhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSB7XG4gICAgICAgIHRoaXMuZnJvbUEgPSBmcm9tQTtcbiAgICAgICAgdGhpcy50b0EgPSB0b0E7XG4gICAgICAgIHRoaXMuZnJvbUIgPSBmcm9tQjtcbiAgICAgICAgdGhpcy50b0IgPSB0b0I7XG4gICAgfVxuICAgIGpvaW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VkUmFuZ2UoTWF0aC5taW4odGhpcy5mcm9tQSwgb3RoZXIuZnJvbUEpLCBNYXRoLm1heCh0aGlzLnRvQSwgb3RoZXIudG9BKSwgTWF0aC5taW4odGhpcy5mcm9tQiwgb3RoZXIuZnJvbUIpLCBNYXRoLm1heCh0aGlzLnRvQiwgb3RoZXIudG9CKSk7XG4gICAgfVxuICAgIGFkZFRvU2V0KHNldCkge1xuICAgICAgICBsZXQgaSA9IHNldC5sZW5ndGgsIG1lID0gdGhpcztcbiAgICAgICAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHNldFtpIC0gMV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZnJvbUEgPiBtZS50b0EpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UudG9BIDwgbWUuZnJvbUEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBtZSA9IG1lLmpvaW4ocmFuZ2UpO1xuICAgICAgICAgICAgc2V0LnNwbGljZShpIC0gMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0LnNwbGljZShpLCAwLCBtZSk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIHN0YXRpYyBleHRlbmRXaXRoUmFuZ2VzKGRpZmYsIHJhbmdlcykge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZEkgPSAwLCBySSA9IDAsIHBvc0EgPSAwLCBwb3NCID0gMDs7IGRJKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZEkgPT0gZGlmZi5sZW5ndGggPyBudWxsIDogZGlmZltkSV0sIG9mZiA9IHBvc0EgLSBwb3NCO1xuICAgICAgICAgICAgbGV0IGVuZCA9IG5leHQgPyBuZXh0LmZyb21CIDogMWU5O1xuICAgICAgICAgICAgd2hpbGUgKHJJIDwgcmFuZ2VzLmxlbmd0aCAmJiByYW5nZXNbckldIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbckldLCB0byA9IHJhbmdlc1tySSArIDFdO1xuICAgICAgICAgICAgICAgIGxldCBmcm9tQiA9IE1hdGgubWF4KHBvc0IsIGZyb20pLCB0b0IgPSBNYXRoLm1pbihlbmQsIHRvKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUIgPD0gdG9CKVxuICAgICAgICAgICAgICAgICAgICBuZXcgQ2hhbmdlZFJhbmdlKGZyb21CICsgb2ZmLCB0b0IgKyBvZmYsIGZyb21CLCB0b0IpLmFkZFRvU2V0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHRvID4gZW5kKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJJICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIG5ldyBDaGFuZ2VkUmFuZ2UobmV4dC5mcm9tQSwgbmV4dC50b0EsIG5leHQuZnJvbUIsIG5leHQudG9CKS5hZGRUb1NldChyZXN1bHQpO1xuICAgICAgICAgICAgcG9zQSA9IG5leHQudG9BO1xuICAgICAgICAgICAgcG9zQiA9IG5leHQudG9CO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG5WaWV3IFtwbHVnaW5zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuVmlld1BsdWdpbikgYXJlIGdpdmVuIGluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcywgd2hpY2ggZGVzY3JpYmUgd2hhdCBoYXBwZW5lZCwgd2hlbmV2ZXIgdGhlIHZpZXcgaXMgdXBkYXRlZC5cbiovXG5jbGFzcyBWaWV3VXBkYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgZWRpdG9yIHZpZXcgdGhhdCB0aGUgdXBkYXRlIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICAqL1xuICAgIHZpZXcsIFxuICAgIC8qKlxuICAgIFRoZSBuZXcgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2FjdGlvbnMgaW52b2x2ZWQgaW4gdGhlIHVwZGF0ZS4gTWF5IGJlIGVtcHR5LlxuICAgICovXG4gICAgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbGFncyA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcyA9IHRoaXMuY2hhbmdlcy5jb21wb3NlKHRyLmNoYW5nZXMpO1xuICAgICAgICBsZXQgY2hhbmdlZFJhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpID0+IGNoYW5nZWRSYW5nZXMucHVzaChuZXcgQ2hhbmdlZFJhbmdlKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpKSk7XG4gICAgICAgIHRoaXMuY2hhbmdlZFJhbmdlcyA9IGNoYW5nZWRSYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZSh2aWV3LCBzdGF0ZSwgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmlld1VwZGF0ZSh2aWV3LCBzdGF0ZSwgdHJhbnNhY3Rpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIFt2aWV3cG9ydF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudmlld3BvcnQpIG9yXG4gICAgW3Zpc2libGUgcmFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy52aXNpYmxlUmFuZ2VzKSBjaGFuZ2VkIGluIHRoaXNcbiAgICB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnRDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGhlaWdodCBvZiBhIGJsb2NrIGVsZW1lbnQgaW4gdGhlIGVkaXRvclxuICAgIGNoYW5nZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgaGVpZ2h0Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZG9jdW1lbnQgd2FzIG1vZGlmaWVkIG9yIHRoZSBzaXplIG9mIHRoZVxuICAgIGVkaXRvciwgb3IgZWxlbWVudHMgd2l0aGluIHRoZSBlZGl0b3IsIGNoYW5nZWQuXG4gICAgKi9cbiAgICBnZXQgZ2VvbWV0cnlDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NDaGFuZ2VkIHx8ICh0aGlzLmZsYWdzICYgKDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLyB8IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIHVwZGF0ZSBpbmRpY2F0ZXMgYSBmb2N1cyBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgZm9jdXNDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgZG9jdW1lbnQgY2hhbmdlZCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBkb2NDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY2hhbmdlcy5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHdhcyBleHBsaWNpdGx5IHNldCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBzZWxlY3Rpb25TZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLnNlbGVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5mbGFncyA9PSAwICYmIHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aCA9PSAwOyB9XG59XG5cbi8qKlxuVXNlZCB0byBpbmRpY2F0ZSBbdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLlxuKi9cbnZhciBEaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcbiAgICAvLyAoVGhlc2UgYXJlIGNob3NlbiB0byBtYXRjaCB0aGUgYmFzZSBsZXZlbHMsIGluIGJpZGkgYWxnb3JpdGhtXG4gICAgLy8gdGVybXMsIG9mIHNwYW5zIGluIHRoYXQgZGlyZWN0aW9uLilcbiAgICAvKipcbiAgICBMZWZ0LXRvLXJpZ2h0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkxUUlwiXSA9IDBdID0gXCJMVFJcIjtcbiAgICAvKipcbiAgICBSaWdodC10by1sZWZ0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIlJUTFwiXSA9IDFdID0gXCJSVExcIjtcbnJldHVybiBEaXJlY3Rpb259KShEaXJlY3Rpb24gfHwgKERpcmVjdGlvbiA9IHt9KSk7XG5jb25zdCBMVFIgPSBEaXJlY3Rpb24uTFRSLCBSVEwgPSBEaXJlY3Rpb24uUlRMO1xuLy8gRGVjb2RlIGEgc3RyaW5nIHdpdGggZWFjaCB0eXBlIGVuY29kZWQgYXMgbG9nMih0eXBlKVxuZnVuY3Rpb24gZGVjKHN0cikge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goMSA8PCArc3RyW2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDAgdG8gMHhmOFxuY29uc3QgTG93VHlwZXMgPSAvKkBfX1BVUkVfXyovZGVjKFwiODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg2NjY4ODg4ODg3ODc4MzMzMzMzMzMzMzc4ODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODc4NjY2Njg4ODgwODg4ODg2NjMzODA4ODgzMDg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDhcIik7XG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcbmNvbnN0IEFyYWJpY1R5cGVzID0gLypAX19QVVJFX18qL2RlYyhcIjQ0NDQ0NDg4MjY2MjcyODg5OTk5OTk5OTk5OTIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjk5OTk5OTk5OTk5OTk5OTk5OTk5OTQ0NDQ0NDQ0NDQ2NDQyMjI4MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI5OTk5OTk5NDk5OTk5OTkyMjk5ODk5OTkyMjMzMzMzMzMzMzNcIik7XG5jb25zdCBCcmFja2V0cyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpLCBCcmFja2V0U3RhY2sgPSBbXTtcbi8vIFRoZXJlJ3MgYSBsb3QgbW9yZSBpblxuLy8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL0JpZGlCcmFja2V0cy50eHQsXG4vLyB3aGljaCBhcmUgbGVmdCBvdXQgdG8ga2VlcCBjb2RlIHNpemUgZG93bi5cbmZvciAobGV0IHAgb2YgW1wiKClcIiwgXCJbXVwiLCBcInt9XCJdKSB7XG4gICAgbGV0IGwgPSAvKkBfX1BVUkVfXyovcC5jaGFyQ29kZUF0KDApLCByID0gLypAX19QVVJFX18qL3AuY2hhckNvZGVBdCgxKTtcbiAgICBCcmFja2V0c1tsXSA9IHI7XG4gICAgQnJhY2tldHNbcl0gPSAtbDtcbn1cbmZ1bmN0aW9uIGNoYXJUeXBlKGNoKSB7XG4gICAgcmV0dXJuIGNoIDw9IDB4ZjcgPyBMb3dUeXBlc1tjaF0gOlxuICAgICAgICAweDU5MCA8PSBjaCAmJiBjaCA8PSAweDVmNCA/IDIgLyogVC5SICovIDpcbiAgICAgICAgICAgIDB4NjAwIDw9IGNoICYmIGNoIDw9IDB4NmY5ID8gQXJhYmljVHlwZXNbY2ggLSAweDYwMF0gOlxuICAgICAgICAgICAgICAgIDB4NmVlIDw9IGNoICYmIGNoIDw9IDB4OGFjID8gNCAvKiBULkFMICovIDpcbiAgICAgICAgICAgICAgICAgICAgMHgyMDAwIDw9IGNoICYmIGNoIDw9IDB4MjAwYiA/IDI1NiAvKiBULk5JICovIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmI1MCA8PSBjaCAmJiBjaCA8PSAweGZkZmYgPyA0IC8qIFQuQUwgKi8gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID09IDB4MjAwYyA/IDI1NiAvKiBULk5JICovIDogMSAvKiBULkwgKi87XG59XG5jb25zdCBCaWRpUkUgPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY1xcdWZiNTAtXFx1ZmRmZl0vO1xuLyoqXG5SZXByZXNlbnRzIGEgY29udGlndW91cyByYW5nZSBvZiB0ZXh0IHRoYXQgaGFzIGEgc2luZ2xlIGRpcmVjdGlvblxuKGFzIGluIGxlZnQtdG8tcmlnaHQgb3IgcmlnaHQtdG8tbGVmdCkuXG4qL1xuY2xhc3MgQmlkaVNwYW4ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBzcGFuIChyZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUpLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgc3Bhbi5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgW1wiYmlkaVxuICAgIGxldmVsXCJdKGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjkvI0Jhc2ljX0Rpc3BsYXlfQWxnb3JpdGhtKVxuICAgIG9mIHRoZSBzcGFuIChpbiB0aGlzIGNvbnRleHQsIDAgbWVhbnNcbiAgICBsZWZ0LXRvLXJpZ2h0LCAxIG1lYW5zIHJpZ2h0LXRvLWxlZnQsIDIgbWVhbnMgbGVmdC10by1yaWdodFxuICAgIG51bWJlciBpbnNpZGUgcmlnaHQtdG8tbGVmdCB0ZXh0KS5cbiAgICAqL1xuICAgIGxldmVsKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZGlyZWN0aW9uIG9mIHRoaXMgc3Bhbi5cbiAgICAqL1xuICAgIGdldCBkaXIoKSB7IHJldHVybiB0aGlzLmxldmVsICUgMiA/IFJUTCA6IExUUjsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2lkZShlbmQsIGRpcikgeyByZXR1cm4gKHRoaXMuZGlyID09IGRpcikgPT0gZW5kID8gdGhpcy50byA6IHRoaXMuZnJvbTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZpbmQob3JkZXIsIGluZGV4LCBsZXZlbCwgYXNzb2MpIHtcbiAgICAgICAgbGV0IG1heWJlID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzcGFuID0gb3JkZXJbaV07XG4gICAgICAgICAgICBpZiAoc3Bhbi5mcm9tIDw9IGluZGV4ICYmIHNwYW4udG8gPj0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Bhbi5sZXZlbCA9PSBsZXZlbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBtdWx0aXBsZSBzcGFucyBtYXRjaCwgaWYgYXNzb2MgIT0gMCwgdGFrZSB0aGUgb25lIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBjb3ZlcnMgdGhhdCBzaWRlLCBvdGhlcndpc2UgdGFrZSB0aGUgb25lIHdpdGggdGhlIG1pbmltdW1cbiAgICAgICAgICAgICAgICAvLyBsZXZlbC5cbiAgICAgICAgICAgICAgICBpZiAobWF5YmUgPCAwIHx8IChhc3NvYyAhPSAwID8gKGFzc29jIDwgMCA/IHNwYW4uZnJvbSA8IGluZGV4IDogc3Bhbi50byA+IGluZGV4KSA6IG9yZGVyW21heWJlXS5sZXZlbCA+IHNwYW4ubGV2ZWwpKVxuICAgICAgICAgICAgICAgICAgICBtYXliZSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heWJlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gbWF5YmU7XG4gICAgfVxufVxuLy8gUmV1c2VkIGFycmF5IG9mIGNoYXJhY3RlciB0eXBlc1xuY29uc3QgdHlwZXMgPSBbXTtcbmZ1bmN0aW9uIGNvbXB1dGVPcmRlcihsaW5lLCBkaXJlY3Rpb24pIHtcbiAgICBsZXQgbGVuID0gbGluZS5sZW5ndGgsIG91dGVyVHlwZSA9IGRpcmVjdGlvbiA9PSBMVFIgPyAxIC8qIFQuTCAqLyA6IDIgLyogVC5SICovLCBvcHBvc2l0ZVR5cGUgPSBkaXJlY3Rpb24gPT0gTFRSID8gMiAvKiBULlIgKi8gOiAxIC8qIFQuTCAqLztcbiAgICBpZiAoIWxpbmUgfHwgb3V0ZXJUeXBlID09IDEgLyogVC5MICovICYmICFCaWRpUkUudGVzdChsaW5lKSlcbiAgICAgICAgcmV0dXJuIHRyaXZpYWxPcmRlcihsZW4pO1xuICAgIC8vIFcxLiBFeGFtaW5lIGVhY2ggbm9uLXNwYWNpbmcgbWFyayAoTlNNKSBpbiB0aGUgbGV2ZWwgcnVuLCBhbmRcbiAgICAvLyBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIE5TTSB0byB0aGUgdHlwZSBvZiB0aGUgcHJldmlvdXNcbiAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcbiAgICAvLyBnZXQgdGhlIHR5cGUgb2Ygc29yLlxuICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXG4gICAgLy8gQUwgaXMgZm91bmQsIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEFyYWJpY1xuICAgIC8vIG51bWJlci5cbiAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cbiAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTiwgQU4sIEVULCBDUywgTkkpXG4gICAgZm9yIChsZXQgaSA9IDAsIHByZXYgPSBvdXRlclR5cGUsIHByZXZTdHJvbmcgPSBvdXRlclR5cGU7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgdHlwZSA9IGNoYXJUeXBlKGxpbmUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgIGlmICh0eXBlID09IDUxMiAvKiBULk5TTSAqLylcbiAgICAgICAgICAgIHR5cGUgPSBwcmV2O1xuICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogVC5FTiAqLyAmJiBwcmV2U3Ryb25nID09IDQgLyogVC5BTCAqLylcbiAgICAgICAgICAgIHR5cGUgPSAxNiAvKiBULkFOICovO1xuICAgICAgICB0eXBlc1tpXSA9IHR5cGUgPT0gNCAvKiBULkFMICovID8gMiAvKiBULlIgKi8gOiB0eXBlO1xuICAgICAgICBpZiAodHlwZSAmIDcgLyogVC5TdHJvbmcgKi8pXG4gICAgICAgICAgICBwcmV2U3Ryb25nID0gdHlwZTtcbiAgICAgICAgcHJldiA9IHR5cGU7XG4gICAgfVxuICAgIC8vIFc1LiBBIHNlcXVlbmNlIG9mIEV1cm9wZWFuIHRlcm1pbmF0b3JzIGFkamFjZW50IHRvIEV1cm9wZWFuXG4gICAgLy8gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxuICAgIC8vIFc2LiBPdGhlcndpc2UsIHNlcGFyYXRvcnMgYW5kIHRlcm1pbmF0b3JzIGNoYW5nZSB0byBPdGhlclxuICAgIC8vIE5ldXRyYWwuXG4gICAgLy8gVzcuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXG4gICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhbiBMIGlzXG4gICAgLy8gZm91bmQsIHRoZW4gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gTC5cbiAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTiwgTkkpXG4gICAgZm9yIChsZXQgaSA9IDAsIHByZXYgPSBvdXRlclR5cGUsIHByZXZTdHJvbmcgPSBvdXRlclR5cGU7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICBpZiAodHlwZSA9PSAxMjggLyogVC5DUyAqLykge1xuICAgICAgICAgICAgaWYgKGkgPCBsZW4gLSAxICYmIHByZXYgPT0gdHlwZXNbaSArIDFdICYmIChwcmV2ICYgMjQgLyogVC5OdW0gKi8pKVxuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlc1tpXSA9IHByZXY7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdHlwZXNbaV0gPSAyNTYgLyogVC5OSSAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09IDY0IC8qIFQuRVQgKi8pIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChlbmQgPCBsZW4gJiYgdHlwZXNbZW5kXSA9PSA2NCAvKiBULkVUICovKVxuICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgbGV0IHJlcGxhY2UgPSAoaSAmJiBwcmV2ID09IDggLyogVC5FTiAqLykgfHwgKGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IDggLyogVC5FTiAqLykgPyAocHJldlN0cm9uZyA9PSAxIC8qIFQuTCAqLyA/IDEgLyogVC5MICovIDogOCAvKiBULkVOICovKSA6IDI1NiAvKiBULk5JICovO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBlbmQ7IGorKylcbiAgICAgICAgICAgICAgICB0eXBlc1tqXSA9IHJlcGxhY2U7XG4gICAgICAgICAgICBpID0gZW5kIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogVC5FTiAqLyAmJiBwcmV2U3Ryb25nID09IDEgLyogVC5MICovKSB7XG4gICAgICAgICAgICB0eXBlc1tpXSA9IDEgLyogVC5MICovO1xuICAgICAgICB9XG4gICAgICAgIHByZXYgPSB0eXBlO1xuICAgICAgICBpZiAodHlwZSAmIDcgLyogVC5TdHJvbmcgKi8pXG4gICAgICAgICAgICBwcmV2U3Ryb25nID0gdHlwZTtcbiAgICB9XG4gICAgLy8gTjAuIFByb2Nlc3MgYnJhY2tldCBwYWlycyBpbiBhbiBpc29sYXRpbmcgcnVuIHNlcXVlbmNlXG4gICAgLy8gc2VxdWVudGlhbGx5IGluIHRoZSBsb2dpY2FsIG9yZGVyIG9mIHRoZSB0ZXh0IHBvc2l0aW9ucyBvZiB0aGVcbiAgICAvLyBvcGVuaW5nIHBhaXJlZCBicmFja2V0cyB1c2luZyB0aGUgbG9naWMgZ2l2ZW4gYmVsb3cuIFdpdGhpbiB0aGlzXG4gICAgLy8gc2NvcGUsIGJpZGlyZWN0aW9uYWwgdHlwZXMgRU4gYW5kIEFOIGFyZSB0cmVhdGVkIGFzIFIuXG4gICAgZm9yIChsZXQgaSA9IDAsIHNJID0gMCwgY29udGV4dCA9IDAsIGNoLCBiciwgdHlwZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIEtlZXBzIFtzdGFydEluZGV4LCB0eXBlLCBzdHJvbmdTZWVuXSB0cmlwbGVzIGZvciBlYWNoIG9wZW5cbiAgICAgICAgLy8gYnJhY2tldCBvbiBCcmFja2V0U3RhY2suXG4gICAgICAgIGlmIChiciA9IEJyYWNrZXRzW2NoID0gbGluZS5jaGFyQ29kZUF0KGkpXSkge1xuICAgICAgICAgICAgaWYgKGJyIDwgMCkgeyAvLyBDbG9zaW5nIGJyYWNrZXRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzSiA9IHNJIC0gMzsgc0ogPj0gMDsgc0ogLT0gMykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQnJhY2tldFN0YWNrW3NKICsgMV0gPT0gLWJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmxhZ3MgPSBCcmFja2V0U3RhY2tbc0ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gKGZsYWdzICYgMiAvKiBCcmFja2V0ZWQuRW1iZWRJbnNpZGUgKi8pID8gb3V0ZXJUeXBlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGZsYWdzICYgNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi8pID8gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbGFncyAmIDEgLyogQnJhY2tldGVkLk9wcG9zaXRlQmVmb3JlICovKSA/IG9wcG9zaXRlVHlwZSA6IG91dGVyVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzW2ldID0gdHlwZXNbQnJhY2tldFN0YWNrW3NKXV0gPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc0kgPSBzSjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQnJhY2tldFN0YWNrLmxlbmd0aCA9PSAxODkgLyogQnJhY2tldGVkLk1heERlcHRoICovKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBpO1xuICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSSsrXSA9IGNoO1xuICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSSsrXSA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHR5cGUgPSB0eXBlc1tpXSkgPT0gMiAvKiBULlIgKi8gfHwgdHlwZSA9PSAxIC8qIFQuTCAqLykge1xuICAgICAgICAgICAgbGV0IGVtYmVkID0gdHlwZSA9PSBvdXRlclR5cGU7XG4gICAgICAgICAgICBjb250ZXh0ID0gZW1iZWQgPyAwIDogMSAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVCZWZvcmUgKi87XG4gICAgICAgICAgICBmb3IgKGxldCBzSiA9IHNJIC0gMzsgc0ogPj0gMDsgc0ogLT0gMykge1xuICAgICAgICAgICAgICAgIGxldCBjdXIgPSBCcmFja2V0U3RhY2tbc0ogKyAyXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyICYgMiAvKiBCcmFja2V0ZWQuRW1iZWRJbnNpZGUgKi8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChlbWJlZCkge1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0ogKyAyXSB8PSAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIgJiA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0ogKyAyXSB8PSA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTjEuIEEgc2VxdWVuY2Ugb2YgbmV1dHJhbHMgdGFrZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGVcbiAgICAvLyBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGUgc2FtZVxuICAgIC8vIGRpcmVjdGlvbi4gRXVyb3BlYW4gYW5kIEFyYWJpYyBudW1iZXJzIGFjdCBhcyBpZiB0aGV5IHdlcmUgUiBpblxuICAgIC8vIHRlcm1zIG9mIHRoZWlyIGluZmx1ZW5jZSBvbiBuZXV0cmFscy4gU3RhcnQtb2YtbGV2ZWwtcnVuIChzb3IpXG4gICAgLy8gYW5kIGVuZC1vZi1sZXZlbC1ydW4gKGVvcikgYXJlIHVzZWQgYXQgbGV2ZWwgcnVuIGJvdW5kYXJpZXMuXG4gICAgLy8gTjIuIEFueSByZW1haW5pbmcgbmV1dHJhbHMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTilcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlc1tpXSA9PSAyNTYgLyogVC5OSSAqLykge1xuICAgICAgICAgICAgbGV0IGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IDI1NiAvKiBULk5JICovKVxuICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgbGV0IGJlZm9yZUwgPSAoaSA/IHR5cGVzW2kgLSAxXSA6IG91dGVyVHlwZSkgPT0gMSAvKiBULkwgKi87XG4gICAgICAgICAgICBsZXQgYWZ0ZXJMID0gKGVuZCA8IGxlbiA/IHR5cGVzW2VuZF0gOiBvdXRlclR5cGUpID09IDEgLyogVC5MICovO1xuICAgICAgICAgICAgbGV0IHJlcGxhY2UgPSBiZWZvcmVMID09IGFmdGVyTCA/IChiZWZvcmVMID8gMSAvKiBULkwgKi8gOiAyIC8qIFQuUiAqLykgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IGVuZDsgaisrKVxuICAgICAgICAgICAgICAgIHR5cGVzW2pdID0gcmVwbGFjZTtcbiAgICAgICAgICAgIGkgPSBlbmQgLSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhlcmUgd2UgZGVwYXJ0IGZyb20gdGhlIGRvY3VtZW50ZWQgYWxnb3JpdGhtLCBpbiBvcmRlciB0byBhdm9pZFxuICAgIC8vIGJ1aWxkaW5nIHVwIGFuIGFjdHVhbCBsZXZlbHMgYXJyYXkuIFNpbmNlIHRoZXJlIGFyZSBvbmx5IHRocmVlXG4gICAgLy8gbGV2ZWxzICgwLCAxLCAyKSBpbiBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXNuJ3QgdGFrZVxuICAgIC8vIGV4cGxpY2l0IGVtYmVkZGluZyBpbnRvIGFjY291bnQsIHdlIGNhbiBidWlsZCB1cCB0aGUgb3JkZXIgb25cbiAgICAvLyB0aGUgZmx5LCB3aXRob3V0IGZvbGxvd2luZyB0aGUgbGV2ZWwtYmFzZWQgYWxnb3JpdGhtLlxuICAgIGxldCBvcmRlciA9IFtdO1xuICAgIGlmIChvdXRlclR5cGUgPT0gMSAvKiBULkwgKi8pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBpLCBydGwgPSB0eXBlc1tpKytdICE9IDEgLyogVC5MICovO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgcnRsID09ICh0eXBlc1tpXSAhPSAxIC8qIFQuTCAqLykpXG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqID4gc3RhcnQ7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSBqLCBsID0gdHlwZXNbLS1qXSAhPSAyIC8qIFQuUiAqLztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPiBzdGFydCAmJiBsID09ICh0eXBlc1tqIC0gMV0gIT0gMiAvKiBULlIgKi8pKVxuICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbihqLCBlbmQsIGwgPyAyIDogMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKHN0YXJ0LCBpLCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gaSwgcnRsID0gdHlwZXNbaSsrXSA9PSAyIC8qIFQuUiAqLztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuICYmIHJ0bCA9PSAodHlwZXNbaV0gPT0gMiAvKiBULlIgKi8pKVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKHN0YXJ0LCBpLCBydGwgPyAxIDogMikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcmRlcjtcbn1cbmZ1bmN0aW9uIHRyaXZpYWxPcmRlcihsZW5ndGgpIHtcbiAgICByZXR1cm4gW25ldyBCaWRpU3BhbigwLCBsZW5ndGgsIDApXTtcbn1cbmxldCBtb3ZlZE92ZXIgPSBcIlwiO1xuZnVuY3Rpb24gbW92ZVZpc3VhbGx5KGxpbmUsIG9yZGVyLCBkaXIsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBzdGFydEluZGV4ID0gc3RhcnQuaGVhZCAtIGxpbmUuZnJvbSwgc3BhbkkgPSAtMTtcbiAgICBpZiAoc3RhcnRJbmRleCA9PSAwKSB7XG4gICAgICAgIGlmICghZm9yd2FyZCB8fCAhbGluZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG9yZGVyWzBdLmxldmVsICE9IGRpcikge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IG9yZGVyWzBdLnNpZGUoZmFsc2UsIGRpcik7XG4gICAgICAgICAgICBzcGFuSSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhcnRJbmRleCA9PSBsaW5lLmxlbmd0aCkge1xuICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbGFzdCA9IG9yZGVyW29yZGVyLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdC5sZXZlbCAhPSBkaXIpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBsYXN0LnNpZGUodHJ1ZSwgZGlyKTtcbiAgICAgICAgICAgIHNwYW5JID0gb3JkZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3BhbkkgPCAwKVxuICAgICAgICBzcGFuSSA9IEJpZGlTcGFuLmZpbmQob3JkZXIsIHN0YXJ0SW5kZXgsIChfYSA9IHN0YXJ0LmJpZGlMZXZlbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTEsIHN0YXJ0LmFzc29jKTtcbiAgICBsZXQgc3BhbiA9IG9yZGVyW3NwYW5JXTtcbiAgICAvLyBFbmQgb2Ygc3Bhbi4gKEJ1dCBub3QgZW5kIG9mIGxpbmUtLXRoYXQgd2FzIGNoZWNrZWQgZm9yIGFib3ZlLilcbiAgICBpZiAoc3RhcnRJbmRleCA9PSBzcGFuLnNpZGUoZm9yd2FyZCwgZGlyKSkge1xuICAgICAgICBzcGFuID0gb3JkZXJbc3BhbkkgKz0gZm9yd2FyZCA/IDEgOiAtMV07XG4gICAgICAgIHN0YXJ0SW5kZXggPSBzcGFuLnNpZGUoIWZvcndhcmQsIGRpcik7XG4gICAgfVxuICAgIGxldCBpbmRleEZvcndhcmQgPSBmb3J3YXJkID09IChzcGFuLmRpciA9PSBkaXIpO1xuICAgIGxldCBuZXh0SW5kZXggPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgc3RhcnRJbmRleCwgaW5kZXhGb3J3YXJkKTtcbiAgICBtb3ZlZE92ZXIgPSBsaW5lLnRleHQuc2xpY2UoTWF0aC5taW4oc3RhcnRJbmRleCwgbmV4dEluZGV4KSwgTWF0aC5tYXgoc3RhcnRJbmRleCwgbmV4dEluZGV4KSk7XG4gICAgaWYgKG5leHRJbmRleCAhPSBzcGFuLnNpZGUoZm9yd2FyZCwgZGlyKSlcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dEluZGV4ICsgbGluZS5mcm9tLCBpbmRleEZvcndhcmQgPyAtMSA6IDEsIHNwYW4ubGV2ZWwpO1xuICAgIGxldCBuZXh0U3BhbiA9IHNwYW5JID09IChmb3J3YXJkID8gb3JkZXIubGVuZ3RoIC0gMSA6IDApID8gbnVsbCA6IG9yZGVyW3NwYW5JICsgKGZvcndhcmQgPyAxIDogLTEpXTtcbiAgICBpZiAoIW5leHRTcGFuICYmIHNwYW4ubGV2ZWwgIT0gZGlyKVxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSwgZm9yd2FyZCA/IC0xIDogMSwgZGlyKTtcbiAgICBpZiAobmV4dFNwYW4gJiYgbmV4dFNwYW4ubGV2ZWwgPCBzcGFuLmxldmVsKVxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXh0U3Bhbi5zaWRlKCFmb3J3YXJkLCBkaXIpICsgbGluZS5mcm9tLCBmb3J3YXJkID8gMSA6IC0xLCBuZXh0U3Bhbi5sZXZlbCk7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dEluZGV4ICsgbGluZS5mcm9tLCBmb3J3YXJkID8gLTEgOiAxLCBzcGFuLmxldmVsKTtcbn1cblxuY29uc3QgTGluZUJyZWFrUGxhY2Vob2xkZXIgPSBcIlxcdWZmZmZcIjtcbmNsYXNzIERPTVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IocG9pbnRzLCBzdGF0ZSkge1xuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5saW5lU2VwYXJhdG9yID0gc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcik7XG4gICAgfVxuICAgIGFwcGVuZCh0ZXh0KSB7XG4gICAgICAgIHRoaXMudGV4dCArPSB0ZXh0O1xuICAgIH1cbiAgICBsaW5lQnJlYWsoKSB7XG4gICAgICAgIHRoaXMudGV4dCArPSBMaW5lQnJlYWtQbGFjZWhvbGRlcjtcbiAgICB9XG4gICAgcmVhZFJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKCFzdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gc3RhcnQucGFyZW50Tm9kZTtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gc3RhcnQ7Oykge1xuICAgICAgICAgICAgdGhpcy5maW5kUG9pbnRCZWZvcmUocGFyZW50LCBjdXIpO1xuICAgICAgICAgICAgdGhpcy5yZWFkTm9kZShjdXIpO1xuICAgICAgICAgICAgbGV0IG5leHQgPSBjdXIubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSBlbmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgdmlldyA9IENvbnRlbnRWaWV3LmdldChjdXIpLCBuZXh0VmlldyA9IENvbnRlbnRWaWV3LmdldChuZXh0KTtcbiAgICAgICAgICAgIGlmICh2aWV3ICYmIG5leHRWaWV3ID8gdmlldy5icmVha0FmdGVyIDpcbiAgICAgICAgICAgICAgICAodmlldyA/IHZpZXcuYnJlYWtBZnRlciA6IGlzQmxvY2tFbGVtZW50KGN1cikpIHx8XG4gICAgICAgICAgICAgICAgICAgIChpc0Jsb2NrRWxlbWVudChuZXh0KSAmJiAoY3VyLm5vZGVOYW1lICE9IFwiQlJcIiB8fCBjdXIuY21JZ25vcmUpKSlcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmRQb2ludEJlZm9yZShwYXJlbnQsIGVuZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWFkVGV4dE5vZGUobm9kZSkge1xuICAgICAgICBsZXQgdGV4dCA9IG5vZGUubm9kZVZhbHVlO1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUpXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aCArIE1hdGgubWluKHBvaW50Lm9mZnNldCwgdGV4dC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBvZmYgPSAwLCByZSA9IHRoaXMubGluZVNlcGFyYXRvciA/IG51bGwgOiAvXFxyXFxuP3xcXG4vZzs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dEJyZWFrID0gLTEsIGJyZWFrU2l6ZSA9IDEsIG07XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgbmV4dEJyZWFrID0gdGV4dC5pbmRleE9mKHRoaXMubGluZVNlcGFyYXRvciwgb2ZmKTtcbiAgICAgICAgICAgICAgICBicmVha1NpemUgPSB0aGlzLmxpbmVTZXBhcmF0b3IubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobSA9IHJlLmV4ZWModGV4dCkpIHtcbiAgICAgICAgICAgICAgICBuZXh0QnJlYWsgPSBtLmluZGV4O1xuICAgICAgICAgICAgICAgIGJyZWFrU2l6ZSA9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHBlbmQodGV4dC5zbGljZShvZmYsIG5leHRCcmVhayA8IDAgPyB0ZXh0Lmxlbmd0aCA6IG5leHRCcmVhaykpO1xuICAgICAgICAgICAgaWYgKG5leHRCcmVhayA8IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgaWYgKGJyZWFrU2l6ZSA+IDEpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUgJiYgcG9pbnQucG9zID4gdGhpcy50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LnBvcyAtPSBicmVha1NpemUgLSAxO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEJyZWFrICsgYnJlYWtTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuY21JZ25vcmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB2aWV3ID0gQ29udGVudFZpZXcuZ2V0KG5vZGUpO1xuICAgICAgICBsZXQgZnJvbVZpZXcgPSB2aWV3ICYmIHZpZXcub3ZlcnJpZGVET01UZXh0O1xuICAgICAgICBpZiAoZnJvbVZpZXcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5maW5kUG9pbnRJbnNpZGUobm9kZSwgZnJvbVZpZXcubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tVmlldy5pdGVyKCk7ICFpLm5leHQoKS5kb25lOykge1xuICAgICAgICAgICAgICAgIGlmIChpLmxpbmVCcmVhaylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKGkudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgdGhpcy5yZWFkVGV4dE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkJSXCIpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRSYW5nZShub2RlLmZpcnN0Q2hpbGQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRQb2ludEJlZm9yZShub2RlLCBuZXh0KSB7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSAmJiBub2RlLmNoaWxkTm9kZXNbcG9pbnQub2Zmc2V0XSA9PSBuZXh0KVxuICAgICAgICAgICAgICAgIHBvaW50LnBvcyA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIGZpbmRQb2ludEluc2lkZShub2RlLCBtYXhMZW4pIHtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzID8gcG9pbnQubm9kZSA9PSBub2RlIDogbm9kZS5jb250YWlucyhwb2ludC5ub2RlKSlcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoICsgTWF0aC5taW4obWF4TGVuLCBwb2ludC5vZmZzZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQmxvY2tFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAxICYmIC9eKERJVnxQfExJfFVMfE9MfEJMT0NLUVVPVEV8RER8RFR8SFxcZHxTRUNUSU9OfFBSRSkkLy50ZXN0KG5vZGUubm9kZU5hbWUpO1xufVxuY2xhc3MgRE9NUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIG9mZnNldCkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5wb3MgPSAtMTtcbiAgICB9XG59XG5cbmNsYXNzIERvY1ZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRGVjbyA9IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwID0gW107XG4gICAgICAgIC8vIFRyYWNrIGEgbWluaW11bSB3aWR0aCBmb3IgdGhlIGVkaXRvci4gV2hlbiBtZWFzdXJpbmcgc2l6ZXMgaW5cbiAgICAgICAgLy8gbWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cywgdGhpcyBpcyB1cGRhdGVkIHRvIHBvaW50IGF0IHRoZSB3aWR0aFxuICAgICAgICAvLyBvZiBhIGdpdmVuIGVsZW1lbnQgYW5kIGl0cyBleHRlbnQgaW4gdGhlIGRvY3VtZW50LiBXaGVuIGEgY2hhbmdlXG4gICAgICAgIC8vIGhhcHBlbnMgaW4gdGhhdCByYW5nZSwgdGhlc2UgYXJlIHJlc2V0LiBUaGF0IHdheSwgb25jZSB3ZSd2ZSBzZWVuXG4gICAgICAgIC8vIGEgbGluZS9lbGVtZW50IG9mIGEgZ2l2ZW4gbGVuZ3RoLCB3ZSBrZWVwIHRoZSBlZGl0b3Igd2lkZSBlbm91Z2hcbiAgICAgICAgLy8gdG8gZml0IGF0IGxlYXN0IHRoYXQgZWxlbWVudCwgdW50aWwgaXQgaXMgY2hhbmdlZCwgYXQgd2hpY2ggcG9pbnRcbiAgICAgICAgLy8gd2UgZm9yZ2V0IGl0IGFnYWluLlxuICAgICAgICB0aGlzLm1pbldpZHRoID0gMDtcbiAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSAwO1xuICAgICAgICB0aGlzLm1pbldpZHRoVG8gPSAwO1xuICAgICAgICAvLyBUcmFjayB3aGV0aGVyIHRoZSBET00gc2VsZWN0aW9uIHdhcyBzZXQgaW4gYSBsb3NzeSB3YXksIHNvIHRoYXRcbiAgICAgICAgLy8gd2UgZG9uJ3QgbWVzcyBpdCB1cCB3aGVuIHJlYWRpbmcgaXQgYmFjayBpdFxuICAgICAgICB0aGlzLmltcHJlY2lzZUFuY2hvciA9IG51bGw7XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlSGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gVXNlZCBieSB0aGUgcmVzaXplIG9ic2VydmVyIHRvIGlnbm9yZSByZXNpemVzIHRoYXQgd2UgY2F1c2VkXG4gICAgICAgIC8vIG91cnNlbHZlc1xuICAgICAgICB0aGlzLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnNldERPTSh2aWV3LmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW25ldyBMaW5lVmlld107XG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMF0uc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZURlY28oKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbm5lcihbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpXSwgMCk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aDsgfVxuICAgIC8vIFVwZGF0ZSB0aGUgZG9jdW1lbnQgdmlldyB0byBhIGdpdmVuIHN0YXRlLiBzY3JvbGxJbnRvVmlldyBjYW4gYmVcbiAgICAvLyB1c2VkIGFzIGEgaGludCB0byBjb21wdXRlIGEgbmV3IHZpZXdwb3J0IHRoYXQgaW5jbHVkZXMgdGhhdFxuICAgIC8vIHBvc2l0aW9uLCBpZiB3ZSBrbm93IHRoZSBlZGl0b3IgaXMgZ29pbmcgdG8gc2Nyb2xsIHRoYXQgcG9zaXRpb25cbiAgICAvLyBpbnRvIHZpZXcuXG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY2hhbmdlZFJhbmdlcyA9IHVwZGF0ZS5jaGFuZ2VkUmFuZ2VzO1xuICAgICAgICBpZiAodGhpcy5taW5XaWR0aCA+IDAgJiYgY2hhbmdlZFJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghY2hhbmdlZFJhbmdlcy5ldmVyeSgoeyBmcm9tQSwgdG9BIH0pID0+IHRvQSA8IHRoaXMubWluV2lkdGhGcm9tIHx8IGZyb21BID4gdGhpcy5taW5XaWR0aFRvKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSB0aGlzLm1pbldpZHRoRnJvbSA9IHRoaXMubWluV2lkdGhUbyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLm1pbldpZHRoRnJvbSwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRoaXMubWluV2lkdGhUbywgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDApXG4gICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRGVjbyA9IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgZWxzZSBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGggfHwgdGhpcy5kaXJ0eSlcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25EZWNvID0gY29tcHV0ZUNvbXBvc2l0aW9uRGVjbyh0aGlzLnZpZXcsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgLy8gV2hlbiB0aGUgRE9NIG5vZGVzIGFyb3VuZCB0aGUgc2VsZWN0aW9uIGFyZSBtb3ZlZCB0byBhbm90aGVyXG4gICAgICAgIC8vIHBhcmVudCwgQ2hyb21lIHNvbWV0aW1lcyByZXBvcnRzIGEgZGlmZmVyZW50IHNlbGVjdGlvbiB0aHJvdWdoXG4gICAgICAgIC8vIGdldFNlbGVjdGlvbiB0aGFuIHRoZSBvbmUgdGhhdCBpdCBhY3R1YWxseSBzaG93cyB0byB0aGUgdXNlci5cbiAgICAgICAgLy8gVGhpcyBmb3JjZXMgYSBzZWxlY3Rpb24gdXBkYXRlIHdoZW4gbGluZXMgYXJlIGpvaW5lZCB0byB3b3JrXG4gICAgICAgIC8vIGFyb3VuZCB0aGF0LiBJc3N1ZSAjNTRcbiAgICAgICAgaWYgKChicm93c2VyLmllIHx8IGJyb3dzZXIuY2hyb21lKSAmJiAhdGhpcy5jb21wb3NpdGlvbkRlY28uc2l6ZSAmJiB1cGRhdGUgJiZcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5kb2MubGluZXMgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxpbmVzKVxuICAgICAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgIGxldCBwcmV2RGVjbyA9IHRoaXMuZGVjb3JhdGlvbnMsIGRlY28gPSB0aGlzLnVwZGF0ZURlY28oKTtcbiAgICAgICAgbGV0IGRlY29EaWZmID0gZmluZENoYW5nZWREZWNvKHByZXZEZWNvLCBkZWNvLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGNoYW5nZWRSYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjaGFuZ2VkUmFuZ2VzLCBkZWNvRGlmZik7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IDAgLyogRGlydHkuTm90ICovICYmIGNoYW5nZWRSYW5nZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5uZXIoY2hhbmdlZFJhbmdlcywgdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0VXBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZWQgYnkgdXBkYXRlIGFuZCB0aGUgY29uc3RydWN0b3IgZG8gcGVyZm9ybSB0aGUgYWN0dWFsIERPTVxuICAgIC8vIHVwZGF0ZVxuICAgIHVwZGF0ZUlubmVyKGNoYW5nZXMsIG9sZExlbmd0aCkge1xuICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4oY2hhbmdlcywgb2xkTGVuZ3RoKTtcbiAgICAgICAgbGV0IHsgb2JzZXJ2ZXIgfSA9IHRoaXMudmlldztcbiAgICAgICAgb2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIC8vIExvY2sgdGhlIGhlaWdodCBkdXJpbmcgcmVkcmF3aW5nLCBzaW5jZSBDaHJvbWUgc29tZXRpbWVzXG4gICAgICAgICAgICAvLyBtZXNzZXMgd2l0aCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGR1cmluZyBET00gbXV0YXRpb24gKHRob3VnaFxuICAgICAgICAgICAgLy8gbm8gcmVsYXlvdXQgaXMgdHJpZ2dlcmVkIGFuZCBJIGNhbm5vdCBpbWFnaW5lIGhvdyBpdCBjYW5cbiAgICAgICAgICAgIC8vIHJlY29tcHV0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHdpdGhvdXQgYSBsYXlvdXQpXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSB0aGlzLnZpZXcudmlld1N0YXRlLmNvbnRlbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5mbGV4QmFzaXMgPSB0aGlzLm1pbldpZHRoID8gdGhpcy5taW5XaWR0aCArIFwicHhcIiA6IFwiXCI7XG4gICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBzb21ldGltZXMsIHdoZW4gRE9NIG11dGF0aW9ucyBvY2N1ciBkaXJlY3RseVxuICAgICAgICAgICAgLy8gYXJvdW5kIHRoZSBzZWxlY3Rpb24sIGdldCBjb25mdXNlZCBhbmQgcmVwb3J0IGEgZGlmZmVyZW50XG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gZnJvbSB0aGUgb25lIGl0IGRpc3BsYXlzIChpc3N1ZSAjMjE4KS4gVGhpcyB0cmllc1xuICAgICAgICAgICAgLy8gdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICAgICAgICAgICAgbGV0IHRyYWNrID0gYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5pb3MgPyB7IG5vZGU6IG9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSwgd3JpdHRlbjogZmFsc2UgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3luYyh0aGlzLnZpZXcsIHRyYWNrKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSAwIC8qIERpcnR5Lk5vdCAqLztcbiAgICAgICAgICAgIGlmICh0cmFjayAmJiAodHJhY2sud3JpdHRlbiB8fCBvYnNlcnZlci5zZWxlY3Rpb25SYW5nZS5mb2N1c05vZGUgIT0gdHJhY2subm9kZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGdhcHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMudmlldy52aWV3cG9ydC5mcm9tIHx8IHRoaXMudmlldy52aWV3cG9ydC50byA8IHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiYgY2hpbGQud2lkZ2V0IGluc3RhbmNlb2YgQmxvY2tHYXBXaWRnZXQpXG4gICAgICAgICAgICAgICAgICAgIGdhcHMucHVzaChjaGlsZC5kb20pO1xuICAgICAgICBvYnNlcnZlci51cGRhdGVHYXBzKGdhcHMpO1xuICAgIH1cbiAgICB1cGRhdGVDaGlsZHJlbihjaGFuZ2VzLCBvbGRMZW5ndGgpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHRoaXMuY2hpbGRDdXJzb3Iob2xkTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGNoYW5nZXMubGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpID49IDAgPyBjaGFuZ2VzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCB7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSA9IG5leHQ7XG4gICAgICAgICAgICBsZXQgeyBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gQ29udGVudEJ1aWxkZXIuYnVpbGQodGhpcy52aWV3LnN0YXRlLmRvYywgZnJvbUIsIHRvQiwgdGhpcy5kZWNvcmF0aW9ucywgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCk7XG4gICAgICAgICAgICBsZXQgeyBpOiB0b0ksIG9mZjogdG9PZmYgfSA9IGN1cnNvci5maW5kUG9zKHRvQSwgMSk7XG4gICAgICAgICAgICBsZXQgeyBpOiBmcm9tSSwgb2ZmOiBmcm9tT2ZmIH0gPSBjdXJzb3IuZmluZFBvcyhmcm9tQSwgLTEpO1xuICAgICAgICAgICAgcmVwbGFjZVJhbmdlKHRoaXMsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3luYyB0aGUgRE9NIHNlbGVjdGlvbiB0byB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgIHVwZGF0ZVNlbGVjdGlvbihtdXN0UmVhZCA9IGZhbHNlLCBmcm9tUG9pbnRlciA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChtdXN0UmVhZCB8fCAhdGhpcy52aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSlcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgaWYgKCEoZnJvbVBvaW50ZXIgfHwgdGhpcy5tYXlDb250cm9sU2VsZWN0aW9uKCkpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZm9yY2UgPSB0aGlzLmZvcmNlU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGxldCBtYWluID0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAvLyBGSVhNRSBuZWVkIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgc2VsZWN0aW9uIGZhbGxzIGluc2lkZSBhIGJsb2NrIHJhbmdlXG4gICAgICAgIGxldCBhbmNob3IgPSB0aGlzLmRvbUF0UG9zKG1haW4uYW5jaG9yKTtcbiAgICAgICAgbGV0IGhlYWQgPSBtYWluLmVtcHR5ID8gYW5jaG9yIDogdGhpcy5kb21BdFBvcyhtYWluLmhlYWQpO1xuICAgICAgICAvLyBBbHdheXMgcmVzZXQgb24gRmlyZWZveCB3aGVuIG5leHQgdG8gYW4gdW5lZGl0YWJsZSBub2RlIHRvXG4gICAgICAgIC8vIGF2b2lkIGludmlzaWJsZSBjdXJzb3IgYnVncyAoIzExMSlcbiAgICAgICAgaWYgKGJyb3dzZXIuZ2Vja28gJiYgbWFpbi5lbXB0eSAmJiBiZXR3ZWVuVW5lZGl0YWJsZShhbmNob3IpKSB7XG4gICAgICAgICAgICBsZXQgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4gYW5jaG9yLm5vZGUuaW5zZXJ0QmVmb3JlKGR1bW15LCBhbmNob3Iubm9kZS5jaGlsZE5vZGVzW2FuY2hvci5vZmZzZXRdIHx8IG51bGwpKTtcbiAgICAgICAgICAgIGFuY2hvciA9IGhlYWQgPSBuZXcgRE9NUG9zKGR1bW15LCAwKTtcbiAgICAgICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZG9tU2VsID0gdGhpcy52aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGFscmVhZHkgaGVyZSwgb3IgaW4gYW4gZXF1aXZhbGVudCBwb3NpdGlvbiwgZG9uJ3QgdG91Y2ggaXRcbiAgICAgICAgaWYgKGZvcmNlIHx8ICFkb21TZWwuZm9jdXNOb2RlIHx8XG4gICAgICAgICAgICAhaXNFcXVpdmFsZW50UG9zaXRpb24oYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQsIGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KSB8fFxuICAgICAgICAgICAgIWlzRXF1aXZhbGVudFBvc2l0aW9uKGhlYWQubm9kZSwgaGVhZC5vZmZzZXQsIGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENocm9tZSBBbmRyb2lkIHdpbGwgaGlkZSB0aGUgdmlydHVhbCBrZXlib2FyZCB3aGVuIHRhcHBpbmdcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgYW4gdW5lZGl0YWJsZSBub2RlLCBhbmQgbm90IGJyaW5nIGl0IGJhY2sgd2hlbiB3ZVxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIGN1cnNvciB0byBpdHMgcHJvcGVyIHBvc2l0aW9uLiBUaGlzIHRyaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUga2V5Ym9hcmQgYnkgY3ljbGluZyBmb2N1cy5cbiAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmIGJyb3dzZXIuY2hyb21lICYmIHRoaXMuZG9tLmNvbnRhaW5zKGRvbVNlbC5mb2N1c05vZGUpICYmXG4gICAgICAgICAgICAgICAgICAgIGluVW5lZGl0YWJsZShkb21TZWwuZm9jdXNOb2RlLCB0aGlzLmRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByYXdTZWwgPSBnZXRTZWxlY3Rpb24odGhpcy52aWV3LnJvb3QpO1xuICAgICAgICAgICAgICAgIGlmICghcmF3U2VsKSA7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWFpbi5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNjEyMDc2XG4gICAgICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmdlY2tvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dFRvID0gbmV4dFRvVW5lZGl0YWJsZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFRvICYmIG5leHRUbyAhPSAoMSAvKiBOZXh0VG8uQmVmb3JlICovIHwgMiAvKiBOZXh0VG8uQWZ0ZXIgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBuZWFyYnlUZXh0Tm9kZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgbmV4dFRvID09IDEgLyogTmV4dFRvLkJlZm9yZSAqLyA/IDEgOiAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IG5ldyBET01Qb3ModGV4dCwgbmV4dFRvID09IDEgLyogTmV4dFRvLkJlZm9yZSAqLyA/IDAgOiB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5jb2xsYXBzZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWluLmJpZGlMZXZlbCAhPSBudWxsICYmIGRvbVNlbC5jdXJzb3JCaWRpTGV2ZWwgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbVNlbC5jdXJzb3JCaWRpTGV2ZWwgPSBtYWluLmJpZGlMZXZlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmF3U2VsLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3Rpb24uZXh0ZW5kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiAnaW52ZXJ0ZWQnIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyAob25lIHdoZXJlIHRoZSBmb2N1cyBpcyBiZWZvcmUgdGhlIGFuY2hvciksIGJ1dCBub3QgYWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXJzIHN1cHBvcnQgaXQgeWV0LlxuICAgICAgICAgICAgICAgICAgICByYXdTZWwuY29sbGFwc2UoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgd2lsbCBpZ25vcmUgdGhlIGNhbGwgYWJvdmUgd2hlbiB0aGUgZWRpdG9yIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGhpZGRlbiwgYW5kIHRoZW4gcmFpc2UgYW4gZXJyb3Igb24gdGhlIGNhbGwgdG8gZXh0ZW5kXG4gICAgICAgICAgICAgICAgICAgIC8vICgjOTQwKS5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1NlbC5leHRlbmQoaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJpbWl0aXZlIChJRSkgd2F5XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWluLmFuY2hvciA+IG1haW4uaGVhZClcbiAgICAgICAgICAgICAgICAgICAgICAgIFthbmNob3IsIGhlYWRdID0gW2hlYWQsIGFuY2hvcl07XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByYXdTZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuc2V0U2VsZWN0aW9uUmFuZ2UoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmltcHJlY2lzZUFuY2hvciA9IGFuY2hvci5wcmVjaXNlID8gbnVsbCA6IG5ldyBET01Qb3MoZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgICB0aGlzLmltcHJlY2lzZUhlYWQgPSBoZWFkLnByZWNpc2UgPyBudWxsIDogbmV3IERPTVBvcyhkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgICBlbmZvcmNlQ3Vyc29yQXNzb2MoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2l0aW9uRGVjby5zaXplKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBjdXJzb3IgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKCFzZWwgfHwgIWN1cnNvci5lbXB0eSB8fCAhY3Vyc29yLmFzc29jIHx8ICFzZWwubW9kaWZ5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodGhpcywgY3Vyc29yLmhlYWQpO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSBsaW5lLnBvc0F0U3RhcnQ7XG4gICAgICAgIGlmIChjdXJzb3IuaGVhZCA9PSBsaW5lU3RhcnQgfHwgY3Vyc29yLmhlYWQgPT0gbGluZVN0YXJ0ICsgbGluZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBiZWZvcmUgPSB0aGlzLmNvb3Jkc0F0KGN1cnNvci5oZWFkLCAtMSksIGFmdGVyID0gdGhpcy5jb29yZHNBdChjdXJzb3IuaGVhZCwgMSk7XG4gICAgICAgIGlmICghYmVmb3JlIHx8ICFhZnRlciB8fCBiZWZvcmUuYm90dG9tID4gYWZ0ZXIudG9wKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5kb21BdFBvcyhjdXJzb3IuaGVhZCArIGN1cnNvci5hc3NvYyk7XG4gICAgICAgIHNlbC5jb2xsYXBzZShkb20ubm9kZSwgZG9tLm9mZnNldCk7XG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGN1cnNvci5hc3NvYyA8IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIiwgXCJsaW5lYm91bmRhcnlcIik7XG4gICAgICAgIC8vIFRoaXMgY2FuIGdvIHdyb25nIGluIGNvcm5lciBjYXNlcyBsaWtlIHNpbmdsZS1jaGFyYWN0ZXIgbGluZXMsXG4gICAgICAgIC8vIHNvIGNoZWNrIGFuZCByZXNldCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIHZpZXcub2JzZXJ2ZXIucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBuZXdSYW5nZSA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIGlmICh2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShuZXdSYW5nZS5hbmNob3JOb2RlLCBuZXdSYW5nZS5hbmNob3JPZmZzZXQpICE9IGN1cnNvci5mcm9tKVxuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gICAgfVxuICAgIG1heUNvbnRyb2xTZWxlY3Rpb24oKSB7XG4gICAgICAgIGxldCBhY3RpdmUgPSB0aGlzLnZpZXcucm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICByZXR1cm4gYWN0aXZlID09IHRoaXMuZG9tIHx8XG4gICAgICAgICAgICBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZSkgJiYgIShhY3RpdmUgJiYgdGhpcy5kb20uY29udGFpbnMoYWN0aXZlKSk7XG4gICAgfVxuICAgIG5lYXJlc3QoZG9tKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOykge1xuICAgICAgICAgICAgbGV0IGRvbVZpZXcgPSBDb250ZW50Vmlldy5nZXQoY3VyKTtcbiAgICAgICAgICAgIGlmIChkb21WaWV3ICYmIGRvbVZpZXcucm9vdFZpZXcgPT0gdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tVmlldztcbiAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgdmlldyA9IHRoaXMubmVhcmVzdChub2RlKTtcbiAgICAgICAgaWYgKCF2aWV3KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gZmluZCBwb3NpdGlvbiBmb3IgYSBET00gcG9zaXRpb24gb3V0c2lkZSBvZiB0aGUgZG9jdW1lbnRcIik7XG4gICAgICAgIHJldHVybiB2aWV3LmxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpICsgdmlldy5wb3NBdFN0YXJ0O1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkQ3Vyc29yKCkuZmluZFBvcyhwb3MsIC0xKTtcbiAgICAgICAgZm9yICg7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7KSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG9mZiA8IGNoaWxkLmxlbmd0aCB8fCBjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgb2ZmID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21BdFBvcyhvZmYpO1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdGhpcy5sZW5ndGgsIGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIHN0YXJ0ID0gb2ZmIC0gY2hpbGQuYnJlYWtBZnRlciAtIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPiBzdGFydCB8fFxuICAgICAgICAgICAgICAgIChwb3MgPT0gc3RhcnQgJiYgY2hpbGQudHlwZSAhPSBCbG9ja1R5cGUuV2lkZ2V0QmVmb3JlICYmIGNoaWxkLnR5cGUgIT0gQmxvY2tUeXBlLldpZGdldEFmdGVyICYmXG4gICAgICAgICAgICAgICAgICAgICghaSB8fCBzaWRlID09IDIgfHwgdGhpcy5jaGlsZHJlbltpIC0gMV0uYnJlYWtBZnRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuY2hpbGRyZW5baSAtIDFdLnR5cGUgPT0gQmxvY2tUeXBlLldpZGdldEJlZm9yZSAmJiBzaWRlID4gLTIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmNvb3Jkc0F0KHBvcyAtIHN0YXJ0LCBzaWRlKTtcbiAgICAgICAgICAgIG9mZiA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModmlld3BvcnQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCB7IGZyb20sIHRvIH0gPSB2aWV3cG9ydDtcbiAgICAgICAgbGV0IGNvbnRlbnRXaWR0aCA9IHRoaXMudmlldy5jb250ZW50RE9NLmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgaXNXaWRlciA9IGNvbnRlbnRXaWR0aCA+IE1hdGgubWF4KHRoaXMudmlldy5zY3JvbGxET00uY2xpZW50V2lkdGgsIHRoaXMubWluV2lkdGgpICsgMTtcbiAgICAgICAgbGV0IHdpZGVzdCA9IC0xLCBsdHIgPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChwb3MgPj0gZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZFJlY3QgPSBjaGlsZC5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGRSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzV2lkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBjaGlsZC5kb20ubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdHMgPSBsYXN0ID8gY2xpZW50UmVjdHNGb3IobGFzdCkgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tyZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IGx0ciA/IHJlY3QucmlnaHQgLSBjaGlsZFJlY3QubGVmdCA6IGNoaWxkUmVjdC5yaWdodCAtIHJlY3QubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aCA+IHdpZGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGVzdCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSBjb250ZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gZW5kICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0ZXh0RGlyZWN0aW9uQXQocG9zKSB7XG4gICAgICAgIGxldCB7IGkgfSA9IHRoaXMuY2hpbGRQb3MocG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUodGhpcy5jaGlsZHJlbltpXS5kb20pLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gRGlyZWN0aW9uLlJUTCA6IERpcmVjdGlvbi5MVFI7XG4gICAgfVxuICAgIG1lYXN1cmVUZXh0U2l6ZSgpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTGluZVZpZXcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyZSA9IGNoaWxkLm1lYXN1cmVUZXh0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVhc3VyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyB3b3JrYWJsZSBsaW5lIGV4aXN0cywgZm9yY2UgYSBsYXlvdXQgb2YgYSBtZWFzdXJhYmxlIGVsZW1lbnRcbiAgICAgICAgbGV0IGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgbGluZUhlaWdodCwgY2hhcldpZHRoO1xuICAgICAgICBkdW1teS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIjtcbiAgICAgICAgZHVtbXkuc3R5bGUud2lkdGggPSBcIjk5OTk5cHhcIjtcbiAgICAgICAgZHVtbXkudGV4dENvbnRlbnQgPSBcImFiYyBkZWYgZ2hpIGprbCBtbm8gcHFyIHN0dVwiO1xuICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGR1bW15KTtcbiAgICAgICAgICAgIGxldCByZWN0ID0gY2xpZW50UmVjdHNGb3IoZHVtbXkuZmlyc3RDaGlsZClbMF07XG4gICAgICAgICAgICBsaW5lSGVpZ2h0ID0gZHVtbXkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICAgICAgY2hhcldpZHRoID0gcmVjdCA/IHJlY3Qud2lkdGggLyAyNyA6IDc7XG4gICAgICAgICAgICBkdW1teS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGxpbmVIZWlnaHQsIGNoYXJXaWR0aCB9O1xuICAgIH1cbiAgICBjaGlsZEN1cnNvcihwb3MgPSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAvLyBNb3ZlIGJhY2sgdG8gc3RhcnQgb2YgbGFzdCBlbGVtZW50IHdoZW4gcG9zc2libGUsIHNvIHRoYXRcbiAgICAgICAgLy8gYENoaWxkQ3Vyc29yLmZpbmRQb3NgIGRvZXNuJ3QgaGF2ZSB0byBkZWFsIHdpdGggdGhlIGVkZ2UgY2FzZVxuICAgICAgICAvLyBvZiBiZWluZyBhZnRlciB0aGUgbGFzdCBlbGVtZW50LlxuICAgICAgICBsZXQgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgIHBvcyAtPSB0aGlzLmNoaWxkcmVuWy0taV0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbmV3IENoaWxkQ3Vyc29yKHRoaXMuY2hpbGRyZW4sIHBvcywgaSk7XG4gICAgfVxuICAgIGNvbXB1dGVCbG9ja0dhcERlY28oKSB7XG4gICAgICAgIGxldCBkZWNvID0gW10sIHZzID0gdGhpcy52aWV3LnZpZXdTdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA9PSB2cy52aWV3cG9ydHMubGVuZ3RoID8gbnVsbCA6IHZzLnZpZXdwb3J0c1tpXTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBuZXh0ID8gbmV4dC5mcm9tIC0gMSA6IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+IHBvcykge1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSB2cy5saW5lQmxvY2tBdChlbmQpLmJvdHRvbSAtIHZzLmxpbmVCbG9ja0F0KHBvcykudG9wO1xuICAgICAgICAgICAgICAgIGRlY28ucHVzaChEZWNvcmF0aW9uLnJlcGxhY2Uoe1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBCbG9ja0dhcFdpZGdldChoZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICBibG9jazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpc0Jsb2NrR2FwOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pLnJhbmdlKHBvcywgZW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBuZXh0LnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxuICAgIHVwZGF0ZURlY28oKSB7XG4gICAgICAgIGxldCBhbGxEZWNvID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5tYXAoKGQsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBkeW5hbWljID0gdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcFtpXSA9IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIHJldHVybiBkeW5hbWljID8gZCh0aGlzLnZpZXcpIDogZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGkgPSBhbGxEZWNvLmxlbmd0aDsgaSA8IGFsbERlY28ubGVuZ3RoICsgMzsgaSsrKVxuICAgICAgICAgICAgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcFtpXSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvcmF0aW9ucyA9IFtcbiAgICAgICAgICAgIC4uLmFsbERlY28sXG4gICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRGVjbyxcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUJsb2NrR2FwRGVjbygpLFxuICAgICAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5saW5lR2FwRGVjb1xuICAgICAgICBdO1xuICAgIH1cbiAgICBzY3JvbGxJbnRvVmlldyh0YXJnZXQpIHtcbiAgICAgICAgbGV0IHsgcmFuZ2UgfSA9IHRhcmdldDtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmNvb3Jkc0F0KHJhbmdlLmhlYWQsIHJhbmdlLmVtcHR5ID8gcmFuZ2UuYXNzb2MgOiByYW5nZS5oZWFkID4gcmFuZ2UuYW5jaG9yID8gLTEgOiAxKSwgb3RoZXI7XG4gICAgICAgIGlmICghcmVjdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSAmJiAob3RoZXIgPSB0aGlzLmNvb3Jkc0F0KHJhbmdlLmFuY2hvciwgcmFuZ2UuYW5jaG9yID4gcmFuZ2UuaGVhZCA/IC0xIDogMSkpKVxuICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogTWF0aC5taW4ocmVjdC5sZWZ0LCBvdGhlci5sZWZ0KSwgdG9wOiBNYXRoLm1pbihyZWN0LnRvcCwgb3RoZXIudG9wKSxcbiAgICAgICAgICAgICAgICByaWdodDogTWF0aC5tYXgocmVjdC5yaWdodCwgb3RoZXIucmlnaHQpLCBib3R0b206IE1hdGgubWF4KHJlY3QuYm90dG9tLCBvdGhlci5ib3R0b20pIH07XG4gICAgICAgIGxldCBtTGVmdCA9IDAsIG1SaWdodCA9IDAsIG1Ub3AgPSAwLCBtQm90dG9tID0gMDtcbiAgICAgICAgZm9yIChsZXQgbWFyZ2lucyBvZiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoc2Nyb2xsTWFyZ2lucykubWFwKGYgPT4gZih0aGlzLnZpZXcpKSlcbiAgICAgICAgICAgIGlmIChtYXJnaW5zKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIH0gPSBtYXJnaW5zO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG1MZWZ0ID0gTWF0aC5tYXgobUxlZnQsIGxlZnQpO1xuICAgICAgICAgICAgICAgIGlmIChyaWdodCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBtUmlnaHQgPSBNYXRoLm1heChtUmlnaHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAodG9wICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG1Ub3AgPSBNYXRoLm1heChtVG9wLCB0b3ApO1xuICAgICAgICAgICAgICAgIGlmIChib3R0b20gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgbUJvdHRvbSA9IE1hdGgubWF4KG1Cb3R0b20sIGJvdHRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCB0YXJnZXRSZWN0ID0ge1xuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0IC0gbUxlZnQsIHRvcDogcmVjdC50b3AgLSBtVG9wLFxuICAgICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBtUmlnaHQsIGJvdHRvbTogcmVjdC5ib3R0b20gKyBtQm90dG9tXG4gICAgICAgIH07XG4gICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLnZpZXcuc2Nyb2xsRE9NLCB0YXJnZXRSZWN0LCByYW5nZS5oZWFkIDwgcmFuZ2UuYW5jaG9yID8gLTEgOiAxLCB0YXJnZXQueCwgdGFyZ2V0LnksIHRhcmdldC54TWFyZ2luLCB0YXJnZXQueU1hcmdpbiwgdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUik7XG4gICAgfVxufVxuZnVuY3Rpb24gYmV0d2VlblVuZWRpdGFibGUocG9zKSB7XG4gICAgcmV0dXJuIHBvcy5ub2RlLm5vZGVUeXBlID09IDEgJiYgcG9zLm5vZGUuZmlyc3RDaGlsZCAmJlxuICAgICAgICAocG9zLm9mZnNldCA9PSAwIHx8IHBvcy5ub2RlLmNoaWxkTm9kZXNbcG9zLm9mZnNldCAtIDFdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpICYmXG4gICAgICAgIChwb3Mub2Zmc2V0ID09IHBvcy5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoIHx8IHBvcy5ub2RlLmNoaWxkTm9kZXNbcG9zLm9mZnNldF0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIik7XG59XG5jbGFzcyBCbG9ja0dhcFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGhlaWdodCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgdG9ET00oKSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnVwZGF0ZURPTShlbHQpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuaGVpZ2h0ID09IHRoaXMuaGVpZ2h0OyB9XG4gICAgdXBkYXRlRE9NKGVsdCkge1xuICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5oZWlnaHQ7IH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2l0aW9uU3Vycm91bmRpbmdOb2RlKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBsZXQgdGV4dE5vZGUgPSBzZWwuZm9jdXNOb2RlICYmIG5lYXJieVRleHROb2RlKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgMCk7XG4gICAgaWYgKCF0ZXh0Tm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGNWaWV3ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3QodGV4dE5vZGUpO1xuICAgIGlmICghY1ZpZXcpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChjVmlldyBpbnN0YW5jZW9mIExpbmVWaWV3KSB7XG4gICAgICAgIGxldCB0b3BOb2RlID0gdGV4dE5vZGU7XG4gICAgICAgIHdoaWxlICh0b3BOb2RlLnBhcmVudE5vZGUgIT0gY1ZpZXcuZG9tKVxuICAgICAgICAgICAgdG9wTm9kZSA9IHRvcE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgbGV0IHByZXYgPSB0b3BOb2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgd2hpbGUgKHByZXYgJiYgIUNvbnRlbnRWaWV3LmdldChwcmV2KSlcbiAgICAgICAgICAgIHByZXYgPSBwcmV2LnByZXZpb3VzU2libGluZztcbiAgICAgICAgbGV0IHBvcyA9IHByZXYgPyBDb250ZW50Vmlldy5nZXQocHJldikucG9zQXRFbmQgOiBjVmlldy5wb3NBdFN0YXJ0O1xuICAgICAgICByZXR1cm4geyBmcm9tOiBwb3MsIHRvOiBwb3MsIG5vZGU6IHRvcE5vZGUsIHRleHQ6IHRleHROb2RlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgeyBwYXJlbnQgfSA9IGNWaWV3O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgTGluZVZpZXcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjVmlldyA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnJvbSA9IGNWaWV3LnBvc0F0U3RhcnQ7XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvOiBmcm9tICsgY1ZpZXcubGVuZ3RoLCBub2RlOiBjVmlldy5kb20sIHRleHQ6IHRleHROb2RlIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZUNvbXBvc2l0aW9uRGVjbyh2aWV3LCBjaGFuZ2VzKSB7XG4gICAgbGV0IHN1cnJvdW5kaW5nID0gY29tcG9zaXRpb25TdXJyb3VuZGluZ05vZGUodmlldyk7XG4gICAgaWYgKCFzdXJyb3VuZGluZylcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICBsZXQgeyBmcm9tLCB0bywgbm9kZSwgdGV4dDogdGV4dE5vZGUgfSA9IHN1cnJvdW5kaW5nO1xuICAgIGxldCBuZXdGcm9tID0gY2hhbmdlcy5tYXBQb3MoZnJvbSwgMSksIG5ld1RvID0gTWF0aC5tYXgobmV3RnJvbSwgY2hhbmdlcy5tYXBQb3ModG8sIC0xKSk7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHRleHQgPSBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZSA6XG4gICAgICAgIG5ldyBET01SZWFkZXIoW10sIHN0YXRlKS5yZWFkUmFuZ2Uobm9kZS5maXJzdENoaWxkLCBudWxsKS50ZXh0O1xuICAgIGlmIChuZXdUbyAtIG5ld0Zyb20gPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKG5ld0Zyb20sIE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIG5ld0Zyb20gKyB0ZXh0Lmxlbmd0aCksIExpbmVCcmVha1BsYWNlaG9sZGVyKSA9PSB0ZXh0KVxuICAgICAgICAgICAgbmV3VG8gPSBuZXdGcm9tICsgdGV4dC5sZW5ndGg7XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmRvYy5zbGljZVN0cmluZyhNYXRoLm1heCgwLCBuZXdUbyAtIHRleHQubGVuZ3RoKSwgbmV3VG8sIExpbmVCcmVha1BsYWNlaG9sZGVyKSA9PSB0ZXh0KVxuICAgICAgICAgICAgbmV3RnJvbSA9IG5ld1RvIC0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlLmRvYy5zbGljZVN0cmluZyhuZXdGcm9tLCBuZXdUbywgTGluZUJyZWFrUGxhY2Vob2xkZXIpICE9IHRleHQpIHtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICB9XG4gICAgbGV0IHRvcFZpZXcgPSBDb250ZW50Vmlldy5nZXQobm9kZSk7XG4gICAgaWYgKHRvcFZpZXcgaW5zdGFuY2VvZiBDb21wb3NpdGlvblZpZXcpXG4gICAgICAgIHRvcFZpZXcgPSB0b3BWaWV3LndpZGdldC50b3BWaWV3O1xuICAgIGVsc2UgaWYgKHRvcFZpZXcpXG4gICAgICAgIHRvcFZpZXcucGFyZW50ID0gbnVsbDtcbiAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgQ29tcG9zaXRpb25XaWRnZXQobm9kZSwgdGV4dE5vZGUsIHRvcFZpZXcpLCBpbmNsdXNpdmU6IHRydWUgfSlcbiAgICAgICAgLnJhbmdlKG5ld0Zyb20sIG5ld1RvKSk7XG59XG5jbGFzcyBDb21wb3NpdGlvbldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRvcCwgdGV4dCwgdG9wVmlldykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy50b3BWaWV3ID0gdG9wVmlldztcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMudG9wID09IG90aGVyLnRvcCAmJiB0aGlzLnRleHQgPT0gb3RoZXIudGV4dDsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gdGhpcy50b3A7IH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGN1c3RvbVZpZXcoKSB7IHJldHVybiBDb21wb3NpdGlvblZpZXc7IH1cbn1cbmZ1bmN0aW9uIG5lYXJieVRleHROb2RlKG5vZGUsIG9mZnNldCwgc2lkZSkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA+IDAgJiYgc2lkZSA8PSAwKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmIHNpZGUgPj0gMCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbmV4dFRvVW5lZGl0YWJsZShub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gKG9mZnNldCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiA/IDEgLyogTmV4dFRvLkJlZm9yZSAqLyA6IDApIHxcbiAgICAgICAgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggJiYgbm9kZS5jaGlsZE5vZGVzW29mZnNldF0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiA/IDIgLyogTmV4dFRvLkFmdGVyICovIDogMCk7XG59XG5jbGFzcyBEZWNvcmF0aW9uQ29tcGFyYXRvciQxIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gW107XG4gICAgfVxuICAgIGNvbXBhcmVSYW5nZShmcm9tLCB0bykgeyBhZGRSYW5nZShmcm9tLCB0bywgdGhpcy5jaGFuZ2VzKTsgfVxuICAgIGNvbXBhcmVQb2ludChmcm9tLCB0bykgeyBhZGRSYW5nZShmcm9tLCB0bywgdGhpcy5jaGFuZ2VzKTsgfVxufVxuZnVuY3Rpb24gZmluZENoYW5nZWREZWNvKGEsIGIsIGRpZmYpIHtcbiAgICBsZXQgY29tcCA9IG5ldyBEZWNvcmF0aW9uQ29tcGFyYXRvciQxO1xuICAgIFJhbmdlU2V0LmNvbXBhcmUoYSwgYiwgZGlmZiwgY29tcCk7XG4gICAgcmV0dXJuIGNvbXAuY2hhbmdlcztcbn1cbmZ1bmN0aW9uIGluVW5lZGl0YWJsZShub2RlLCBpbnNpZGUpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOyBjdXIgJiYgY3VyICE9IGluc2lkZTsgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09IDEgJiYgY3VyLmNvbnRlbnRFZGl0YWJsZSA9PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdyb3VwQXQoc3RhdGUsIHBvcywgYmlhcyA9IDEpIHtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBsaW5lUG9zID0gcG9zIC0gbGluZS5mcm9tO1xuICAgIGlmIChsaW5lLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpO1xuICAgIGlmIChsaW5lUG9zID09IDApXG4gICAgICAgIGJpYXMgPSAxO1xuICAgIGVsc2UgaWYgKGxpbmVQb3MgPT0gbGluZS5sZW5ndGgpXG4gICAgICAgIGJpYXMgPSAtMTtcbiAgICBsZXQgZnJvbSA9IGxpbmVQb3MsIHRvID0gbGluZVBvcztcbiAgICBpZiAoYmlhcyA8IDApXG4gICAgICAgIGZyb20gPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgbGluZVBvcywgZmFsc2UpO1xuICAgIGVsc2VcbiAgICAgICAgdG8gPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgbGluZVBvcyk7XG4gICAgbGV0IGNhdCA9IGNhdGVnb3JpemUobGluZS50ZXh0LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgd2hpbGUgKGZyb20gPiAwKSB7XG4gICAgICAgIGxldCBwcmV2ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGZyb20sIGZhbHNlKTtcbiAgICAgICAgaWYgKGNhdGVnb3JpemUobGluZS50ZXh0LnNsaWNlKHByZXYsIGZyb20pKSAhPSBjYXQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZnJvbSA9IHByZXY7XG4gICAgfVxuICAgIHdoaWxlICh0byA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHRvKTtcbiAgICAgICAgaWYgKGNhdGVnb3JpemUobGluZS50ZXh0LnNsaWNlKHRvLCBuZXh0KSkgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHRvID0gbmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tICsgbGluZS5mcm9tLCB0byArIGxpbmUuZnJvbSk7XG59XG4vLyBTZWFyY2ggdGhlIERPTSBmb3IgdGhlIHtub2RlLCBvZmZzZXR9IHBvc2l0aW9uIGNsb3Nlc3QgdG8gdGhlIGdpdmVuXG4vLyBjb29yZGluYXRlcy4gVmVyeSBpbmVmZmljaWVudCBhbmQgY3J1ZGUsIGJ1dCBjYW4gdXN1YWxseSBiZSBhdm9pZGVkXG4vLyBieSBjYWxsaW5nIGNhcmV0KFBvc2l0aW9ufFJhbmdlKUZyb21Qb2ludCBpbnN0ZWFkLlxuZnVuY3Rpb24gZ2V0ZHgoeCwgcmVjdCkge1xuICAgIHJldHVybiByZWN0LmxlZnQgPiB4ID8gcmVjdC5sZWZ0IC0geCA6IE1hdGgubWF4KDAsIHggLSByZWN0LnJpZ2h0KTtcbn1cbmZ1bmN0aW9uIGdldGR5KHksIHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC50b3AgPiB5ID8gcmVjdC50b3AgLSB5IDogTWF0aC5tYXgoMCwgeSAtIHJlY3QuYm90dG9tKTtcbn1cbmZ1bmN0aW9uIHlPdmVybGFwKGEsIGIpIHtcbiAgICByZXR1cm4gYS50b3AgPCBiLmJvdHRvbSAtIDEgJiYgYS5ib3R0b20gPiBiLnRvcCArIDE7XG59XG5mdW5jdGlvbiB1cFRvcChyZWN0LCB0b3ApIHtcbiAgICByZXR1cm4gdG9wIDwgcmVjdC50b3AgPyB7IHRvcCwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCwgYm90dG9tOiByZWN0LmJvdHRvbSB9IDogcmVjdDtcbn1cbmZ1bmN0aW9uIHVwQm90KHJlY3QsIGJvdHRvbSkge1xuICAgIHJldHVybiBib3R0b20gPiByZWN0LmJvdHRvbSA/IHsgdG9wOiByZWN0LnRvcCwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCwgYm90dG9tIH0gOiByZWN0O1xufVxuZnVuY3Rpb24gZG9tUG9zQXRDb29yZHMocGFyZW50LCB4LCB5KSB7XG4gICAgbGV0IGNsb3Nlc3QsIGNsb3Nlc3RSZWN0LCBjbG9zZXN0WCwgY2xvc2VzdFksIGNsb3Nlc3RPdmVybGFwID0gZmFsc2U7XG4gICAgbGV0IGFib3ZlLCBiZWxvdywgYWJvdmVSZWN0LCBiZWxvd1JlY3Q7XG4gICAgZm9yIChsZXQgY2hpbGQgPSBwYXJlbnQuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbGV0IHJlY3RzID0gY2xpZW50UmVjdHNGb3IoY2hpbGQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKGNsb3Nlc3RSZWN0ICYmIHlPdmVybGFwKGNsb3Nlc3RSZWN0LCByZWN0KSlcbiAgICAgICAgICAgICAgICByZWN0ID0gdXBUb3AodXBCb3QocmVjdCwgY2xvc2VzdFJlY3QuYm90dG9tKSwgY2xvc2VzdFJlY3QudG9wKTtcbiAgICAgICAgICAgIGxldCBkeCA9IGdldGR4KHgsIHJlY3QpLCBkeSA9IGdldGR5KHksIHJlY3QpO1xuICAgICAgICAgICAgaWYgKGR4ID09IDAgJiYgZHkgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubm9kZVR5cGUgPT0gMyA/IGRvbVBvc0luVGV4dChjaGlsZCwgeCwgeSkgOiBkb21Qb3NBdENvb3JkcyhjaGlsZCwgeCwgeSk7XG4gICAgICAgICAgICBpZiAoIWNsb3Nlc3QgfHwgY2xvc2VzdFkgPiBkeSB8fCBjbG9zZXN0WSA9PSBkeSAmJiBjbG9zZXN0WCA+IGR4KSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0WCA9IGR4O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RZID0gZHk7XG4gICAgICAgICAgICAgICAgbGV0IHNpZGUgPSBkeSA/ICh5IDwgcmVjdC50b3AgPyAtMSA6IDEpIDogZHggPyAoeCA8IHJlY3QubGVmdCA/IC0xIDogMSkgOiAwO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RPdmVybGFwID0gIXNpZGUgfHwgKHNpZGUgPiAwID8gaSA8IHJlY3RzLmxlbmd0aCAtIDEgOiBpID4gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHggPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh5ID4gcmVjdC5ib3R0b20gJiYgKCFhYm92ZVJlY3QgfHwgYWJvdmVSZWN0LmJvdHRvbSA8IHJlY3QuYm90dG9tKSkge1xuICAgICAgICAgICAgICAgICAgICBhYm92ZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBhYm92ZVJlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5IDwgcmVjdC50b3AgJiYgKCFiZWxvd1JlY3QgfHwgYmVsb3dSZWN0LnRvcCA+IHJlY3QudG9wKSkge1xuICAgICAgICAgICAgICAgICAgICBiZWxvdyA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBiZWxvd1JlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFib3ZlUmVjdCAmJiB5T3ZlcmxhcChhYm92ZVJlY3QsIHJlY3QpKSB7XG4gICAgICAgICAgICAgICAgYWJvdmVSZWN0ID0gdXBCb3QoYWJvdmVSZWN0LCByZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZWxvd1JlY3QgJiYgeU92ZXJsYXAoYmVsb3dSZWN0LCByZWN0KSkge1xuICAgICAgICAgICAgICAgIGJlbG93UmVjdCA9IHVwVG9wKGJlbG93UmVjdCwgcmVjdC50b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhYm92ZVJlY3QgJiYgYWJvdmVSZWN0LmJvdHRvbSA+PSB5KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBhYm92ZTtcbiAgICAgICAgY2xvc2VzdFJlY3QgPSBhYm92ZVJlY3Q7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJlbG93UmVjdCAmJiBiZWxvd1JlY3QudG9wIDw9IHkpIHtcbiAgICAgICAgY2xvc2VzdCA9IGJlbG93O1xuICAgICAgICBjbG9zZXN0UmVjdCA9IGJlbG93UmVjdDtcbiAgICB9XG4gICAgaWYgKCFjbG9zZXN0KVxuICAgICAgICByZXR1cm4geyBub2RlOiBwYXJlbnQsIG9mZnNldDogMCB9O1xuICAgIGxldCBjbGlwWCA9IE1hdGgubWF4KGNsb3Nlc3RSZWN0LmxlZnQsIE1hdGgubWluKGNsb3Nlc3RSZWN0LnJpZ2h0LCB4KSk7XG4gICAgaWYgKGNsb3Nlc3Qubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIGRvbVBvc0luVGV4dChjbG9zZXN0LCBjbGlwWCwgeSk7XG4gICAgaWYgKGNsb3Nlc3RPdmVybGFwICYmIGNsb3Nlc3QuY29udGVudEVkaXRhYmxlICE9IFwiZmFsc2VcIilcbiAgICAgICAgcmV0dXJuIGRvbVBvc0F0Q29vcmRzKGNsb3Nlc3QsIGNsaXBYLCB5KTtcbiAgICBsZXQgb2Zmc2V0ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChwYXJlbnQuY2hpbGROb2RlcywgY2xvc2VzdCkgK1xuICAgICAgICAoeCA+PSAoY2xvc2VzdFJlY3QubGVmdCArIGNsb3Nlc3RSZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCk7XG4gICAgcmV0dXJuIHsgbm9kZTogcGFyZW50LCBvZmZzZXQgfTtcbn1cbmZ1bmN0aW9uIGRvbVBvc0luVGV4dChub2RlLCB4LCB5KSB7XG4gICAgbGV0IGxlbiA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICBsZXQgY2xvc2VzdE9mZnNldCA9IC0xLCBjbG9zZXN0RFkgPSAxZTksIGdlbmVyYWxTaWRlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCByZWN0cyA9IHRleHRSYW5nZShub2RlLCBpLCBpICsgMSkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZWN0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tqXTtcbiAgICAgICAgICAgIGlmIChyZWN0LnRvcCA9PSByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghZ2VuZXJhbFNpZGUpXG4gICAgICAgICAgICAgICAgZ2VuZXJhbFNpZGUgPSB4IC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgbGV0IGR5ID0gKHJlY3QudG9wID4geSA/IHJlY3QudG9wIC0geSA6IHkgLSByZWN0LmJvdHRvbSkgLSAxO1xuICAgICAgICAgICAgaWYgKHJlY3QubGVmdCAtIDEgPD0geCAmJiByZWN0LnJpZ2h0ICsgMSA+PSB4ICYmIGR5IDwgY2xvc2VzdERZKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0geCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLCBhZnRlciA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmdlY2tvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBSVEwgb24gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGdldHRpbmcgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY3RzIGZvciBlbXB0eSByYW5nZXMuXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0QmVmb3JlID0gdGV4dFJhbmdlKG5vZGUsIGkpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdEJlZm9yZS5sZWZ0ID09IHJlY3QucmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlciA9ICFyaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGR5IDw9IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogaSArIChhZnRlciA/IDEgOiAwKSB9O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RPZmZzZXQgPSBpICsgKGFmdGVyID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3REWSA9IGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogY2xvc2VzdE9mZnNldCA+IC0xID8gY2xvc2VzdE9mZnNldCA6IGdlbmVyYWxTaWRlID4gMCA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IDAgfTtcbn1cbmZ1bmN0aW9uIHBvc0F0Q29vcmRzKHZpZXcsIGNvb3JkcywgcHJlY2lzZSwgYmlhcyA9IC0xKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBjb250ZW50ID0gdmlldy5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBkb2NUb3AgPSBjb250ZW50LnRvcCArIHZpZXcudmlld1N0YXRlLnBhZGRpbmdUb3A7XG4gICAgbGV0IGJsb2NrLCB7IGRvY0hlaWdodCB9ID0gdmlldy52aWV3U3RhdGU7XG4gICAgbGV0IHsgeCwgeSB9ID0gY29vcmRzLCB5T2Zmc2V0ID0geSAtIGRvY1RvcDtcbiAgICBpZiAoeU9mZnNldCA8IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmICh5T2Zmc2V0ID4gZG9jSGVpZ2h0KVxuICAgICAgICByZXR1cm4gdmlldy5zdGF0ZS5kb2MubGVuZ3RoO1xuICAgIC8vIFNjYW4gZm9yIGEgdGV4dCBibG9jayBuZWFyIHRoZSBxdWVyaWVkIHkgcG9zaXRpb25cbiAgICBmb3IgKGxldCBoYWxmTGluZSA9IHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgLyAyLCBib3VuY2VkID0gZmFsc2U7Oykge1xuICAgICAgICBibG9jayA9IHZpZXcuZWxlbWVudEF0SGVpZ2h0KHlPZmZzZXQpO1xuICAgICAgICBpZiAoYmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSB5IHBvc2l0aW9uIG91dCBvZiB0aGlzIGJsb2NrXG4gICAgICAgICAgICB5T2Zmc2V0ID0gYmlhcyA+IDAgPyBibG9jay5ib3R0b20gKyBoYWxmTGluZSA6IGJsb2NrLnRvcCAtIGhhbGZMaW5lO1xuICAgICAgICAgICAgaWYgKHlPZmZzZXQgPj0gMCAmJiB5T2Zmc2V0IDw9IGRvY0hlaWdodClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIElmIHRoZSBkb2N1bWVudCBjb25zaXN0cyBlbnRpcmVseSBvZiByZXBsYWNlZCB3aWRnZXRzLCB3ZVxuICAgICAgICAgICAgLy8gd29uJ3QgZmluZCBhIHRleHQgYmxvY2ssIHNvIHJldHVybiAwXG4gICAgICAgICAgICBpZiAoYm91bmNlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlY2lzZSA/IG51bGwgOiAwO1xuICAgICAgICAgICAgYm91bmNlZCA9IHRydWU7XG4gICAgICAgICAgICBiaWFzID0gLWJpYXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgeSA9IGRvY1RvcCArIHlPZmZzZXQ7XG4gICAgbGV0IGxpbmVTdGFydCA9IGJsb2NrLmZyb207XG4gICAgLy8gSWYgdGhpcyBpcyBvdXRzaWRlIG9mIHRoZSByZW5kZXJlZCB2aWV3cG9ydCwgd2UgY2FuJ3QgZGV0ZXJtaW5lIGEgcG9zaXRpb25cbiAgICBpZiAobGluZVN0YXJ0IDwgdmlldy52aWV3cG9ydC5mcm9tKVxuICAgICAgICByZXR1cm4gdmlldy52aWV3cG9ydC5mcm9tID09IDAgPyAwIDogcHJlY2lzZSA/IG51bGwgOiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50LCBibG9jaywgeCwgeSk7XG4gICAgaWYgKGxpbmVTdGFydCA+IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiB2aWV3LnZpZXdwb3J0LnRvID09IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCA/IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCA6XG4gICAgICAgICAgICBwcmVjaXNlID8gbnVsbCA6IHBvc0F0Q29vcmRzSW1wcmVjaXNlKHZpZXcsIGNvbnRlbnQsIGJsb2NrLCB4LCB5KTtcbiAgICAvLyBQcmVmZXIgU2hhZG93Um9vdE9yRG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCBpZiBwcmVzZW50LCBmYWxsIGJhY2sgdG8gZG9jdW1lbnQgaWYgbm90XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgbGV0IHJvb3QgPSB2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCA/IHZpZXcucm9vdCA6IGRvYztcbiAgICBsZXQgZWxlbWVudCA9IHJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICBpZiAoZWxlbWVudCAmJiAhdmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGVsZW1lbnQpKVxuICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyB1bmV4cGVjdGVkLCBjbGlwIHggYXQgdGhlIHNpZGVzIG9mIHRoZSBjb250ZW50IGFyZWEgYW5kIHRyeSBhZ2FpblxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB4ID0gTWF0aC5tYXgoY29udGVudC5sZWZ0ICsgMSwgTWF0aC5taW4oY29udGVudC5yaWdodCAtIDEsIHgpKTtcbiAgICAgICAgZWxlbWVudCA9IHJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIXZpZXcuY29udGVudERPTS5jb250YWlucyhlbGVtZW50KSlcbiAgICAgICAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBUaGVyZSdzIHZpc2libGUgZWRpdG9yIGNvbnRlbnQgdW5kZXIgdGhlIHBvaW50LCBzbyB3ZSBjYW4gdHJ5XG4gICAgLy8gdXNpbmcgY2FyZXQoUG9zaXRpb258UmFuZ2UpRnJvbVBvaW50IGFzIGEgc2hvcnRjdXRcbiAgICBsZXQgbm9kZSwgb2Zmc2V0ID0gLTE7XG4gICAgaWYgKGVsZW1lbnQgJiYgKChfYSA9IHZpZXcuZG9jVmlldy5uZWFyZXN0KGVsZW1lbnQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNFZGl0YWJsZSkgIT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgICAgICh7IG9mZnNldE5vZGU6IG5vZGUsIG9mZnNldCB9ID0gcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAoeyBzdGFydENvbnRhaW5lcjogbm9kZSwgc3RhcnRPZmZzZXQ6IG9mZnNldCB9ID0gcmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlmICghdmlldy5jb250ZW50RE9NLmNvbnRhaW5zKG5vZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuc2FmYXJpICYmIGlzU3VzcGljaW91c1NhZmFyaUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkgfHxcbiAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5jaHJvbWUgJiYgaXNTdXNwaWNpb3VzQ2hyb21lQ2FyZXRSZXN1bHQobm9kZSwgb2Zmc2V0LCB4KSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBObyBsdWNrLCBkbyBvdXIgb3duIChwb3RlbnRpYWxseSBleHBlbnNpdmUpIHNlYXJjaFxuICAgIGlmICghbm9kZSB8fCAhdmlldy5kb2NWaWV3LmRvbS5jb250YWlucyhub2RlKSkge1xuICAgICAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBsaW5lU3RhcnQpO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICByZXR1cm4geU9mZnNldCA+IGJsb2NrLnRvcCArIGJsb2NrLmhlaWdodCAvIDIgPyBibG9jay50byA6IGJsb2NrLmZyb207XG4gICAgICAgICh7IG5vZGUsIG9mZnNldCB9ID0gZG9tUG9zQXRDb29yZHMobGluZS5kb20sIHgsIHkpKTtcbiAgICB9XG4gICAgbGV0IG5lYXJlc3QgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChub2RlKTtcbiAgICBpZiAoIW5lYXJlc3QpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChuZWFyZXN0LmlzV2lkZ2V0KSB7XG4gICAgICAgIGxldCByZWN0ID0gbmVhcmVzdC5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiBjb29yZHMueSA8IHJlY3QudG9wIHx8IGNvb3Jkcy55IDw9IHJlY3QuYm90dG9tICYmIGNvb3Jkcy54IDw9IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDJcbiAgICAgICAgICAgID8gbmVhcmVzdC5wb3NBdFN0YXJ0IDogbmVhcmVzdC5wb3NBdEVuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZWFyZXN0LmxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpICsgbmVhcmVzdC5wb3NBdFN0YXJ0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBvc0F0Q29vcmRzSW1wcmVjaXNlKHZpZXcsIGNvbnRlbnRSZWN0LCBibG9jaywgeCwgeSkge1xuICAgIGxldCBpbnRvID0gTWF0aC5yb3VuZCgoeCAtIGNvbnRlbnRSZWN0LmxlZnQpICogdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpO1xuICAgIGlmICh2aWV3LmxpbmVXcmFwcGluZyAmJiBibG9jay5oZWlnaHQgPiB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0ICogMS41KSB7XG4gICAgICAgIGxldCBsaW5lID0gTWF0aC5mbG9vcigoeSAtIGJsb2NrLnRvcCkgLyB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0KTtcbiAgICAgICAgaW50byArPSBsaW5lICogdmlldy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVMZW5ndGg7XG4gICAgfVxuICAgIGxldCBjb250ZW50ID0gdmlldy5zdGF0ZS5zbGljZURvYyhibG9jay5mcm9tLCBibG9jay50byk7XG4gICAgcmV0dXJuIGJsb2NrLmZyb20gKyBmaW5kQ29sdW1uKGNvbnRlbnQsIGludG8sIHZpZXcuc3RhdGUudGFiU2l6ZSk7XG59XG4vLyBJbiBjYXNlIG9mIGEgaGlnaCBsaW5lIGhlaWdodCwgU2FmYXJpJ3MgY2FyZXRSYW5nZUZyb21Qb2ludCB0cmVhdHNcbi8vIHRoZSBzcGFjZSBiZXR3ZWVuIGxpbmVzIGFzIGJlbG9uZ2luZyB0byB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgdGhlXG4vLyBsaW5lIGJlZm9yZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVjdCBzdWNoIGEgcmVzdWx0IHNvIHRoYXQgaXQgY2FuIGJlXG4vLyBpZ25vcmVkIChpc3N1ZSAjNDAxKS5cbmZ1bmN0aW9uIGlzU3VzcGljaW91c1NhZmFyaUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkge1xuICAgIGxldCBsZW47XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMyB8fCBvZmZzZXQgIT0gKGxlbiA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZzsgbmV4dDsgbmV4dCA9IG5leHQubmV4dFNpYmxpbmcpXG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlICE9IDEgfHwgbmV4dC5ub2RlTmFtZSAhPSBcIkJSXCIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRleHRSYW5nZShub2RlLCBsZW4gLSAxLCBsZW4pLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgPiB4O1xufVxuLy8gQ2hyb21lIHdpbGwgbW92ZSBwb3NpdGlvbnMgYmV0d2VlbiBsaW5lcyB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHQgbGluZVxuZnVuY3Rpb24gaXNTdXNwaWNpb3VzQ2hyb21lQ2FyZXRSZXN1bHQobm9kZSwgb2Zmc2V0LCB4KSB7XG4gICAgaWYgKG9mZnNldCAhPSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZTs7KSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEgfHwgcGFyZW50LmZpcnN0Q2hpbGQgIT0gY3VyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocGFyZW50LmNsYXNzTGlzdC5jb250YWlucyhcImNtLWxpbmVcIikpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY3VyID0gcGFyZW50O1xuICAgIH1cbiAgICBsZXQgcmVjdCA9IG5vZGUubm9kZVR5cGUgPT0gMSA/IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgOiB0ZXh0UmFuZ2Uobm9kZSwgMCwgTWF0aC5tYXgobm9kZS5ub2RlVmFsdWUubGVuZ3RoLCAxKSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHggLSByZWN0LmxlZnQgPiA1O1xufVxuZnVuY3Rpb24gbW92ZVRvTGluZUJvdW5kYXJ5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCkge1xuICAgIGxldCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHN0YXJ0LmhlYWQpO1xuICAgIGxldCBjb29yZHMgPSAhaW5jbHVkZVdyYXAgfHwgIXZpZXcubGluZVdyYXBwaW5nID8gbnVsbFxuICAgICAgICA6IHZpZXcuY29vcmRzQXRQb3Moc3RhcnQuYXNzb2MgPCAwICYmIHN0YXJ0LmhlYWQgPiBsaW5lLmZyb20gPyBzdGFydC5oZWFkIC0gMSA6IHN0YXJ0LmhlYWQpO1xuICAgIGlmIChjb29yZHMpIHtcbiAgICAgICAgbGV0IGVkaXRvclJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGRpcmVjdGlvbiA9IHZpZXcudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZm9yd2FyZCA9PSAoZGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIpID8gZWRpdG9yUmVjdC5yaWdodCAtIDEgOiBlZGl0b3JSZWN0LmxlZnQgKyAxLFxuICAgICAgICAgICAgeTogKGNvb3Jkcy50b3AgKyBjb29yZHMuYm90dG9tKSAvIDIgfSk7XG4gICAgICAgIGlmIChwb3MgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgZm9yd2FyZCA/IC0xIDogMSk7XG4gICAgfVxuICAgIGxldCBsaW5lVmlldyA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBzdGFydC5oZWFkKTtcbiAgICBsZXQgZW5kID0gbGluZVZpZXcgPyAoZm9yd2FyZCA/IGxpbmVWaWV3LnBvc0F0RW5kIDogbGluZVZpZXcucG9zQXRTdGFydCkgOiAoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20pO1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGVuZCwgZm9yd2FyZCA/IC0xIDogMSk7XG59XG5mdW5jdGlvbiBtb3ZlQnlDaGFyKHZpZXcsIHN0YXJ0LCBmb3J3YXJkLCBieSkge1xuICAgIGxldCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHN0YXJ0LmhlYWQpLCBzcGFucyA9IHZpZXcuYmlkaVNwYW5zKGxpbmUpO1xuICAgIGxldCBkaXJlY3Rpb24gPSB2aWV3LnRleHREaXJlY3Rpb25BdChsaW5lLmZyb20pO1xuICAgIGZvciAobGV0IGN1ciA9IHN0YXJ0LCBjaGVjayA9IG51bGw7Oykge1xuICAgICAgICBsZXQgbmV4dCA9IG1vdmVWaXN1YWxseShsaW5lLCBzcGFucywgZGlyZWN0aW9uLCBjdXIsIGZvcndhcmQpLCBjaGFyID0gbW92ZWRPdmVyO1xuICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLm51bWJlciA9PSAoZm9yd2FyZCA/IHZpZXcuc3RhdGUuZG9jLmxpbmVzIDogMSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgICAgIGNoYXIgPSBcIlxcblwiO1xuICAgICAgICAgICAgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmUobGluZS5udW1iZXIgKyAoZm9yd2FyZCA/IDEgOiAtMSkpO1xuICAgICAgICAgICAgc3BhbnMgPSB2aWV3LmJpZGlTcGFucyhsaW5lKTtcbiAgICAgICAgICAgIG5leHQgPSBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZvcndhcmQgPyBsaW5lLmZyb20gOiBsaW5lLnRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoZWNrKSB7XG4gICAgICAgICAgICBpZiAoIWJ5KVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgY2hlY2sgPSBieShjaGFyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghY2hlY2soY2hhcikpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgY3VyID0gbmV4dDtcbiAgICB9XG59XG5mdW5jdGlvbiBieUdyb3VwKHZpZXcsIHBvcywgc3RhcnQpIHtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHZpZXcuc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgbGV0IGNhdCA9IGNhdGVnb3JpemUoc3RhcnQpO1xuICAgIHJldHVybiAobmV4dCkgPT4ge1xuICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dCk7XG4gICAgICAgIGlmIChjYXQgPT0gQ2hhckNhdGVnb3J5LlNwYWNlKVxuICAgICAgICAgICAgY2F0ID0gbmV4dENhdDtcbiAgICAgICAgcmV0dXJuIGNhdCA9PSBuZXh0Q2F0O1xuICAgIH07XG59XG5mdW5jdGlvbiBtb3ZlVmVydGljYWxseSh2aWV3LCBzdGFydCwgZm9yd2FyZCwgZGlzdGFuY2UpIHtcbiAgICBsZXQgc3RhcnRQb3MgPSBzdGFydC5oZWFkLCBkaXIgPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgIGlmIChzdGFydFBvcyA9PSAoZm9yd2FyZCA/IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCA6IDApKVxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihzdGFydFBvcywgc3RhcnQuYXNzb2MpO1xuICAgIGxldCBnb2FsID0gc3RhcnQuZ29hbENvbHVtbiwgc3RhcnRZO1xuICAgIGxldCByZWN0ID0gdmlldy5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBzdGFydENvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3Moc3RhcnRQb3MpLCBkb2NUb3AgPSB2aWV3LmRvY3VtZW50VG9wO1xuICAgIGlmIChzdGFydENvb3Jkcykge1xuICAgICAgICBpZiAoZ29hbCA9PSBudWxsKVxuICAgICAgICAgICAgZ29hbCA9IHN0YXJ0Q29vcmRzLmxlZnQgLSByZWN0LmxlZnQ7XG4gICAgICAgIHN0YXJ0WSA9IGRpciA8IDAgPyBzdGFydENvb3Jkcy50b3AgOiBzdGFydENvb3Jkcy5ib3R0b207XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbGluZSA9IHZpZXcudmlld1N0YXRlLmxpbmVCbG9ja0F0KHN0YXJ0UG9zKTtcbiAgICAgICAgaWYgKGdvYWwgPT0gbnVsbClcbiAgICAgICAgICAgIGdvYWwgPSBNYXRoLm1pbihyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LCB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCAqIChzdGFydFBvcyAtIGxpbmUuZnJvbSkpO1xuICAgICAgICBzdGFydFkgPSAoZGlyIDwgMCA/IGxpbmUudG9wIDogbGluZS5ib3R0b20pICsgZG9jVG9wO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZWRHb2FsID0gcmVjdC5sZWZ0ICsgZ29hbDtcbiAgICBsZXQgZGlzdCA9IGRpc3RhbmNlICE9PSBudWxsICYmIGRpc3RhbmNlICE9PSB2b2lkIDAgPyBkaXN0YW5jZSA6ICh2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0ID4+IDEpO1xuICAgIGZvciAobGV0IGV4dHJhID0gMDs7IGV4dHJhICs9IDEwKSB7XG4gICAgICAgIGxldCBjdXJZID0gc3RhcnRZICsgKGRpc3QgKyBleHRyYSkgKiBkaXI7XG4gICAgICAgIGxldCBwb3MgPSBwb3NBdENvb3Jkcyh2aWV3LCB7IHg6IHJlc29sdmVkR29hbCwgeTogY3VyWSB9LCBmYWxzZSwgZGlyKTtcbiAgICAgICAgaWYgKGN1clkgPCByZWN0LnRvcCB8fCBjdXJZID4gcmVjdC5ib3R0b20gfHwgKGRpciA8IDAgPyBwb3MgPCBzdGFydFBvcyA6IHBvcyA+IHN0YXJ0UG9zKSlcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgc3RhcnQuYXNzb2MsIHVuZGVmaW5lZCwgZ29hbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2tpcEF0b21zKHZpZXcsIG9sZFBvcywgcG9zKSB7XG4gICAgbGV0IGF0b21zID0gdmlldy5zdGF0ZS5mYWNldChhdG9taWNSYW5nZXMpLm1hcChmID0+IGYodmlldykpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG1vdmVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHNldCBvZiBhdG9tcykge1xuICAgICAgICAgICAgc2V0LmJldHdlZW4ocG9zLmZyb20gLSAxLCBwb3MuZnJvbSArIDEsIChmcm9tLCB0bywgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9zLmZyb20gPiBmcm9tICYmIHBvcy5mcm9tIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gb2xkUG9zLmhlYWQgPiBwb3MuZnJvbSA/IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZnJvbSwgMSkgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHRvLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vdmVkKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG59XG5cbi8vIFRoaXMgd2lsbCBhbHNvIGJlIHdoZXJlIGRyYWdnaW5nIGluZm8gYW5kIHN1Y2ggZ29lc1xuY2xhc3MgSW5wdXRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gMDtcbiAgICAgICAgdGhpcy5sYXN0S2V5VGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IDA7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbExlZnQgPSAwO1xuICAgICAgICB0aGlzLmNocm9tZVNjcm9sbEhhY2sgPSAtMTtcbiAgICAgICAgLy8gT24gaU9TLCBzb21lIGtleXMgbmVlZCB0byBoYXZlIHRoZWlyIGRlZmF1bHQgYmVoYXZpb3IgaGFwcGVuXG4gICAgICAgIC8vIChhZnRlciB3aGljaCB3ZSByZXRyb2FjdGl2ZWx5IGhhbmRsZSB0aGVtIGFuZCByZXNldCB0aGUgRE9NKSB0b1xuICAgICAgICAvLyBhdm9pZCBtZXNzaW5nIHVwIHRoZSB2aXJ0dWFsIGtleWJvYXJkIHN0YXRlLlxuICAgICAgICB0aGlzLnBlbmRpbmdJT1NLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RFc2NQcmVzcyA9IDA7XG4gICAgICAgIHRoaXMubGFzdENvbnRleHRNZW51ID0gMDtcbiAgICAgICAgdGhpcy5zY3JvbGxIYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXN0b21IYW5kbGVycyA9IFtdO1xuICAgICAgICAvLyAtMSBtZWFucyBub3QgaW4gYSBjb21wb3NpdGlvbi4gT3RoZXJ3aXNlLCB0aGlzIGNvdW50cyB0aGUgbnVtYmVyXG4gICAgICAgIC8vIG9mIGNoYW5nZXMgbWFkZSBkdXJpbmcgdGhlIGNvbXBvc2l0aW9uLiBUaGUgY291bnQgaXMgdXNlZCB0b1xuICAgICAgICAvLyBhdm9pZCB0cmVhdGluZyB0aGUgc3RhcnQgc3RhdGUgb2YgdGhlIGNvbXBvc2l0aW9uLCBiZWZvcmUgYW55XG4gICAgICAgIC8vIGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUsIGFzIHBhcnQgb2YgdGhlIGNvbXBvc2l0aW9uLlxuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IC0xO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciB0aGUgbmV4dCBjaGFuZ2Ugc2hvdWxkIGJlIG1hcmtlZCBhcyBzdGFydGluZyB0aGVcbiAgICAgICAgLy8gY29tcG9zaXRpb24gKG51bGwgbWVhbnMgbm8gY29tcG9zaXRpb24sIHRydWUgbWVhbnMgbmV4dCBpcyB0aGVcbiAgICAgICAgLy8gZmlyc3QsIGZhbHNlIG1lYW5zIGZpcnN0IGhhcyBhbHJlYWR5IGJlZW4gbWFya2VkIGZvciB0aGlzXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uKVxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA9IDA7XG4gICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBsZXQgaGFuZGxlRXZlbnQgPSAoaGFuZGxlciwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uKGV2ZW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PSBcImtleWRvd25cIiAmJiB0aGlzLmtleWRvd24odmlldywgZXZlbnQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0aGlzLm11c3RGbHVzaE9ic2VydmVyKGV2ZW50KSlcbiAgICAgICAgICAgICAgICB2aWV3Lm9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJ1bkN1c3RvbUhhbmRsZXJzKGV2ZW50LnR5cGUsIHZpZXcsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGhhbmRsZXIodmlldywgZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCB0eXBlIGluIGhhbmRsZXJzKSB7XG4gICAgICAgICAgICBsZXQgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudEJlbG9uZ3NUb0VkaXRvcih2aWV3LCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50KGhhbmRsZXIsIGV2ZW50KTtcbiAgICAgICAgICAgIH0sIGhhbmRsZXJPcHRpb25zW3R5cGVdKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cy5wdXNoKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09IHZpZXcuc2Nyb2xsRE9NICYmIGV2ZW50LmNsaWVudFkgPiB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tKVxuICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50KGhhbmRsZXJzLm1vdXNlZG93biwgZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIGJyb3dzZXIuY2hyb21lX3ZlcnNpb24gPT0gMTAyKSB7IC8vIEZJWE1FIHJlbW92ZSBhdCBzb21lIHBvaW50XG4gICAgICAgICAgICAvLyBPbiBDaHJvbWUgMTAyLCB2aWV3cG9ydCB1cGRhdGVzIHNvbWVob3cgc3RvcCB3aGVlbC1iYXNlZFxuICAgICAgICAgICAgLy8gc2Nyb2xsaW5nLiBUdXJuaW5nIG9mZiBwb2ludGVyIGV2ZW50cyBkdXJpbmcgdGhlIHNjcm9sbCBzZWVtc1xuICAgICAgICAgICAgLy8gdG8gYXZvaWQgdGhlIGlzc3VlLlxuICAgICAgICAgICAgdmlldy5zY3JvbGxET00uYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaHJvbWVTY3JvbGxIYWNrIDwgMClcbiAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5jaHJvbWVTY3JvbGxIYWNrKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNocm9tZVNjcm9sbEhhY2sgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHJvbWVTY3JvbGxIYWNrID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgfSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90aWZpZWRGb2N1c2VkID0gdmlldy5oYXNGb2N1cztcbiAgICAgICAgLy8gT24gU2FmYXJpIGFkZGluZyBhbiBpbnB1dCBldmVudCBoYW5kbGVyIHNvbWVob3cgcHJldmVudHMgYW5cbiAgICAgICAgLy8gaXNzdWUgd2hlcmUgdGhlIGNvbXBvc2l0aW9uIHZhbmlzaGVzIHdoZW4geW91IHByZXNzIGVudGVyLlxuICAgICAgICBpZiAoYnJvd3Nlci5zYWZhcmkpXG4gICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IG51bGwpO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4ob3JpZ2luKSB7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IERhdGUubm93KCk7XG4gICAgfVxuICAgIGVuc3VyZUhhbmRsZXJzKHZpZXcsIHBsdWdpbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgaGFuZGxlcnM7XG4gICAgICAgIHRoaXMuY3VzdG9tSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHBsdWdpbnMpXG4gICAgICAgICAgICBpZiAoaGFuZGxlcnMgPSAoX2EgPSBwbHVnaW4udXBkYXRlKHZpZXcpLnNwZWMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kb21FdmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b21IYW5kbGVycy5wdXNoKHsgcGx1Z2luOiBwbHVnaW4udmFsdWUsIGhhbmRsZXJzIH0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHR5cGUgaW4gaGFuZGxlcnMpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRFdmVudHMuaW5kZXhPZih0eXBlKSA8IDAgJiYgdHlwZSAhPSBcInNjcm9sbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnRCZWxvbmdzVG9FZGl0b3IodmlldywgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucnVuQ3VzdG9tSGFuZGxlcnModHlwZSwgdmlldywgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcnVuQ3VzdG9tSGFuZGxlcnModHlwZSwgdmlldywgZXZlbnQpIHtcbiAgICAgICAgZm9yIChsZXQgc2V0IG9mIHRoaXMuY3VzdG9tSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyID0gc2V0LmhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5jYWxsKHNldC5wbHVnaW4sIGV2ZW50LCB2aWV3KSB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBydW5TY3JvbGxIYW5kbGVycyh2aWV3LCBldmVudCkge1xuICAgICAgICB0aGlzLmxhc3RTY3JvbGxUb3AgPSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3A7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbExlZnQgPSB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0O1xuICAgICAgICBmb3IgKGxldCBzZXQgb2YgdGhpcy5jdXN0b21IYW5kbGVycykge1xuICAgICAgICAgICAgbGV0IGhhbmRsZXIgPSBzZXQuaGFuZGxlcnMuc2Nyb2xsO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwoc2V0LnBsdWdpbiwgZXZlbnQsIHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGtleWRvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgLy8gTXVzdCBhbHdheXMgcnVuLCBldmVuIGlmIGEgY3VzdG9tIGhhbmRsZXIgaGFuZGxlZCB0aGUgZXZlbnRcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgICAgIHRoaXMubGFzdEtleVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSA5ICYmIERhdGUubm93KCkgPCB0aGlzLmxhc3RFc2NQcmVzcyArIDIwMDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gQ2hyb21lIGZvciBBbmRyb2lkIHVzdWFsbHkgZG9lc24ndCBmaXJlIHByb3BlciBrZXkgZXZlbnRzLCBidXRcbiAgICAgICAgLy8gb2NjYXNpb25hbGx5IGRvZXMsIHVzdWFsbHkgc3Vycm91bmRlZCBieSBhIGJ1bmNoIG9mIGNvbXBsaWNhdGVkXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIGNoYW5nZXMuIFdoZW4gYW4gZW50ZXIgb3IgYmFja3NwYWNlIGtleSBldmVudCBpc1xuICAgICAgICAvLyBzZWVuLCBob2xkIG9mZiBvbiBoYW5kbGluZyBET00gZXZlbnRzIGZvciBhIGJpdCwgYW5kIHRoZW5cbiAgICAgICAgLy8gZGlzcGF0Y2ggaXQuXG4gICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgIWV2ZW50LnN5bnRoZXRpYyAmJlxuICAgICAgICAgICAgKGV2ZW50LmtleUNvZGUgPT0gMTMgfHwgZXZlbnQua2V5Q29kZSA9PSA4KSkge1xuICAgICAgICAgICAgdmlldy5vYnNlcnZlci5kZWxheUFuZHJvaWRLZXkoZXZlbnQua2V5LCBldmVudC5rZXlDb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgRW50ZXIgb24gaU9TIG1ha2VzIHRoZVxuICAgICAgICAvLyB2aXJ0dWFsIGtleWJvYXJkIGdldCBzdHVjayBpbiB0aGUgd3JvbmcgKGxvd2VyY2FzZSlcbiAgICAgICAgLy8gc3RhdGUuIFNvIHdlIGxldCBpdCBnbyB0aHJvdWdoLCBhbmQgdGhlbiwgaW5cbiAgICAgICAgLy8gYXBwbHlET01DaGFuZ2UsIG5vdGlmeSBrZXkgaGFuZGxlcnMgb2YgaXQgYW5kIHJlc2V0IHRvXG4gICAgICAgIC8vIHRoZSBzdGF0ZSB0aGV5IHByb2R1Y2UuXG4gICAgICAgIGxldCBwZW5kaW5nO1xuICAgICAgICBpZiAoYnJvd3Nlci5pb3MgJiYgIWV2ZW50LnN5bnRoZXRpYyAmJiAhZXZlbnQuYWx0S2V5ICYmICFldmVudC5tZXRhS2V5ICYmXG4gICAgICAgICAgICAoKHBlbmRpbmcgPSBQZW5kaW5nS2V5cy5maW5kKGtleSA9PiBrZXkua2V5Q29kZSA9PSBldmVudC5rZXlDb2RlKSkgJiYgIWV2ZW50LmN0cmxLZXkgfHxcbiAgICAgICAgICAgICAgICBFbWFjc3lQZW5kaW5nS2V5cy5pbmRleE9mKGV2ZW50LmtleSkgPiAtMSAmJiBldmVudC5jdHJsS2V5ICYmICFldmVudC5zaGlmdEtleSkpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHBlbmRpbmcgfHwgZXZlbnQ7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZmx1c2hJT1NLZXkodmlldyksIDI1MCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZsdXNoSU9TS2V5KHZpZXcpIHtcbiAgICAgICAgbGV0IGtleSA9IHRoaXMucGVuZGluZ0lPU0tleTtcbiAgICAgICAgaWYgKCFrZXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwga2V5LmtleSwga2V5LmtleUNvZGUpO1xuICAgIH1cbiAgICBpZ25vcmVEdXJpbmdDb21wb3NpdGlvbihldmVudCkge1xuICAgICAgICBpZiAoIS9ea2V5Ly50ZXN0KGV2ZW50LnR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIFNlZSBodHRwczovL3d3dy5zdHVtLmRlLzIwMTYvMDYvMjQvaGFuZGxpbmctaW1lLWV2ZW50cy1pbi1qYXZhc2NyaXB0Ly5cbiAgICAgICAgLy8gT24gc29tZSBpbnB1dCBtZXRob2QgZWRpdG9ycyAoSU1FcyksIHRoZSBFbnRlciBrZXkgaXMgdXNlZCB0b1xuICAgICAgICAvLyBjb25maXJtIGNoYXJhY3RlciBzZWxlY3Rpb24uIE9uIFNhZmFyaSwgd2hlbiBFbnRlciBpcyBwcmVzc2VkLFxuICAgICAgICAvLyBjb21wb3NpdGlvbmVuZCBhbmQga2V5ZG93biBldmVudHMgYXJlIHNvbWV0aW1lcyBlbWl0dGVkIGluIHRoZVxuICAgICAgICAvLyB3cm9uZyBvcmRlci4gVGhlIGtleSBldmVudCBzaG91bGQgc3RpbGwgYmUgaWdub3JlZCwgZXZlbiB3aGVuXG4gICAgICAgIC8vIGl0IGhhcHBlbnMgYWZ0ZXIgdGhlIGNvbXBvc2l0aW9uZW5kIGV2ZW50LlxuICAgICAgICBpZiAoYnJvd3Nlci5zYWZhcmkgJiYgIWJyb3dzZXIuaW9zICYmIERhdGUubm93KCkgLSB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA8IDEwMCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtdXN0Rmx1c2hPYnNlcnZlcihldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQudHlwZSA9PSBcImtleWRvd25cIiAmJiBldmVudC5rZXlDb2RlICE9IDIyOTtcbiAgICB9XG4gICAgc3RhcnRNb3VzZVNlbGVjdGlvbihtb3VzZVNlbGVjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uID0gbW91c2VTZWxlY3Rpb247XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgfVxufVxuY29uc3QgUGVuZGluZ0tleXMgPSBbXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIGtleUNvZGU6IDgsIGlucHV0VHlwZTogXCJkZWxldGVDb250ZW50QmFja3dhcmRcIiB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIGtleUNvZGU6IDEzLCBpbnB1dFR5cGU6IFwiaW5zZXJ0UGFyYWdyYXBoXCIgfSxcbiAgICB7IGtleTogXCJEZWxldGVcIiwga2V5Q29kZTogNDYsIGlucHV0VHlwZTogXCJkZWxldGVDb250ZW50Rm9yd2FyZFwiIH1cbl07XG5jb25zdCBFbWFjc3lQZW5kaW5nS2V5cyA9IFwiZHRoa29cIjtcbi8vIEtleSBjb2RlcyBmb3IgbW9kaWZpZXIga2V5c1xuY29uc3QgbW9kaWZpZXJDb2RlcyA9IFsxNiwgMTcsIDE4LCAyMCwgOTEsIDkyLCAyMjQsIDIyNV07XG5mdW5jdGlvbiBkcmFnU2Nyb2xsU3BlZWQoZGlzdCkge1xuICAgIHJldHVybiBkaXN0ICogMC43ICsgODtcbn1cbmNsYXNzIE1vdXNlU2VsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzdGFydEV2ZW50LCBzdHlsZSwgbXVzdFNlbGVjdCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIHRoaXMubXVzdFNlbGVjdCA9IG11c3RTZWxlY3Q7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0RXZlbnQgPSBzdGFydEV2ZW50O1xuICAgICAgICB0aGlzLnNjcm9sbFBhcmVudCA9IHNjcm9sbGFibGVQYXJlbnQodmlldy5jb250ZW50RE9NKTtcbiAgICAgICAgbGV0IGRvYyA9IHZpZXcuY29udGVudERPTS5vd25lckRvY3VtZW50O1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUgPSB0aGlzLm1vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwID0gdGhpcy51cC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5leHRlbmQgPSBzdGFydEV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICB0aGlzLm11bHRpcGxlID0gdmlldy5zdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5hbGxvd011bHRpcGxlU2VsZWN0aW9ucykgJiYgYWRkc1NlbGVjdGlvblJhbmdlKHZpZXcsIHN0YXJ0RXZlbnQpO1xuICAgICAgICB0aGlzLmRyYWdNb3ZlID0gZHJhZ01vdmVzU2VsZWN0aW9uKHZpZXcsIHN0YXJ0RXZlbnQpO1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gaXNJblByaW1hcnlTZWxlY3Rpb24odmlldywgc3RhcnRFdmVudCkgJiYgZ2V0Q2xpY2tUeXBlKHN0YXJ0RXZlbnQpID09IDEgPyBudWxsIDogZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0KGV2ZW50KSB7XG4gICAgICAgIC8vIFdoZW4gY2xpY2tpbmcgb3V0c2lkZSBvZiB0aGUgc2VsZWN0aW9uLCBpbW1lZGlhdGVseSBhcHBseSB0aGVcbiAgICAgICAgLy8gZWZmZWN0IG9mIHN0YXJ0aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3QoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmUoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9ucyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyAhPT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50ID0gZXZlbnQpO1xuICAgICAgICBsZXQgc3ggPSAwLCBzeSA9IDA7XG4gICAgICAgIGxldCByZWN0ID0gKChfYSA9IHRoaXMuc2Nyb2xsUGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpXG4gICAgICAgICAgICB8fCB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IHRoaXMudmlldy53aW4uaW5uZXJXaWR0aCwgYm90dG9tOiB0aGlzLnZpZXcud2luLmlubmVySGVpZ2h0IH07XG4gICAgICAgIGlmIChldmVudC5jbGllbnRYIDw9IHJlY3QubGVmdClcbiAgICAgICAgICAgIHN4ID0gLWRyYWdTY3JvbGxTcGVlZChyZWN0LmxlZnQgLSBldmVudC5jbGllbnRYKTtcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuY2xpZW50WCA+PSByZWN0LnJpZ2h0KVxuICAgICAgICAgICAgc3ggPSBkcmFnU2Nyb2xsU3BlZWQoZXZlbnQuY2xpZW50WCAtIHJlY3QucmlnaHQpO1xuICAgICAgICBpZiAoZXZlbnQuY2xpZW50WSA8PSByZWN0LnRvcClcbiAgICAgICAgICAgIHN5ID0gLWRyYWdTY3JvbGxTcGVlZChyZWN0LnRvcCAtIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICBlbHNlIGlmIChldmVudC5jbGllbnRZID49IHJlY3QuYm90dG9tKVxuICAgICAgICAgICAgc3kgPSBkcmFnU2Nyb2xsU3BlZWQoZXZlbnQuY2xpZW50WSAtIHJlY3QuYm90dG9tKTtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxTcGVlZChzeCwgc3kpO1xuICAgIH1cbiAgICB1cChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpO1xuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxTcGVlZCgwLCAwKTtcbiAgICAgICAgbGV0IGRvYyA9IHRoaXMudmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubW91c2VTZWxlY3Rpb24gPSBudWxsO1xuICAgIH1cbiAgICBzZXRTY3JvbGxTcGVlZChzeCwgc3kpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxTcGVlZCA9IHsgeDogc3gsIHk6IHN5IH07XG4gICAgICAgIGlmIChzeCB8fCBzeSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsaW5nIDwgMClcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IHNldEludGVydmFsKCgpID0+IHRoaXMuc2Nyb2xsKCksIDUwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjcm9sbGluZyA+IC0xKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuc2Nyb2xsaW5nKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2Nyb2xsKCkge1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQgKz0gdGhpcy5zY3JvbGxTcGVlZC54O1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wICs9IHRoaXMuc2Nyb2xsU3BlZWQueTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlldy53aW4uc2Nyb2xsQnkodGhpcy5zY3JvbGxTcGVlZC54LCB0aGlzLnNjcm9sbFNwZWVkLnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50KTtcbiAgICB9XG4gICAgc2VsZWN0KGV2ZW50KSB7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLnN0eWxlLmdldChldmVudCwgdGhpcy5leHRlbmQsIHRoaXMubXVsdGlwbGUpO1xuICAgICAgICBpZiAodGhpcy5tdXN0U2VsZWN0IHx8ICFzZWxlY3Rpb24uZXEodGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbikgfHxcbiAgICAgICAgICAgIHNlbGVjdGlvbi5tYWluLmFzc29jICE9IHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hc3NvYylcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3QucG9pbnRlclwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tdXN0U2VsZWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkICYmIHRoaXMuZHJhZ2dpbmcpXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZy5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICBpZiAodGhpcy5zdHlsZS51cGRhdGUodXBkYXRlKSlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpLCAyMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkc1NlbGVjdGlvblJhbmdlKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IGZhY2V0ID0gdmlldy5zdGF0ZS5mYWNldChjbGlja0FkZHNTZWxlY3Rpb25SYW5nZSk7XG4gICAgcmV0dXJuIGZhY2V0Lmxlbmd0aCA/IGZhY2V0WzBdKGV2ZW50KSA6IGJyb3dzZXIubWFjID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXk7XG59XG5mdW5jdGlvbiBkcmFnTW92ZXNTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgZmFjZXQgPSB2aWV3LnN0YXRlLmZhY2V0KGRyYWdNb3Zlc1NlbGVjdGlvbiQxKTtcbiAgICByZXR1cm4gZmFjZXQubGVuZ3RoID8gZmFjZXRbMF0oZXZlbnQpIDogYnJvd3Nlci5tYWMgPyAhZXZlbnQuYWx0S2V5IDogIWV2ZW50LmN0cmxLZXk7XG59XG5mdW5jdGlvbiBpc0luUHJpbWFyeVNlbGVjdGlvbih2aWV3LCBldmVudCkge1xuICAgIGxldCB7IG1haW4gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChtYWluLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gT24gYm91bmRhcnkgY2xpY2tzLCBjaGVjayB3aGV0aGVyIHRoZSBjb29yZGluYXRlcyBhcmUgaW5zaWRlIHRoZVxuICAgIC8vIHNlbGVjdGlvbidzIGNsaWVudCByZWN0YW5nbGVzXG4gICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgIGlmICghc2VsIHx8IHNlbC5yYW5nZUNvdW50ID09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCByZWN0cyA9IHNlbC5nZXRSYW5nZUF0KDApLmdldENsaWVudFJlY3RzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICBpZiAocmVjdC5sZWZ0IDw9IGV2ZW50LmNsaWVudFggJiYgcmVjdC5yaWdodCA+PSBldmVudC5jbGllbnRYICYmXG4gICAgICAgICAgICByZWN0LnRvcCA8PSBldmVudC5jbGllbnRZICYmIHJlY3QuYm90dG9tID49IGV2ZW50LmNsaWVudFkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9FZGl0b3IodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LmJ1YmJsZXMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgbm9kZSA9IGV2ZW50LnRhcmdldCwgY1ZpZXc7IG5vZGUgIT0gdmlldy5jb250ZW50RE9NOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSB8fCAoKGNWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5vZGUpKSAmJiBjVmlldy5pZ25vcmVFdmVudChldmVudCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgaGFuZGxlcnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IGhhbmRsZXJPcHRpb25zID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG4vLyBUaGlzIGlzIHZlcnkgY3J1ZGUsIGJ1dCB1bmZvcnR1bmF0ZWx5IGJvdGggdGhlc2UgYnJvd3NlcnMgX3ByZXRlbmRfXG4vLyB0aGF0IHRoZXkgaGF2ZSBhIGNsaXBib2FyZCBBUElcdTIwMTRhbGwgdGhlIG9iamVjdHMgYW5kIG1ldGhvZHMgYXJlXG4vLyB0aGVyZSwgdGhleSBqdXN0IGRvbid0IHdvcmssIGFuZCB0aGV5IGFyZSBoYXJkIHRvIHRlc3QuXG5jb25zdCBicm9rZW5DbGlwYm9hcmRBUEkgPSAoYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPCAxNSkgfHxcbiAgICAoYnJvd3Nlci5pb3MgJiYgYnJvd3Nlci53ZWJraXRfdmVyc2lvbiA8IDYwNCk7XG5mdW5jdGlvbiBjYXB0dXJlUGFzdGUodmlldykge1xuICAgIGxldCBwYXJlbnQgPSB2aWV3LmRvbS5wYXJlbnROb2RlO1xuICAgIGlmICghcGFyZW50KVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHRhcmdldCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIikpO1xuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlKCk7XG4gICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnZhbHVlKTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBkb1Bhc3RlKHZpZXcsIGlucHV0KSB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGNoYW5nZXMsIGkgPSAxLCB0ZXh0ID0gc3RhdGUudG9UZXh0KGlucHV0KTtcbiAgICBsZXQgYnlMaW5lID0gdGV4dC5saW5lcyA9PSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aDtcbiAgICBsZXQgbGluZXdpc2UgPSBsYXN0TGluZXdpc2VDb3B5ICE9IG51bGwgJiYgc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5ldmVyeShyID0+IHIuZW1wdHkpICYmIGxhc3RMaW5ld2lzZUNvcHkgPT0gdGV4dC50b1N0cmluZygpO1xuICAgIGlmIChsaW5ld2lzZSkge1xuICAgICAgICBsZXQgbGFzdExpbmUgPSAtMTtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pO1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA9PSBsYXN0TGluZSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICAgICAgbGFzdExpbmUgPSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgaW5zZXJ0ID0gc3RhdGUudG9UZXh0KChieUxpbmUgPyB0ZXh0LmxpbmUoaSsrKS50ZXh0IDogaW5wdXQpICsgc3RhdGUubGluZUJyZWFrKTtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogbGluZS5mcm9tLCBpbnNlcnQgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgaW5zZXJ0Lmxlbmd0aCkgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJ5TGluZSkge1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRleHQubGluZShpKyspO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tLCB0bzogcmFuZ2UudG8sIGluc2VydDogbGluZS50ZXh0IH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIGxpbmUubGVuZ3RoKSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKHRleHQpO1xuICAgIH1cbiAgICB2aWV3LmRpc3BhdGNoKGNoYW5nZXMsIHtcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnBhc3RlXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgfSk7XG59XG5oYW5kbGVycy5rZXlkb3duID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdFwiKTtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNylcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmxhc3RFc2NQcmVzcyA9IERhdGUubm93KCk7XG4gICAgZWxzZSBpZiAobW9kaWZpZXJDb2Rlcy5pbmRleE9mKGV2ZW50LmtleUNvZGUpIDwgMClcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmxhc3RFc2NQcmVzcyA9IDA7XG59O1xuaGFuZGxlcnMudG91Y2hzdGFydCA9ICh2aWV3LCBlKSA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RUb3VjaFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3QucG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy50b3VjaG1vdmUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0LnBvaW50ZXJcIik7XG59O1xuaGFuZGxlck9wdGlvbnMudG91Y2hzdGFydCA9IGhhbmRsZXJPcHRpb25zLnRvdWNobW92ZSA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuaGFuZGxlcnMubW91c2Vkb3duID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgdmlldy5vYnNlcnZlci5mbHVzaCgpO1xuICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA+IERhdGUubm93KCkgLSAyMDAwKVxuICAgICAgICByZXR1cm47IC8vIElnbm9yZSB0b3VjaCBpbnRlcmFjdGlvblxuICAgIGxldCBzdHlsZSA9IG51bGw7XG4gICAgZm9yIChsZXQgbWFrZVN0eWxlIG9mIHZpZXcuc3RhdGUuZmFjZXQobW91c2VTZWxlY3Rpb25TdHlsZSkpIHtcbiAgICAgICAgc3R5bGUgPSBtYWtlU3R5bGUodmlldywgZXZlbnQpO1xuICAgICAgICBpZiAoc3R5bGUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFzdHlsZSAmJiBldmVudC5idXR0b24gPT0gMClcbiAgICAgICAgc3R5bGUgPSBiYXNpY01vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50KTtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgbGV0IG11c3RGb2N1cyA9IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50ICE9IHZpZXcuY29udGVudERPTTtcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLnN0YXJ0TW91c2VTZWxlY3Rpb24obmV3IE1vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50LCBzdHlsZSwgbXVzdEZvY3VzKSk7XG4gICAgICAgIGlmIChtdXN0Rm9jdXMpXG4gICAgICAgICAgICB2aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiBmb2N1c1ByZXZlbnRTY3JvbGwodmlldy5jb250ZW50RE9NKSk7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUubW91c2VTZWxlY3Rpb24uc3RhcnQoZXZlbnQpO1xuICAgIH1cbn07XG5mdW5jdGlvbiByYW5nZUZvckNsaWNrKHZpZXcsIHBvcywgYmlhcywgdHlwZSkge1xuICAgIGlmICh0eXBlID09IDEpIHsgLy8gU2luZ2xlIGNsaWNrXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgYmlhcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT0gMikgeyAvLyBEb3VibGUgY2xpY2tcbiAgICAgICAgcmV0dXJuIGdyb3VwQXQodmlldy5zdGF0ZSwgcG9zLCBiaWFzKTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIFRyaXBsZSBjbGlja1xuICAgICAgICBsZXQgdmlzdWFsID0gTGluZVZpZXcuZmluZCh2aWV3LmRvY1ZpZXcsIHBvcyksIGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQodmlzdWFsID8gdmlzdWFsLnBvc0F0RW5kIDogcG9zKTtcbiAgICAgICAgbGV0IGZyb20gPSB2aXN1YWwgPyB2aXN1YWwucG9zQXRTdGFydCA6IGxpbmUuZnJvbSwgdG8gPSB2aXN1YWwgPyB2aXN1YWwucG9zQXRFbmQgOiBsaW5lLnRvO1xuICAgICAgICBpZiAodG8gPCB2aWV3LnN0YXRlLmRvYy5sZW5ndGggJiYgdG8gPT0gbGluZS50bylcbiAgICAgICAgICAgIHRvKys7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbmxldCBpbnNpZGVZID0gKHksIHJlY3QpID0+IHkgPj0gcmVjdC50b3AgJiYgeSA8PSByZWN0LmJvdHRvbTtcbmxldCBpbnNpZGUgPSAoeCwgeSwgcmVjdCkgPT4gaW5zaWRlWSh5LCByZWN0KSAmJiB4ID49IHJlY3QubGVmdCAmJiB4IDw9IHJlY3QucmlnaHQ7XG4vLyBUcnkgdG8gZGV0ZXJtaW5lLCBmb3IgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLCBhc3NvY2lhdGVkIHdpdGggdGhlXG4vLyBnaXZlbiBwb3NpdGlvbiwgd2hldGhlciB0aGV5IGFyZSByZWxhdGVkIHRvIHRoZSBlbGVtZW50IGJlZm9yZSBvclxuLy8gdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIHBvc2l0aW9uLlxuZnVuY3Rpb24gZmluZFBvc2l0aW9uU2lkZSh2aWV3LCBwb3MsIHgsIHkpIHtcbiAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBwb3MpO1xuICAgIGlmICghbGluZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgbGV0IG9mZiA9IHBvcyAtIGxpbmUucG9zQXRTdGFydDtcbiAgICAvLyBMaW5lIGJvdW5kYXJpZXMgcG9pbnQgaW50byB0aGUgbGluZVxuICAgIGlmIChvZmYgPT0gMClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKG9mZiA9PSBsaW5lLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIC8vIFBvc2l0aW9ucyBvbiB0b3Agb2YgYW4gZWxlbWVudCBwb2ludCBhdCB0aGF0IGVsZW1lbnRcbiAgICBsZXQgYmVmb3JlID0gbGluZS5jb29yZHNBdChvZmYsIC0xKTtcbiAgICBpZiAoYmVmb3JlICYmIGluc2lkZSh4LCB5LCBiZWZvcmUpKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgbGV0IGFmdGVyID0gbGluZS5jb29yZHNBdChvZmYsIDEpO1xuICAgIGlmIChhZnRlciAmJiBpbnNpZGUoeCwgeSwgYWZ0ZXIpKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgbGluZSB3cmFwIHBvaW50LiBQaWNrIGJlZm9yZSBpZiB0aGUgcG9pbnQgaXNcbiAgICAvLyBiZXNpZGUgaXQuXG4gICAgcmV0dXJuIGJlZm9yZSAmJiBpbnNpZGVZKHksIGJlZm9yZSkgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBxdWVyeVBvcyh2aWV3LCBldmVudCkge1xuICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSk7XG4gICAgcmV0dXJuIHsgcG9zLCBiaWFzOiBmaW5kUG9zaXRpb25TaWRlKHZpZXcsIHBvcywgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSkgfTtcbn1cbmNvbnN0IEJhZE1vdXNlRGV0YWlsID0gYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTE7XG5sZXQgbGFzdE1vdXNlRG93biA9IG51bGwsIGxhc3RNb3VzZURvd25Db3VudCA9IDAsIGxhc3RNb3VzZURvd25UaW1lID0gMDtcbmZ1bmN0aW9uIGdldENsaWNrVHlwZShldmVudCkge1xuICAgIGlmICghQmFkTW91c2VEZXRhaWwpXG4gICAgICAgIHJldHVybiBldmVudC5kZXRhaWw7XG4gICAgbGV0IGxhc3QgPSBsYXN0TW91c2VEb3duLCBsYXN0VGltZSA9IGxhc3RNb3VzZURvd25UaW1lO1xuICAgIGxhc3RNb3VzZURvd24gPSBldmVudDtcbiAgICBsYXN0TW91c2VEb3duVGltZSA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIGxhc3RNb3VzZURvd25Db3VudCA9ICFsYXN0IHx8IChsYXN0VGltZSA+IERhdGUubm93KCkgLSA0MDAgJiYgTWF0aC5hYnMobGFzdC5jbGllbnRYIC0gZXZlbnQuY2xpZW50WCkgPCAyICYmXG4gICAgICAgIE1hdGguYWJzKGxhc3QuY2xpZW50WSAtIGV2ZW50LmNsaWVudFkpIDwgMikgPyAobGFzdE1vdXNlRG93bkNvdW50ICsgMSkgJSAzIDogMTtcbn1cbmZ1bmN0aW9uIGJhc2ljTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSBxdWVyeVBvcyh2aWV3LCBldmVudCksIHR5cGUgPSBnZXRDbGlja1R5cGUoZXZlbnQpO1xuICAgIGxldCBzdGFydFNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0LnBvcyA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyhzdGFydC5wb3MpO1xuICAgICAgICAgICAgICAgIHN0YXJ0U2VsID0gc3RhcnRTZWwubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KGV2ZW50LCBleHRlbmQsIG11bHRpcGxlKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gcXVlcnlQb3ModmlldywgZXZlbnQpO1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VGb3JDbGljayh2aWV3LCBjdXIucG9zLCBjdXIuYmlhcywgdHlwZSk7XG4gICAgICAgICAgICBpZiAoc3RhcnQucG9zICE9IGN1ci5wb3MgJiYgIWV4dGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydFJhbmdlID0gcmFuZ2VGb3JDbGljayh2aWV3LCBzdGFydC5wb3MsIHN0YXJ0LmJpYXMsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5taW4oc3RhcnRSYW5nZS5mcm9tLCByYW5nZS5mcm9tKSwgdG8gPSBNYXRoLm1heChzdGFydFJhbmdlLnRvLCByYW5nZS50byk7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBmcm9tIDwgcmFuZ2UuZnJvbSA/IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0bykgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodG8sIGZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWwucmVwbGFjZVJhbmdlKHN0YXJ0U2VsLm1haW4uZXh0ZW5kKHJhbmdlLmZyb20sIHJhbmdlLnRvKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChtdWx0aXBsZSAmJiBzdGFydFNlbC5yYW5nZXMubGVuZ3RoID4gMSAmJiBzdGFydFNlbC5yYW5nZXMuc29tZShyID0+IHIuZXEocmFuZ2UpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlUmFuZ2Uoc3RhcnRTZWwsIHJhbmdlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG11bHRpcGxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW3JhbmdlXSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlUmFuZ2Uoc2VsLCByYW5nZSkge1xuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGlmIChzZWwucmFuZ2VzW2ldLmVxKHJhbmdlKSlcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbC5yYW5nZXMuc2xpY2UoMCwgaSkuY29uY2F0KHNlbC5yYW5nZXMuc2xpY2UoaSArIDEpKSwgc2VsLm1haW5JbmRleCA9PSBpID8gMCA6IHNlbC5tYWluSW5kZXggLSAoc2VsLm1haW5JbmRleCA+IGkgPyAxIDogMCkpO1xuICAgIH1cbn1cbmhhbmRsZXJzLmRyYWdzdGFydCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGxldCB7IHNlbGVjdGlvbjogeyBtYWluIH0gfSA9IHZpZXcuc3RhdGU7XG4gICAgbGV0IHsgbW91c2VTZWxlY3Rpb24gfSA9IHZpZXcuaW5wdXRTdGF0ZTtcbiAgICBpZiAobW91c2VTZWxlY3Rpb24pXG4gICAgICAgIG1vdXNlU2VsZWN0aW9uLmRyYWdnaW5nID0gbWFpbjtcbiAgICBpZiAoZXZlbnQuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiVGV4dFwiLCB2aWV3LnN0YXRlLnNsaWNlRG9jKG1haW4uZnJvbSwgbWFpbi50bykpO1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcbiAgICB9XG59O1xuZnVuY3Rpb24gZHJvcFRleHQodmlldywgZXZlbnQsIHRleHQsIGRpcmVjdCkge1xuICAgIGlmICghdGV4dClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBkcm9wUG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbGV0IHsgbW91c2VTZWxlY3Rpb24gfSA9IHZpZXcuaW5wdXRTdGF0ZTtcbiAgICBsZXQgZGVsID0gZGlyZWN0ICYmIG1vdXNlU2VsZWN0aW9uICYmIG1vdXNlU2VsZWN0aW9uLmRyYWdnaW5nICYmIG1vdXNlU2VsZWN0aW9uLmRyYWdNb3ZlID9cbiAgICAgICAgeyBmcm9tOiBtb3VzZVNlbGVjdGlvbi5kcmFnZ2luZy5mcm9tLCB0bzogbW91c2VTZWxlY3Rpb24uZHJhZ2dpbmcudG8gfSA6IG51bGw7XG4gICAgbGV0IGlucyA9IHsgZnJvbTogZHJvcFBvcywgaW5zZXJ0OiB0ZXh0IH07XG4gICAgbGV0IGNoYW5nZXMgPSB2aWV3LnN0YXRlLmNoYW5nZXMoZGVsID8gW2RlbCwgaW5zXSA6IGlucyk7XG4gICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiBjaGFuZ2VzLm1hcFBvcyhkcm9wUG9zLCAtMSksIGhlYWQ6IGNoYW5nZXMubWFwUG9zKGRyb3BQb3MsIDEpIH0sXG4gICAgICAgIHVzZXJFdmVudDogZGVsID8gXCJtb3ZlLmRyb3BcIiA6IFwiaW5wdXQuZHJvcFwiXG4gICAgfSk7XG59XG5oYW5kbGVycy5kcm9wID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbGV0IGZpbGVzID0gZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgIGlmIChmaWxlcyAmJiBmaWxlcy5sZW5ndGgpIHsgLy8gRm9yIGEgZmlsZSBkcm9wLCByZWFkIHRoZSBmaWxlJ3MgdGV4dC5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IHRleHQgPSBBcnJheShmaWxlcy5sZW5ndGgpLCByZWFkID0gMDtcbiAgICAgICAgbGV0IGZpbmlzaEZpbGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoKytyZWFkID09IGZpbGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBkcm9wVGV4dCh2aWV3LCBldmVudCwgdGV4dC5maWx0ZXIocyA9PiBzICE9IG51bGwpLmpvaW4odmlldy5zdGF0ZS5saW5lQnJlYWspLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcjtcbiAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gZmluaXNoRmlsZTtcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEvW1xceDAwLVxceDA4XFx4MGUtXFx4MWZdezJ9Ly50ZXN0KHJlYWRlci5yZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICB0ZXh0W2ldID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgICAgICBmaW5pc2hGaWxlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkcm9wVGV4dCh2aWV3LCBldmVudCwgZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJUZXh0XCIpLCB0cnVlKTtcbiAgICB9XG59O1xuaGFuZGxlcnMucGFzdGUgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmlldy5vYnNlcnZlci5mbHVzaCgpO1xuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZG9QYXN0ZSh2aWV3LCBkYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVQYXN0ZSh2aWV3KTtcbiAgICB9XG59O1xuZnVuY3Rpb24gY2FwdHVyZUNvcHkodmlldywgdGV4dCkge1xuICAgIC8vIFRoZSBleHRyYSB3cmFwcGVyIGlzIHNvbWVob3cgbmVjZXNzYXJ5IG9uIElFL0VkZ2UgdG8gcHJldmVudCB0aGVcbiAgICAvLyBjb250ZW50IGZyb20gYmVpbmcgbWFuZ2xlZCB3aGVuIGl0IGlzIHB1dCBvbnRvIHRoZSBjbGlwYm9hcmRcbiAgICBsZXQgcGFyZW50ID0gdmlldy5kb20ucGFyZW50Tm9kZTtcbiAgICBpZiAoIXBhcmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB0YXJnZXQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpKTtcbiAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgdGFyZ2V0LnZhbHVlID0gdGV4dDtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICB0YXJnZXQuc2VsZWN0aW9uRW5kID0gdGV4dC5sZW5ndGg7XG4gICAgdGFyZ2V0LnNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gY29waWVkUmFuZ2Uoc3RhdGUpIHtcbiAgICBsZXQgY29udGVudCA9IFtdLCByYW5nZXMgPSBbXSwgbGluZXdpc2UgPSBmYWxzZTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKVxuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBjb250ZW50LnB1c2goc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgfVxuICAgIGlmICghY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgLy8gTm90aGluZyBzZWxlY3RlZCwgZG8gYSBsaW5lLXdpc2UgY29weVxuICAgICAgICBsZXQgdXB0byA9IC0xO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20gfSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZnJvbSk7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPiB1cHRvKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGxpbmUudGV4dCk7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCBsaW5lLnRvICsgMSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cHRvID0gbGluZS5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGluZXdpc2UgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4geyB0ZXh0OiBjb250ZW50LmpvaW4oc3RhdGUubGluZUJyZWFrKSwgcmFuZ2VzLCBsaW5ld2lzZSB9O1xufVxubGV0IGxhc3RMaW5ld2lzZUNvcHkgPSBudWxsO1xuaGFuZGxlcnMuY29weSA9IGhhbmRsZXJzLmN1dCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGxldCB7IHRleHQsIHJhbmdlcywgbGluZXdpc2UgfSA9IGNvcGllZFJhbmdlKHZpZXcuc3RhdGUpO1xuICAgIGlmICghdGV4dCAmJiAhbGluZXdpc2UpXG4gICAgICAgIHJldHVybjtcbiAgICBsYXN0TGluZXdpc2VDb3B5ID0gbGluZXdpc2UgPyB0ZXh0IDogbnVsbDtcbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgIGRhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgdGV4dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYXB0dXJlQ29weSh2aWV3LCB0ZXh0KTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJjdXRcIiAmJiAhdmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBjaGFuZ2VzOiByYW5nZXMsXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgICAgIHVzZXJFdmVudDogXCJkZWxldGUuY3V0XCJcbiAgICAgICAgfSk7XG59O1xuY29uc3QgaXNGb2N1c0NoYW5nZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuZnVuY3Rpb24gZm9jdXNDaGFuZ2VUcmFuc2FjdGlvbihzdGF0ZSwgZm9jdXMpIHtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IGdldEVmZmVjdCBvZiBzdGF0ZS5mYWNldChmb2N1c0NoYW5nZUVmZmVjdCkpIHtcbiAgICAgICAgbGV0IGVmZmVjdCA9IGdldEVmZmVjdChzdGF0ZSwgZm9jdXMpO1xuICAgICAgICBpZiAoZWZmZWN0KVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgfVxuICAgIHJldHVybiBlZmZlY3RzID8gc3RhdGUudXBkYXRlKHsgZWZmZWN0cywgYW5ub3RhdGlvbnM6IGlzRm9jdXNDaGFuZ2Uub2YodHJ1ZSkgfSkgOiBudWxsO1xufVxuZnVuY3Rpb24gdXBkYXRlRm9yRm9jdXNDaGFuZ2Uodmlldykge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsZXQgZm9jdXMgPSB2aWV3Lmhhc0ZvY3VzO1xuICAgICAgICBpZiAoZm9jdXMgIT0gdmlldy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCkge1xuICAgICAgICAgICAgbGV0IHRyID0gZm9jdXNDaGFuZ2VUcmFuc2FjdGlvbih2aWV3LnN0YXRlLCBmb2N1cyk7XG4gICAgICAgICAgICBpZiAodHIpXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGUoW10pO1xuICAgICAgICB9XG4gICAgfSwgMTApO1xufVxuaGFuZGxlcnMuZm9jdXMgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IERhdGUubm93KCk7XG4gICAgLy8gV2hlbiBmb2N1c2luZyByZXNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uLCBtb3ZlIGl0IGJhY2sgdG8gd2hlcmUgaXQgd2FzXG4gICAgaWYgKCF2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgJiYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsVG9wIHx8IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsTGVmdCkpIHtcbiAgICAgICAgdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wID0gdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxUb3A7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbExlZnQ7XG4gICAgfVxuICAgIHVwZGF0ZUZvckZvY3VzQ2hhbmdlKHZpZXcpO1xufTtcbmhhbmRsZXJzLmJsdXIgPSB2aWV3ID0+IHtcbiAgICB2aWV3Lm9ic2VydmVyLmNsZWFyU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KTtcbn07XG5oYW5kbGVycy5jb21wb3NpdGlvbnN0YXJ0ID0gaGFuZGxlcnMuY29tcG9zaXRpb251cGRhdGUgPSB2aWV3ID0+IHtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPT0gbnVsbClcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSB0cnVlO1xuICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCkge1xuICAgICAgICAvLyBGSVhNRSBwb3NzaWJseSBzZXQgYSB0aW1lb3V0IHRvIGNsZWFyIGl0IGFnYWluIG9uIEFuZHJvaWRcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IDA7XG4gICAgfVxufTtcbmhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IC0xO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkVuZGVkQXQgPSBEYXRlLm5vdygpO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gbnVsbDtcbiAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgYnJvd3Nlci5hbmRyb2lkKVxuICAgICAgICB2aWV3Lm9ic2VydmVyLmZsdXNoU29vbigpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyBGb3JjZSB0aGUgY29tcG9zaXRpb24gc3RhdGUgdG8gYmUgY2xlYXJlZCBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuXG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCAmJiB2aWV3LmRvY1ZpZXcuY29tcG9zaXRpb25EZWNvLnNpemUpXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZShbXSk7XG4gICAgfSwgNTApO1xufTtcbmhhbmRsZXJzLmNvbnRleHRtZW51ID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RDb250ZXh0TWVudSA9IERhdGUubm93KCk7XG59O1xuaGFuZGxlcnMuYmVmb3JlaW5wdXQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgLy8gQmVjYXVzZSBDaHJvbWUgQW5kcm9pZCBkb2Vzbid0IGZpcmUgdXNlZnVsIGtleSBldmVudHMsIHVzZVxuICAgIC8vIGJlZm9yZWlucHV0IHRvIGRldGVjdCBiYWNrc3BhY2UgKGFuZCBwb3NzaWJseSBlbnRlciBhbmQgZGVsZXRlLFxuICAgIC8vIGJ1dCB0aG9zZSB1c3VhbGx5IGRvbid0IGV2ZW4gc2VlbSB0byBmaXJlIGJlZm9yZWlucHV0IGV2ZW50cyBhdFxuICAgIC8vIHRoZSBtb21lbnQpIGFuZCBmYWtlIGEga2V5IGV2ZW50IGZvciBpdC5cbiAgICAvL1xuICAgIC8vIChwcmV2ZW50RGVmYXVsdCBvbiBiZWZvcmVpbnB1dCwgdGhvdWdoIHN1cHBvcnRlZCBpbiB0aGUgc3BlYyxcbiAgICAvLyBzZWVtcyB0byBkbyBub3RoaW5nIGF0IGFsbCBvbiBDaHJvbWUpLlxuICAgIGxldCBwZW5kaW5nO1xuICAgIGlmIChicm93c2VyLmNocm9tZSAmJiBicm93c2VyLmFuZHJvaWQgJiYgKHBlbmRpbmcgPSBQZW5kaW5nS2V5cy5maW5kKGtleSA9PiBrZXkuaW5wdXRUeXBlID09IGV2ZW50LmlucHV0VHlwZSkpKSB7XG4gICAgICAgIHZpZXcub2JzZXJ2ZXIuZGVsYXlBbmRyb2lkS2V5KHBlbmRpbmcua2V5LCBwZW5kaW5nLmtleUNvZGUpO1xuICAgICAgICBpZiAocGVuZGluZy5rZXkgPT0gXCJCYWNrc3BhY2VcIiB8fCBwZW5kaW5nLmtleSA9PSBcIkRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRWaWV3SGVpZ2h0ID0gKChfYSA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlaWdodCkgfHwgMDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBCYWNrc3BhY2luZyBuZWFyIHVuZWRpdGFibGUgbm9kZXMgb24gQ2hyb21lIEFuZHJvaWQgc29tZXRpbWVzXG4gICAgICAgICAgICAgICAgLy8gY2xvc2VzIHRoZSB2aXJ0dWFsIGtleWJvYXJkLiBUaGlzIHRyaWVzIHRvIGNydWRlbHkgZGV0ZWN0XG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhbmQgcmVmb2N1cyB0byBnZXQgaXQgYmFjay5cbiAgICAgICAgICAgICAgICBpZiAoKCgoX2EgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWlnaHQpIHx8IDApID4gc3RhcnRWaWV3SGVpZ2h0ICsgMTAgJiYgdmlldy5oYXNGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNvbnN0IHdyYXBwaW5nV2hpdGVTcGFjZSA9IFtcInByZS13cmFwXCIsIFwibm9ybWFsXCIsIFwicHJlLWxpbmVcIiwgXCJicmVhay1zcGFjZXNcIl07XG5jbGFzcyBIZWlnaHRPcmFjbGUge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVXcmFwcGluZykge1xuICAgICAgICB0aGlzLmxpbmVXcmFwcGluZyA9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5kb2MgPSBUZXh0LmVtcHR5O1xuICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gMTQ7XG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gNztcbiAgICAgICAgdGhpcy5saW5lTGVuZ3RoID0gMzA7XG4gICAgICAgIC8vIFVzZWQgdG8gdHJhY2ssIGR1cmluZyB1cGRhdGVIZWlnaHQsIGlmIGFueSBhY3R1YWwgaGVpZ2h0cyBjaGFuZ2VkXG4gICAgICAgIHRoaXMuaGVpZ2h0Q2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBoZWlnaHRGb3JHYXAoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGxpbmVzID0gdGhpcy5kb2MubGluZUF0KHRvKS5udW1iZXIgLSB0aGlzLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyICsgMTtcbiAgICAgICAgaWYgKHRoaXMubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgbGluZXMgKz0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKCgodG8gLSBmcm9tKSAtIChsaW5lcyAqIHRoaXMubGluZUxlbmd0aCAqIDAuNSkpIC8gdGhpcy5saW5lTGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVIZWlnaHQgKiBsaW5lcztcbiAgICB9XG4gICAgaGVpZ2h0Rm9yTGluZShsZW5ndGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpbmVXcmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIGxldCBsaW5lcyA9IDEgKyBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGxlbmd0aCAtIHRoaXMubGluZUxlbmd0aCkgLyAodGhpcy5saW5lTGVuZ3RoIC0gNSkpKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzICogdGhpcy5saW5lSGVpZ2h0O1xuICAgIH1cbiAgICBzZXREb2MoZG9jKSB7IHRoaXMuZG9jID0gZG9jOyByZXR1cm4gdGhpczsgfVxuICAgIG11c3RSZWZyZXNoRm9yV3JhcHBpbmcod2hpdGVTcGFjZSkge1xuICAgICAgICByZXR1cm4gKHdyYXBwaW5nV2hpdGVTcGFjZS5pbmRleE9mKHdoaXRlU3BhY2UpID4gLTEpICE9IHRoaXMubGluZVdyYXBwaW5nO1xuICAgIH1cbiAgICBtdXN0UmVmcmVzaEZvckhlaWdodHMobGluZUhlaWdodHMpIHtcbiAgICAgICAgbGV0IG5ld0hlaWdodCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVIZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaCA9IGxpbmVIZWlnaHRzW2ldO1xuICAgICAgICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldKSB7IC8vIFJvdW5kIHRvIC4xIHBpeGVsc1xuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdIZWlnaHQ7XG4gICAgfVxuICAgIHJlZnJlc2god2hpdGVTcGFjZSwgbGluZUhlaWdodCwgY2hhcldpZHRoLCBsaW5lTGVuZ3RoLCBrbm93bkhlaWdodHMpIHtcbiAgICAgICAgbGV0IGxpbmVXcmFwcGluZyA9IHdyYXBwaW5nV2hpdGVTcGFjZS5pbmRleE9mKHdoaXRlU3BhY2UpID4gLTE7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gTWF0aC5yb3VuZChsaW5lSGVpZ2h0KSAhPSBNYXRoLnJvdW5kKHRoaXMubGluZUhlaWdodCkgfHwgdGhpcy5saW5lV3JhcHBpbmcgIT0gbGluZVdyYXBwaW5nO1xuICAgICAgICB0aGlzLmxpbmVXcmFwcGluZyA9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgdGhpcy5jaGFyV2lkdGggPSBjaGFyV2lkdGg7XG4gICAgICAgIHRoaXMubGluZUxlbmd0aCA9IGxpbmVMZW5ndGg7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga25vd25IZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGggPSBrbm93bkhlaWdodHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGggPCAwKVxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXNbTWF0aC5mbG9vcihoICogMTApXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxufVxuLy8gVGhpcyBvYmplY3QgaXMgdXNlZCBieSBgdXBkYXRlSGVpZ2h0YCB0byBtYWtlIERPTSBtZWFzdXJlbWVudHNcbi8vIGFycml2ZSBhdCB0aGUgcmlnaHQgbmlkZXMuIFRoZSBgaGVpZ2h0c2AgYXJyYXkgaXMgYSBzZXF1ZW5jZSBvZlxuLy8gYmxvY2sgaGVpZ2h0cywgc3RhcnRpbmcgZnJvbSBwb3NpdGlvbiBgZnJvbWAuXG5jbGFzcyBNZWFzdXJlZEhlaWdodHMge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIGhlaWdodHMpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5oZWlnaHRzID0gaGVpZ2h0cztcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIGdldCBtb3JlKCkgeyByZXR1cm4gdGhpcy5pbmRleCA8IHRoaXMuaGVpZ2h0cy5sZW5ndGg7IH1cbn1cbi8qKlxuUmVjb3JkIHVzZWQgdG8gcmVwcmVzZW50IGluZm9ybWF0aW9uIGFib3V0IGEgYmxvY2stbGV2ZWwgZWxlbWVudFxuaW4gdGhlIGVkaXRvciB2aWV3LlxuKi9cbmNsYXNzIEJsb2NrSW5mbyB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIGVsZW1lbnQgaW4gdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgZWxlbWVudC5cbiAgICAqL1xuICAgIGxlbmd0aCwgXG4gICAgLyoqXG4gICAgVGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCAocmVsYXRpdmUgdG8gdGhlIHRvcCBvZiB0aGVcbiAgICBkb2N1bWVudCkuXG4gICAgKi9cbiAgICB0b3AsIFxuICAgIC8qKlxuICAgIEl0cyBoZWlnaHQuXG4gICAgKi9cbiAgICBoZWlnaHQsIFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIGVsZW1lbnQgdGhpcyBpcy4gV2hlbiBxdWVyeWluZyBsaW5lcywgdGhpcyBtYXkgYmVcbiAgICBhbiBhcnJheSBvZiBhbGwgdGhlIGJsb2NrcyB0aGF0IG1ha2UgdXAgdGhlIGxpbmUuXG4gICAgKi9cbiAgICB0eXBlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIGVsZW1lbnQgYXMgYSBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgVGhlIGJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudC5cbiAgICAqL1xuICAgIGdldCBib3R0b20oKSB7IHJldHVybiB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0OyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBqb2luKG90aGVyKSB7XG4gICAgICAgIGxldCBkZXRhaWwgPSAoQXJyYXkuaXNBcnJheSh0aGlzLnR5cGUpID8gdGhpcy50eXBlIDogW3RoaXNdKVxuICAgICAgICAgICAgLmNvbmNhdChBcnJheS5pc0FycmF5KG90aGVyLnR5cGUpID8gb3RoZXIudHlwZSA6IFtvdGhlcl0pO1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyh0aGlzLmZyb20sIHRoaXMubGVuZ3RoICsgb3RoZXIubGVuZ3RoLCB0aGlzLnRvcCwgdGhpcy5oZWlnaHQgKyBvdGhlci5oZWlnaHQsIGRldGFpbCk7XG4gICAgfVxufVxudmFyIFF1ZXJ5VHlwZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFF1ZXJ5VHlwZSkge1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeVBvc1wiXSA9IDBdID0gXCJCeVBvc1wiO1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeUhlaWdodFwiXSA9IDFdID0gXCJCeUhlaWdodFwiO1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeVBvc05vSGVpZ2h0XCJdID0gMl0gPSBcIkJ5UG9zTm9IZWlnaHRcIjtcbnJldHVybiBRdWVyeVR5cGV9KShRdWVyeVR5cGUgfHwgKFF1ZXJ5VHlwZSA9IHt9KSk7XG5jb25zdCBFcHNpbG9uID0gMWUtMztcbmNsYXNzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCAvLyBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY292ZXJlZFxuICAgIGhlaWdodCwgLy8gSGVpZ2h0IG9mIHRoaXMgcGFydCBvZiB0aGUgZG9jdW1lbnRcbiAgICBmbGFncyA9IDIgLyogRmxhZy5PdXRkYXRlZCAqLykge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgZ2V0IG91dGRhdGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8pID4gMDsgfVxuICAgIHNldCBvdXRkYXRlZCh2YWx1ZSkgeyB0aGlzLmZsYWdzID0gKHZhbHVlID8gMiAvKiBGbGFnLk91dGRhdGVkICovIDogMCkgfCAodGhpcy5mbGFncyAmIH4yIC8qIEZsYWcuT3V0ZGF0ZWQgKi8pOyB9XG4gICAgc2V0SGVpZ2h0KG9yYWNsZSwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmhlaWdodCAtIGhlaWdodCkgPiBFcHNpbG9uKVxuICAgICAgICAgICAgICAgIG9yYWNsZS5oZWlnaHRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJhc2UgY2FzZSBpcyB0byByZXBsYWNlIGEgbGVhZiBub2RlLCB3aGljaCBzaW1wbHkgYnVpbGRzIGEgdHJlZVxuICAgIC8vIGZyb20gdGhlIG5ldyBub2RlcyBhbmQgcmV0dXJucyB0aGF0IChIZWlnaHRNYXBCcmFuY2ggYW5kXG4gICAgLy8gSGVpZ2h0TWFwR2FwIG92ZXJyaWRlIHRoaXMgdG8gYWN0dWFsbHkgdXNlIGZyb20vdG8pXG4gICAgcmVwbGFjZShfZnJvbSwgX3RvLCBub2Rlcykge1xuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICB9XG4gICAgLy8gQWdhaW4sIHRoZXNlIGFyZSBiYXNlIGNhc2VzLCBhbmQgYXJlIG92ZXJyaWRkZW4gZm9yIGJyYW5jaCBhbmQgZ2FwIG5vZGVzLlxuICAgIGRlY29tcG9zZUxlZnQoX3RvLCByZXN1bHQpIHsgcmVzdWx0LnB1c2godGhpcyk7IH1cbiAgICBkZWNvbXBvc2VSaWdodChfZnJvbSwgcmVzdWx0KSB7IHJlc3VsdC5wdXNoKHRoaXMpOyB9XG4gICAgYXBwbHlDaGFuZ2VzKGRlY29yYXRpb25zLCBvbGREb2MsIG9yYWNsZSwgY2hhbmdlcykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLCBkb2MgPSBvcmFjbGUuZG9jO1xuICAgICAgICBmb3IgKGxldCBpID0gY2hhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHsgZnJvbUEsIHRvQSwgZnJvbUIsIHRvQiB9ID0gY2hhbmdlc1tpXTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IG1lLmxpbmVBdChmcm9tQSwgUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQsIG9yYWNsZS5zZXREb2Mob2xkRG9jKSwgMCwgMCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gc3RhcnQudG8gPj0gdG9BID8gc3RhcnQgOiBtZS5saW5lQXQodG9BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb3JhY2xlLCAwLCAwKTtcbiAgICAgICAgICAgIHRvQiArPSBlbmQudG8gLSB0b0E7XG4gICAgICAgICAgICB0b0EgPSBlbmQudG87XG4gICAgICAgICAgICB3aGlsZSAoaSA+IDAgJiYgc3RhcnQuZnJvbSA8PSBjaGFuZ2VzW2kgLSAxXS50b0EpIHtcbiAgICAgICAgICAgICAgICBmcm9tQSA9IGNoYW5nZXNbaSAtIDFdLmZyb21BO1xuICAgICAgICAgICAgICAgIGZyb21CID0gY2hhbmdlc1tpIC0gMV0uZnJvbUI7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQSA8IHN0YXJ0LmZyb20pXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbWUubGluZUF0KGZyb21BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb3JhY2xlLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb21CICs9IHN0YXJ0LmZyb20gLSBmcm9tQTtcbiAgICAgICAgICAgIGZyb21BID0gc3RhcnQuZnJvbTtcbiAgICAgICAgICAgIGxldCBub2RlcyA9IE5vZGVCdWlsZGVyLmJ1aWxkKG9yYWNsZS5zZXREb2MoZG9jKSwgZGVjb3JhdGlvbnMsIGZyb21CLCB0b0IpO1xuICAgICAgICAgICAgbWUgPSBtZS5yZXBsYWNlKGZyb21BLCB0b0EsIG5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWUudXBkYXRlSGVpZ2h0KG9yYWNsZSwgMCk7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eSgpIHsgcmV0dXJuIG5ldyBIZWlnaHRNYXBUZXh0KDAsIDApOyB9XG4gICAgLy8gbm9kZXMgdXNlcyBudWxsIHZhbHVlcyB0byBpbmRpY2F0ZSB0aGUgcG9zaXRpb24gb2YgbGluZSBicmVha3MuXG4gICAgLy8gVGhlcmUgYXJlIG5ldmVyIGxpbmUgYnJlYWtzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGFycmF5LCBvclxuICAgIC8vIHR3byBsaW5lIGJyZWFrcyBuZXh0IHRvIGVhY2ggb3RoZXIsIGFuZCB0aGUgYXJyYXkgaXNuJ3QgYWxsb3dlZFxuICAgIC8vIHRvIGJlIGVtcHR5IChzYW1lIHJlc3RyaWN0aW9ucyBhcyByZXR1cm4gdmFsdWUgZnJvbSB0aGUgYnVpbGRlcikuXG4gICAgc3RhdGljIG9mKG5vZGVzKSB7XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBub2Rlc1swXTtcbiAgICAgICAgbGV0IGkgPSAwLCBqID0gbm9kZXMubGVuZ3RoLCBiZWZvcmUgPSAwLCBhZnRlciA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChpID09IGopIHtcbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlID4gYWZ0ZXIgKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGxpdCA9IG5vZGVzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0LmJyZWFrKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKC0taSwgMSwgc3BsaXQubGVmdCwgbnVsbCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoLS1pLCAxLCBzcGxpdC5sZWZ0LCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGogKz0gMSArIHNwbGl0LmJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgLT0gc3BsaXQuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWZ0ZXIgPiBiZWZvcmUgKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGxpdCA9IG5vZGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQuYnJlYWspXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaiwgMSwgc3BsaXQubGVmdCwgbnVsbCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaiwgMSwgc3BsaXQubGVmdCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBqICs9IDIgKyBzcGxpdC5icmVhaztcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgLT0gc3BsaXQuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJlZm9yZSA8IGFmdGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2Rlc1tpKytdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2Rlc1stLWpdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgICAgICAgICBhZnRlciArPSBuZXh0LnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJyayA9IDA7XG4gICAgICAgIGlmIChub2Rlc1tpIC0gMV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJrID0gMTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2Rlc1tpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmsgPSAxO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGVpZ2h0TWFwQnJhbmNoKEhlaWdodE1hcC5vZihub2Rlcy5zbGljZSgwLCBpKSksIGJyaywgSGVpZ2h0TWFwLm9mKG5vZGVzLnNsaWNlKGopKSk7XG4gICAgfVxufVxuSGVpZ2h0TWFwLnByb3RvdHlwZS5zaXplID0gMTtcbmNsYXNzIEhlaWdodE1hcEJsb2NrIGV4dGVuZHMgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGhlaWdodCwgdHlwZSkge1xuICAgICAgICBzdXBlcihsZW5ndGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIGJsb2NrQXQoX2hlaWdodCwgX29yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8ob2Zmc2V0LCB0aGlzLmxlbmd0aCwgdG9wLCB0aGlzLmhlaWdodCwgdGhpcy50eXBlKTtcbiAgICB9XG4gICAgbGluZUF0KF92YWx1ZSwgX3R5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tBdCgwLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpIHtcbiAgICAgICAgaWYgKGZyb20gPD0gb2Zmc2V0ICsgdGhpcy5sZW5ndGggJiYgdG8gPj0gb2Zmc2V0KVxuICAgICAgICAgICAgZih0aGlzLmJsb2NrQXQoMCwgb3JhY2xlLCB0b3AsIG9mZnNldCkpO1xuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBfZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUsIG1lYXN1cmVkLmhlaWdodHNbbWVhc3VyZWQuaW5kZXgrK10pO1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIGBibG9jaygke3RoaXMubGVuZ3RofSlgOyB9XG59XG5jbGFzcyBIZWlnaHRNYXBUZXh0IGV4dGVuZHMgSGVpZ2h0TWFwQmxvY2sge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGxlbmd0aCwgaGVpZ2h0LCBCbG9ja1R5cGUuVGV4dCk7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkID0gMDsgLy8gQW1vdW50IG9mIGNvbGxhcHNlZCBjb250ZW50IGluIHRoZSBsaW5lXG4gICAgICAgIHRoaXMud2lkZ2V0SGVpZ2h0ID0gMDsgLy8gTWF4aW11bSBpbmxpbmUgd2lkZ2V0IGhlaWdodFxuICAgIH1cbiAgICByZXBsYWNlKF9mcm9tLCBfdG8sIG5vZGVzKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbMF07XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMSAmJiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQgfHwgbm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcCAmJiAobm9kZS5mbGFncyAmIDQgLyogRmxhZy5TaW5nbGVMaW5lICovKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMubGVuZ3RoIC0gbm9kZS5sZW5ndGgpIDwgMTApIHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgSGVpZ2h0TWFwVGV4dChub2RlLmxlbmd0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3V0ZGF0ZWQpXG4gICAgICAgICAgICAgICAgbm9kZS5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBmb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KG9yYWNsZSwgbWVhc3VyZWQuaGVpZ2h0c1ttZWFzdXJlZC5pbmRleCsrXSk7XG4gICAgICAgIGVsc2UgaWYgKGZvcmNlIHx8IHRoaXMub3V0ZGF0ZWQpXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUsIE1hdGgubWF4KHRoaXMud2lkZ2V0SGVpZ2h0LCBvcmFjbGUuaGVpZ2h0Rm9yTGluZSh0aGlzLmxlbmd0aCAtIHRoaXMuY29sbGFwc2VkKSkpO1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBsaW5lKCR7dGhpcy5sZW5ndGh9JHt0aGlzLmNvbGxhcHNlZCA/IC10aGlzLmNvbGxhcHNlZCA6IFwiXCJ9JHt0aGlzLndpZGdldEhlaWdodCA/IFwiOlwiICsgdGhpcy53aWRnZXRIZWlnaHQgOiBcIlwifSlgO1xuICAgIH1cbn1cbmNsYXNzIEhlaWdodE1hcEdhcCBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7IHN1cGVyKGxlbmd0aCwgMCk7IH1cbiAgICBoZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBmaXJzdExpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChvZmZzZXQpLm51bWJlciwgbGFzdExpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChvZmZzZXQgKyB0aGlzLmxlbmd0aCkubnVtYmVyO1xuICAgICAgICBsZXQgbGluZXMgPSBsYXN0TGluZSAtIGZpcnN0TGluZSArIDE7XG4gICAgICAgIGxldCBwZXJMaW5lLCBwZXJDaGFyID0gMDtcbiAgICAgICAgaWYgKG9yYWNsZS5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIGxldCB0b3RhbFBlckxpbmUgPSBNYXRoLm1pbih0aGlzLmhlaWdodCwgb3JhY2xlLmxpbmVIZWlnaHQgKiBsaW5lcyk7XG4gICAgICAgICAgICBwZXJMaW5lID0gdG90YWxQZXJMaW5lIC8gbGluZXM7XG4gICAgICAgICAgICBwZXJDaGFyID0gKHRoaXMuaGVpZ2h0IC0gdG90YWxQZXJMaW5lKSAvICh0aGlzLmxlbmd0aCAtIGxpbmVzIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwZXJMaW5lID0gdGhpcy5oZWlnaHQgLyBsaW5lcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmaXJzdExpbmUsIGxhc3RMaW5lLCBwZXJMaW5lLCBwZXJDaGFyIH07XG4gICAgfVxuICAgIGJsb2NrQXQoaGVpZ2h0LCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgbGFzdExpbmUsIHBlckxpbmUsIHBlckNoYXIgfSA9IHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCk7XG4gICAgICAgIGlmIChvcmFjbGUubGluZVdyYXBwaW5nKSB7XG4gICAgICAgICAgICBsZXQgZ3Vlc3MgPSBvZmZzZXQgKyBNYXRoLnJvdW5kKE1hdGgubWF4KDAsIE1hdGgubWluKDEsIChoZWlnaHQgLSB0b3ApIC8gdGhpcy5oZWlnaHQpKSAqIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBsaW5lID0gb3JhY2xlLmRvYy5saW5lQXQoZ3Vlc3MpLCBsaW5lSGVpZ2h0ID0gcGVyTGluZSArIGxpbmUubGVuZ3RoICogcGVyQ2hhcjtcbiAgICAgICAgICAgIGxldCBsaW5lVG9wID0gTWF0aC5tYXgodG9wLCBoZWlnaHQgLSBsaW5lSGVpZ2h0IC8gMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhsaW5lLmZyb20sIGxpbmUubGVuZ3RoLCBsaW5lVG9wLCBsaW5lSGVpZ2h0LCBCbG9ja1R5cGUuVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxhc3RMaW5lIC0gZmlyc3RMaW5lLCBNYXRoLmZsb29yKChoZWlnaHQgLSB0b3ApIC8gcGVyTGluZSkpKTtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIGxlbmd0aCB9ID0gb3JhY2xlLmRvYy5saW5lKGZpcnN0TGluZSArIGxpbmUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8oZnJvbSwgbGVuZ3RoLCB0b3AgKyBwZXJMaW5lICogbGluZSwgcGVyTGluZSwgQmxvY2tUeXBlLlRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBpZiAodHlwZSA9PSBRdWVyeVR5cGUuQnlIZWlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibG9ja0F0KHZhbHVlLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBvcmFjbGUuZG9jLmxpbmVBdCh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhmcm9tLCB0byAtIGZyb20sIDAsIDAsIEJsb2NrVHlwZS5UZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIHBlckxpbmUsIHBlckNoYXIgfSA9IHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCk7XG4gICAgICAgIGxldCBsaW5lID0gb3JhY2xlLmRvYy5saW5lQXQodmFsdWUpLCBsaW5lSGVpZ2h0ID0gcGVyTGluZSArIGxpbmUubGVuZ3RoICogcGVyQ2hhcjtcbiAgICAgICAgbGV0IGxpbmVzQWJvdmUgPSBsaW5lLm51bWJlciAtIGZpcnN0TGluZTtcbiAgICAgICAgbGV0IGxpbmVUb3AgPSB0b3AgKyBwZXJMaW5lICogbGluZXNBYm92ZSArIHBlckNoYXIgKiAobGluZS5mcm9tIC0gb2Zmc2V0IC0gbGluZXNBYm92ZSk7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGxpbmUuZnJvbSwgbGluZS5sZW5ndGgsIE1hdGgubWF4KHRvcCwgTWF0aC5taW4obGluZVRvcCwgdG9wICsgdGhpcy5oZWlnaHQgLSBsaW5lSGVpZ2h0KSksIGxpbmVIZWlnaHQsIEJsb2NrVHlwZS5UZXh0KTtcbiAgICB9XG4gICAgZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpIHtcbiAgICAgICAgZnJvbSA9IE1hdGgubWF4KGZyb20sIG9mZnNldCk7XG4gICAgICAgIHRvID0gTWF0aC5taW4odG8sIG9mZnNldCArIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgbGV0IHsgZmlyc3RMaW5lLCBwZXJMaW5lLCBwZXJDaGFyIH0gPSB0aGlzLmhlaWdodE1ldHJpY3Mob3JhY2xlLCBvZmZzZXQpO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBmcm9tLCBsaW5lVG9wID0gdG9wOyBwb3MgPD0gdG87KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IG9yYWNsZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAocG9zID09IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXNBYm92ZSA9IGxpbmUubnVtYmVyIC0gZmlyc3RMaW5lO1xuICAgICAgICAgICAgICAgIGxpbmVUb3AgKz0gcGVyTGluZSAqIGxpbmVzQWJvdmUgKyBwZXJDaGFyICogKGZyb20gLSBvZmZzZXQgLSBsaW5lc0Fib3ZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsaW5lSGVpZ2h0ID0gcGVyTGluZSArIHBlckNoYXIgKiBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGYobmV3IEJsb2NrSW5mbyhsaW5lLmZyb20sIGxpbmUubGVuZ3RoLCBsaW5lVG9wLCBsaW5lSGVpZ2h0LCBCbG9ja1R5cGUuVGV4dCkpO1xuICAgICAgICAgICAgbGluZVRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5sZW5ndGggLSB0bztcbiAgICAgICAgaWYgKGFmdGVyID4gMCkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdID0gbmV3IEhlaWdodE1hcEdhcChsYXN0Lmxlbmd0aCArIGFmdGVyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAoYWZ0ZXIgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gPiAwKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBub2Rlc1swXTtcbiAgICAgICAgICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2Rlc1swXSA9IG5ldyBIZWlnaHRNYXBHYXAoZnJvbSArIGZpcnN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMudW5zaGlmdChuZXcgSGVpZ2h0TWFwR2FwKGZyb20gLSAxKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gMSksIG51bGwpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcCh0aGlzLmxlbmd0aCAtIGZyb20gLSAxKSk7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCBlbmQgPSBvZmZzZXQgKyB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICsgdGhpcy5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgLy8gRmlsbCBpbiBwYXJ0IG9mIHRoaXMgZ2FwIHdpdGggbWVhc3VyZWQgbGluZXMuIFdlIGtub3cgdGhlcmVcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIHdpZGdldHMgb3IgY29sbGFwc2VkIHJhbmdlcyBpbiB0aG9zZSBsaW5lcywgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGhleSB3b3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgaGVpZ2h0bWFwIChnYXBzXG4gICAgICAgICAgICAvLyBvbmx5IGNvbnRhaW4gcGxhaW4gdGV4dCkuXG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBbXSwgcG9zID0gTWF0aC5tYXgob2Zmc2V0LCBtZWFzdXJlZC5mcm9tKSwgc2luZ2xlSGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICBpZiAobWVhc3VyZWQuZnJvbSA+IG9mZnNldClcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBHYXAobWVhc3VyZWQuZnJvbSAtIG9mZnNldCAtIDEpLnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCkpO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8PSBlbmQgJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBvcmFjbGUuZG9jLmxpbmVBdChwb3MpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVIZWlnaHQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhoZWlnaHQgLSBzaW5nbGVIZWlnaHQpID49IEVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IC0yO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQobGVuLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGxpbmUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW4gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKGVuZCAtIHBvcykudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcG9zKSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICAgICAgICAgIGlmIChzaW5nbGVIZWlnaHQgPCAwIHx8IE1hdGguYWJzKHJlc3VsdC5oZWlnaHQgLSB0aGlzLmhlaWdodCkgPj0gRXBzaWxvbiB8fFxuICAgICAgICAgICAgICAgIE1hdGguYWJzKHNpbmdsZUhlaWdodCAtIHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCkucGVyTGluZSkgPj0gRXBzaWxvbilcbiAgICAgICAgICAgICAgICBvcmFjbGUuaGVpZ2h0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvcmNlIHx8IHRoaXMub3V0ZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KG9yYWNsZSwgb3JhY2xlLmhlaWdodEZvckdhcChvZmZzZXQsIG9mZnNldCArIHRoaXMubGVuZ3RoKSk7XG4gICAgICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gYGdhcCgke3RoaXMubGVuZ3RofSlgOyB9XG59XG5jbGFzcyBIZWlnaHRNYXBCcmFuY2ggZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIGJyaywgcmlnaHQpIHtcbiAgICAgICAgc3VwZXIobGVmdC5sZW5ndGggKyBicmsgKyByaWdodC5sZW5ndGgsIGxlZnQuaGVpZ2h0ICsgcmlnaHQuaGVpZ2h0LCBicmsgfCAobGVmdC5vdXRkYXRlZCB8fCByaWdodC5vdXRkYXRlZCA/IDIgLyogRmxhZy5PdXRkYXRlZCAqLyA6IDApKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLnNpemUgPSBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgIH1cbiAgICBnZXQgYnJlYWsoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMSAvKiBGbGFnLkJyZWFrICovOyB9XG4gICAgYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IG1pZCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBoZWlnaHQgPCBtaWQgPyB0aGlzLmxlZnQuYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQuYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgbWlkLCBvZmZzZXQgKyB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhayk7XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBsZXQgbGVmdCA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5SGVpZ2h0ID8gdmFsdWUgPCByaWdodFRvcCA6IHZhbHVlIDwgcmlnaHRPZmZzZXQ7XG4gICAgICAgIGxldCBiYXNlID0gbGVmdCA/IHRoaXMubGVmdC5saW5lQXQodmFsdWUsIHR5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQubGluZUF0KHZhbHVlLCB0eXBlLCBvcmFjbGUsIHJpZ2h0VG9wLCByaWdodE9mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrIHx8IChsZWZ0ID8gYmFzZS50byA8IHJpZ2h0T2Zmc2V0IDogYmFzZS5mcm9tID4gcmlnaHRPZmZzZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIGxldCBzdWJRdWVyeSA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQgPyBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCA6IFF1ZXJ5VHlwZS5CeVBvcztcbiAgICAgICAgaWYgKGxlZnQpXG4gICAgICAgICAgICByZXR1cm4gYmFzZS5qb2luKHRoaXMucmlnaHQubGluZUF0KHJpZ2h0T2Zmc2V0LCBzdWJRdWVyeSwgb3JhY2xlLCByaWdodFRvcCwgcmlnaHRPZmZzZXQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5saW5lQXQocmlnaHRPZmZzZXQsIHN1YlF1ZXJ5LCBvcmFjbGUsIHRvcCwgb2Zmc2V0KS5qb2luKGJhc2UpO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAodGhpcy5icmVhaykge1xuICAgICAgICAgICAgaWYgKGZyb20gPCByaWdodE9mZnNldClcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpO1xuICAgICAgICAgICAgaWYgKHRvID49IHJpZ2h0T2Zmc2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0LCBmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSB0aGlzLmxpbmVBdChyaWdodE9mZnNldCwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgbWlkLmZyb20pXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hMaW5lKGZyb20sIG1pZC5mcm9tIC0gMSwgb3JhY2xlLCB0b3AsIG9mZnNldCwgZik7XG4gICAgICAgICAgICBpZiAobWlkLnRvID49IGZyb20gJiYgbWlkLmZyb20gPD0gdG8pXG4gICAgICAgICAgICAgICAgZihtaWQpO1xuICAgICAgICAgICAgaWYgKHRvID4gbWlkLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaExpbmUobWlkLnRvICsgMSwgdG8sIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0LCBmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCBub2Rlcykge1xuICAgICAgICBsZXQgcmlnaHRTdGFydCA9IHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAodG8gPCByaWdodFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQodGhpcy5sZWZ0LnJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSwgdGhpcy5yaWdodCk7XG4gICAgICAgIGlmIChmcm9tID4gdGhpcy5sZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKHRoaXMubGVmdCwgdGhpcy5yaWdodC5yZXBsYWNlKGZyb20gLSByaWdodFN0YXJ0LCB0byAtIHJpZ2h0U3RhcnQsIG5vZGVzKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VMZWZ0KGZyb20sIHJlc3VsdCk7XG4gICAgICAgIGxldCBsZWZ0ID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2RlcylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICBtZXJnZUdhcHMocmVzdWx0LCBsZWZ0IC0gMSk7XG4gICAgICAgIGlmICh0byA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VSaWdodCh0bywgcmVzdWx0KTtcbiAgICAgICAgICAgIG1lcmdlR2FwcyhyZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKHJlc3VsdCk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgICAgIGlmICh0byA8PSBsZWZ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5kZWNvbXBvc2VMZWZ0KHRvLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLmxlZnQpO1xuICAgICAgICBpZiAodGhpcy5icmVhaykge1xuICAgICAgICAgICAgbGVmdCsrO1xuICAgICAgICAgICAgaWYgKHRvID49IGxlZnQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvID4gbGVmdClcbiAgICAgICAgICAgIHRoaXMucmlnaHQuZGVjb21wb3NlTGVmdCh0byAtIGxlZnQsIHJlc3VsdCk7XG4gICAgfVxuICAgIGRlY29tcG9zZVJpZ2h0KGZyb20sIHJlc3VsdCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGgsIHJpZ2h0ID0gbGVmdCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmIChmcm9tID49IHJpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQuZGVjb21wb3NlUmlnaHQoZnJvbSAtIHJpZ2h0LCByZXN1bHQpO1xuICAgICAgICBpZiAoZnJvbSA8IGxlZnQpXG4gICAgICAgICAgICB0aGlzLmxlZnQuZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWsgJiYgZnJvbSA8IHJpZ2h0KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucmlnaHQpO1xuICAgIH1cbiAgICBiYWxhbmNlZChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAobGVmdC5zaXplID4gMiAqIHJpZ2h0LnNpemUgfHwgcmlnaHQuc2l6ZSA+IDIgKiBsZWZ0LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKHRoaXMuYnJlYWsgPyBbbGVmdCwgbnVsbCwgcmlnaHRdIDogW2xlZnQsIHJpZ2h0XSk7XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBsZWZ0LmhlaWdodCArIHJpZ2h0LmhlaWdodDtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGxlZnQub3V0ZGF0ZWQgfHwgcmlnaHQub3V0ZGF0ZWQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGxlZnQuc2l6ZSArIHJpZ2h0LnNpemU7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrICsgcmlnaHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgbGV0IHsgbGVmdCwgcmlnaHQgfSA9IHRoaXMsIHJpZ2h0U3RhcnQgPSBvZmZzZXQgKyBsZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWssIHJlYmFsYW5jZSA9IG51bGw7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCArIGxlZnQubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICByZWJhbGFuY2UgPSBsZWZ0ID0gbGVmdC51cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQsIGZvcmNlLCBtZWFzdXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxlZnQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0LCBmb3JjZSk7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IHJpZ2h0U3RhcnQgKyByaWdodC5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHJlYmFsYW5jZSA9IHJpZ2h0ID0gcmlnaHQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcmlnaHRTdGFydCwgZm9yY2UsIG1lYXN1cmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmlnaHQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcmlnaHRTdGFydCwgZm9yY2UpO1xuICAgICAgICBpZiAocmViYWxhbmNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMubGVmdC5oZWlnaHQgKyB0aGlzLnJpZ2h0LmhlaWdodDtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmxlZnQgKyAodGhpcy5icmVhayA/IFwiIFwiIDogXCItXCIpICsgdGhpcy5yaWdodDsgfVxufVxuZnVuY3Rpb24gbWVyZ2VHYXBzKG5vZGVzLCBhcm91bmQpIHtcbiAgICBsZXQgYmVmb3JlLCBhZnRlcjtcbiAgICBpZiAobm9kZXNbYXJvdW5kXSA9PSBudWxsICYmXG4gICAgICAgIChiZWZvcmUgPSBub2Rlc1thcm91bmQgLSAxXSkgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXAgJiZcbiAgICAgICAgKGFmdGVyID0gbm9kZXNbYXJvdW5kICsgMV0pIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICBub2Rlcy5zcGxpY2UoYXJvdW5kIC0gMSwgMywgbmV3IEhlaWdodE1hcEdhcChiZWZvcmUubGVuZ3RoICsgMSArIGFmdGVyLmxlbmd0aCkpO1xufVxuY29uc3QgcmVsZXZhbnRXaWRnZXRIZWlnaHQgPSA1O1xuY2xhc3MgTm9kZUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvcywgb3JhY2xlKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm9yYWNsZSA9IG9yYWNsZTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxpbmVFbmQgPSAtMTtcbiAgICAgICAgdGhpcy5jb3ZlcmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gcG9zO1xuICAgIH1cbiAgICBnZXQgaXNDb3ZlcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3ZlcmluZyAmJiB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gPT0gdGhpcy5jb3ZlcmluZztcbiAgICB9XG4gICAgc3BhbihfZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbih0bywgdGhpcy5saW5lRW5kKSwgbGFzdCA9IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dClcbiAgICAgICAgICAgICAgICBsYXN0Lmxlbmd0aCArPSBlbmQgLSB0aGlzLnBvcztcbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZCA+IHRoaXMucG9zIHx8ICF0aGlzLmlzQ292ZXJlZClcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQoZW5kIC0gdGhpcy5wb3MsIC0xKSk7XG4gICAgICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IGVuZDtcbiAgICAgICAgICAgIGlmICh0byA+IGVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXR0ZW5UbysrO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICB9XG4gICAgcG9pbnQoZnJvbSwgdG8sIGRlY28pIHtcbiAgICAgICAgaWYgKGZyb20gPCB0byB8fCBkZWNvLmhlaWdodFJlbGV2YW50KSB7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gZGVjby53aWRnZXQgPyBkZWNvLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgOiAwO1xuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDApXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5vcmFjbGUubGluZUhlaWdodDtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0byAtIGZyb207XG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmxvY2sobmV3IEhlaWdodE1hcEJsb2NrKGxlbiwgaGVpZ2h0LCBkZWNvLnR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiB8fCBoZWlnaHQgPj0gcmVsZXZhbnRXaWRnZXRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExpbmVEZWNvKGhlaWdodCwgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0byA+IGZyb20pIHtcbiAgICAgICAgICAgIHRoaXMuc3Bhbihmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGluZUVuZCA+IC0xICYmIHRoaXMubGluZUVuZCA8IHRoaXMucG9zKVxuICAgICAgICAgICAgdGhpcy5saW5lRW5kID0gdGhpcy5vcmFjbGUuZG9jLmxpbmVBdCh0aGlzLnBvcykudG87XG4gICAgfVxuICAgIGVudGVyTGluZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLm9yYWNsZS5kb2MubGluZUF0KHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLmxpbmVFbmQgPSB0bztcbiAgICAgICAgaWYgKHRoaXMud3JpdHRlblRvIDwgZnJvbSkge1xuICAgICAgICAgICAgaWYgKHRoaXMud3JpdHRlblRvIDwgZnJvbSAtIDEgfHwgdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYmxhbmtDb250ZW50KHRoaXMud3JpdHRlblRvLCBmcm9tIC0gMSkpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvcyA+IGZyb20pXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQodGhpcy5wb3MgLSBmcm9tLCAtMSkpO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zO1xuICAgIH1cbiAgICBibGFua0NvbnRlbnQoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGdhcCA9IG5ldyBIZWlnaHRNYXBHYXAodG8gLSBmcm9tKTtcbiAgICAgICAgaWYgKHRoaXMub3JhY2xlLmRvYy5saW5lQXQoZnJvbSkudG8gPT0gdG8pXG4gICAgICAgICAgICBnYXAuZmxhZ3MgfD0gNCAvKiBGbGFnLlNpbmdsZUxpbmUgKi87XG4gICAgICAgIHJldHVybiBnYXA7XG4gICAgfVxuICAgIGVuc3VyZUxpbmUoKSB7XG4gICAgICAgIHRoaXMuZW50ZXJMaW5lKCk7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5ub2Rlcy5sZW5ndGggPyB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgbGV0IGxpbmUgPSBuZXcgSGVpZ2h0TWFwVGV4dCgwLCAtMSk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChsaW5lKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICAgIGFkZEJsb2NrKGJsb2NrKSB7XG4gICAgICAgIHRoaXMuZW50ZXJMaW5lKCk7XG4gICAgICAgIGlmIChibG9jay50eXBlID09IEJsb2NrVHlwZS5XaWRnZXRBZnRlciAmJiAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICB0aGlzLmVuc3VyZUxpbmUoKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGJsb2NrKTtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcyA9IHRoaXMucG9zICsgYmxvY2subGVuZ3RoO1xuICAgICAgICBpZiAoYmxvY2sudHlwZSAhPSBCbG9ja1R5cGUuV2lkZ2V0QmVmb3JlKVxuICAgICAgICAgICAgdGhpcy5jb3ZlcmluZyA9IGJsb2NrO1xuICAgIH1cbiAgICBhZGRMaW5lRGVjbyhoZWlnaHQsIGxlbmd0aCkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuZW5zdXJlTGluZSgpO1xuICAgICAgICBsaW5lLmxlbmd0aCArPSBsZW5ndGg7XG4gICAgICAgIGxpbmUuY29sbGFwc2VkICs9IGxlbmd0aDtcbiAgICAgICAgbGluZS53aWRnZXRIZWlnaHQgPSBNYXRoLm1heChsaW5lLndpZGdldEhlaWdodCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcyA9IHRoaXMucG9zICsgbGVuZ3RoO1xuICAgIH1cbiAgICBmaW5pc2goZnJvbSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoID09IDAgPyBudWxsIDogdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy5saW5lU3RhcnQgPiAtMSAmJiAhKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KSAmJiAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQoMCwgLTEpKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy53cml0dGVuVG8gPCB0aGlzLnBvcyB8fCBsYXN0ID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2godGhpcy5ibGFua0NvbnRlbnQodGhpcy53cml0dGVuVG8sIHRoaXMucG9zKSk7XG4gICAgICAgIGxldCBwb3MgPSBmcm9tO1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIHRoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dClcbiAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZUhlaWdodCh0aGlzLm9yYWNsZSwgcG9zKTtcbiAgICAgICAgICAgIHBvcyArPSBub2RlID8gbm9kZS5sZW5ndGggOiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzO1xuICAgIH1cbiAgICAvLyBBbHdheXMgY2FsbGVkIHdpdGggYSByZWdpb24gdGhhdCBvbiBib3RoIHNpZGVzIGVpdGhlciBzdHJldGNoZXNcbiAgICAvLyB0byBhIGxpbmUgYnJlYWsgb3IgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4gICAgLy8gVGhlIHJldHVybmVkIGFycmF5IHVzZXMgbnVsbCB0byBpbmRpY2F0ZSBsaW5lIGJyZWFrcywgYnV0IG5ldmVyXG4gICAgLy8gc3RhcnRzIG9yIGVuZHMgaW4gYSBsaW5lIGJyZWFrLCBvciBoYXMgbXVsdGlwbGUgbGluZSBicmVha3MgbmV4dFxuICAgIC8vIHRvIGVhY2ggb3RoZXIuXG4gICAgc3RhdGljIGJ1aWxkKG9yYWNsZSwgZGVjb3JhdGlvbnMsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IE5vZGVCdWlsZGVyKGZyb20sIG9yYWNsZSk7XG4gICAgICAgIFJhbmdlU2V0LnNwYW5zKGRlY29yYXRpb25zLCBmcm9tLCB0bywgYnVpbGRlciwgMCk7XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaChmcm9tKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoZWlnaHRSZWxldmFudERlY29DaGFuZ2VzKGEsIGIsIGRpZmYpIHtcbiAgICBsZXQgY29tcCA9IG5ldyBEZWNvcmF0aW9uQ29tcGFyYXRvcjtcbiAgICBSYW5nZVNldC5jb21wYXJlKGEsIGIsIGRpZmYsIGNvbXAsIDApO1xuICAgIHJldHVybiBjb21wLmNoYW5nZXM7XG59XG5jbGFzcyBEZWNvcmF0aW9uQ29tcGFyYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBjb21wYXJlUmFuZ2UoKSB7IH1cbiAgICBjb21wYXJlUG9pbnQoZnJvbSwgdG8sIGEsIGIpIHtcbiAgICAgICAgaWYgKGZyb20gPCB0byB8fCBhICYmIGEuaGVpZ2h0UmVsZXZhbnQgfHwgYiAmJiBiLmhlaWdodFJlbGV2YW50KVxuICAgICAgICAgICAgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcywgNSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2aXNpYmxlUGl4ZWxSYW5nZShkb20sIHBhZGRpbmdUb3ApIHtcbiAgICBsZXQgcmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQsIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgbGV0IGxlZnQgPSBNYXRoLm1heCgwLCByZWN0LmxlZnQpLCByaWdodCA9IE1hdGgubWluKHdpbi5pbm5lcldpZHRoLCByZWN0LnJpZ2h0KTtcbiAgICBsZXQgdG9wID0gTWF0aC5tYXgoMCwgcmVjdC50b3ApLCBib3R0b20gPSBNYXRoLm1pbih3aW4uaW5uZXJIZWlnaHQsIHJlY3QuYm90dG9tKTtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTsgcGFyZW50ICYmIHBhcmVudCAhPSBkb2MuYm9keTspIHtcbiAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgZWx0ID0gcGFyZW50O1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWx0KTtcbiAgICAgICAgICAgIGlmICgoZWx0LnNjcm9sbEhlaWdodCA+IGVsdC5jbGllbnRIZWlnaHQgfHwgZWx0LnNjcm9sbFdpZHRoID4gZWx0LmNsaWVudFdpZHRoKSAmJlxuICAgICAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93ICE9IFwidmlzaWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudFJlY3QgPSBlbHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIHBhcmVudFJlY3QubGVmdCk7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1pbihyaWdodCwgcGFyZW50UmVjdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBwYXJlbnRSZWN0LnRvcCk7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gcGFyZW50ID09IGRvbS5wYXJlbnROb2RlID8gcGFyZW50UmVjdC5ib3R0b20gOiBNYXRoLm1pbihib3R0b20sIHBhcmVudFJlY3QuYm90dG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHN0eWxlLnBvc2l0aW9uID09IFwiYWJzb2x1dGVcIiB8fCBzdHlsZS5wb3NpdGlvbiA9PSBcImZpeGVkXCIgPyBlbHQub2Zmc2V0UGFyZW50IDogZWx0LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyZW50Lm5vZGVUeXBlID09IDExKSB7IC8vIFNoYWRvdyByb290XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQgLSByZWN0LmxlZnQsIHJpZ2h0OiBNYXRoLm1heChsZWZ0LCByaWdodCkgLSByZWN0LmxlZnQsXG4gICAgICAgIHRvcDogdG9wIC0gKHJlY3QudG9wICsgcGFkZGluZ1RvcCksIGJvdHRvbTogTWF0aC5tYXgodG9wLCBib3R0b20pIC0gKHJlY3QudG9wICsgcGFkZGluZ1RvcCkgfTtcbn1cbmZ1bmN0aW9uIGZ1bGxQaXhlbFJhbmdlKGRvbSwgcGFkZGluZ1RvcCkge1xuICAgIGxldCByZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7IGxlZnQ6IDAsIHJpZ2h0OiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgICAgICB0b3A6IHBhZGRpbmdUb3AsIGJvdHRvbTogcmVjdC5ib3R0b20gLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSB9O1xufVxuLy8gTGluZSBnYXBzIGFyZSBwbGFjZWhvbGRlciB3aWRnZXRzIHVzZWQgdG8gaGlkZSBwaWVjZXMgb2Ygb3Zlcmxvbmdcbi8vIGxpbmVzIHdpdGhpbiB0aGUgdmlld3BvcnQsIGFzIGEga2x1ZGdlIHRvIGtlZXAgdGhlIGVkaXRvclxuLy8gcmVzcG9uc2l2ZSB3aGVuIGEgcmlkaWN1bG91c2x5IGxvbmcgbGluZSBpcyBsb2FkZWQgaW50byBpdC5cbmNsYXNzIExpbmVHYXAge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCBzaXplKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB9XG4gICAgc3RhdGljIHNhbWUoYSwgYikge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGdBID0gYVtpXSwgZ0IgPSBiW2ldO1xuICAgICAgICAgICAgaWYgKGdBLmZyb20gIT0gZ0IuZnJvbSB8fCBnQS50byAhPSBnQi50byB8fCBnQS5zaXplICE9IGdCLnNpemUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkcmF3KHdyYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IG5ldyBMaW5lR2FwV2lkZ2V0KHRoaXMuc2l6ZSwgd3JhcHBpbmcpIH0pLnJhbmdlKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgfVxufVxuY2xhc3MgTGluZUdhcFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHZlcnRpY2FsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMudmVydGljYWwgPSB2ZXJ0aWNhbDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLnNpemUgPT0gdGhpcy5zaXplICYmIG90aGVyLnZlcnRpY2FsID09IHRoaXMudmVydGljYWw7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmICh0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5zaXplICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWx0LnN0eWxlLndpZHRoID0gdGhpcy5zaXplICsgXCJweFwiO1xuICAgICAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IFwiMnB4XCI7XG4gICAgICAgICAgICBlbHQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIHRoaXMudmVydGljYWwgPyB0aGlzLnNpemUgOiAtMTsgfVxufVxuY2xhc3MgVmlld1N0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIC8vIFRoZXNlIGFyZSBjb250ZW50RE9NLWxvY2FsIGNvb3JkaW5hdGVzXG4gICAgICAgIHRoaXMucGl4ZWxWaWV3cG9ydCA9IHsgbGVmdDogMCwgcmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoLCB0b3A6IDAsIGJvdHRvbTogMCB9O1xuICAgICAgICB0aGlzLmluVmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMucGFkZGluZ1RvcCA9IDA7XG4gICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IDA7XG4gICAgICAgIHRoaXMuY29udGVudERPTVdpZHRoID0gMDtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5lZGl0b3JIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLmVkaXRvcldpZHRoID0gMDtcbiAgICAgICAgLy8gU2VlIFZQLk1heERPTUhlaWdodFxuICAgICAgICB0aGlzLnNjYWxlciA9IElkU2NhbGVyO1xuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCA9IG51bGw7XG4gICAgICAgIC8vIEJyaWVmbHkgc2V0IHRvIHRydWUgd2hlbiBwcmludGluZywgdG8gZGlzYWJsZSB2aWV3cG9ydCBsaW1pdGluZ1xuICAgICAgICB0aGlzLnByaW50aW5nID0gZmFsc2U7XG4gICAgICAgIC8vIEZsYWcgc2V0IHdoZW4gZWRpdG9yIGNvbnRlbnQgd2FzIHJlZHJhd24sIHNvIHRoYXQgdGhlIG5leHRcbiAgICAgICAgLy8gbWVhc3VyZSBzdGFnZSBrbm93cyBpdCBtdXN0IHJlYWQgRE9NIGxheW91dFxuICAgICAgICB0aGlzLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVmYXVsdFRleHREaXJlY3Rpb24gPSBEaXJlY3Rpb24uTFRSO1xuICAgICAgICB0aGlzLnZpc2libGVSYW5nZXMgPSBbXTtcbiAgICAgICAgLy8gQ3Vyc29yICdhc3NvYycgaXMgb25seSBzaWduaWZpY2FudCB3aGVuIHRoZSBjdXJzb3IgaXMgb24gYSBsaW5lXG4gICAgICAgIC8vIHdyYXAgcG9pbnQsIHdoZXJlIGl0IG11c3Qgc3RpY2sgdG8gdGhlIGNoYXJhY3RlciB0aGF0IGl0IGlzXG4gICAgICAgIC8vIGFzc29jaWF0ZWQgd2l0aC4gU2luY2UgYnJvd3NlcnMgZG9uJ3QgcHJvdmlkZSBhIHJlYXNvbmFibGVcbiAgICAgICAgLy8gaW50ZXJmYWNlIHRvIHNldCBvciBxdWVyeSB0aGlzLCB3aGVuIGEgc2VsZWN0aW9uIGlzIHNldCB0aGF0XG4gICAgICAgIC8vIG1pZ2h0IGNhdXNlIHRoaXMgdG8gYmUgc2lnbmlmaWNhbnQsIHRoaXMgZmxhZyBpcyBzZXQuIFRoZSBuZXh0XG4gICAgICAgIC8vIG1lYXN1cmUgcGhhc2Ugd2lsbCBjaGVjayB3aGV0aGVyIHRoZSBjdXJzb3IgaXMgb24gYSBsaW5lLXdyYXBwaW5nXG4gICAgICAgIC8vIGJvdW5kYXJ5IGFuZCwgaWYgc28sIHJlc2V0IGl0IHRvIG1ha2Ugc3VyZSBpdCBpcyBwb3NpdGlvbmVkIGluXG4gICAgICAgIC8vIHRoZSByaWdodCBwbGFjZS5cbiAgICAgICAgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gZmFsc2U7XG4gICAgICAgIGxldCBndWVzc1dyYXBwaW5nID0gc3RhdGUuZmFjZXQoY29udGVudEF0dHJpYnV0ZXMpLnNvbWUodiA9PiB0eXBlb2YgdiAhPSBcImZ1bmN0aW9uXCIgJiYgdi5jbGFzcyA9PSBcImNtLWxpbmVXcmFwcGluZ1wiKTtcbiAgICAgICAgdGhpcy5oZWlnaHRPcmFjbGUgPSBuZXcgSGVpZ2h0T3JhY2xlKGd1ZXNzV3JhcHBpbmcpO1xuICAgICAgICB0aGlzLnN0YXRlRGVjbyA9IHN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5maWx0ZXIoZCA9PiB0eXBlb2YgZCAhPSBcImZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLmhlaWdodE1hcCA9IEhlaWdodE1hcC5lbXB0eSgpLmFwcGx5Q2hhbmdlcyh0aGlzLnN0YXRlRGVjbywgVGV4dC5lbXB0eSwgdGhpcy5oZWlnaHRPcmFjbGUuc2V0RG9jKHN0YXRlLmRvYyksIFtuZXcgQ2hhbmdlZFJhbmdlKDAsIDAsIDAsIHN0YXRlLmRvYy5sZW5ndGgpXSk7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KDAsIG51bGwpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0TGluZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVGb3JWaWV3cG9ydCgpO1xuICAgICAgICB0aGlzLmxpbmVHYXBzID0gdGhpcy5lbnN1cmVMaW5lR2FwcyhbXSk7XG4gICAgICAgIHRoaXMubGluZUdhcERlY28gPSBEZWNvcmF0aW9uLnNldCh0aGlzLmxpbmVHYXBzLm1hcChnYXAgPT4gZ2FwLmRyYXcoZmFsc2UpKSk7XG4gICAgICAgIHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKTtcbiAgICB9XG4gICAgdXBkYXRlRm9yVmlld3BvcnQoKSB7XG4gICAgICAgIGxldCB2aWV3cG9ydHMgPSBbdGhpcy52aWV3cG9ydF0sIHsgbWFpbiB9ID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDE7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGkgPyBtYWluLmhlYWQgOiBtYWluLmFuY2hvcjtcbiAgICAgICAgICAgIGlmICghdmlld3BvcnRzLnNvbWUoKHsgZnJvbSwgdG8gfSkgPT4gcG9zID49IGZyb20gJiYgcG9zIDw9IHRvKSkge1xuICAgICAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLmxpbmVCbG9ja0F0KHBvcyk7XG4gICAgICAgICAgICAgICAgdmlld3BvcnRzLnB1c2gobmV3IFZpZXdwb3J0KGZyb20sIHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3cG9ydHMgPSB2aWV3cG9ydHMuc29ydCgoYSwgYikgPT4gYS5mcm9tIC0gYi5mcm9tKTtcbiAgICAgICAgdGhpcy5zY2FsZXIgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQgPD0gNzAwMDAwMCAvKiBWUC5NYXhET01IZWlnaHQgKi8gPyBJZFNjYWxlciA6XG4gICAgICAgICAgICBuZXcgQmlnU2NhbGVyKHRoaXMuaGVpZ2h0T3JhY2xlLCB0aGlzLmhlaWdodE1hcCwgdGhpcy52aWV3cG9ydHMpO1xuICAgIH1cbiAgICB1cGRhdGVWaWV3cG9ydExpbmVzKCkge1xuICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAuZm9yRWFjaExpbmUodGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2ModGhpcy5zdGF0ZS5kb2MpLCAwLCAwLCBibG9jayA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMucHVzaCh0aGlzLnNjYWxlci5zY2FsZSA9PSAxID8gYmxvY2sgOiBzY2FsZUJsb2NrKGJsb2NrLCB0aGlzLnNjYWxlcikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSwgc2Nyb2xsVGFyZ2V0ID0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gdXBkYXRlLnN0YXRlO1xuICAgICAgICBsZXQgcHJldkRlY28gPSB0aGlzLnN0YXRlRGVjbztcbiAgICAgICAgdGhpcy5zdGF0ZURlY28gPSB0aGlzLnN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5maWx0ZXIoZCA9PiB0eXBlb2YgZCAhPSBcImZ1bmN0aW9uXCIpO1xuICAgICAgICBsZXQgY29udGVudENoYW5nZXMgPSB1cGRhdGUuY2hhbmdlZFJhbmdlcztcbiAgICAgICAgbGV0IGhlaWdodENoYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjb250ZW50Q2hhbmdlcywgaGVpZ2h0UmVsZXZhbnREZWNvQ2hhbmdlcyhwcmV2RGVjbywgdGhpcy5zdGF0ZURlY28sIHVwZGF0ZSA/IHVwZGF0ZS5jaGFuZ2VzIDogQ2hhbmdlU2V0LmVtcHR5KHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpKTtcbiAgICAgICAgbGV0IHByZXZIZWlnaHQgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gdGhpcy5oZWlnaHRNYXAuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCB1cGRhdGUuc3RhcnRTdGF0ZS5kb2MsIHRoaXMuaGVpZ2h0T3JhY2xlLnNldERvYyh0aGlzLnN0YXRlLmRvYyksIGhlaWdodENoYW5nZXMpO1xuICAgICAgICBpZiAodGhpcy5oZWlnaHRNYXAuaGVpZ2h0ICE9IHByZXZIZWlnaHQpXG4gICAgICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgbGV0IHZpZXdwb3J0ID0gaGVpZ2h0Q2hhbmdlcy5sZW5ndGggPyB0aGlzLm1hcFZpZXdwb3J0KHRoaXMudmlld3BvcnQsIHVwZGF0ZS5jaGFuZ2VzKSA6IHRoaXMudmlld3BvcnQ7XG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQgJiYgKHNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDwgdmlld3BvcnQuZnJvbSB8fCBzY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA+IHZpZXdwb3J0LnRvKSB8fFxuICAgICAgICAgICAgIXRoaXMudmlld3BvcnRJc0FwcHJvcHJpYXRlKHZpZXdwb3J0KSlcbiAgICAgICAgICAgIHZpZXdwb3J0ID0gdGhpcy5nZXRWaWV3cG9ydCgwLCBzY3JvbGxUYXJnZXQpO1xuICAgICAgICBsZXQgdXBkYXRlTGluZXMgPSAhdXBkYXRlLmNoYW5nZXMuZW1wdHkgfHwgKHVwZGF0ZS5mbGFncyAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pIHx8XG4gICAgICAgICAgICB2aWV3cG9ydC5mcm9tICE9IHRoaXMudmlld3BvcnQuZnJvbSB8fCB2aWV3cG9ydC50byAhPSB0aGlzLnZpZXdwb3J0LnRvO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcbiAgICAgICAgaWYgKHVwZGF0ZUxpbmVzKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aCB8fCB0aGlzLnZpZXdwb3J0LnRvIC0gdGhpcy52aWV3cG9ydC5mcm9tID4gKDIwMDAgLyogTEcuTWFyZ2luICovIDw8IDEpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5lR2Fwcyh0aGlzLmVuc3VyZUxpbmVHYXBzKHRoaXMubWFwTGluZUdhcHModGhpcy5saW5lR2FwcywgdXBkYXRlLmNoYW5nZXMpKSk7XG4gICAgICAgIHVwZGF0ZS5mbGFncyB8PSB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQpXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCA9IHNjcm9sbFRhcmdldDtcbiAgICAgICAgaWYgKCF0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgJiYgdXBkYXRlLnNlbGVjdGlvblNldCAmJiB1cGRhdGUudmlldy5saW5lV3JhcHBpbmcgJiZcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJiB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uYXNzb2MgJiZcbiAgICAgICAgICAgICF1cGRhdGUuc3RhdGUuZmFjZXQobmF0aXZlU2VsZWN0aW9uSGlkZGVuKSlcbiAgICAgICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IHRydWU7XG4gICAgfVxuICAgIG1lYXN1cmUodmlldykge1xuICAgICAgICBsZXQgZG9tID0gdmlldy5jb250ZW50RE9NLCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSk7XG4gICAgICAgIGxldCBvcmFjbGUgPSB0aGlzLmhlaWdodE9yYWNsZTtcbiAgICAgICAgbGV0IHdoaXRlU3BhY2UgPSBzdHlsZS53aGl0ZVNwYWNlO1xuICAgICAgICB0aGlzLmRlZmF1bHRUZXh0RGlyZWN0aW9uID0gc3R5bGUuZGlyZWN0aW9uID09IFwicnRsXCIgPyBEaXJlY3Rpb24uUlRMIDogRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgbGV0IHJlZnJlc2ggPSB0aGlzLmhlaWdodE9yYWNsZS5tdXN0UmVmcmVzaEZvcldyYXBwaW5nKHdoaXRlU3BhY2UpO1xuICAgICAgICBsZXQgZG9tUmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IG1lYXN1cmVDb250ZW50ID0gcmVmcmVzaCB8fCB0aGlzLm11c3RNZWFzdXJlQ29udGVudCB8fCB0aGlzLmNvbnRlbnRET01IZWlnaHQgIT0gZG9tUmVjdC5oZWlnaHQ7XG4gICAgICAgIHRoaXMuY29udGVudERPTUhlaWdodCA9IGRvbVJlY3QuaGVpZ2h0O1xuICAgICAgICB0aGlzLm11c3RNZWFzdXJlQ29udGVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVzdWx0ID0gMCwgYmlhcyA9IDA7XG4gICAgICAgIC8vIFZlcnRpY2FsIHBhZGRpbmdcbiAgICAgICAgbGV0IHBhZGRpbmdUb3AgPSBwYXJzZUludChzdHlsZS5wYWRkaW5nVG9wKSB8fCAwLCBwYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoc3R5bGUucGFkZGluZ0JvdHRvbSkgfHwgMDtcbiAgICAgICAgaWYgKHRoaXMucGFkZGluZ1RvcCAhPSBwYWRkaW5nVG9wIHx8IHRoaXMucGFkZGluZ0JvdHRvbSAhPSBwYWRkaW5nQm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wO1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gcGFkZGluZ0JvdHRvbTtcbiAgICAgICAgICAgIHJlc3VsdCB8PSA4IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi8gfCAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVkaXRvcldpZHRoICE9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICBpZiAob3JhY2xlLmxpbmVXcmFwcGluZylcbiAgICAgICAgICAgICAgICBtZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVkaXRvcldpZHRoID0gdmlldy5zY3JvbGxET00uY2xpZW50V2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBpeGVsIHZpZXdwb3J0XG4gICAgICAgIGxldCBwaXhlbFZpZXdwb3J0ID0gKHRoaXMucHJpbnRpbmcgPyBmdWxsUGl4ZWxSYW5nZSA6IHZpc2libGVQaXhlbFJhbmdlKShkb20sIHRoaXMucGFkZGluZ1RvcCk7XG4gICAgICAgIGxldCBkVG9wID0gcGl4ZWxWaWV3cG9ydC50b3AgLSB0aGlzLnBpeGVsVmlld3BvcnQudG9wLCBkQm90dG9tID0gcGl4ZWxWaWV3cG9ydC5ib3R0b20gLSB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tO1xuICAgICAgICB0aGlzLnBpeGVsVmlld3BvcnQgPSBwaXhlbFZpZXdwb3J0O1xuICAgICAgICBsZXQgaW5WaWV3ID0gdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbSA+IHRoaXMucGl4ZWxWaWV3cG9ydC50b3AgJiYgdGhpcy5waXhlbFZpZXdwb3J0LnJpZ2h0ID4gdGhpcy5waXhlbFZpZXdwb3J0LmxlZnQ7XG4gICAgICAgIGlmIChpblZpZXcgIT0gdGhpcy5pblZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5WaWV3ID0gaW5WaWV3O1xuICAgICAgICAgICAgaWYgKGluVmlldylcbiAgICAgICAgICAgICAgICBtZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmluVmlldyAmJiAhdGhpcy5zY3JvbGxUYXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IGNvbnRlbnRXaWR0aCA9IGRvbVJlY3Qud2lkdGg7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET01XaWR0aCAhPSBjb250ZW50V2lkdGggfHwgdGhpcy5lZGl0b3JIZWlnaHQgIT0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET01XaWR0aCA9IGRvbVJlY3Qud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmVkaXRvckhlaWdodCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIHJlc3VsdCB8PSA4IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lYXN1cmVDb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgbGluZUhlaWdodHMgPSB2aWV3LmRvY1ZpZXcubWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cyh0aGlzLnZpZXdwb3J0KTtcbiAgICAgICAgICAgIGlmIChvcmFjbGUubXVzdFJlZnJlc2hGb3JIZWlnaHRzKGxpbmVIZWlnaHRzKSlcbiAgICAgICAgICAgICAgICByZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChyZWZyZXNoIHx8IG9yYWNsZS5saW5lV3JhcHBpbmcgJiYgTWF0aC5hYnMoY29udGVudFdpZHRoIC0gdGhpcy5jb250ZW50RE9NV2lkdGgpID4gb3JhY2xlLmNoYXJXaWR0aCkge1xuICAgICAgICAgICAgICAgIGxldCB7IGxpbmVIZWlnaHQsIGNoYXJXaWR0aCB9ID0gdmlldy5kb2NWaWV3Lm1lYXN1cmVUZXh0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSBsaW5lSGVpZ2h0ID4gMCAmJiBvcmFjbGUucmVmcmVzaCh3aGl0ZVNwYWNlLCBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIGNvbnRlbnRXaWR0aCAvIGNoYXJXaWR0aCwgbGluZUhlaWdodHMpO1xuICAgICAgICAgICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZG9jVmlldy5taW5XaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCB8PSA4IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRUb3AgPiAwICYmIGRCb3R0b20gPiAwKVxuICAgICAgICAgICAgICAgIGJpYXMgPSBNYXRoLm1heChkVG9wLCBkQm90dG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGRUb3AgPCAwICYmIGRCb3R0b20gPCAwKVxuICAgICAgICAgICAgICAgIGJpYXMgPSBNYXRoLm1pbihkVG9wLCBkQm90dG9tKTtcbiAgICAgICAgICAgIG9yYWNsZS5oZWlnaHRDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCB2cCBvZiB0aGlzLnZpZXdwb3J0cykge1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHRzID0gdnAuZnJvbSA9PSB0aGlzLnZpZXdwb3J0LmZyb20gPyBsaW5lSGVpZ2h0cyA6IHZpZXcuZG9jVmlldy5tZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHZwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodE1hcCA9IChyZWZyZXNoID8gSGVpZ2h0TWFwLmVtcHR5KCkuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCBUZXh0LmVtcHR5LCB0aGlzLmhlaWdodE9yYWNsZSwgW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoKV0pIDogdGhpcy5oZWlnaHRNYXApLnVwZGF0ZUhlaWdodChvcmFjbGUsIDAsIHJlZnJlc2gsIG5ldyBNZWFzdXJlZEhlaWdodHModnAuZnJvbSwgaGVpZ2h0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9yYWNsZS5oZWlnaHRDaGFuZ2VkKVxuICAgICAgICAgICAgICAgIHJlc3VsdCB8PSAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2aWV3cG9ydENoYW5nZSA9ICF0aGlzLnZpZXdwb3J0SXNBcHByb3ByaWF0ZSh0aGlzLnZpZXdwb3J0LCBiaWFzKSB8fFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQgJiYgKHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPCB0aGlzLnZpZXdwb3J0LmZyb20gfHxcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldC5yYW5nZS5oZWFkID4gdGhpcy52aWV3cG9ydC50byk7XG4gICAgICAgIGlmICh2aWV3cG9ydENoYW5nZSlcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KGJpYXMsIHRoaXMuc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgdGhpcy51cGRhdGVGb3JWaWV3cG9ydCgpO1xuICAgICAgICBpZiAoKHJlc3VsdCAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pIHx8IHZpZXdwb3J0Q2hhbmdlKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aCB8fCB0aGlzLnZpZXdwb3J0LnRvIC0gdGhpcy52aWV3cG9ydC5mcm9tID4gKDIwMDAgLyogTEcuTWFyZ2luICovIDw8IDEpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5lR2Fwcyh0aGlzLmVuc3VyZUxpbmVHYXBzKHJlZnJlc2ggPyBbXSA6IHRoaXMubGluZUdhcHMsIHZpZXcpKTtcbiAgICAgICAgcmVzdWx0IHw9IHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYykge1xuICAgICAgICAgICAgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGRvbmUgaW4gdGhlIHJlYWQgc3RhZ2UsIGJlY2F1c2UgbW92aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIHRvIGEgbGluZSBlbmQgaXMgZ29pbmcgdG8gdHJpZ2dlciBhIGxheW91dCBhbnl3YXksIHNvIGl0XG4gICAgICAgICAgICAvLyBjYW4ndCBiZSBhIHB1cmUgd3JpdGUuIEl0IHNob3VsZCBiZSByYXJlIHRoYXQgaXQgZG9lcyBhbnlcbiAgICAgICAgICAgIC8vIHdyaXRpbmcuXG4gICAgICAgICAgICB2aWV3LmRvY1ZpZXcuZW5mb3JjZUN1cnNvckFzc29jKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0IHZpc2libGVUb3AoKSB7IHJldHVybiB0aGlzLnNjYWxlci5mcm9tRE9NKHRoaXMucGl4ZWxWaWV3cG9ydC50b3ApOyB9XG4gICAgZ2V0IHZpc2libGVCb3R0b20oKSB7IHJldHVybiB0aGlzLnNjYWxlci5mcm9tRE9NKHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20pOyB9XG4gICAgZ2V0Vmlld3BvcnQoYmlhcywgc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBkaXZpZGUgVlAuTWFyZ2luIGJldHdlZW4gdGhlIHRvcCBhbmQgdGhlXG4gICAgICAgIC8vIGJvdHRvbSwgZGVwZW5kaW5nIG9uIHRoZSBiaWFzICh0aGUgY2hhbmdlIGluIHZpZXdwb3J0IHBvc2l0aW9uXG4gICAgICAgIC8vIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZSkuIEl0J2xsIGhvbGQgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICAgIGxldCBtYXJnaW5Ub3AgPSAwLjUgLSBNYXRoLm1heCgtMC41LCBNYXRoLm1pbigwLjUsIGJpYXMgLyAxMDAwIC8qIFZQLk1hcmdpbiAqLyAvIDIpKTtcbiAgICAgICAgbGV0IG1hcCA9IHRoaXMuaGVpZ2h0TWFwLCBvcmFjbGUgPSB0aGlzLmhlaWdodE9yYWNsZTtcbiAgICAgICAgbGV0IHsgdmlzaWJsZVRvcCwgdmlzaWJsZUJvdHRvbSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KG1hcC5saW5lQXQodmlzaWJsZVRvcCAtIG1hcmdpblRvcCAqIDEwMDAgLyogVlAuTWFyZ2luICovLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkuZnJvbSwgbWFwLmxpbmVBdCh2aXNpYmxlQm90dG9tICsgKDEgLSBtYXJnaW5Ub3ApICogMTAwMCAvKiBWUC5NYXJnaW4gKi8sIFF1ZXJ5VHlwZS5CeUhlaWdodCwgb3JhY2xlLCAwLCAwKS50byk7XG4gICAgICAgIC8vIElmIHNjcm9sbFRhcmdldCBpcyBnaXZlbiwgbWFrZSBzdXJlIHRoZSB2aWV3cG9ydCBpbmNsdWRlcyB0aGF0IHBvc2l0aW9uXG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgIGxldCB7IGhlYWQgfSA9IHNjcm9sbFRhcmdldC5yYW5nZTtcbiAgICAgICAgICAgIGlmIChoZWFkIDwgdmlld3BvcnQuZnJvbSB8fCBoZWFkID4gdmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgdmlld0hlaWdodCA9IE1hdGgubWluKHRoaXMuZWRpdG9ySGVpZ2h0LCB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tIC0gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCk7XG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrID0gbWFwLmxpbmVBdChoZWFkLCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgMCwgMCksIHRvcFBvcztcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0LnkgPT0gXCJjZW50ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gKGJsb2NrLnRvcCArIGJsb2NrLmJvdHRvbSkgLyAyIC0gdmlld0hlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Nyb2xsVGFyZ2V0LnkgPT0gXCJzdGFydFwiIHx8IHNjcm9sbFRhcmdldC55ID09IFwibmVhcmVzdFwiICYmIGhlYWQgPCB2aWV3cG9ydC5mcm9tKVxuICAgICAgICAgICAgICAgICAgICB0b3BQb3MgPSBibG9jay50b3A7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0b3BQb3MgPSBibG9jay5ib3R0b20gLSB2aWV3SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KG1hcC5saW5lQXQodG9wUG9zIC0gMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkuZnJvbSwgbWFwLmxpbmVBdCh0b3BQb3MgKyB2aWV3SGVpZ2h0ICsgMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3cG9ydDtcbiAgICB9XG4gICAgbWFwVmlld3BvcnQodmlld3BvcnQsIGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC5mcm9tLCAtMSksIHRvID0gY2hhbmdlcy5tYXBQb3Modmlld3BvcnQudG8sIDEpO1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdwb3J0KHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKS5mcm9tLCB0aGlzLmhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLnRvKTtcbiAgICB9XG4gICAgLy8gQ2hlY2tzIGlmIGEgZ2l2ZW4gdmlld3BvcnQgY292ZXJzIHRoZSB2aXNpYmxlIHBhcnQgb2YgdGhlXG4gICAgLy8gZG9jdW1lbnQgYW5kIG5vdCB0b28gbXVjaCBiZXlvbmQgdGhhdC5cbiAgICB2aWV3cG9ydElzQXBwcm9wcmlhdGUoeyBmcm9tLCB0byB9LCBiaWFzID0gMCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCB7IHRvcCB9ID0gdGhpcy5oZWlnaHRNYXAubGluZUF0KGZyb20sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApO1xuICAgICAgICBsZXQgeyBib3R0b20gfSA9IHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0bywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCk7XG4gICAgICAgIGxldCB7IHZpc2libGVUb3AsIHZpc2libGVCb3R0b20gfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoZnJvbSA9PSAwIHx8IHRvcCA8PSB2aXNpYmxlVG9wIC0gTWF0aC5tYXgoMTAgLyogVlAuTWluQ292ZXJNYXJnaW4gKi8sIE1hdGgubWluKC1iaWFzLCAyNTAgLyogVlAuTWF4Q292ZXJNYXJnaW4gKi8pKSkgJiZcbiAgICAgICAgICAgICh0byA9PSB0aGlzLnN0YXRlLmRvYy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICBib3R0b20gPj0gdmlzaWJsZUJvdHRvbSArIE1hdGgubWF4KDEwIC8qIFZQLk1pbkNvdmVyTWFyZ2luICovLCBNYXRoLm1pbihiaWFzLCAyNTAgLyogVlAuTWF4Q292ZXJNYXJnaW4gKi8pKSkgJiZcbiAgICAgICAgICAgICh0b3AgPiB2aXNpYmxlVG9wIC0gMiAqIDEwMDAgLyogVlAuTWFyZ2luICovICYmIGJvdHRvbSA8IHZpc2libGVCb3R0b20gKyAyICogMTAwMCAvKiBWUC5NYXJnaW4gKi8pO1xuICAgIH1cbiAgICBtYXBMaW5lR2FwcyhnYXBzLCBjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghZ2Fwcy5sZW5ndGggfHwgY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBnYXBzO1xuICAgICAgICBsZXQgbWFwcGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGdhcCBvZiBnYXBzKVxuICAgICAgICAgICAgaWYgKCFjaGFuZ2VzLnRvdWNoZXNSYW5nZShnYXAuZnJvbSwgZ2FwLnRvKSlcbiAgICAgICAgICAgICAgICBtYXBwZWQucHVzaChuZXcgTGluZUdhcChjaGFuZ2VzLm1hcFBvcyhnYXAuZnJvbSksIGNoYW5nZXMubWFwUG9zKGdhcC50byksIGdhcC5zaXplKSk7XG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfVxuICAgIC8vIENvbXB1dGVzIHBvc2l0aW9ucyBpbiB0aGUgdmlld3BvcnQgd2hlcmUgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhXG4gICAgLy8gbGluZSBzaG91bGQgYmUgaGlkZGVuLCB0cnlpbmcgdG8gcmV1c2UgZXhpc3RpbmcgbGluZSBnYXBzIHdoZW5cbiAgICAvLyBhcHByb3ByaWF0ZSB0byBhdm9pZCB1bm5lY2Nlc2FyeSByZWRyYXdzLlxuICAgIC8vIFVzZXMgY3J1ZGUgY2hhcmFjdGVyLWNvdW50aW5nIGZvciB0aGUgcG9zaXRpb25pbmcgYW5kIHNpemluZyxcbiAgICAvLyBzaW5jZSBhY3R1YWwgRE9NIGNvb3JkaW5hdGVzIGFyZW4ndCBhbHdheXMgYXZhaWxhYmxlIGFuZFxuICAgIC8vIHByZWRpY3RhYmxlLiBSZWxpZXMgb24gZ2VuZXJvdXMgbWFyZ2lucyAoc2VlIExHLk1hcmdpbikgdG8gaGlkZVxuICAgIC8vIHRoZSBhcnRpZmFjdHMgdGhpcyBtaWdodCBwcm9kdWNlIGZyb20gdGhlIHVzZXIuXG4gICAgZW5zdXJlTGluZUdhcHMoY3VycmVudCwgbWF5TWVhc3VyZSkge1xuICAgICAgICBsZXQgd3JhcHBpbmcgPSB0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmc7XG4gICAgICAgIGxldCBtYXJnaW4gPSB3cmFwcGluZyA/IDEwMDAwIC8qIExHLk1hcmdpbldyYXAgKi8gOiAyMDAwIC8qIExHLk1hcmdpbiAqLywgaGFsZk1hcmdpbiA9IG1hcmdpbiA+PiAxLCBkb3VibGVNYXJnaW4gPSBtYXJnaW4gPDwgMTtcbiAgICAgICAgLy8gVGhlIG5vbi13cmFwcGluZyBsb2dpYyB3b24ndCB3b3JrIGF0IGFsbCBpbiBwcmVkb21pbmFudGx5IHJpZ2h0LXRvLWxlZnQgdGV4dC5cbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdFRleHREaXJlY3Rpb24gIT0gRGlyZWN0aW9uLkxUUiAmJiAhd3JhcHBpbmcpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBnYXBzID0gW107XG4gICAgICAgIGxldCBhZGRHYXAgPSAoZnJvbSwgdG8sIGxpbmUsIHN0cnVjdHVyZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRvIC0gZnJvbSA8IGhhbGZNYXJnaW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHNlbCA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uLm1haW4sIGF2b2lkID0gW3NlbC5mcm9tXTtcbiAgICAgICAgICAgIGlmICghc2VsLmVtcHR5KVxuICAgICAgICAgICAgICAgIGF2b2lkLnB1c2goc2VsLnRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBhdm9pZCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tICYmIHBvcyA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdhcChmcm9tLCBwb3MgLSAxMCAvKiBMRy5TZWxlY3Rpb25NYXJnaW4gKi8sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdhcChwb3MgKyAxMCAvKiBMRy5TZWxlY3Rpb25NYXJnaW4gKi8sIHRvLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGdhcCA9IGZpbmQoY3VycmVudCwgZ2FwID0+IGdhcC5mcm9tID49IGxpbmUuZnJvbSAmJiBnYXAudG8gPD0gbGluZS50byAmJlxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGdhcC5mcm9tIC0gZnJvbSkgPCBoYWxmTWFyZ2luICYmIE1hdGguYWJzKGdhcC50byAtIHRvKSA8IGhhbGZNYXJnaW4gJiZcbiAgICAgICAgICAgICAgICAhYXZvaWQuc29tZShwb3MgPT4gZ2FwLmZyb20gPCBwb3MgJiYgZ2FwLnRvID4gcG9zKSk7XG4gICAgICAgICAgICBpZiAoIWdhcCkge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gc2Nyb2xsaW5nIGRvd24sIHNuYXAgZ2FwIGVuZHMgdG8gbGluZSBzdGFydHMgdG8gYXZvaWQgc2hpZnRzIGluIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgaWYgKHRvIDwgbGluZS50byAmJiBtYXlNZWFzdXJlICYmIHdyYXBwaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIG1heU1lYXN1cmUudmlzaWJsZVJhbmdlcy5zb21lKHIgPT4gci5mcm9tIDw9IHRvICYmIHIudG8gPj0gdG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lU3RhcnQgPSBtYXlNZWFzdXJlLm1vdmVUb0xpbmVCb3VuZGFyeShFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHRvKSwgZmFsc2UsIHRydWUpLmhlYWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU3RhcnQgPiBmcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG8gPSBsaW5lU3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdhcCA9IG5ldyBMaW5lR2FwKGZyb20sIHRvLCB0aGlzLmdhcFNpemUobGluZSwgZnJvbSwgdG8sIHN0cnVjdHVyZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2Fwcy5wdXNoKGdhcCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy52aWV3cG9ydExpbmVzKSB7XG4gICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPCBkb3VibGVNYXJnaW4pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgc3RydWN0dXJlID0gbGluZVN0cnVjdHVyZShsaW5lLmZyb20sIGxpbmUudG8sIHRoaXMuc3RhdGVEZWNvKTtcbiAgICAgICAgICAgIGlmIChzdHJ1Y3R1cmUudG90YWwgPCBkb3VibGVNYXJnaW4pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5zY3JvbGxUYXJnZXQgPyB0aGlzLnNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDogbnVsbDtcbiAgICAgICAgICAgIGxldCB2aWV3RnJvbSwgdmlld1RvO1xuICAgICAgICAgICAgaWYgKHdyYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmdpbkhlaWdodCA9IChtYXJnaW4gLyB0aGlzLmhlaWdodE9yYWNsZS5saW5lTGVuZ3RoKSAqIHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgbGV0IHRvcCwgYm90O1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RnJhYyA9IGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZUZyYWMgPSAoKHRoaXMudmlzaWJsZUJvdHRvbSAtIHRoaXMudmlzaWJsZVRvcCkgLyAyICsgbWFyZ2luSGVpZ2h0KSAvIGxpbmUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSB0YXJnZXRGcmFjIC0gc3BhY2VGcmFjO1xuICAgICAgICAgICAgICAgICAgICBib3QgPSB0YXJnZXRGcmFjICsgc3BhY2VGcmFjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gKHRoaXMudmlzaWJsZVRvcCAtIGxpbmUudG9wIC0gbWFyZ2luSGVpZ2h0KSAvIGxpbmUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBib3QgPSAodGhpcy52aXNpYmxlQm90dG9tIC0gbGluZS50b3AgKyBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgdG9wKTtcbiAgICAgICAgICAgICAgICB2aWV3VG8gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCBib3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsV2lkdGggPSBzdHJ1Y3R1cmUudG90YWwgKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmdpbldpZHRoID0gbWFyZ2luICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoO1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0LCByaWdodDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldEZyYWMgPSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VGcmFjID0gKCh0aGlzLnBpeGVsVmlld3BvcnQucmlnaHQgLSB0aGlzLnBpeGVsVmlld3BvcnQubGVmdCkgLyAyICsgbWFyZ2luV2lkdGgpIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHRhcmdldEZyYWMgLSBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGFyZ2V0RnJhYyArIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSAodGhpcy5waXhlbFZpZXdwb3J0LmxlZnQgLSBtYXJnaW5XaWR0aCkgLyB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9ICh0aGlzLnBpeGVsVmlld3BvcnQucmlnaHQgKyBtYXJnaW5XaWR0aCkgLyB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aWV3RnJvbSA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIGxlZnQpO1xuICAgICAgICAgICAgICAgIHZpZXdUbyA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIHJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3RnJvbSA+IGxpbmUuZnJvbSlcbiAgICAgICAgICAgICAgICBhZGRHYXAobGluZS5mcm9tLCB2aWV3RnJvbSwgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgIGlmICh2aWV3VG8gPCBsaW5lLnRvKVxuICAgICAgICAgICAgICAgIGFkZEdhcCh2aWV3VG8sIGxpbmUudG8sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdhcHM7XG4gICAgfVxuICAgIGdhcFNpemUobGluZSwgZnJvbSwgdG8sIHN0cnVjdHVyZSkge1xuICAgICAgICBsZXQgZnJhY3Rpb24gPSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCB0bykgLSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCBmcm9tKTtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmUuaGVpZ2h0ICogZnJhY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0dXJlLnRvdGFsICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoICogZnJhY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlTGluZUdhcHMoZ2Fwcykge1xuICAgICAgICBpZiAoIUxpbmVHYXAuc2FtZShnYXBzLCB0aGlzLmxpbmVHYXBzKSkge1xuICAgICAgICAgICAgdGhpcy5saW5lR2FwcyA9IGdhcHM7XG4gICAgICAgICAgICB0aGlzLmxpbmVHYXBEZWNvID0gRGVjb3JhdGlvbi5zZXQoZ2Fwcy5tYXAoZ2FwID0+IGdhcC5kcmF3KHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wdXRlVmlzaWJsZVJhbmdlcygpIHtcbiAgICAgICAgbGV0IGRlY28gPSB0aGlzLnN0YXRlRGVjbztcbiAgICAgICAgaWYgKHRoaXMubGluZUdhcHMubGVuZ3RoKVxuICAgICAgICAgICAgZGVjbyA9IGRlY28uY29uY2F0KHRoaXMubGluZUdhcERlY28pO1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIFJhbmdlU2V0LnNwYW5zKGRlY28sIHRoaXMudmlld3BvcnQuZnJvbSwgdGhpcy52aWV3cG9ydC50bywge1xuICAgICAgICAgICAgc3Bhbihmcm9tLCB0bykgeyByYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pOyB9LFxuICAgICAgICAgICAgcG9pbnQoKSB7IH1cbiAgICAgICAgfSwgMjApO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IHJhbmdlcy5sZW5ndGggIT0gdGhpcy52aXNpYmxlUmFuZ2VzLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2VzLnNvbWUoKHIsIGkpID0+IHIuZnJvbSAhPSByYW5nZXNbaV0uZnJvbSB8fCByLnRvICE9IHJhbmdlc1tpXS50byk7XG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQgPyA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8gOiAwO1xuICAgIH1cbiAgICBsaW5lQmxvY2tBdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIChwb3MgPj0gdGhpcy52aWV3cG9ydC5mcm9tICYmIHBvcyA8PSB0aGlzLnZpZXdwb3J0LnRvICYmIHRoaXMudmlld3BvcnRMaW5lcy5maW5kKGIgPT4gYi5mcm9tIDw9IHBvcyAmJiBiLnRvID49IHBvcykpIHx8XG4gICAgICAgICAgICBzY2FsZUJsb2NrKHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChwb3MsIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLCB0aGlzLnNjYWxlcik7XG4gICAgfVxuICAgIGxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICByZXR1cm4gc2NhbGVCbG9jayh0aGlzLmhlaWdodE1hcC5saW5lQXQodGhpcy5zY2FsZXIuZnJvbURPTShoZWlnaHQpLCBRdWVyeVR5cGUuQnlIZWlnaHQsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICAgIH1cbiAgICBlbGVtZW50QXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBzY2FsZUJsb2NrKHRoaXMuaGVpZ2h0TWFwLmJsb2NrQXQodGhpcy5zY2FsZXIuZnJvbURPTShoZWlnaHQpLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgZ2V0IGRvY0hlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVyLnRvRE9NKHRoaXMuaGVpZ2h0TWFwLmhlaWdodCk7XG4gICAgfVxuICAgIGdldCBjb250ZW50SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NIZWlnaHQgKyB0aGlzLnBhZGRpbmdUb3AgKyB0aGlzLnBhZGRpbmdCb3R0b207XG4gICAgfVxufVxuY2xhc3MgVmlld3BvcnQge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG5mdW5jdGlvbiBsaW5lU3RydWN0dXJlKGZyb20sIHRvLCBzdGF0ZURlY28pIHtcbiAgICBsZXQgcmFuZ2VzID0gW10sIHBvcyA9IGZyb20sIHRvdGFsID0gMDtcbiAgICBSYW5nZVNldC5zcGFucyhzdGF0ZURlY28sIGZyb20sIHRvLCB7XG4gICAgICAgIHNwYW4oKSB7IH0sXG4gICAgICAgIHBvaW50KGZyb20sIHRvKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IHBvcykge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogcG9zLCB0bzogZnJvbSB9KTtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBmcm9tIC0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gdG87XG4gICAgICAgIH1cbiAgICB9LCAyMCk7IC8vIFdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiBjb2xsYXBzZWQgcmFuZ2VzIG9mIGEgc2lnbmlmaWNhbnQgc2l6ZVxuICAgIGlmIChwb3MgPCB0bykge1xuICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IHBvcywgdG8gfSk7XG4gICAgICAgIHRvdGFsICs9IHRvIC0gcG9zO1xuICAgIH1cbiAgICByZXR1cm4geyB0b3RhbCwgcmFuZ2VzIH07XG59XG5mdW5jdGlvbiBmaW5kUG9zaXRpb24oeyB0b3RhbCwgcmFuZ2VzIH0sIHJhdGlvKSB7XG4gICAgaWYgKHJhdGlvIDw9IDApXG4gICAgICAgIHJldHVybiByYW5nZXNbMF0uZnJvbTtcbiAgICBpZiAocmF0aW8gPj0gMSlcbiAgICAgICAgcmV0dXJuIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgbGV0IGRpc3QgPSBNYXRoLmZsb29yKHRvdGFsICogcmF0aW8pO1xuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZXNbaV0sIHNpemUgPSB0byAtIGZyb207XG4gICAgICAgIGlmIChkaXN0IDw9IHNpemUpXG4gICAgICAgICAgICByZXR1cm4gZnJvbSArIGRpc3Q7XG4gICAgICAgIGRpc3QgLT0gc2l6ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCBwb3MpIHtcbiAgICBsZXQgY291bnRlZCA9IDA7XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHN0cnVjdHVyZS5yYW5nZXMpIHtcbiAgICAgICAgaWYgKHBvcyA8PSB0bykge1xuICAgICAgICAgICAgY291bnRlZCArPSBwb3MgLSBmcm9tO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRlZCArPSB0byAtIGZyb207XG4gICAgfVxuICAgIHJldHVybiBjb3VudGVkIC8gc3RydWN0dXJlLnRvdGFsO1xufVxuZnVuY3Rpb24gZmluZChhcnJheSwgZikge1xuICAgIGZvciAobGV0IHZhbCBvZiBhcnJheSlcbiAgICAgICAgaWYgKGYodmFsKSlcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8vIERvbid0IHNjYWxlIHdoZW4gdGhlIGRvY3VtZW50IGhlaWdodCBpcyB3aXRoaW4gdGhlIHJhbmdlIG9mIHdoYXRcbi8vIHRoZSBET00gY2FuIGhhbmRsZS5cbmNvbnN0IElkU2NhbGVyID0ge1xuICAgIHRvRE9NKG4pIHsgcmV0dXJuIG47IH0sXG4gICAgZnJvbURPTShuKSB7IHJldHVybiBuOyB9LFxuICAgIHNjYWxlOiAxXG59O1xuLy8gV2hlbiB0aGUgaGVpZ2h0IGlzIHRvbyBiaWcgKD4gVlAuTWF4RE9NSGVpZ2h0KSwgc2NhbGUgZG93biB0aGVcbi8vIHJlZ2lvbnMgb3V0c2lkZSB0aGUgdmlld3BvcnRzIHNvIHRoYXQgdGhlIHRvdGFsIGhlaWdodCBpc1xuLy8gVlAuTWF4RE9NSGVpZ2h0LlxuY2xhc3MgQmlnU2NhbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcmFjbGUsIGhlaWdodE1hcCwgdmlld3BvcnRzKSB7XG4gICAgICAgIGxldCB2cEhlaWdodCA9IDAsIGJhc2UgPSAwLCBkb21CYXNlID0gMDtcbiAgICAgICAgdGhpcy52aWV3cG9ydHMgPSB2aWV3cG9ydHMubWFwKCh7IGZyb20sIHRvIH0pID0+IHtcbiAgICAgICAgICAgIGxldCB0b3AgPSBoZWlnaHRNYXAubGluZUF0KGZyb20sIFF1ZXJ5VHlwZS5CeVBvcywgb3JhY2xlLCAwLCAwKS50b3A7XG4gICAgICAgICAgICBsZXQgYm90dG9tID0gaGVpZ2h0TWFwLmxpbmVBdCh0bywgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIDAsIDApLmJvdHRvbTtcbiAgICAgICAgICAgIHZwSGVpZ2h0ICs9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb20sIHRvLCB0b3AsIGJvdHRvbSwgZG9tVG9wOiAwLCBkb21Cb3R0b206IDAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2NhbGUgPSAoNzAwMDAwMCAvKiBWUC5NYXhET01IZWlnaHQgKi8gLSB2cEhlaWdodCkgLyAoaGVpZ2h0TWFwLmhlaWdodCAtIHZwSGVpZ2h0KTtcbiAgICAgICAgZm9yIChsZXQgb2JqIG9mIHRoaXMudmlld3BvcnRzKSB7XG4gICAgICAgICAgICBvYmouZG9tVG9wID0gZG9tQmFzZSArIChvYmoudG9wIC0gYmFzZSkgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgZG9tQmFzZSA9IG9iai5kb21Cb3R0b20gPSBvYmouZG9tVG9wICsgKG9iai5ib3R0b20gLSBvYmoudG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSBvYmouYm90dG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvRE9NKG4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGJhc2UgPSAwLCBkb21CYXNlID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZwID0gaSA8IHRoaXMudmlld3BvcnRzLmxlbmd0aCA/IHRoaXMudmlld3BvcnRzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghdnAgfHwgbiA8IHZwLnRvcClcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQmFzZSArIChuIC0gYmFzZSkgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgaWYgKG4gPD0gdnAuYm90dG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiB2cC5kb21Ub3AgKyAobiAtIHZwLnRvcCk7XG4gICAgICAgICAgICBiYXNlID0gdnAuYm90dG9tO1xuICAgICAgICAgICAgZG9tQmFzZSA9IHZwLmRvbUJvdHRvbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmcm9tRE9NKG4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGJhc2UgPSAwLCBkb21CYXNlID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZwID0gaSA8IHRoaXMudmlld3BvcnRzLmxlbmd0aCA/IHRoaXMudmlld3BvcnRzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghdnAgfHwgbiA8IHZwLmRvbVRvcClcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZSArIChuIC0gZG9tQmFzZSkgLyB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgaWYgKG4gPD0gdnAuZG9tQm90dG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiB2cC50b3AgKyAobiAtIHZwLmRvbVRvcCk7XG4gICAgICAgICAgICBiYXNlID0gdnAuYm90dG9tO1xuICAgICAgICAgICAgZG9tQmFzZSA9IHZwLmRvbUJvdHRvbTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNjYWxlQmxvY2soYmxvY2ssIHNjYWxlcikge1xuICAgIGlmIChzY2FsZXIuc2NhbGUgPT0gMSlcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIGxldCBiVG9wID0gc2NhbGVyLnRvRE9NKGJsb2NrLnRvcCksIGJCb3R0b20gPSBzY2FsZXIudG9ET00oYmxvY2suYm90dG9tKTtcbiAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhibG9jay5mcm9tLCBibG9jay5sZW5ndGgsIGJUb3AsIGJCb3R0b20gLSBiVG9wLCBBcnJheS5pc0FycmF5KGJsb2NrLnR5cGUpID8gYmxvY2sudHlwZS5tYXAoYiA9PiBzY2FsZUJsb2NrKGIsIHNjYWxlcikpIDogYmxvY2sudHlwZSk7XG59XG5cbmNvbnN0IHRoZW1lID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHN0cnMgPT4gc3Rycy5qb2luKFwiIFwiKSB9KTtcbmNvbnN0IGRhcmtUaGVtZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmluZGV4T2YodHJ1ZSkgPiAtMSB9KTtcbmNvbnN0IGJhc2VUaGVtZUlEID0gLypAX19QVVJFX18qL1N0eWxlTW9kdWxlLm5ld05hbWUoKSwgYmFzZUxpZ2h0SUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpLCBiYXNlRGFya0lEID0gLypAX19QVVJFX18qL1N0eWxlTW9kdWxlLm5ld05hbWUoKTtcbmNvbnN0IGxpZ2h0RGFya0lEcyA9IHsgXCImbGlnaHRcIjogXCIuXCIgKyBiYXNlTGlnaHRJRCwgXCImZGFya1wiOiBcIi5cIiArIGJhc2VEYXJrSUQgfTtcbmZ1bmN0aW9uIGJ1aWxkVGhlbWUobWFpbiwgc3BlYywgc2NvcGVzKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZU1vZHVsZShzcGVjLCB7XG4gICAgICAgIGZpbmlzaChzZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAvJi8udGVzdChzZWwpID8gc2VsLnJlcGxhY2UoLyZcXHcqLywgbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG0gPT0gXCImXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWluO1xuICAgICAgICAgICAgICAgIGlmICghc2NvcGVzIHx8ICFzY29wZXNbbV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnN1cHBvcnRlZCBzZWxlY3RvcjogJHttfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZXNbbV07XG4gICAgICAgICAgICB9KSA6IG1haW4gKyBcIiBcIiArIHNlbDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgYmFzZVRoZW1lJDEgPSAvKkBfX1BVUkVfXyovYnVpbGRUaGVtZShcIi5cIiArIGJhc2VUaGVtZUlELCB7XG4gICAgXCImXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmUgIWltcG9ydGFudFwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBcIiYuY20tZm9jdXNlZFwiOiB7XG4gICAgICAgICAgICAvLyBQcm92aWRlIGEgc2ltcGxlIGRlZmF1bHQgb3V0bGluZSB0byBtYWtlIHN1cmUgYSBmb2N1c2VkXG4gICAgICAgICAgICAvLyBlZGl0b3IgaXMgdmlzdWFsbHkgZGlzdGluY3QuIENhbid0IGxlYXZlIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd2lsbCBhcHBseSB0byB0aGUgY29udGVudCBlbGVtZW50LCB3aGljaCBpc1xuICAgICAgICAgICAgLy8gaW5zaWRlIHRoZSBzY3JvbGxhYmxlIGNvbnRhaW5lciBhbmQgZG9lc24ndCBpbmNsdWRlIHRoZVxuICAgICAgICAgICAgLy8gZ3V0dGVycy4gV2UgYWxzbyBjYW4ndCB1c2UgYW4gJ2F1dG8nIG91dGxpbmUsIHNpbmNlIHRob3NlXG4gICAgICAgICAgICAvLyBhcmUsIGZvciBzb21lIHJlYXNvbiwgZHJhd24gYmVoaW5kIHRoZSBlbGVtZW50IGNvbnRlbnQsIHdoaWNoXG4gICAgICAgICAgICAvLyB3aWxsIGNhdXNlIHRoaW5ncyBsaWtlIHRoZSBhY3RpdmUgbGluZSBiYWNrZ3JvdW5kIHRvIGNvdmVyXG4gICAgICAgICAgICAvLyB0aGUgb3V0bGluZSAoIzI5NykuXG4gICAgICAgICAgICBvdXRsaW5lOiBcIjFweCBkb3R0ZWQgIzIxMjEyMVwiXG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCJcbiAgICB9LFxuICAgIFwiLmNtLXNjcm9sbGVyXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAgICAgYWxpZ25JdGVtczogXCJmbGV4LXN0YXJ0ICFpbXBvcnRhbnRcIixcbiAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgbGluZUhlaWdodDogMS40LFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvdmVyZmxvd1g6IFwiYXV0b1wiLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICB6SW5kZXg6IDBcbiAgICB9LFxuICAgIFwiLmNtLWNvbnRlbnRcIjoge1xuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIGZsZXhHcm93OiAyLFxuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCIsXG4gICAgICAgIHdvcmRXcmFwOiBcIm5vcm1hbFwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBwYWRkaW5nOiBcIjRweCAwXCIsXG4gICAgICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgICAgICBcIiZbY29udGVudGVkaXRhYmxlPXRydWVdXCI6IHtcbiAgICAgICAgICAgIFdlYmtpdFVzZXJNb2RpZnk6IFwicmVhZC13cml0ZS1wbGFpbnRleHQtb25seVwiLFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS1saW5lV3JhcHBpbmdcIjoge1xuICAgICAgICB3aGl0ZVNwYWNlX2ZhbGxiYWNrOiBcInByZS13cmFwXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwiYnJlYWstc3BhY2VzXCIsXG4gICAgICAgIHdvcmRCcmVhazogXCJicmVhay13b3JkXCIsXG4gICAgICAgIG92ZXJmbG93V3JhcDogXCJhbnl3aGVyZVwiLFxuICAgICAgICBmbGV4U2hyaW5rOiAxXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tY29udGVudFwiOiB7IGNhcmV0Q29sb3I6IFwiYmxhY2tcIiB9LFxuICAgIFwiJmRhcmsgLmNtLWNvbnRlbnRcIjogeyBjYXJldENvbG9yOiBcIndoaXRlXCIgfSxcbiAgICBcIi5jbS1saW5lXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICBwYWRkaW5nOiBcIjAgMnB4IDAgNnB4XCJcbiAgICB9LFxuICAgIFwiLmNtLWxheWVyXCI6IHtcbiAgICAgICAgY29udGFpbjogXCJzaXplIHN0eWxlXCIsXG4gICAgICAgIFwiJiA+ICpcIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiI2Q5ZDlkOVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMjIyXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0LmNtLWZvY3VzZWQgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNkN2Q0ZjBcIlxuICAgIH0sXG4gICAgXCImZGFyay5jbS1mb2N1c2VkIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMjMzXCJcbiAgICB9LFxuICAgIFwiLmNtLWN1cnNvckxheWVyXCI6IHtcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICB9LFxuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1jdXJzb3JMYXllclwiOiB7XG4gICAgICAgIGFuaW1hdGlvbjogXCJzdGVwcygxKSBjbS1ibGluayAxLjJzIGluZmluaXRlXCJcbiAgICB9LFxuICAgIC8vIFR3byBhbmltYXRpb25zIGRlZmluZWQgc28gdGhhdCB3ZSBjYW4gc3dpdGNoIGJldHdlZW4gdGhlbSB0b1xuICAgIC8vIHJlc3RhcnQgdGhlIGFuaW1hdGlvbiB3aXRob3V0IGZvcmNpbmcgYW5vdGhlciBzdHlsZVxuICAgIC8vIHJlY29tcHV0YXRpb24uXG4gICAgXCJAa2V5ZnJhbWVzIGNtLWJsaW5rXCI6IHsgXCIwJVwiOiB7fSwgXCI1MCVcIjogeyBvcGFjaXR5OiAwIH0sIFwiMTAwJVwiOiB7fSB9LFxuICAgIFwiQGtleWZyYW1lcyBjbS1ibGluazJcIjogeyBcIjAlXCI6IHt9LCBcIjUwJVwiOiB7IG9wYWNpdHk6IDAgfSwgXCIxMDAlXCI6IHt9IH0sXG4gICAgXCIuY20tY3Vyc29yLCAuY20tZHJvcEN1cnNvclwiOiB7XG4gICAgICAgIGJvcmRlckxlZnQ6IFwiMS4ycHggc29saWQgYmxhY2tcIixcbiAgICAgICAgbWFyZ2luTGVmdDogXCItMC42cHhcIixcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgfSxcbiAgICBcIi5jbS1jdXJzb3JcIjoge1xuICAgICAgICBkaXNwbGF5OiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tY3Vyc29yXCI6IHtcbiAgICAgICAgYm9yZGVyTGVmdENvbG9yOiBcIiM0NDRcIlxuICAgIH0sXG4gICAgXCIuY20tZHJvcEN1cnNvclwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICB9LFxuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1jdXJzb3JcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1hY3RpdmVMaW5lXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNjY2VlZmY0NFwiIH0sXG4gICAgXCImZGFyayAuY20tYWN0aXZlTGluZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjOTllZWZmMzNcIiB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zcGVjaWFsQ2hhclwiOiB7IGNvbG9yOiBcInJlZFwiIH0sXG4gICAgXCImZGFyayAuY20tc3BlY2lhbENoYXJcIjogeyBjb2xvcjogXCIjZjc4XCIgfSxcbiAgICBcIi5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgZmxleFNocmluazogMCxcbiAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHpJbmRleDogMjAwXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCIsXG4gICAgICAgIGNvbG9yOiBcIiM2YzZjNmNcIixcbiAgICAgICAgYm9yZGVyUmlnaHQ6IFwiMXB4IHNvbGlkICNkZGRcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgIGNvbG9yOiBcIiNjY2NcIlxuICAgIH0sXG4gICAgXCIuY20tZ3V0dGVyXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgICAgZmxleFNocmluazogMCxcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgbWluSGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCJcbiAgICB9LFxuICAgIFwiLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiXG4gICAgfSxcbiAgICBcIi5jbS1saW5lTnVtYmVycyAuY20tZ3V0dGVyRWxlbWVudFwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMCAzcHggMCA1cHhcIixcbiAgICAgICAgbWluV2lkdGg6IFwiMjBweFwiLFxuICAgICAgICB0ZXh0QWxpZ246IFwicmlnaHRcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2UyZjJmZlwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMyMjIyMjdcIlxuICAgIH0sXG4gICAgXCIuY20tcGFuZWxzXCI6IHtcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgcG9zaXRpb246IFwic3RpY2t5XCIsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHJpZ2h0OiAwXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIixcbiAgICAgICAgY29sb3I6IFwiYmxhY2tcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXBhbmVscy10b3BcIjoge1xuICAgICAgICBib3JkZXJCb3R0b206IFwiMXB4IHNvbGlkICNkZGRcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXBhbmVscy1ib3R0b21cIjoge1xuICAgICAgICBib3JkZXJUb3A6IFwiMXB4IHNvbGlkICNkZGRcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tcGFuZWxzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIlxuICAgIH0sXG4gICAgXCIuY20tdGFiXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwiYm90dG9tXCJcbiAgICB9LFxuICAgIFwiLmNtLXdpZGdldEJ1ZmZlclwiOiB7XG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwidGV4dC10b3BcIixcbiAgICAgICAgaGVpZ2h0OiBcIjFlbVwiLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmVcIlxuICAgIH0sXG4gICAgXCIuY20tcGxhY2Vob2xkZXJcIjoge1xuICAgICAgICBjb2xvcjogXCIjODg4XCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwidG9wXCIsXG4gICAgfSxcbiAgICBcIi5jbS1oaWdobGlnaHRTcGFjZTpiZWZvcmVcIjoge1xuICAgICAgICBjb250ZW50OiBcImF0dHIoZGF0YS1kaXNwbGF5KVwiLFxuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICAgICAgY29sb3I6IFwiIzg4OFwiXG4gICAgfSxcbiAgICBcIi5jbS1oaWdobGlnaHRUYWJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbCw8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjIwXCI+PHBhdGggc3Ryb2tlPVwiJTIzODg4XCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGZpbGw9XCJub25lXCIgZD1cIk0xIDEwSDE5NkwxOTAgNU0xOTAgMTVMMTk2IDEwTTE5NyA0TDE5NyAxNlwiLz48L3N2Zz4nKWAsXG4gICAgICAgIGJhY2tncm91bmRTaXplOiBcImF1dG8gMTAwJVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IFwicmlnaHQgOTAlXCIsXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6IFwibm8tcmVwZWF0XCJcbiAgICB9LFxuICAgIFwiLmNtLXRyYWlsaW5nU3BhY2VcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmMzMyMjU1XCJcbiAgICB9LFxuICAgIFwiLmNtLWJ1dHRvblwiOiB7XG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIsXG4gICAgICAgIGNvbG9yOiBcImluaGVyaXRcIixcbiAgICAgICAgZm9udFNpemU6IFwiNzAlXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiLjJlbSAxZW1cIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjFweFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjZWZmMWY1LCAjZDlkOWRmKVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIixcbiAgICAgICAgXCImOmFjdGl2ZVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCNiNGI0YjQsICNkMGQzZDYpXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImZGFyayAuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjMzkzOTM5LCAjMTExKVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIixcbiAgICAgICAgXCImOmFjdGl2ZVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMxMTEsICMzMzMpXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCBzaWx2ZXJcIixcbiAgICAgICAgcGFkZGluZzogXCIuMmVtIC41ZW1cIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM1NTVcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImluaGVyaXRcIlxuICAgIH1cbn0sIGxpZ2h0RGFya0lEcyk7XG5cbmNsYXNzIERPTUNoYW5nZSB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhcnQsIGVuZCwgdHlwZU92ZXIpIHtcbiAgICAgICAgdGhpcy50eXBlT3ZlciA9IHR5cGVPdmVyO1xuICAgICAgICB0aGlzLmJvdW5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCB7IGltcHJlY2lzZUhlYWQ6IGlIZWFkLCBpbXByZWNpc2VBbmNob3I6IGlBbmNob3IgfSA9IHZpZXcuZG9jVmlldztcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkgJiYgc3RhcnQgPiAtMSkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGNoYW5nZXMgd2hlbiB0aGUgZWRpdG9yIGlzIHJlYWQtb25seVxuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0ID4gLTEgJiYgKHRoaXMuYm91bmRzID0gdmlldy5kb2NWaWV3LmRvbUJvdW5kc0Fyb3VuZChzdGFydCwgZW5kLCAwKSkpIHtcbiAgICAgICAgICAgIGxldCBzZWxQb2ludHMgPSBpSGVhZCB8fCBpQW5jaG9yID8gW10gOiBzZWxlY3Rpb25Qb2ludHModmlldyk7XG4gICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IERPTVJlYWRlcihzZWxQb2ludHMsIHZpZXcuc3RhdGUpO1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRSYW5nZSh0aGlzLmJvdW5kcy5zdGFydERPTSwgdGhpcy5ib3VuZHMuZW5kRE9NKTtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHJlYWRlci50ZXh0O1xuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBzZWxlY3Rpb25Gcm9tUG9pbnRzKHNlbFBvaW50cywgdGhpcy5ib3VuZHMuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZG9tU2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgICAgIGxldCBoZWFkID0gaUhlYWQgJiYgaUhlYWQubm9kZSA9PSBkb21TZWwuZm9jdXNOb2RlICYmIGlIZWFkLm9mZnNldCA9PSBkb21TZWwuZm9jdXNPZmZzZXQgfHxcbiAgICAgICAgICAgICAgICAhY29udGFpbnModmlldy5jb250ZW50RE9NLCBkb21TZWwuZm9jdXNOb2RlKVxuICAgICAgICAgICAgICAgID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkXG4gICAgICAgICAgICAgICAgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IGFuY2hvciA9IGlBbmNob3IgJiYgaUFuY2hvci5ub2RlID09IGRvbVNlbC5hbmNob3JOb2RlICYmIGlBbmNob3Iub2Zmc2V0ID09IGRvbVNlbC5hbmNob3JPZmZzZXQgfHxcbiAgICAgICAgICAgICAgICAhY29udGFpbnModmlldy5jb250ZW50RE9NLCBkb21TZWwuYW5jaG9yTm9kZSlcbiAgICAgICAgICAgICAgICA/IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yXG4gICAgICAgICAgICAgICAgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5RE9NQ2hhbmdlKHZpZXcsIGRvbUNoYW5nZSkge1xuICAgIGxldCBjaGFuZ2U7XG4gICAgbGV0IHsgbmV3U2VsIH0gPSBkb21DaGFuZ2UsIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKGRvbUNoYW5nZS5ib3VuZHMpIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGRvbUNoYW5nZS5ib3VuZHM7XG4gICAgICAgIGxldCBwcmVmZXJyZWRQb3MgPSBzZWwuZnJvbSwgcHJlZmVycmVkU2lkZSA9IG51bGw7XG4gICAgICAgIC8vIFByZWZlciBhbmNob3JpbmcgdG8gZW5kIHdoZW4gQmFja3NwYWNlIGlzIHByZXNzZWQgKG9yLCBvblxuICAgICAgICAvLyBBbmRyb2lkLCB3aGVuIHNvbWV0aGluZyB3YXMgZGVsZXRlZClcbiAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA9PT0gOCAmJiB2aWV3LmlucHV0U3RhdGUubGFzdEtleVRpbWUgPiBEYXRlLm5vdygpIC0gMTAwIHx8XG4gICAgICAgICAgICBicm93c2VyLmFuZHJvaWQgJiYgZG9tQ2hhbmdlLnRleHQubGVuZ3RoIDwgdG8gLSBmcm9tKSB7XG4gICAgICAgICAgICBwcmVmZXJyZWRQb3MgPSBzZWwudG87XG4gICAgICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJlbmRcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlmZiA9IGZpbmREaWZmKHZpZXcuc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvLCBMaW5lQnJlYWtQbGFjZWhvbGRlciksIGRvbUNoYW5nZS50ZXh0LCBwcmVmZXJyZWRQb3MgLSBmcm9tLCBwcmVmZXJyZWRTaWRlKTtcbiAgICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgICAgIC8vIENocm9tZSBpbnNlcnRzIHR3byBuZXdsaW5lcyB3aGVuIHByZXNzaW5nIHNoaWZ0LWVudGVyIGF0IHRoZVxuICAgICAgICAgICAgLy8gZW5kIG9mIGEgbGluZS4gRG9tQ2hhbmdlIGRyb3BzIG9uZSBvZiB0aG9zZS5cbiAgICAgICAgICAgIGlmIChicm93c2VyLmNocm9tZSAmJiB2aWV3LmlucHV0U3RhdGUubGFzdEtleUNvZGUgPT0gMTMgJiZcbiAgICAgICAgICAgICAgICBkaWZmLnRvQiA9PSBkaWZmLmZyb20gKyAyICYmIGRvbUNoYW5nZS50ZXh0LnNsaWNlKGRpZmYuZnJvbSwgZGlmZi50b0IpID09IExpbmVCcmVha1BsYWNlaG9sZGVyICsgTGluZUJyZWFrUGxhY2Vob2xkZXIpXG4gICAgICAgICAgICAgICAgZGlmZi50b0ItLTtcbiAgICAgICAgICAgIGNoYW5nZSA9IHsgZnJvbTogZnJvbSArIGRpZmYuZnJvbSwgdG86IGZyb20gKyBkaWZmLnRvQSxcbiAgICAgICAgICAgICAgICBpbnNlcnQ6IFRleHQub2YoZG9tQ2hhbmdlLnRleHQuc2xpY2UoZGlmZi5mcm9tLCBkaWZmLnRvQikuc3BsaXQoTGluZUJyZWFrUGxhY2Vob2xkZXIpKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5ld1NlbCAmJiAoIXZpZXcuaGFzRm9jdXMgJiYgdmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgfHwgbmV3U2VsLm1haW4uZXEoc2VsKSkpIHtcbiAgICAgICAgbmV3U2VsID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2UgJiYgIW5ld1NlbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghY2hhbmdlICYmIGRvbUNoYW5nZS50eXBlT3ZlciAmJiAhc2VsLmVtcHR5ICYmIG5ld1NlbCAmJiBuZXdTZWwubWFpbi5lbXB0eSkge1xuICAgICAgICAvLyBIZXVyaXN0aWMgdG8gbm90aWNlIHR5cGluZyBvdmVyIGEgc2VsZWN0ZWQgY2hhcmFjdGVyXG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogdmlldy5zdGF0ZS5kb2Muc2xpY2Uoc2VsLmZyb20sIHNlbC50bykgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhbmdlICYmIGNoYW5nZS5mcm9tID49IHNlbC5mcm9tICYmIGNoYW5nZS50byA8PSBzZWwudG8gJiZcbiAgICAgICAgKGNoYW5nZS5mcm9tICE9IHNlbC5mcm9tIHx8IGNoYW5nZS50byAhPSBzZWwudG8pICYmXG4gICAgICAgIChzZWwudG8gLSBzZWwuZnJvbSkgLSAoY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20pIDw9IDQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGNoYW5nZSBpcyBpbnNpZGUgdGhlIHNlbGVjdGlvbiBhbmQgY292ZXJzIG1vc3Qgb2YgaXQsXG4gICAgICAgIC8vIGFzc3VtZSBpdCBpcyBhIHNlbGVjdGlvbiByZXBsYWNlICh3aXRoIGlkZW50aWNhbCBjaGFyYWN0ZXJzIGF0XG4gICAgICAgIC8vIHRoZSBzdGFydC9lbmQgbm90IGluY2x1ZGVkIGluIHRoZSBkaWZmKVxuICAgICAgICBjaGFuZ2UgPSB7XG4gICAgICAgICAgICBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50byxcbiAgICAgICAgICAgIGluc2VydDogdmlldy5zdGF0ZS5kb2Muc2xpY2Uoc2VsLmZyb20sIGNoYW5nZS5mcm9tKS5hcHBlbmQoY2hhbmdlLmluc2VydCkuYXBwZW5kKHZpZXcuc3RhdGUuZG9jLnNsaWNlKGNoYW5nZS50bywgc2VsLnRvKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGJyb3dzZXIubWFjIHx8IGJyb3dzZXIuYW5kcm9pZCkgJiYgY2hhbmdlICYmIGNoYW5nZS5mcm9tID09IGNoYW5nZS50byAmJiBjaGFuZ2UuZnJvbSA9PSBzZWwuaGVhZCAtIDEgJiZcbiAgICAgICAgL15cXC4gPyQvLnRlc3QoY2hhbmdlLmluc2VydC50b1N0cmluZygpKSAmJiB2aWV3LmNvbnRlbnRET00uZ2V0QXR0cmlidXRlKFwiYXV0b2NvcnJlY3RcIikgPT0gXCJvZmZcIikge1xuICAgICAgICAvLyBEZXRlY3QgaW5zZXJ0LXBlcmlvZC1vbi1kb3VibGUtc3BhY2UgTWFjIGFuZCBBbmRyb2lkIGJlaGF2aW9yLFxuICAgICAgICAvLyBhbmQgdHJhbnNmb3JtIGl0IGludG8gYSByZWd1bGFyIHNwYWNlIGluc2VydC5cbiAgICAgICAgaWYgKG5ld1NlbCAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAyKVxuICAgICAgICAgICAgbmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShuZXdTZWwubWFpbi5hbmNob3IgLSAxLCBuZXdTZWwubWFpbi5oZWFkIC0gMSk7XG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogVGV4dC5vZihbXCIgXCJdKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChicm93c2VyLmNocm9tZSAmJiBjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPT0gY2hhbmdlLnRvICYmIGNoYW5nZS5mcm9tID09IHNlbC5oZWFkICYmXG4gICAgICAgIGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKSA9PSBcIlxcbiBcIiAmJiB2aWV3LmxpbmVXcmFwcGluZykge1xuICAgICAgICAvLyBJbiBDaHJvbWUsIGlmIHlvdSBpbnNlcnQgYSBzcGFjZSBhdCB0aGUgc3RhcnQgb2YgYSB3cmFwcGVkXG4gICAgICAgIC8vIGxpbmUsIGl0IHdpbGwgYWN0dWFsbHkgaW5zZXJ0IGEgbmV3bGluZSBhbmQgYSBzcGFjZSwgY2F1c2luZyBhXG4gICAgICAgIC8vIGJvZ3VzIG5ldyBsaW5lIHRvIGJlIGNyZWF0ZWQgaW4gQ29kZU1pcnJvciAoIzk2OClcbiAgICAgICAgaWYgKG5ld1NlbClcbiAgICAgICAgICAgIG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV3U2VsLm1haW4uYW5jaG9yIC0gMSwgbmV3U2VsLm1haW4uaGVhZCAtIDEpO1xuICAgICAgICBjaGFuZ2UgPSB7IGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLCBpbnNlcnQ6IFRleHQub2YoW1wiIFwiXSkgfTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZSkge1xuICAgICAgICBsZXQgc3RhcnRTdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIGlmIChicm93c2VyLmlvcyAmJiB2aWV3LmlucHV0U3RhdGUuZmx1c2hJT1NLZXkodmlldykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gQW5kcm9pZCBicm93c2VycyBkb24ndCBmaXJlIHJlYXNvbmFibGUga2V5IGV2ZW50cyBmb3IgZW50ZXIsXG4gICAgICAgIC8vIGJhY2tzcGFjZSwgb3IgZGVsZXRlLiBTbyB0aGlzIGRldGVjdHMgY2hhbmdlcyB0aGF0IGxvb2sgbGlrZVxuICAgICAgICAvLyB0aGV5J3JlIGNhdXNlZCBieSB0aG9zZSBrZXlzLCBhbmQgcmVpbnRlcnByZXRzIHRoZW0gYXMga2V5XG4gICAgICAgIC8vIGV2ZW50cy4gKFNvbWUgb2YgdGhlc2Uga2V5cyBhcmUgYWxzbyBoYW5kbGVkIGJ5IGJlZm9yZWlucHV0XG4gICAgICAgIC8vIGV2ZW50cyBhbmQgdGhlIHBlbmRpbmdBbmRyb2lkS2V5IG1lY2hhbmlzbSwgYnV0IHRoYXQncyBub3RcbiAgICAgICAgLy8gcmVsaWFibGUgaW4gYWxsIHNpdHVhdGlvbnMuKVxuICAgICAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmXG4gICAgICAgICAgICAoKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIGNoYW5nZS50byA9PSBzZWwudG8gJiZcbiAgICAgICAgICAgICAgICBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAxICYmIGNoYW5nZS5pbnNlcnQubGluZXMgPT0gMiAmJlxuICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJFbnRlclwiLCAxMykpIHx8XG4gICAgICAgICAgICAgICAgKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tIC0gMSAmJiBjaGFuZ2UudG8gPT0gc2VsLnRvICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBcIkJhY2tzcGFjZVwiLCA4KSkgfHxcbiAgICAgICAgICAgICAgICAoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gJiYgY2hhbmdlLnRvID09IHNlbC50byArIDEgJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LmNvbnRlbnRET00sIFwiRGVsZXRlXCIsIDQ2KSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCB0ZXh0ID0gY2hhbmdlLmluc2VydC50b1N0cmluZygpO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5mYWNldChpbnB1dEhhbmRsZXIpLnNvbWUoaCA9PiBoKHZpZXcsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8sIHRleHQpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwKVxuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZysrO1xuICAgICAgICBsZXQgdHI7XG4gICAgICAgIGlmIChjaGFuZ2UuZnJvbSA+PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPD0gc2VsLnRvICYmIGNoYW5nZS50byAtIGNoYW5nZS5mcm9tID49IChzZWwudG8gLSBzZWwuZnJvbSkgLyAzICYmXG4gICAgICAgICAgICAoIW5ld1NlbCB8fCBuZXdTZWwubWFpbi5lbXB0eSAmJiBuZXdTZWwubWFpbi5mcm9tID09IGNoYW5nZS5mcm9tICsgY2hhbmdlLmluc2VydC5sZW5ndGgpICYmXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHNlbC5mcm9tIDwgY2hhbmdlLmZyb20gPyBzdGFydFN0YXRlLnNsaWNlRG9jKHNlbC5mcm9tLCBjaGFuZ2UuZnJvbSkgOiBcIlwiO1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gc2VsLnRvID4gY2hhbmdlLnRvID8gc3RhcnRTdGF0ZS5zbGljZURvYyhjaGFuZ2UudG8sIHNlbC50bykgOiBcIlwiO1xuICAgICAgICAgICAgdHIgPSBzdGFydFN0YXRlLnJlcGxhY2VTZWxlY3Rpb24odmlldy5zdGF0ZS50b1RleHQoYmVmb3JlICsgY2hhbmdlLmluc2VydC5zbGljZVN0cmluZygwLCB1bmRlZmluZWQsIHZpZXcuc3RhdGUubGluZUJyZWFrKSArIGFmdGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY2hhbmdlcyA9IHN0YXJ0U3RhdGUuY2hhbmdlcyhjaGFuZ2UpO1xuICAgICAgICAgICAgbGV0IG1haW5TZWwgPSBuZXdTZWwgJiYgIXN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1haW4uZXEobmV3U2VsLm1haW4pICYmIG5ld1NlbC5tYWluLnRvIDw9IGNoYW5nZXMubmV3TGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBuZXdTZWwubWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIFRyeSB0byBhcHBseSBhIGNvbXBvc2l0aW9uIGNoYW5nZSB0byBhbGwgY3Vyc29yc1xuICAgICAgICAgICAgaWYgKHN0YXJ0U3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGggPiAxICYmIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCAmJlxuICAgICAgICAgICAgICAgIGNoYW5nZS50byA8PSBzZWwudG8gJiYgY2hhbmdlLnRvID49IHNlbC50byAtIDEwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlcGxhY2VkID0gdmlldy5zdGF0ZS5zbGljZURvYyhjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcbiAgICAgICAgICAgICAgICBsZXQgY29tcG9zaXRpb25SYW5nZSA9IGNvbXBvc2l0aW9uU3Vycm91bmRpbmdOb2RlKHZpZXcpIHx8IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzZWwuaGVhZCk7XG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IHNlbC50byAtIGNoYW5nZS50bywgc2l6ZSA9IHNlbC50byAtIHNlbC5mcm9tO1xuICAgICAgICAgICAgICAgIHRyID0gc3RhcnRTdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLmZyb20gPT0gc2VsLmZyb20gJiYgcmFuZ2UudG8gPT0gc2VsLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlcywgcmFuZ2U6IG1haW5TZWwgfHwgcmFuZ2UubWFwKGNoYW5nZXMpIH07XG4gICAgICAgICAgICAgICAgICAgIGxldCB0byA9IHJhbmdlLnRvIC0gb2Zmc2V0LCBmcm9tID0gdG8gLSByZXBsYWNlZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS50byAtIHJhbmdlLmZyb20gIT0gc2l6ZSB8fCB2aWV3LnN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSAhPSByZXBsYWNlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgdGhlcmUncyBubyB3YXkgdG8gbWFrZSBtdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlcyBpbiB0aGUgc2FtZSBub2RlIHdvcmsgd2l0aG91dCBhYm9ydGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9zaXRpb24sIHNvIGN1cnNvcnMgaW4gdGhlIGNvbXBvc2l0aW9uIHJhbmdlIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uUmFuZ2UgJiYgcmFuZ2UudG8gPj0gY29tcG9zaXRpb25SYW5nZS5mcm9tICYmIHJhbmdlLmZyb20gPD0gY29tcG9zaXRpb25SYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZUNoYW5nZXMgPSBzdGFydFN0YXRlLmNoYW5nZXMoeyBmcm9tLCB0bywgaW5zZXJ0OiBjaGFuZ2UuaW5zZXJ0IH0pLCBzZWxPZmYgPSByYW5nZS50byAtIHNlbC50bztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXM6IHJhbmdlQ2hhbmdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiAhbWFpblNlbCA/IHJhbmdlLm1hcChyYW5nZUNoYW5nZXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoTWF0aC5tYXgoMCwgbWFpblNlbC5hbmNob3IgKyBzZWxPZmYpLCBNYXRoLm1heCgwLCBtYWluU2VsLmhlYWQgKyBzZWxPZmYpKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXMsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogbWFpblNlbCAmJiBzdGFydFN0YXRlLnNlbGVjdGlvbi5yZXBsYWNlUmFuZ2UobWFpblNlbClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB1c2VyRXZlbnQgPSBcImlucHV0LnR5cGVcIjtcbiAgICAgICAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICB1c2VyRXZlbnQgKz0gXCIuY29tcG9zZVwiO1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdXNlckV2ZW50ICs9IFwiLnN0YXJ0XCI7XG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChuZXdTZWwgJiYgIW5ld1NlbC5tYWluLmVxKHNlbCkpIHtcbiAgICAgICAgbGV0IHNjcm9sbEludG9WaWV3ID0gZmFsc2UsIHVzZXJFdmVudCA9IFwic2VsZWN0XCI7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvblRpbWUgPiBEYXRlLm5vdygpIC0gNTApIHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvbk9yaWdpbiA9PSBcInNlbGVjdFwiKVxuICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIHVzZXJFdmVudCA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2VsZWN0aW9uT3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBzZWxlY3Rpb246IG5ld1NlbCwgc2Nyb2xsSW50b1ZpZXcsIHVzZXJFdmVudCB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKSB7XG4gICAgbGV0IG1pbkxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgbGV0IGZyb20gPSAwO1xuICAgIHdoaWxlIChmcm9tIDwgbWluTGVuICYmIGEuY2hhckNvZGVBdChmcm9tKSA9PSBiLmNoYXJDb2RlQXQoZnJvbSkpXG4gICAgICAgIGZyb20rKztcbiAgICBpZiAoZnJvbSA9PSBtaW5MZW4gJiYgYS5sZW5ndGggPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB0b0EgPSBhLmxlbmd0aCwgdG9CID0gYi5sZW5ndGg7XG4gICAgd2hpbGUgKHRvQSA+IDAgJiYgdG9CID4gMCAmJiBhLmNoYXJDb2RlQXQodG9BIC0gMSkgPT0gYi5jaGFyQ29kZUF0KHRvQiAtIDEpKSB7XG4gICAgICAgIHRvQS0tO1xuICAgICAgICB0b0ItLTtcbiAgICB9XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgZnJvbSAtIE1hdGgubWluKHRvQSwgdG9CKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSB0b0EgKyBhZGp1c3QgLSBmcm9tO1xuICAgIH1cbiAgICBpZiAodG9BIDwgZnJvbSAmJiBhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IGZyb20gJiYgcHJlZmVycmVkUG9zID49IHRvQSA/IGZyb20gLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBmcm9tIC09IG1vdmU7XG4gICAgICAgIHRvQiA9IGZyb20gKyAodG9CIC0gdG9BKTtcbiAgICAgICAgdG9BID0gZnJvbTtcbiAgICB9XG4gICAgZWxzZSBpZiAodG9CIDwgZnJvbSkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBmcm9tICYmIHByZWZlcnJlZFBvcyA+PSB0b0IgPyBmcm9tIC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgZnJvbSAtPSBtb3ZlO1xuICAgICAgICB0b0EgPSBmcm9tICsgKHRvQSAtIHRvQik7XG4gICAgICAgIHRvQiA9IGZyb207XG4gICAgfVxuICAgIHJldHVybiB7IGZyb20sIHRvQSwgdG9CIH07XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Qb2ludHModmlldykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBpZiAodmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdmlldy5jb250ZW50RE9NKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoYW5jaG9yTm9kZSkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSk7XG4gICAgICAgIGlmIChmb2N1c05vZGUgIT0gYW5jaG9yTm9kZSB8fCBmb2N1c09mZnNldCAhPSBhbmNob3JPZmZzZXQpXG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbVBvaW50cyhwb2ludHMsIGJhc2UpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYW5jaG9yID0gcG9pbnRzWzBdLnBvcywgaGVhZCA9IHBvaW50cy5sZW5ndGggPT0gMiA/IHBvaW50c1sxXS5wb3MgOiBhbmNob3I7XG4gICAgcmV0dXJuIGFuY2hvciA+IC0xICYmIGhlYWQgPiAtMSA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yICsgYmFzZSwgaGVhZCArIGJhc2UpIDogbnVsbDtcbn1cblxuY29uc3Qgb2JzZXJ2ZU9wdGlvbnMgPSB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZVxufTtcbi8vIElFMTEgaGFzIHZlcnkgYnJva2VuIG11dGF0aW9uIG9ic2VydmVycywgc28gd2UgYWxzbyBsaXN0ZW4gdG9cbi8vIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZCB0aGVyZVxuY29uc3QgdXNlQ2hhckRhdGEgPSBicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMTtcbmNsYXNzIERPTU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8vIFRoZSBrbm93biBzZWxlY3Rpb24uIEtlcHQgaW4gb3VyIG93biBvYmplY3QsIGFzIG9wcG9zZWQgdG8ganVzdFxuICAgICAgICAvLyBkaXJlY3RseSBhY2Nlc3NpbmcgdGhlIHNlbGVjdGlvbiBiZWNhdXNlOlxuICAgICAgICAvLyAgLSBTYWZhcmkgZG9lc24ndCByZXBvcnQgdGhlIHJpZ2h0IHNlbGVjdGlvbiBpbiBzaGFkb3cgRE9NXG4gICAgICAgIC8vICAtIFJlYWRpbmcgZnJvbSB0aGUgc2VsZWN0aW9uIGZvcmNlcyBhIERPTSBsYXlvdXRcbiAgICAgICAgLy8gIC0gVGhpcyB3YXksIHdlIGNhbiBpZ25vcmUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50cyBpZiB3ZSBoYXZlXG4gICAgICAgIC8vICAgIGFscmVhZHkgc2VlbiB0aGUgJ25ldycgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2UgPSBuZXcgRE9NU2VsZWN0aW9uU3RhdGU7XG4gICAgICAgIC8vIFNldCB3aGVuIGEgc2VsZWN0aW9uIGNoYW5nZSBpcyBkZXRlY3RlZCwgY2xlYXJlZCBvbiBmbHVzaFxuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSAtMTtcbiAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdENoYW5nZSA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzaXplU2Nyb2xsID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNpemVDb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmdhcHMgPSBbXTtcbiAgICAgICAgLy8gVGltZW91dCBmb3Igc2NoZWR1bGluZyBjaGVjayBvZiB0aGUgcGFyZW50cyB0aGF0IG5lZWQgc2Nyb2xsIGhhbmRsZXJzXG4gICAgICAgIHRoaXMucGFyZW50Q2hlY2sgPSAtMTtcbiAgICAgICAgdGhpcy5kb20gPSB2aWV3LmNvbnRlbnRET007XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgbXV0IG9mIG11dGF0aW9ucylcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgICAgIC8vIElFMTEgd2lsbCBzb21ldGltZXMgKG9uIHR5cGluZyBvdmVyIGEgc2VsZWN0aW9uIG9yXG4gICAgICAgICAgICAvLyBiYWNrc3BhY2luZyBvdXQgYSBzaW5nbGUgY2hhcmFjdGVyIHRleHQgbm9kZSkgY2FsbCB0aGVcbiAgICAgICAgICAgIC8vIG9ic2VydmVyIGNhbGxiYWNrIGJlZm9yZSBhY3R1YWxseSB1cGRhdGluZyB0aGUgRE9NLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFVucmVsYXRlZGx5LCBpT1MgU2FmYXJpIHdpbGwsIHdoZW4gZW5kaW5nIGEgY29tcG9zaXRpb24sXG4gICAgICAgICAgICAvLyBzb21ldGltZXMgZmlyc3QgY2xlYXIgaXQsIGRlbGl2ZXIgdGhlIG11dGF0aW9ucywgYW5kIHRoZW5cbiAgICAgICAgICAgIC8vIHJlaW5zZXJ0IHRoZSBmaW5pc2hlZCB0ZXh0LiBDb2RlTWlycm9yJ3MgaGFuZGxpbmcgb2YgdGhlXG4gICAgICAgICAgICAvLyBkZWxldGlvbiB3aWxsIHByZXZlbnQgdGhlIHJlaW5zZXJ0aW9uIGZyb20gaGFwcGVuaW5nLFxuICAgICAgICAgICAgLy8gYnJlYWtpbmcgY29tcG9zaXRpb24uXG4gICAgICAgICAgICBpZiAoKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExIHx8IGJyb3dzZXIuaW9zICYmIHZpZXcuY29tcG9zaW5nKSAmJlxuICAgICAgICAgICAgICAgIG11dGF0aW9ucy5zb21lKG0gPT4gbS50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgbS5yZW1vdmVkTm9kZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIG0udHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIiAmJiBtLm9sZFZhbHVlLmxlbmd0aCA+IG0udGFyZ2V0Lm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2hhcmFjdGVyRGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogZXZlbnQucHJldlZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUmVzaXplID0gdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUHJpbnQgPSB0aGlzLm9uUHJpbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblNjcm9sbCA9IHRoaXMub25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU2Nyb2xsID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnZpZXcuZG9jVmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RVcGRhdGUpIDwgRGF0ZS5ub3coKSAtIDc1KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU2Nyb2xsLm9ic2VydmUodmlldy5zY3JvbGxET00pO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVDb250ZW50ID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSgpKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplQ29udGVudC5vYnNlcnZlKHZpZXcuY29udGVudERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4gPSB2aWV3Lndpbik7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudENoZWNrIDwgMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IHNldFRpbWVvdXQodGhpcy5saXN0ZW5Gb3JTY3JvbGwuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCAmJiAoZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvID4gMCkgIT0gdGhpcy5pbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3RpbmcgPSAhdGhpcy5pbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZyAhPSB0aGlzLnZpZXcuaW5WaWV3KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24ub2JzZXJ2ZSh0aGlzLmRvbSk7XG4gICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbiA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwICYmIGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXS5pbnRlcnNlY3Rpb25SYXRpbyA+IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TY3JvbGxDaGFuZ2VkKGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIikpO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdGVuRm9yU2Nyb2xsKCk7XG4gICAgICAgIHRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgfVxuICAgIG9uU2Nyb2xsQ2hhbmdlZChlKSB7XG4gICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLnJ1blNjcm9sbEhhbmRsZXJzKHRoaXMudmlldywgZSk7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZylcbiAgICAgICAgICAgIHRoaXMudmlldy5tZWFzdXJlKCk7XG4gICAgfVxuICAgIG9uU2Nyb2xsKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgdGhpcy5mbHVzaChmYWxzZSk7XG4gICAgICAgIHRoaXMub25TY3JvbGxDaGFuZ2VkKGUpO1xuICAgIH1cbiAgICBvblJlc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplVGltZW91dCA8IDApXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgb25QcmludCgpIHtcbiAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5wcmludGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudmlldy5tZWFzdXJlKCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5wcmludGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfVxuICAgIHVwZGF0ZUdhcHMoZ2Fwcykge1xuICAgICAgICBpZiAodGhpcy5nYXBJbnRlcnNlY3Rpb24gJiYgKGdhcHMubGVuZ3RoICE9IHRoaXMuZ2Fwcy5sZW5ndGggfHwgdGhpcy5nYXBzLnNvbWUoKGcsIGkpID0+IGcgIT0gZ2Fwc1tpXSkpKSB7XG4gICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBnYXAgb2YgZ2FwcylcbiAgICAgICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbi5vYnNlcnZlKGdhcCk7XG4gICAgICAgICAgICB0aGlzLmdhcHMgPSBnYXBzO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGxldCB3YXNDaGFuZ2VkID0gdGhpcy5zZWxlY3Rpb25DaGFuZ2VkO1xuICAgICAgICBpZiAoIXRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCkgfHwgdGhpcy5kZWxheWVkQW5kcm9pZEtleSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcywgc2VsID0gdGhpcy5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpID8gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdGhpcy5kb20gOiAhaGFzU2VsZWN0aW9uKHZpZXcuZG9tLCBzZWwpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgY29udGV4dCA9IHNlbC5hbmNob3JOb2RlICYmIHZpZXcuZG9jVmlldy5uZWFyZXN0KHNlbC5hbmNob3JOb2RlKTtcbiAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5pZ25vcmVFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgIGlmICghd2FzQ2hhbmdlZClcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxldGlvbnMgb24gSUUxMSBmaXJlIHRoZWlyIGV2ZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIsIGdpdmluZ1xuICAgICAgICAvLyB1cyBhIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQgYmVmb3JlIHRoZSBET00gY2hhbmdlcyBhcmVcbiAgICAgICAgLy8gcmVwb3J0ZWQuXG4gICAgICAgIC8vIENocm9tZSBBbmRyb2lkIGhhcyBhIHNpbWlsYXIgaXNzdWUgd2hlbiBiYWNrc3BhY2luZyBvdXQgYVxuICAgICAgICAvLyBzZWxlY3Rpb24gKCM2NDUpLlxuICAgICAgICBpZiAoKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExIHx8IGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSkgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiZcbiAgICAgICAgICAgIC8vIChTZWxlY3Rpb24uaXNDb2xsYXBzZWQgaXNuJ3QgcmVsaWFibGUgb24gSUUpXG4gICAgICAgICAgICBzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxuICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5mbHVzaChmYWxzZSk7XG4gICAgfVxuICAgIHJlYWRTZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgLy8gVGhlIFNlbGVjdGlvbiBvYmplY3QgaXMgYnJva2VuIGluIHNoYWRvdyByb290cyBpbiBTYWZhcmkuIFNlZVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzQxNFxuICAgICAgICBsZXQgcmFuZ2UgPSBicm93c2VyLnNhZmFyaSAmJiB2aWV3LnJvb3Qubm9kZVR5cGUgPT0gMTEgJiZcbiAgICAgICAgICAgIGRlZXBBY3RpdmVFbGVtZW50KHRoaXMuZG9tLm93bmVyRG9jdW1lbnQpID09IHRoaXMuZG9tICYmXG4gICAgICAgICAgICBzYWZhcmlTZWxlY3Rpb25SYW5nZUhhY2sodGhpcy52aWV3KSB8fCBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICAgICAgaWYgKCFyYW5nZSB8fCB0aGlzLnNlbGVjdGlvblJhbmdlLmVxKHJhbmdlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGxvY2FsID0gaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCByYW5nZSk7XG4gICAgICAgIC8vIERldGVjdCB0aGUgc2l0dWF0aW9uIHdoZXJlIHRoZSBicm93c2VyIGhhcywgb24gZm9jdXMsIG1vdmVkIHRoZVxuICAgICAgICAvLyBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb250ZW50IGVsZW1lbnQuIFJlc2V0IGl0IHRvIHRoZVxuICAgICAgICAvLyBwb3NpdGlvbiBmcm9tIHRoZSBlZGl0b3Igc3RhdGUuXG4gICAgICAgIGlmIChsb2NhbCAmJiAhdGhpcy5zZWxlY3Rpb25DaGFuZ2VkICYmXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA+IERhdGUubm93KCkgLSAyMDAgJiZcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lIDwgRGF0ZS5ub3coKSAtIDMwMCAmJlxuICAgICAgICAgICAgYXRFbGVtZW50U3RhcnQodGhpcy5kb20sIHJhbmdlKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgICAgICB2aWV3LmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXRSYW5nZShyYW5nZSk7XG4gICAgICAgIGlmIChsb2NhbClcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb25SYW5nZShhbmNob3IsIGhlYWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXQoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQsIGhlYWQubm9kZSwgaGVhZC5vZmZzZXQpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgY2xlYXJTZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXQobnVsbCwgMCwgbnVsbCwgMCk7XG4gICAgfVxuICAgIGxpc3RlbkZvclNjcm9sbCgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IC0xO1xuICAgICAgICBsZXQgaSA9IDAsIGNoYW5nZWQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBkb20gPSB0aGlzLmRvbTsgZG9tOykge1xuICAgICAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VkICYmIGkgPCB0aGlzLnNjcm9sbFRhcmdldHMubGVuZ3RoICYmIHRoaXMuc2Nyb2xsVGFyZ2V0c1tpXSA9PSBkb20pXG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRoaXMuc2Nyb2xsVGFyZ2V0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZC5wdXNoKGRvbSk7XG4gICAgICAgICAgICAgICAgZG9tID0gZG9tLmFzc2lnbmVkU2xvdCB8fCBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5ob3N0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCB0aGlzLnNjcm9sbFRhcmdldHMubGVuZ3RoICYmICFjaGFuZ2VkKVxuICAgICAgICAgICAgY2hhbmdlZCA9IHRoaXMuc2Nyb2xsVGFyZ2V0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMpXG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzID0gY2hhbmdlZClcbiAgICAgICAgICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZ25vcmUoZikge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy5kb20sIG9ic2VydmVPcHRpb25zKTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgfVxuICAgIC8vIFRocm93IGF3YXkgYW55IHBlbmRpbmcgY2hhbmdlc1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NSZWNvcmRzKCk7XG4gICAgICAgIHRoaXMucXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIENocm9tZSBBbmRyb2lkLCBlc3BlY2lhbGx5IGluIGNvbWJpbmF0aW9uIHdpdGggR0JvYXJkLCBub3Qgb25seVxuICAgIC8vIGRvZXNuJ3QgcmVsaWFibHkgZmlyZSByZWd1bGFyIGtleSBldmVudHMsIGJ1dCBhbHNvIG9mdGVuXG4gICAgLy8gc3Vycm91bmRzIHRoZSBlZmZlY3Qgb2YgZW50ZXIgb3IgYmFja3NwYWNlIHdpdGggYSBidW5jaCBvZlxuICAgIC8vIGNvbXBvc2l0aW9uIGV2ZW50cyB0aGF0LCB3aGVuIGludGVycnVwdGVkLCBjYXVzZSB0ZXh0IGR1cGxpY2F0aW9uXG4gICAgLy8gb3Igb3RoZXIga2luZHMgb2YgY29ycnVwdGlvbi4gVGhpcyBoYWNrIG1ha2VzIHRoZSBlZGl0b3IgYmFjayBvZmZcbiAgICAvLyBmcm9tIGhhbmRsaW5nIERPTSBjaGFuZ2VzIGZvciBhIG1vbWVudCB3aGVuIHN1Y2ggYSBrZXkgaXNcbiAgICAvLyBkZXRlY3RlZCAodmlhIGJlZm9yZWlucHV0IG9yIGtleWRvd24pLCBhbmQgdGhlbiB0cmllcyB0byBmbHVzaFxuICAgIC8vIHRoZW0gb3IsIGlmIHRoYXQgaGFzIG5vIGVmZmVjdCwgZGlzcGF0Y2hlcyB0aGUgZ2l2ZW4ga2V5LlxuICAgIGRlbGF5QW5kcm9pZEtleShrZXksIGtleUNvZGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuZGVsYXllZEFuZHJvaWRLZXkpIHtcbiAgICAgICAgICAgIGxldCBmbHVzaCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gdGhpcy5kZWxheWVkQW5kcm9pZEtleTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZmx1c2goKSAmJiBrZXkuZm9yY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh0aGlzLmRvbSwga2V5LmtleSwga2V5LmtleUNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSA9IHRoaXMudmlldy53aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZsdXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSBiYWNrc3BhY2UgYmVmb3JlaW5wdXQgaXMgc29tZXRpbWVzIHNpZ25hbGxlZCBzcHVyaW91c2x5LFxuICAgICAgICAvLyBFbnRlciBhbHdheXMgdGFrZXMgcHJlY2VkZW5jZS5cbiAgICAgICAgaWYgKCF0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5IHx8IGtleSA9PSBcIkVudGVyXCIpXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5ID0ge1xuICAgICAgICAgICAgICAgIGtleSwga2V5Q29kZSxcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJ1biB0aGUga2V5IGhhbmRsZXIgd2hlbiBubyBjaGFuZ2VzIGFyZSBkZXRlY3RlZCBpZlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXNuJ3QgY29taW5nIHJpZ2h0IGFmdGVyIGFub3RoZXIgY2hhbmdlLCBpbiB3aGljaCBjYXNlXG4gICAgICAgICAgICAgICAgLy8gaXQgaXMgcHJvYmFibHkgcGFydCBvZiBhIHdlaXJkIGNoYWluIG9mIHVwZGF0ZXMsIGFuZCBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBiZSBpZ25vcmVkIGlmIGl0IHJldHVybnMgdGhlIERPTSB0byBpdHMgcHJldmlvdXMgc3RhdGUuXG4gICAgICAgICAgICAgICAgZm9yY2U6IHRoaXMubGFzdENoYW5nZSA8IERhdGUubm93KCkgLSA1MCB8fCAhISgoX2EgPSB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yY2UpXG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICBjbGVhckRlbGF5ZWRBbmRyb2lkS2V5KCkge1xuICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSk7XG4gICAgICAgIHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSA9IC0xO1xuICAgIH1cbiAgICBmbHVzaFNvb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRGbHVzaCA8IDApXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IHRoaXMudmlldy53aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHsgdGhpcy5kZWxheWVkRmx1c2ggPSAtMTsgdGhpcy5mbHVzaCgpOyB9KTtcbiAgICB9XG4gICAgZm9yY2VGbHVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZEZsdXNoID49IDApIHtcbiAgICAgICAgICAgIHRoaXMudmlldy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5kZWxheWVkRmx1c2gpO1xuICAgICAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICAgIHByb2Nlc3NSZWNvcmRzKCkge1xuICAgICAgICBsZXQgcmVjb3JkcyA9IHRoaXMucXVldWU7XG4gICAgICAgIGZvciAobGV0IG11dCBvZiB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCkpXG4gICAgICAgICAgICByZWNvcmRzLnB1c2gobXV0KTtcbiAgICAgICAgaWYgKHJlY29yZHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICBsZXQgZnJvbSA9IC0xLCB0byA9IC0xLCB0eXBlT3ZlciA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCByZWNvcmQgb2YgcmVjb3Jkcykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5yZWFkTXV0YXRpb24ocmVjb3JkKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UudHlwZU92ZXIpXG4gICAgICAgICAgICAgICAgdHlwZU92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGZyb20gPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAoeyBmcm9tLCB0byB9ID0gcmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9IE1hdGgubWluKHJhbmdlLmZyb20sIGZyb20pO1xuICAgICAgICAgICAgICAgIHRvID0gTWF0aC5tYXgocmFuZ2UudG8sIHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tLCB0bywgdHlwZU92ZXIgfTtcbiAgICB9XG4gICAgcmVhZENoYW5nZSgpIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8sIHR5cGVPdmVyIH0gPSB0aGlzLnByb2Nlc3NSZWNvcmRzKCk7XG4gICAgICAgIGxldCBuZXdTZWwgPSB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgJiYgaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCB0aGlzLnNlbGVjdGlvblJhbmdlKTtcbiAgICAgICAgaWYgKGZyb20gPCAwICYmICFuZXdTZWwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGZyb20gPiAtMSlcbiAgICAgICAgICAgIHRoaXMubGFzdENoYW5nZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSAwO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5ldyBET01DaGFuZ2UodGhpcy52aWV3LCBmcm9tLCB0bywgdHlwZU92ZXIpO1xuICAgIH1cbiAgICAvLyBBcHBseSBwZW5kaW5nIGNoYW5nZXMsIGlmIGFueVxuICAgIGZsdXNoKHJlYWRTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgICAgIC8vIENvbXBsZXRlbHkgaG9sZCBvZmYgZmx1c2hpbmcgd2hlbiBwZW5kaW5nIGtleXMgYXJlIHNldFx1MjAxNHRoZSBjb2RlXG4gICAgICAgIC8vIG1hbmFnaW5nIHRob3NlIHdpbGwgbWFrZSBzdXJlIHByb2Nlc3NSZWNvcmRzIGlzIGNhbGxlZCBhbmQgdGhlXG4gICAgICAgIC8vIHZpZXcgaXMgcmVzeW5jaHJvbml6ZWQgYWZ0ZXJcbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZEZsdXNoID49IDAgfHwgdGhpcy5kZWxheWVkQW5kcm9pZEtleSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHJlYWRTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgZG9tQ2hhbmdlID0gdGhpcy5yZWFkQ2hhbmdlKCk7XG4gICAgICAgIGlmICghZG9tQ2hhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnRTdGF0ZSA9IHRoaXMudmlldy5zdGF0ZTtcbiAgICAgICAgbGV0IGhhbmRsZWQgPSBhcHBseURPTUNoYW5nZSh0aGlzLnZpZXcsIGRvbUNoYW5nZSk7XG4gICAgICAgIC8vIFRoZSB2aWV3IHdhc24ndCB1cGRhdGVkXG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUgPT0gc3RhcnRTdGF0ZSlcbiAgICAgICAgICAgIHRoaXMudmlldy51cGRhdGUoW10pO1xuICAgICAgICByZXR1cm4gaGFuZGxlZDtcbiAgICB9XG4gICAgcmVhZE11dGF0aW9uKHJlYykge1xuICAgICAgICBsZXQgY1ZpZXcgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0KHJlYy50YXJnZXQpO1xuICAgICAgICBpZiAoIWNWaWV3IHx8IGNWaWV3Lmlnbm9yZU11dGF0aW9uKHJlYykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY1ZpZXcubWFya0RpcnR5KHJlYy50eXBlID09IFwiYXR0cmlidXRlc1wiKTtcbiAgICAgICAgaWYgKHJlYy50eXBlID09IFwiYXR0cmlidXRlc1wiKVxuICAgICAgICAgICAgY1ZpZXcuZGlydHkgfD0gNCAvKiBEaXJ0eS5BdHRycyAqLztcbiAgICAgICAgaWYgKHJlYy50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZEJlZm9yZSA9IGZpbmRDaGlsZChjVmlldywgcmVjLnByZXZpb3VzU2libGluZyB8fCByZWMudGFyZ2V0LnByZXZpb3VzU2libGluZywgLTEpO1xuICAgICAgICAgICAgbGV0IGNoaWxkQWZ0ZXIgPSBmaW5kQ2hpbGQoY1ZpZXcsIHJlYy5uZXh0U2libGluZyB8fCByZWMudGFyZ2V0Lm5leHRTaWJsaW5nLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb206IGNoaWxkQmVmb3JlID8gY1ZpZXcucG9zQWZ0ZXIoY2hpbGRCZWZvcmUpIDogY1ZpZXcucG9zQXRTdGFydCxcbiAgICAgICAgICAgICAgICB0bzogY2hpbGRBZnRlciA/IGNWaWV3LnBvc0JlZm9yZShjaGlsZEFmdGVyKSA6IGNWaWV3LnBvc0F0RW5kLCB0eXBlT3ZlcjogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWMudHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogY1ZpZXcucG9zQXRTdGFydCwgdG86IGNWaWV3LnBvc0F0RW5kLCB0eXBlT3ZlcjogcmVjLnRhcmdldC5ub2RlVmFsdWUgPT0gcmVjLm9sZFZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRXaW5kb3cod2luKSB7XG4gICAgICAgIGlmICh3aW4gIT0gdGhpcy53aW4pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcbiAgICAgICAgICAgIHRoaXMud2luID0gd2luO1xuICAgICAgICAgICAgdGhpcy5hZGRXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFdpbmRvd0xpc3RlbmVycyh3aW4pIHtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vblJlc2l6ZSk7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlcHJpbnRcIiwgdGhpcy5vblByaW50KTtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIHdpbi5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICByZW1vdmVXaW5kb3dMaXN0ZW5lcnMod2luKSB7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKTtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmVwcmludFwiLCB0aGlzLm9uUHJpbnQpO1xuICAgICAgICB3aW4uZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgKF9hID0gdGhpcy5pbnRlcnNlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgICAgIChfYiA9IHRoaXMuZ2FwSW50ZXJzZWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgICAgICAoX2MgPSB0aGlzLnJlc2l6ZVNjcm9sbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKF9kID0gdGhpcy5yZXNpemVDb250ZW50KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZGlzY29ubmVjdCgpO1xuICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzKVxuICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIHRoaXMucmVtb3ZlV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGFyZW50Q2hlY2spO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5kZWxheWVkRmx1c2gpO1xuICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZENoaWxkKGNWaWV3LCBkb20sIGRpcikge1xuICAgIHdoaWxlIChkb20pIHtcbiAgICAgICAgbGV0IGN1clZpZXcgPSBDb250ZW50Vmlldy5nZXQoZG9tKTtcbiAgICAgICAgaWYgKGN1clZpZXcgJiYgY3VyVmlldy5wYXJlbnQgPT0gY1ZpZXcpXG4gICAgICAgICAgICByZXR1cm4gY3VyVmlldztcbiAgICAgICAgbGV0IHBhcmVudCA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICBkb20gPSBwYXJlbnQgIT0gY1ZpZXcuZG9tID8gcGFyZW50IDogZGlyID4gMCA/IGRvbS5uZXh0U2libGluZyA6IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBhIFNhZmFyaSBTZWxlY3Rpb24vc2hhZG93IERPTSBidWcgKCM0MTQpXG5mdW5jdGlvbiBzYWZhcmlTZWxlY3Rpb25SYW5nZUhhY2sodmlldykge1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgLy8gQmVjYXVzZSBTYWZhcmkgKGF0IGxlYXN0IGluIDIwMTgtMjAyMSkgZG9lc24ndCBwcm92aWRlIHJlZ3VsYXJcbiAgICAvLyBhY2Nlc3MgdG8gdGhlIHNlbGVjdGlvbiBpbnNpZGUgYSBzaGFkb3dyb290LCB3ZSBoYXZlIHRvIHBlcmZvcm0gYVxuICAgIC8vIHJpZGljdWxvdXMgaGFjayB0byBnZXQgYXQgaXRcdTIwMTR1c2luZyBgZXhlY0NvbW1hbmRgIHRvIHRyaWdnZXIgYVxuICAgIC8vIGBiZWZvcmVJbnB1dGAgZXZlbnQgc28gdGhhdCB3ZSBjYW4gcmVhZCB0aGUgdGFyZ2V0IHJhbmdlIGZyb20gdGhlXG4gICAgLy8gZXZlbnQuXG4gICAgZnVuY3Rpb24gcmVhZChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZm91bmQgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKVswXTtcbiAgICB9XG4gICAgdmlldy5jb250ZW50RE9NLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICB2aWV3LmRvbS5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKFwiaW5kZW50XCIpO1xuICAgIHZpZXcuY29udGVudERPTS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGFuY2hvck5vZGUgPSBmb3VuZC5zdGFydENvbnRhaW5lciwgYW5jaG9yT2Zmc2V0ID0gZm91bmQuc3RhcnRPZmZzZXQ7XG4gICAgbGV0IGZvY3VzTm9kZSA9IGZvdW5kLmVuZENvbnRhaW5lciwgZm9jdXNPZmZzZXQgPSBmb3VuZC5lbmRPZmZzZXQ7XG4gICAgbGV0IGN1ckFuY2hvciA9IHZpZXcuZG9jVmlldy5kb21BdFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvcik7XG4gICAgLy8gU2luY2Ugc3VjaCBhIHJhbmdlIGRvZXNuJ3QgZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbmNob3IgYW5kIGhlYWQsXG4gICAgLy8gdXNlIGEgaGV1cmlzdGljIHRoYXQgZmxpcHMgaXQgYXJvdW5kIGlmIGl0cyBlbmQgbWF0Y2hlcyB0aGVcbiAgICAvLyBjdXJyZW50IGFuY2hvci5cbiAgICBpZiAoaXNFcXVpdmFsZW50UG9zaXRpb24oY3VyQW5jaG9yLm5vZGUsIGN1ckFuY2hvci5vZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKVxuICAgICAgICBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSA9IFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0LCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdO1xuICAgIHJldHVybiB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9O1xufVxuXG4vLyBUaGUgZWRpdG9yJ3MgdXBkYXRlIHN0YXRlIG1hY2hpbmUgbG9va3Mgc29tZXRoaW5nIGxpa2UgdGhpczpcbi8vXG4vLyAgICAgSWRsZSBcdTIxOTIgVXBkYXRpbmcgXHUyMUM2IElkbGUgKHVuY2hlY2tlZCkgXHUyMTkyIE1lYXN1cmluZyBcdTIxOTIgSWRsZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx1MjE5MSAgICAgIFx1MjE5M1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVwZGF0aW5nIChtZWFzdXJlKVxuLy9cbi8vIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gJ0lkbGUnIGFuZCAnSWRsZSAodW5jaGVja2VkKScgbGllcyBpblxuLy8gd2hldGhlciBhIGxheW91dCBjaGVjayBoYXMgYmVlbiBzY2hlZHVsZWQuIEEgcmVndWxhciB1cGRhdGUgdGhyb3VnaFxuLy8gdGhlIGB1cGRhdGVgIG1ldGhvZCB1cGRhdGVzIHRoZSBET00gaW4gYSB3cml0ZS1vbmx5IGZhc2hpb24sIGFuZFxuLy8gcmVsaWVzIG9uIGEgY2hlY2sgKHNjaGVkdWxlZCB3aXRoIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgKSB0byBtYWtlXG4vLyBzdXJlIGV2ZXJ5dGhpbmcgaXMgd2hlcmUgaXQgc2hvdWxkIGJlIGFuZCB0aGUgdmlld3BvcnQgY292ZXJzIHRoZVxuLy8gdmlzaWJsZSBjb2RlLiBUaGF0IGNoZWNrIGNvbnRpbnVlcyB0byBtZWFzdXJlIGFuZCB0aGVuIG9wdGlvbmFsbHlcbi8vIHVwZGF0ZSB1bnRpbCBpdCByZWFjaGVzIGEgY29oZXJlbnQgc3RhdGUuXG4vKipcbkFuIGVkaXRvciB2aWV3IHJlcHJlc2VudHMgdGhlIGVkaXRvcidzIHVzZXIgaW50ZXJmYWNlLiBJdCBob2xkc1xudGhlIGVkaXRhYmxlIERPTSBzdXJmYWNlLCBhbmQgcG9zc2libHkgb3RoZXIgZWxlbWVudHMgc3VjaCBhcyB0aGVcbmxpbmUgbnVtYmVyIGd1dHRlci4gSXQgaGFuZGxlcyBldmVudHMgYW5kIGRpc3BhdGNoZXMgc3RhdGVcbnRyYW5zYWN0aW9ucyBmb3IgZWRpdGluZyBhY3Rpb25zLlxuKi9cbmNsYXNzIEVkaXRvclZpZXcge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIG5ldyB2aWV3LiBZb3UnbGwgd2FudCB0byBlaXRoZXIgcHJvdmlkZSBhIGBwYXJlbnRgXG4gICAgb3B0aW9uLCBvciBwdXQgYHZpZXcuZG9tYCBpbnRvIHlvdXIgZG9jdW1lbnQgYWZ0ZXIgY3JlYXRpbmcgYVxuICAgIHZpZXcsIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHNlZSB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMucGx1Z2luTWFwID0gbmV3IE1hcDtcbiAgICAgICAgdGhpcy5lZGl0b3JBdHRycyA9IHt9O1xuICAgICAgICB0aGlzLmNvbnRlbnRBdHRycyA9IHt9O1xuICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzID0gW107XG4gICAgICAgIHRoaXMuY29udGVudERPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00udGFiSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00uY2xhc3NOYW1lID0gXCJjbS1zY3JvbGxlclwiO1xuICAgICAgICB0aGlzLnNjcm9sbERPTS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IHRvcDogLTEwMDAwcHhcIjtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIiwgXCJwb2xpdGVcIik7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5hbm5vdW5jZURPTSk7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsRE9NKTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2ggPSBjb25maWcuZGlzcGF0Y2ggfHwgKCh0cikgPT4gdGhpcy51cGRhdGUoW3RyXSkpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gdGhpcy5kaXNwYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9yb290ID0gKGNvbmZpZy5yb290IHx8IGdldFJvb3QoY29uZmlnLnBhcmVudCkgfHwgZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLnZpZXdTdGF0ZSA9IG5ldyBWaWV3U3RhdGUoY29uZmlnLnN0YXRlIHx8IEVkaXRvclN0YXRlLmNyZWF0ZShjb25maWcpKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5zdGF0ZS5mYWNldCh2aWV3UGx1Z2luKS5tYXAoc3BlYyA9PiBuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgcGx1Z2luLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBET01PYnNlcnZlcih0aGlzKTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlID0gbmV3IElucHV0U3RhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzLCB0aGlzLnBsdWdpbnMpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcgPSBuZXcgRG9jVmlldyh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wYXJlbnQpXG4gICAgICAgICAgICBjb25maWcucGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZG9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IHN0YXRlKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuc3RhdGU7IH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIGRpc3BsYXkgbGFyZ2UgZG9jdW1lbnRzIHdpdGhvdXQgY29uc3VtaW5nIHRvbyBtdWNoXG4gICAgbWVtb3J5IG9yIG92ZXJsb2FkaW5nIHRoZSBicm93c2VyLCBDb2RlTWlycm9yIG9ubHkgZHJhd3MgdGhlXG4gICAgY29kZSB0aGF0IGlzIHZpc2libGUgKHBsdXMgYSBtYXJnaW4gYXJvdW5kIGl0KSB0byB0aGUgRE9NLiBUaGlzXG4gICAgcHJvcGVydHkgdGVsbHMgeW91IHRoZSBleHRlbnQgb2YgdGhlIGN1cnJlbnQgZHJhd24gdmlld3BvcnQsIGluXG4gICAgZG9jdW1lbnQgcG9zaXRpb25zLlxuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlld3BvcnQ7IH1cbiAgICAvKipcbiAgICBXaGVuIHRoZXJlIGFyZSwgZm9yIGV4YW1wbGUsIGxhcmdlIGNvbGxhcHNlZCByYW5nZXMgaW4gdGhlXG4gICAgdmlld3BvcnQsIGl0cyBzaXplIGNhbiBiZSBhIGxvdCBiaWdnZXIgdGhhbiB0aGUgYWN0dWFsIHZpc2libGVcbiAgICBjb250ZW50LiBUaHVzLCBpZiB5b3UgYXJlIGRvaW5nIHNvbWV0aGluZyBsaWtlIHN0eWxpbmcgdGhlXG4gICAgY29udGVudCBpbiB0aGUgdmlld3BvcnQsIGl0IGlzIHByZWZlcmFibGUgdG8gb25seSBkbyBzbyBmb3JcbiAgICB0aGVzZSByYW5nZXMsIHdoaWNoIGFyZSB0aGUgc3Vic2V0IG9mIHRoZSB2aWV3cG9ydCB0aGF0IGlzXG4gICAgYWN0dWFsbHkgZHJhd24uXG4gICAgKi9cbiAgICBnZXQgdmlzaWJsZVJhbmdlcygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpc2libGVSYW5nZXM7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGZhbHNlIHdoZW4gdGhlIGVkaXRvciBpcyBlbnRpcmVseSBzY3JvbGxlZCBvdXQgb2Ygdmlld1xuICAgIG9yIG90aGVyd2lzZSBoaWRkZW4uXG4gICAgKi9cbiAgICBnZXQgaW5WaWV3KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaW5WaWV3OyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgaXMgY3VycmVudGx5IGNvbXBvc2luZyB0ZXh0IHZpYVxuICAgIFtJTUVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lucHV0X21ldGhvZCksIGFuZCBhdCBsZWFzdFxuICAgIG9uZSBjaGFuZ2UgaGFzIGJlZW4gbWFkZSBpbiB0aGUgY3VycmVudCBjb21wb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBjb21wb3NpbmcoKSB7IHJldHVybiB0aGlzLmlucHV0U3RhdGUuY29tcG9zaW5nID4gMDsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBpbiBjb21wb3Npbmcgc3RhdGUuIE5vdGVcbiAgICB0aGF0IG9uIHNvbWUgcGxhdGZvcm1zLCBsaWtlIEFuZHJvaWQsIHRoaXMgd2lsbCBiZSB0aGUgY2FzZSBhXG4gICAgbG90LCBzaW5jZSBqdXN0IHB1dHRpbmcgdGhlIGN1cnNvciBvbiBhIHdvcmQgc3RhcnRzIGFcbiAgICBjb21wb3NpdGlvbiB0aGVyZS5cbiAgICAqL1xuICAgIGdldCBjb21wb3NpdGlvblN0YXJ0ZWQoKSB7IHJldHVybiB0aGlzLmlucHV0U3RhdGUuY29tcG9zaW5nID49IDA7IH1cbiAgICAvKipcbiAgICBUaGUgZG9jdW1lbnQgb3Igc2hhZG93IHJvb3QgdGhhdCB0aGUgdmlldyBsaXZlcyBpbi5cbiAgICAqL1xuICAgIGdldCByb290KCkgeyByZXR1cm4gdGhpcy5fcm9vdDsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHdpbigpIHsgcmV0dXJuIHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93OyB9XG4gICAgZGlzcGF0Y2goLi4uaW5wdXQpIHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2goaW5wdXQubGVuZ3RoID09IDEgJiYgaW5wdXRbMF0gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbiA/IGlucHV0WzBdXG4gICAgICAgICAgICA6IHRoaXMuc3RhdGUudXBkYXRlKC4uLmlucHV0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdmlldyBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIHRyYW5zYWN0aW9ucy4gVGhpcyB3aWxsXG4gICAgdXBkYXRlIHRoZSB2aXNpYmxlIGRvY3VtZW50IGFuZCBzZWxlY3Rpb24gdG8gbWF0Y2ggdGhlIHN0YXRlXG4gICAgcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9ucywgYW5kIG5vdGlmeSB2aWV3IHBsdWdpbnMgb2YgdGhlXG4gICAgY2hhbmdlLiBZb3Ugc2hvdWxkIHVzdWFsbHkgY2FsbFxuICAgIFtgZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkgaW5zdGVhZCwgd2hpY2ggdXNlcyB0aGlzXG4gICAgYXMgYSBwcmltaXRpdmUuXG4gICAgKi9cbiAgICB1cGRhdGUodHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlICE9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxzIHRvIEVkaXRvclZpZXcudXBkYXRlIGFyZSBub3QgYWxsb3dlZCB3aGlsZSBhbiB1cGRhdGUgaXMgaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgIGxldCByZWRyYXduID0gZmFsc2UsIGF0dHJzQ2hhbmdlZCA9IGZhbHNlLCB1cGRhdGU7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRyLnN0YXJ0U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gdXBkYXRlIHN0YXRlIHdpdGggYSB0cmFuc2FjdGlvbiB0aGF0IGRvZXNuJ3Qgc3RhcnQgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUuXCIpO1xuICAgICAgICAgICAgc3RhdGUgPSB0ci5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvY3VzID0gdGhpcy5oYXNGb2N1cywgZm9jdXNGbGFnID0gMCwgZGlzcGF0Y2hGb2N1cyA9IG51bGw7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5hbm5vdGF0aW9uKGlzRm9jdXNDaGFuZ2UpKSkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCA9IGZvY3VzO1xuICAgICAgICAgICAgLy8gSWYgYSBmb2N1cy1jaGFuZ2UgdHJhbnNhY3Rpb24gaXMgYmVpbmcgZGlzcGF0Y2hlZCwgc2V0IHRoaXMgdXBkYXRlIGZsYWcuXG4gICAgICAgICAgICBmb2N1c0ZsYWcgPSAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9jdXMgIT0gdGhpcy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCA9IGZvY3VzO1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBzZXBhcmF0ZSBmb2N1cyB0cmFuc2FjdGlvbiBpZiBuZWNlc3NhcnksIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gYWRkIGEgZmxhZyB0byB0aGlzIHVwZGF0ZVxuICAgICAgICAgICAgZGlzcGF0Y2hGb2N1cyA9IGZvY3VzQ2hhbmdlVHJhbnNhY3Rpb24oc3RhdGUsIGZvY3VzKTtcbiAgICAgICAgICAgIGlmICghZGlzcGF0Y2hGb2N1cylcbiAgICAgICAgICAgICAgICBmb2N1c0ZsYWcgPSAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi87XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcGVuZGluZyBET00gY2hhbmdlLCBlYWdlcmx5IHJlYWQgaXQgYW5kIHRyeSB0b1xuICAgICAgICAvLyBhcHBseSBpdCBhZnRlciB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb25zLlxuICAgICAgICBsZXQgcGVuZGluZ0tleSA9IHRoaXMub2JzZXJ2ZXIuZGVsYXllZEFuZHJvaWRLZXksIGRvbUNoYW5nZSA9IG51bGw7XG4gICAgICAgIGlmIChwZW5kaW5nS2V5KSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKTtcbiAgICAgICAgICAgIGRvbUNoYW5nZSA9IHRoaXMub2JzZXJ2ZXIucmVhZENoYW5nZSgpO1xuICAgICAgICAgICAgLy8gT25seSB0cnkgdG8gYXBwbHkgRE9NIGNoYW5nZXMgaWYgdGhlIHRyYW5zYWN0aW9ucyBkaWRuJ3RcbiAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgZG9jIG9yIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIGlmIChkb21DaGFuZ2UgJiYgIXRoaXMuc3RhdGUuZG9jLmVxKHN0YXRlLmRvYykgfHwgIXRoaXMuc3RhdGUuc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgZG9tQ2hhbmdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZSBwaHJhc2VzIGNoYW5nZSwgcmVkcmF3IHRoZSBlZGl0b3JcbiAgICAgICAgaWYgKHN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLnBocmFzZXMpICE9IHRoaXMuc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHVwZGF0ZSA9IFZpZXdVcGRhdGUuY3JlYXRlKHRoaXMsIHN0YXRlLCB0cmFuc2FjdGlvbnMpO1xuICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gZm9jdXNGbGFnO1xuICAgICAgICBsZXQgc2Nyb2xsVGFyZ2V0ID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBzY3JvbGxUYXJnZXQubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIGlmICh0ci5zY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBtYWluIH0gPSB0ci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IG5ldyBTY3JvbGxUYXJnZXQobWFpbi5lbXB0eSA/IG1haW4gOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG1haW4uaGVhZCwgbWFpbi5oZWFkID4gbWFpbi5hbmNob3IgPyAtMSA6IDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5pcyhzY3JvbGxJbnRvVmlldykpXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUudXBkYXRlKHVwZGF0ZSwgc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuYmlkaUNhY2hlID0gQ2FjaGVkT3JkZXIudXBkYXRlKHRoaXMuYmlkaUNhY2hlLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGx1Z2lucyh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZHJhd24gPSB0aGlzLmRvY1ZpZXcudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5mYWNldChzdHlsZU1vZHVsZSkgIT0gdGhpcy5zdHlsZU1vZHVsZXMpXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICAgICAgYXR0cnNDaGFuZ2VkID0gdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICAgICAgdGhpcy5zaG93QW5ub3VuY2VtZW50cyh0cmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbihyZWRyYXduLCB0cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5pc1VzZXJFdmVudChcInNlbGVjdC5wb2ludGVyXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldCh0aGVtZSkgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KHRoZW1lKSlcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIGlmIChyZWRyYXduIHx8IGF0dHJzQ2hhbmdlZCB8fCBzY3JvbGxUYXJnZXQgfHwgdGhpcy52aWV3U3RhdGUubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyB8fCB0aGlzLnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQpXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIGlmICghdXBkYXRlLmVtcHR5KVxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZS5mYWNldCh1cGRhdGVMaXN0ZW5lcikpXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIodXBkYXRlKTtcbiAgICAgICAgaWYgKGRpc3BhdGNoRm9jdXMgfHwgZG9tQ2hhbmdlKVxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoRm9jdXMgJiYgdGhpcy5zdGF0ZSA9PSBkaXNwYXRjaEZvY3VzLnN0YXJ0U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goZGlzcGF0Y2hGb2N1cyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbUNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFwcGx5RE9NQ2hhbmdlKHRoaXMsIGRvbUNoYW5nZSkgJiYgcGVuZGluZ0tleS5mb3JjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHRoaXMuY29udGVudERPTSwgcGVuZGluZ0tleS5rZXksIHBlbmRpbmdLZXkua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc2V0IHRoZSB2aWV3IHRvIHRoZSBnaXZlbiBzdGF0ZS4gKFRoaXMgd2lsbCBjYXVzZSB0aGUgZW50aXJlXG4gICAgZG9jdW1lbnQgdG8gYmUgcmVkcmF3biBhbmQgYWxsIHZpZXcgcGx1Z2lucyB0byBiZSByZWluaXRpYWxpemVkLFxuICAgIHNvIHlvdSBzaG91bGQgcHJvYmFibHkgb25seSB1c2UgaXQgd2hlbiB0aGUgbmV3IHN0YXRlIGlzbid0XG4gICAgZGVyaXZlZCBmcm9tIHRoZSBvbGQgc3RhdGUuIE90aGVyd2lzZSwgdXNlXG4gICAgW2BkaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKSBpbnN0ZWFkLilcbiAgICAqL1xuICAgIHNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlICE9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxzIHRvIEVkaXRvclZpZXcuc2V0U3RhdGUgYXJlIG5vdCBhbGxvd2VkIHdoaWxlIGFuIHVwZGF0ZSBpcyBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICBsZXQgaGFkRm9jdXMgPSB0aGlzLmhhc0ZvY3VzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBwbHVnaW4uZGVzdHJveSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlID0gbmV3IFZpZXdTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMgPSBuZXdTdGF0ZS5mYWNldCh2aWV3UGx1Z2luKS5tYXAoc3BlYyA9PiBuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuY2xlYXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgcGx1Z2luLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldyA9IG5ldyBEb2NWaWV3KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMsIHRoaXMucGx1Z2lucyk7XG4gICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFkRm9jdXMpXG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICB9XG4gICAgdXBkYXRlUGx1Z2lucyh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXZTcGVjcyA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLCBzcGVjcyA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh2aWV3UGx1Z2luKTtcbiAgICAgICAgaWYgKHByZXZTcGVjcyAhPSBzcGVjcykge1xuICAgICAgICAgICAgbGV0IG5ld1BsdWdpbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBwcmV2U3BlY3MuaW5kZXhPZihzcGVjKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BsdWdpbnMucHVzaChuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMucGx1Z2luc1tmb3VuZF07XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5tdXN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICBuZXdQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ubXVzdFVwZGF0ZSAhPSB1cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3UGx1Z2lucztcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcywgdGhpcy5wbHVnaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHAubXVzdFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucGx1Z2luc1tpXS51cGRhdGUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWVhc3VyZShmbHVzaCA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xuICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAwOyAvLyBQcmV2ZW50IHJlcXVlc3RNZWFzdXJlIGNhbGxzIGZyb20gc2NoZWR1bGluZyBhbm90aGVyIGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICBpZiAoZmx1c2gpXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBudWxsO1xuICAgICAgICBsZXQgeyBzY3JvbGxIZWlnaHQsIHNjcm9sbFRvcCwgY2xpZW50SGVpZ2h0IH0gPSB0aGlzLnNjcm9sbERPTTtcbiAgICAgICAgbGV0IHJlZkhlaWdodCA9IHNjcm9sbFRvcCA+IHNjcm9sbEhlaWdodCAtIGNsaWVudEhlaWdodCAtIDQgPyBzY3JvbGxIZWlnaHQgOiBzY3JvbGxUb3A7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAxIC8qIFVwZGF0ZVN0YXRlLk1lYXN1cmluZyAqLztcbiAgICAgICAgICAgICAgICBsZXQgb2xkVmlld3BvcnQgPSB0aGlzLnZpZXdwb3J0O1xuICAgICAgICAgICAgICAgIGxldCByZWZCbG9jayA9IHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0SGVpZ2h0KHJlZkhlaWdodCk7XG4gICAgICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLnZpZXdTdGF0ZS5tZWFzdXJlKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICghY2hhbmdlZCAmJiAhdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoICYmIHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIk1lYXN1cmUgbG9vcCByZXN0YXJ0ZWQgbW9yZSB0aGFuIDUgdGltZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlZpZXdwb3J0IGZhaWxlZCB0byBzdGFiaWxpemVcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyaW5nID0gW107XG4gICAgICAgICAgICAgICAgLy8gT25seSBydW4gbWVhc3VyZSByZXF1ZXN0cyBpbiB0aGlzIGN5Y2xlIHdoZW4gdGhlIHZpZXdwb3J0IGRpZG4ndCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoIShjaGFuZ2VkICYgNCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0ICovKSlcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMubWVhc3VyZVJlcXVlc3RzLCBtZWFzdXJpbmddID0gW21lYXN1cmluZywgdGhpcy5tZWFzdXJlUmVxdWVzdHNdO1xuICAgICAgICAgICAgICAgIGxldCBtZWFzdXJlZCA9IG1lYXN1cmluZy5tYXAobSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbS5yZWFkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFkTWVhc3VyZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCB1cGRhdGUgPSBWaWV3VXBkYXRlLmNyZWF0ZSh0aGlzLCB0aGlzLnN0YXRlLCBbXSksIHJlZHJhd24gPSBmYWxzZSwgc2Nyb2xsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gY2hhbmdlZDtcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSB1cGRhdGU7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmZsYWdzIHw9IGNoYW5nZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5zKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICAgICAgICAgICAgICByZWRyYXduID0gdGhpcy5kb2NWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lYXN1cmluZy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lYXN1cmVkW2ldICE9IEJhZE1lYXN1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBtZWFzdXJpbmdbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ud3JpdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ud3JpdGUobWVhc3VyZWRbaV0sIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3U3RhdGUuZWRpdG9ySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy5zY3JvbGxJbnRvVmlldyh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaWZmID0gdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXQocmVmQmxvY2suZnJvbSkudG9wIC0gcmVmQmxvY2sudG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPiAxIHx8IGRpZmYgPCAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRE9NLnNjcm9sbFRvcCArPSBkaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVkcmF3bilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3cG9ydC5mcm9tID09IG9sZFZpZXdwb3J0LmZyb20gJiYgdGhpcy52aWV3cG9ydC50byA9PSBvbGRWaWV3cG9ydC50byAmJlxuICAgICAgICAgICAgICAgICAgICAhc2Nyb2xsZWQgJiYgdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkICYmICF1cGRhdGVkLmVtcHR5KVxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZS5mYWNldCh1cGRhdGVMaXN0ZW5lcikpXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIodXBkYXRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgQ1NTIGNsYXNzZXMgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGVkaXRvciB0aGVtZXMuXG4gICAgKi9cbiAgICBnZXQgdGhlbWVDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gYmFzZVRoZW1lSUQgKyBcIiBcIiArXG4gICAgICAgICAgICAodGhpcy5zdGF0ZS5mYWNldChkYXJrVGhlbWUpID8gYmFzZURhcmtJRCA6IGJhc2VMaWdodElEKSArIFwiIFwiICtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZmFjZXQodGhlbWUpO1xuICAgIH1cbiAgICB1cGRhdGVBdHRycygpIHtcbiAgICAgICAgbGV0IGVkaXRvckF0dHJzID0gYXR0cnNGcm9tRmFjZXQodGhpcywgZWRpdG9yQXR0cmlidXRlcywge1xuICAgICAgICAgICAgY2xhc3M6IFwiY20tZWRpdG9yXCIgKyAodGhpcy5oYXNGb2N1cyA/IFwiIGNtLWZvY3VzZWQgXCIgOiBcIiBcIikgKyB0aGlzLnRoZW1lQ2xhc3Nlc1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGNvbnRlbnRBdHRycyA9IHtcbiAgICAgICAgICAgIHNwZWxsY2hlY2s6IFwiZmFsc2VcIixcbiAgICAgICAgICAgIGF1dG9jb3JyZWN0OiBcIm9mZlwiLFxuICAgICAgICAgICAgYXV0b2NhcGl0YWxpemU6IFwib2ZmXCIsXG4gICAgICAgICAgICB0cmFuc2xhdGU6IFwibm9cIixcbiAgICAgICAgICAgIGNvbnRlbnRlZGl0YWJsZTogIXRoaXMuc3RhdGUuZmFjZXQoZWRpdGFibGUpID8gXCJmYWxzZVwiIDogXCJ0cnVlXCIsXG4gICAgICAgICAgICBjbGFzczogXCJjbS1jb250ZW50XCIsXG4gICAgICAgICAgICBzdHlsZTogYCR7YnJvd3Nlci50YWJTaXplfTogJHt0aGlzLnN0YXRlLnRhYlNpemV9YCxcbiAgICAgICAgICAgIHJvbGU6IFwidGV4dGJveFwiLFxuICAgICAgICAgICAgXCJhcmlhLW11bHRpbGluZVwiOiBcInRydWVcIlxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIGNvbnRlbnRBdHRyc1tcImFyaWEtcmVhZG9ubHlcIl0gPSBcInRydWVcIjtcbiAgICAgICAgYXR0cnNGcm9tRmFjZXQodGhpcywgY29udGVudEF0dHJpYnV0ZXMsIGNvbnRlbnRBdHRycyk7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNoYW5nZWRDb250ZW50ID0gdXBkYXRlQXR0cnModGhpcy5jb250ZW50RE9NLCB0aGlzLmNvbnRlbnRBdHRycywgY29udGVudEF0dHJzKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkRWRpdG9yID0gdXBkYXRlQXR0cnModGhpcy5kb20sIHRoaXMuZWRpdG9yQXR0cnMsIGVkaXRvckF0dHJzKTtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkQ29udGVudCB8fCBjaGFuZ2VkRWRpdG9yO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lZGl0b3JBdHRycyA9IGVkaXRvckF0dHJzO1xuICAgICAgICB0aGlzLmNvbnRlbnRBdHRycyA9IGNvbnRlbnRBdHRycztcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuICAgIHNob3dBbm5vdW5jZW1lbnRzKHRycykge1xuICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cnMpXG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKEVkaXRvclZpZXcuYW5ub3VuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5ub3VuY2VET00udGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGl2ID0gdGhpcy5hbm5vdW5jZURPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnRleHRDb250ZW50ID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICB9XG4gICAgbW91bnRTdHlsZXMoKSB7XG4gICAgICAgIHRoaXMuc3R5bGVNb2R1bGVzID0gdGhpcy5zdGF0ZS5mYWNldChzdHlsZU1vZHVsZSk7XG4gICAgICAgIFN0eWxlTW9kdWxlLm1vdW50KHRoaXMucm9vdCwgdGhpcy5zdHlsZU1vZHVsZXMuY29uY2F0KGJhc2VUaGVtZSQxKS5yZXZlcnNlKCkpO1xuICAgIH1cbiAgICByZWFkTWVhc3VyZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlID09IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFkaW5nIHRoZSBlZGl0b3IgbGF5b3V0IGlzbid0IGFsbG93ZWQgZHVyaW5nIGFuIHVwZGF0ZVwiKTtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgPT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovICYmIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA+IC0xKVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlKGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2NoZWR1bGUgYSBsYXlvdXQgbWVhc3VyZW1lbnQsIG9wdGlvbmFsbHkgcHJvdmlkaW5nIGNhbGxiYWNrcyB0b1xuICAgIGRvIGN1c3RvbSBET00gbWVhc3VyaW5nIGZvbGxvd2VkIGJ5IGEgRE9NIHdyaXRlIHBoYXNlLiBVc2luZ1xuICAgIHRoaXMgaXMgcHJlZmVyYWJsZSByZWFkaW5nIERPTSBsYXlvdXQgZGlyZWN0bHkgZnJvbSwgZm9yXG4gICAgZXhhbXBsZSwgYW4gZXZlbnQgaGFuZGxlciwgYmVjYXVzZSBpdCdsbCBtYWtlIHN1cmUgbWVhc3VyaW5nIGFuZFxuICAgIGRyYXdpbmcgZG9uZSBieSBvdGhlciBjb21wb25lbnRzIGlzIHN5bmNocm9uaXplZCwgYXZvaWRpbmdcbiAgICB1bm5lY2Vzc2FyeSBET00gbGF5b3V0IGNvbXB1dGF0aW9ucy5cbiAgICAqL1xuICAgIHJlcXVlc3RNZWFzdXJlKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVNjaGVkdWxlZCA8IDApXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSB0aGlzLndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5tZWFzdXJlKCkpO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWVhc3VyZVJlcXVlc3RzLmluZGV4T2YocmVxdWVzdCkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5rZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1lYXN1cmVSZXF1ZXN0c1tpXS5rZXkgPT09IHJlcXVlc3Qua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0c1tpXSA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpYyBwbHVnaW4sIGlmIHByZXNlbnQuIE5vdGUgdGhhdFxuICAgIHBsdWdpbnMgdGhhdCBjcmFzaCBjYW4gYmUgZHJvcHBlZCBmcm9tIGEgdmlldywgc28gZXZlbiB3aGVuIHlvdVxuICAgIGtub3cgeW91IHJlZ2lzdGVyZWQgYSBnaXZlbiBwbHVnaW4sIGl0IGlzIHJlY29tbWVuZGVkIHRvIGNoZWNrXG4gICAgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIG1ldGhvZC5cbiAgICAqL1xuICAgIHBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgbGV0IGtub3duID0gdGhpcy5wbHVnaW5NYXAuZ2V0KHBsdWdpbik7XG4gICAgICAgIGlmIChrbm93biA9PT0gdW5kZWZpbmVkIHx8IGtub3duICYmIGtub3duLnNwZWMgIT0gcGx1Z2luKVxuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuc2V0KHBsdWdpbiwga25vd24gPSB0aGlzLnBsdWdpbnMuZmluZChwID0+IHAuc3BlYyA9PSBwbHVnaW4pIHx8IG51bGwpO1xuICAgICAgICByZXR1cm4ga25vd24gJiYga25vd24udXBkYXRlKHRoaXMpLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBkb2N1bWVudCwgaW4gc2NyZWVuIGNvb3JkaW5hdGVzLiBUaGlzXG4gICAgbWF5IGJlIG5lZ2F0aXZlIHdoZW4gdGhlIGVkaXRvciBpcyBzY3JvbGxlZCBkb3duLiBQb2ludHNcbiAgICBkaXJlY3RseSB0byB0aGUgdG9wIG9mIHRoZSBmaXJzdCBsaW5lLCBub3QgYWJvdmUgdGhlIHBhZGRpbmcuXG4gICAgKi9cbiAgICBnZXQgZG9jdW1lbnRUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy52aWV3U3RhdGUucGFkZGluZ1RvcDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwb3J0cyB0aGUgcGFkZGluZyBhYm92ZSBhbmQgYmVsb3cgdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRvY3VtZW50UGFkZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nVG9wLCBib3R0b206IHRoaXMudmlld1N0YXRlLnBhZGRpbmdCb3R0b20gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgdGV4dCBsaW5lIG9yIGJsb2NrIHdpZGdldCBhdCB0aGUgZ2l2ZW4gdmVydGljYWxcbiAgICBwb3NpdGlvbiAod2hpY2ggaXMgaW50ZXJwcmV0ZWQgYXMgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvY3VtZW50VG9wKSkuXG4gICAgKi9cbiAgICBlbGVtZW50QXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5lbGVtZW50QXRIZWlnaHQoaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgbGluZSBibG9jayAoc2VlXG4gICAgW2BsaW5lQmxvY2tBdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVCbG9ja0F0KSBhdCB0aGUgZ2l2ZW5cbiAgICBoZWlnaHQsIGFnYWluIGludGVycHJldGVkIHJlbGF0aXZlIHRvIHRoZSBbdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb2N1bWVudFRvcCkuXG4gICAgKi9cbiAgICBsaW5lQmxvY2tBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZXh0ZW50IGFuZCB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBhbGwgW2xpbmVcbiAgICBibG9ja3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVCbG9ja0F0KSBpbiB0aGUgdmlld3BvcnQuIFBvc2l0aW9uc1xuICAgIGFyZSByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0TGluZUJsb2NrcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpZXdwb3J0TGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGxpbmUgYmxvY2sgYXJvdW5kIHRoZSBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi4gQSBsaW5lXG4gICAgYmxvY2sgaXMgYSByYW5nZSBkZWxpbWl0ZWQgb24gYm90aCBzaWRlcyBieSBlaXRoZXIgYVxuICAgIG5vbi1baGlkZGVuXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBsaW5lIGJyZWFrcywgb3IgdGhlXG4gICAgc3RhcnQvZW5kIG9mIHRoZSBkb2N1bWVudC4gSXQgd2lsbCB1c3VhbGx5IGp1c3QgaG9sZCBhIGxpbmUgb2ZcbiAgICB0ZXh0LCBidXQgbWF5IGJlIGJyb2tlbiBpbnRvIG11bHRpcGxlIHRleHRibG9ja3MgYnkgYmxvY2tcbiAgICB3aWRnZXRzLlxuICAgICovXG4gICAgbGluZUJsb2NrQXQocG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5saW5lQmxvY2tBdChwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZWRpdG9yJ3MgdG90YWwgY29udGVudCBoZWlnaHQuXG4gICAgKi9cbiAgICBnZXQgY29udGVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmNvbnRlbnRIZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gYnkgW2dyYXBoZW1lXG4gICAgY2x1c3Rlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKS4gYGZvcndhcmRgIGRldGVybWluZXMgd2hldGhlclxuICAgIHRoZSBtb3Rpb24gaXMgYXdheSBmcm9tIHRoZSBsaW5lIHN0YXJ0LCBvciB0b3dhcmRzIGl0LiBJblxuICAgIGJpZGlyZWN0aW9uYWwgdGV4dCwgdGhlIGxpbmUgaXMgdHJhdmVyc2VkIGluIHZpc3VhbCBvcmRlciwgdXNpbmdcbiAgICB0aGUgZWRpdG9yJ3MgW3RleHQgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS5cbiAgICBXaGVuIHRoZSBzdGFydCBwb3NpdGlvbiB3YXMgdGhlIGxhc3Qgb25lIG9uIHRoZSBsaW5lLCB0aGVcbiAgICByZXR1cm5lZCBwb3NpdGlvbiB3aWxsIGJlIGFjcm9zcyB0aGUgbGluZSBicmVhay4gSWYgdGhlcmUgaXMgbm9cbiAgICBmdXJ0aGVyIGxpbmUsIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGlzIG1ldGhvZCBtb3ZlcyBvdmVyIGEgc2luZ2xlIGNsdXN0ZXIuIFRoZVxuICAgIG9wdGlvbmFsIGBieWAgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gbW92ZSBhY3Jvc3MgbW9yZS4gSXQgd2lsbFxuICAgIGJlIGNhbGxlZCB3aXRoIHRoZSBmaXJzdCBjbHVzdGVyIGFzIGFyZ3VtZW50LCBhbmQgc2hvdWxkIHJldHVyblxuICAgIGEgcHJlZGljYXRlIHRoYXQgZGV0ZXJtaW5lcywgZm9yIGVhY2ggc3Vic2VxdWVudCBjbHVzdGVyLFxuICAgIHdoZXRoZXIgaXQgc2hvdWxkIGFsc28gYmUgbW92ZWQgb3Zlci5cbiAgICAqL1xuICAgIG1vdmVCeUNoYXIoc3RhcnQsIGZvcndhcmQsIGJ5KSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVCeUNoYXIodGhpcywgc3RhcnQsIGZvcndhcmQsIGJ5KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gYWNyb3NzIHRoZSBuZXh0IGdyb3VwIG9mIGVpdGhlclxuICAgIFtsZXR0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikgb3Igbm9uLWxldHRlclxuICAgIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBtb3ZlQnlHcm91cChzdGFydCwgZm9yd2FyZCkge1xuICAgICAgICByZXR1cm4gc2tpcEF0b21zKHRoaXMsIHN0YXJ0LCBtb3ZlQnlDaGFyKHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBpbml0aWFsID0+IGJ5R3JvdXAodGhpcywgc3RhcnQuaGVhZCwgaW5pdGlhbCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBsaW5lIGJvdW5kYXJ5IGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uIElmXG4gICAgYGluY2x1ZGVXcmFwYCBpcyB0cnVlLCBsaW5lIHdyYXBwaW5nIGlzIG9uLCBhbmQgdGhlcmUgaXMgYVxuICAgIGZ1cnRoZXIgd3JhcCBwb2ludCBvbiB0aGUgY3VycmVudCBsaW5lLCB0aGUgd3JhcCBwb2ludCB3aWxsIGJlXG4gICAgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzdGFydCBvciBlbmRcbiAgICBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIG1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCwgaW5jbHVkZVdyYXAgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBtb3ZlVG9MaW5lQm91bmRhcnkodGhpcywgc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiB2ZXJ0aWNhbGx5LiBXaGVuIGBkaXN0YW5jZWAgaXNuJ3QgZ2l2ZW4sXG4gICAgaXQgZGVmYXVsdHMgdG8gbW92aW5nIHRvIHRoZSBuZXh0IGxpbmUgKGluY2x1ZGluZyB3cmFwcGVkXG4gICAgbGluZXMpLiBPdGhlcndpc2UsIGBkaXN0YW5jZWAgc2hvdWxkIHByb3ZpZGUgYSBwb3NpdGl2ZSBkaXN0YW5jZVxuICAgIGluIHBpeGVscy5cbiAgICBcbiAgICBXaGVuIGBzdGFydGAgaGFzIGFcbiAgICBbYGdvYWxDb2x1bW5gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmdvYWxDb2x1bW4pLCB0aGUgdmVydGljYWxcbiAgICBtb3Rpb24gd2lsbCB1c2UgdGhhdCBhcyBhIHRhcmdldCBob3Jpem9udGFsIHBvc2l0aW9uLiBPdGhlcndpc2UsXG4gICAgdGhlIGN1cnNvcidzIG93biBob3Jpem9udGFsIHBvc2l0aW9uIGlzIHVzZWQuIFRoZSByZXR1cm5lZFxuICAgIGN1cnNvciB3aWxsIGhhdmUgaXRzIGdvYWwgY29sdW1uIHNldCB0byB3aGljaGV2ZXIgY29sdW1uIHdhc1xuICAgIHVzZWQuXG4gICAgKi9cbiAgICBtb3ZlVmVydGljYWxseShzdGFydCwgZm9yd2FyZCwgZGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZVZlcnRpY2FsbHkodGhpcywgc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBwYXJlbnQgbm9kZSBhbmQgb2Zmc2V0IChjaGlsZCBvZmZzZXQgaWYgYG5vZGVgIGlzXG4gICAgYW4gZWxlbWVudCwgY2hhcmFjdGVyIG9mZnNldCB3aGVuIGl0IGlzIGEgdGV4dCBub2RlKSBhdCB0aGVcbiAgICBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICBcbiAgICBOb3RlIHRoYXQgZm9yIHBvc2l0aW9ucyB0aGF0IGFyZW4ndCBjdXJyZW50bHkgaW5cbiAgICBgdmlzaWJsZVJhbmdlc2AsIHRoZSByZXN1bHRpbmcgRE9NIHBvc2l0aW9uIGlzbid0IG5lY2Vzc2FyaWx5XG4gICAgbWVhbmluZ2Z1bCAoaXQgbWF5IGp1c3QgcG9pbnQgYmVmb3JlIG9yIGFmdGVyIGEgcGxhY2Vob2xkZXJcbiAgICBlbGVtZW50KS5cbiAgICAqL1xuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmRvbUF0UG9zKHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBET00gbm9kZS4gQ2FuIGJlIHVzZWZ1bFxuICAgIGZvciBhc3NvY2lhdGluZyBwb3NpdGlvbnMgd2l0aCBET00gZXZlbnRzLiBXaWxsIHJhaXNlIGFuIGVycm9yXG4gICAgd2hlbiBgbm9kZWAgaXNuJ3QgcGFydCBvZiB0aGUgZWRpdG9yIGNvbnRlbnQuXG4gICAgKi9cbiAgICBwb3NBdERPTShub2RlLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgICBwb3NBdENvb3Jkcyhjb29yZHMsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiBwb3NBdENvb3Jkcyh0aGlzLCBjb29yZHMsIHByZWNpc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHNjcmVlbiBjb29yZGluYXRlcyBhdCB0aGUgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgYHNpZGVgIGRldGVybWluZXMgd2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGJhc2VkIG9uIHRoZVxuICAgIGVsZW1lbnQgYmVmb3JlICgtMSkgb3IgYWZ0ZXIgKDEpIHRoZSBwb3NpdGlvbiAoaWYgbm8gZWxlbWVudCBpc1xuICAgIGF2YWlsYWJsZSBvbiB0aGUgZ2l2ZW4gc2lkZSwgdGhlIG1ldGhvZCB3aWxsIHRyYW5zcGFyZW50bHkgdXNlXG4gICAgYW5vdGhlciBzdHJhdGVneSB0byBnZXQgcmVhc29uYWJsZSBjb29yZGluYXRlcykuXG4gICAgKi9cbiAgICBjb29yZHNBdFBvcyhwb3MsIHNpZGUgPSAxKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5kb2NWaWV3LmNvb3Jkc0F0KHBvcywgc2lkZSk7XG4gICAgICAgIGlmICghcmVjdCB8fCByZWN0LmxlZnQgPT0gcmVjdC5yaWdodClcbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBvcmRlciA9IHRoaXMuYmlkaVNwYW5zKGxpbmUpO1xuICAgICAgICBsZXQgc3BhbiA9IG9yZGVyW0JpZGlTcGFuLmZpbmQob3JkZXIsIHBvcyAtIGxpbmUuZnJvbSwgLTEsIHNpZGUpXTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5SZWN0KHJlY3QsIChzcGFuLmRpciA9PSBEaXJlY3Rpb24uTFRSKSA9PSAoc2lkZSA+IDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgd2lkdGggb2YgYSBjaGFyYWN0ZXIgaW4gdGhlIGVkaXRvci4gTWF5IG5vdFxuICAgIGFjY3VyYXRlbHkgcmVmbGVjdCB0aGUgd2lkdGggb2YgYWxsIGNoYXJhY3RlcnMgKGdpdmVuIHZhcmlhYmxlXG4gICAgd2lkdGggZm9udHMgb3Igc3R5bGluZyBvZiBpbnZpZGlkdWFsIHJhbmdlcykuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdENoYXJhY3RlcldpZHRoKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDsgfVxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IGhlaWdodCBvZiBhIGxpbmUgaW4gdGhlIGVkaXRvci4gTWF5IG5vdCBiZSBhY2N1cmF0ZVxuICAgIGZvciBhbGwgbGluZXMuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdExpbmVIZWlnaHQoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZUhlaWdodDsgfVxuICAgIC8qKlxuICAgIFRoZSB0ZXh0IGRpcmVjdGlvblxuICAgIChbYGRpcmVjdGlvbmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9kaXJlY3Rpb24pXG4gICAgQ1NTIHByb3BlcnR5KSBvZiB0aGUgZWRpdG9yJ3MgY29udGVudCBlbGVtZW50LlxuICAgICovXG4gICAgZ2V0IHRleHREaXJlY3Rpb24oKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5kZWZhdWx0VGV4dERpcmVjdGlvbjsgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBibG9jayBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGFzXG4gICAgYXNzaWduZWQgYnkgQ1NTLiBJZlxuICAgIFtgcGVyTGluZVRleHREaXJlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15wZXJMaW5lVGV4dERpcmVjdGlvbilcbiAgICBpc24ndCBlbmFibGVkLCBvciB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnQsXG4gICAgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgYXNcbiAgICBbYHRleHREaXJlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS4gTm90ZSB0aGF0XG4gICAgdGhpcyBtYXkgdHJpZ2dlciBhIERPTSBsYXlvdXQuXG4gICAgKi9cbiAgICB0ZXh0RGlyZWN0aW9uQXQocG9zKSB7XG4gICAgICAgIGxldCBwZXJMaW5lID0gdGhpcy5zdGF0ZS5mYWNldChwZXJMaW5lVGV4dERpcmVjdGlvbik7XG4gICAgICAgIGlmICghcGVyTGluZSB8fCBwb3MgPCB0aGlzLnZpZXdwb3J0LmZyb20gfHwgcG9zID4gdGhpcy52aWV3cG9ydC50bylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHREaXJlY3Rpb247XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcudGV4dERpcmVjdGlvbkF0KHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhpcyBlZGl0b3IgW3dyYXBzIGxpbmVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcpXG4gICAgKGFzIGRldGVybWluZWQgYnkgdGhlXG4gICAgW2B3aGl0ZS1zcGFjZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy93aGl0ZS1zcGFjZSlcbiAgICBDU1MgcHJvcGVydHkgb2YgaXRzIGNvbnRlbnQgZWxlbWVudCkuXG4gICAgKi9cbiAgICBnZXQgbGluZVdyYXBwaW5nKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZzsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIGJpZGlyZWN0aW9uYWwgdGV4dCBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuIGxpbmVcbiAgICAod2hpY2ggc2hvdWxkIGJlIGluIHRoZSBjdXJyZW50IGRvY3VtZW50KSBhcyBhbiBhcnJheSBvZiBzcGFuXG4gICAgb2JqZWN0cy4gVGhlIG9yZGVyIG9mIHRoZXNlIHNwYW5zIG1hdGNoZXMgdGhlIFt0ZXh0XG4gICAgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKVx1MjAxNGlmIHRoYXQgaXNcbiAgICBsZWZ0LXRvLXJpZ2h0LCB0aGUgbGVmdG1vc3Qgc3BhbnMgY29tZSBmaXJzdCwgb3RoZXJ3aXNlIHRoZVxuICAgIHJpZ2h0bW9zdCBzcGFucyBjb21lIGZpcnN0LlxuICAgICovXG4gICAgYmlkaVNwYW5zKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gTWF4QmlkaUxpbmUpXG4gICAgICAgICAgICByZXR1cm4gdHJpdmlhbE9yZGVyKGxpbmUubGVuZ3RoKTtcbiAgICAgICAgbGV0IGRpciA9IHRoaXMudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgICAgIGZvciAobGV0IGVudHJ5IG9mIHRoaXMuYmlkaUNhY2hlKVxuICAgICAgICAgICAgaWYgKGVudHJ5LmZyb20gPT0gbGluZS5mcm9tICYmIGVudHJ5LmRpciA9PSBkaXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm9yZGVyO1xuICAgICAgICBsZXQgb3JkZXIgPSBjb21wdXRlT3JkZXIobGluZS50ZXh0LCBkaXIpO1xuICAgICAgICB0aGlzLmJpZGlDYWNoZS5wdXNoKG5ldyBDYWNoZWRPcmRlcihsaW5lLmZyb20sIGxpbmUudG8sIGRpciwgb3JkZXIpKTtcbiAgICAgICAgcmV0dXJuIG9yZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZSBlZGl0b3IgaGFzIGZvY3VzLlxuICAgICovXG4gICAgZ2V0IGhhc0ZvY3VzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFNhZmFyaSByZXR1cm4gZmFsc2UgZm9yIGhhc0ZvY3VzIHdoZW4gdGhlIGNvbnRleHQgbWVudSBpcyBvcGVuXG4gICAgICAgIC8vIG9yIGNsb3NpbmcsIHdoaWNoIGxlYWRzIHVzIHRvIGlnbm9yZSBzZWxlY3Rpb24gY2hhbmdlcyBmcm9tIHRoZVxuICAgICAgICAvLyBjb250ZXh0IG1lbnUgYmVjYXVzZSBpdCBsb29rcyBsaWtlIHRoZSBlZGl0b3IgaXNuJ3QgZm9jdXNlZC5cbiAgICAgICAgLy8gVGhpcyBrbHVkZ2VzIGFyb3VuZCB0aGF0LlxuICAgICAgICByZXR1cm4gKHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuaGFzRm9jdXMoKSB8fCBicm93c2VyLnNhZmFyaSAmJiAoKF9hID0gdGhpcy5pbnB1dFN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdENvbnRleHRNZW51KSA+IERhdGUubm93KCkgLSAzZTQpICYmXG4gICAgICAgICAgICB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmNvbnRlbnRET007XG4gICAgfVxuICAgIC8qKlxuICAgIFB1dCBmb2N1cyBvbiB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIGZvY3VzUHJldmVudFNjcm9sbCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSBbcm9vdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyMjdmlldy5FZGl0b3JWaWV3Q29uZmlnLnJvb3QpIGluIHdoaWNoIHRoZSBlZGl0b3IgbGl2ZXMuIFRoaXMgaXMgb25seVxuICAgIG5lY2Vzc2FyeSB3aGVuIG1vdmluZyB0aGUgZWRpdG9yJ3MgZXhpc3RpbmcgRE9NIHRvIGEgbmV3IHdpbmRvdyBvciBzaGFkb3cgcm9vdC5cbiAgICAqL1xuICAgIHNldFJvb3Qocm9vdCkge1xuICAgICAgICBpZiAodGhpcy5fcm9vdCAhPSByb290KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290ID0gcm9vdDtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuc2V0V2luZG93KChyb290Lm5vZGVUeXBlID09IDkgPyByb290IDogcm9vdC5vd25lckRvY3VtZW50KS5kZWZhdWx0VmlldyB8fCB3aW5kb3cpO1xuICAgICAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENsZWFuIHVwIHRoaXMgZWRpdG9yIHZpZXcsIHJlbW92aW5nIGl0cyBlbGVtZW50IGZyb20gdGhlXG4gICAgZG9jdW1lbnQsIHVucmVnaXN0ZXJpbmcgZXZlbnQgaGFuZGxlcnMsIGFuZCBub3RpZnlpbmdcbiAgICBwbHVnaW5zLiBUaGUgdmlldyBpbnN0YW5jZSBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgYWZ0ZXJcbiAgICBjYWxsaW5nIHRoaXMuXG4gICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubWVhc3VyZVNjaGVkdWxlZCk7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhbiBlZmZlY3QgdGhhdCBjYW4gYmVcbiAgICBbYWRkZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIHRvIGEgdHJhbnNhY3Rpb24gdG9cbiAgICBjYXVzZSBpdCB0byBzY3JvbGwgdGhlIGdpdmVuIHBvc2l0aW9uIG9yIHJhbmdlIGludG8gdmlldy5cbiAgICAqL1xuICAgIHN0YXRpYyBzY3JvbGxJbnRvVmlldyhwb3MsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gc2Nyb2xsSW50b1ZpZXcub2YobmV3IFNjcm9sbFRhcmdldCh0eXBlb2YgcG9zID09IFwibnVtYmVyXCIgPyBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcykgOiBwb3MsIG9wdGlvbnMueSwgb3B0aW9ucy54LCBvcHRpb25zLnlNYXJnaW4sIG9wdGlvbnMueE1hcmdpbikpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBET00gZXZlbnQgaGFuZGxlcnMuXG4gICAgVGhlIHZhbHVlIHNob3VsZCBiZSBhbiBvYmplY3QgbWFwcGluZyBldmVudCBuYW1lcyB0byBoYW5kbGVyXG4gICAgZnVuY3Rpb25zLiBGb3IgYW55IGdpdmVuIGV2ZW50LCBzdWNoIGZ1bmN0aW9ucyBhcmUgb3JkZXJlZCBieVxuICAgIGV4dGVuc2lvbiBwcmVjZWRlbmNlLCBhbmQgdGhlIGZpcnN0IGhhbmRsZXIgdG8gcmV0dXJuIHRydWUgd2lsbFxuICAgIGJlIGFzc3VtZWQgdG8gaGF2ZSBoYW5kbGVkIHRoYXQgZXZlbnQsIGFuZCBubyBvdGhlciBoYW5kbGVycyBvclxuICAgIGJ1aWx0LWluIGJlaGF2aW9yIHdpbGwgYmUgYWN0aXZhdGVkIGZvciBpdC4gVGhlc2UgYXJlIHJlZ2lzdGVyZWRcbiAgICBvbiB0aGUgW2NvbnRlbnQgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuY29udGVudERPTSksIGV4Y2VwdFxuICAgIGZvciBgc2Nyb2xsYCBoYW5kbGVycywgd2hpY2ggd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgdGhlXG4gICAgZWRpdG9yJ3MgW3Njcm9sbCBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5zY3JvbGxET00pIG9yIG9uZSBvZlxuICAgIGl0cyBwYXJlbnQgbm9kZXMgaXMgc2Nyb2xsZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgZG9tRXZlbnRIYW5kbGVycyhoYW5kbGVycykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUoKCkgPT4gKHt9KSwgeyBldmVudEhhbmRsZXJzOiBoYW5kbGVycyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGhlbWUgZXh0ZW5zaW9uLiBUaGUgZmlyc3QgYXJndW1lbnQgY2FuIGJlIGFcbiAgICBbYHN0eWxlLW1vZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKVxuICAgIHN0eWxlIHNwZWMgcHJvdmlkaW5nIHRoZSBzdHlsZXMgZm9yIHRoZSB0aGVtZS4gVGhlc2Ugd2lsbCBiZVxuICAgIHByZWZpeGVkIHdpdGggYSBnZW5lcmF0ZWQgY2xhc3MgZm9yIHRoZSBzdHlsZS5cbiAgICBcbiAgICBCZWNhdXNlIHRoZSBzZWxlY3RvcnMgd2lsbCBiZSBwcmVmaXhlZCB3aXRoIGEgc2NvcGUgY2xhc3MsIHJ1bGVcbiAgICB0aGF0IGRpcmVjdGx5IG1hdGNoIHRoZSBlZGl0b3IncyBbd3JhcHBlclxuICAgIGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvbSlcdTIwMTR0byB3aGljaCB0aGUgc2NvcGUgY2xhc3Mgd2lsbCBiZVxuICAgIGFkZGVkXHUyMDE0bmVlZCB0byBiZSBleHBsaWNpdGx5IGRpZmZlcmVudGlhdGVkIGJ5IGFkZGluZyBhbiBgJmAgdG9cbiAgICB0aGUgc2VsZWN0b3IgZm9yIHRoYXQgZWxlbWVudFx1MjAxNGZvciBleGFtcGxlXG4gICAgYCYuY20tZm9jdXNlZGAuXG4gICAgXG4gICAgV2hlbiBgZGFya2AgaXMgc2V0IHRvIHRydWUsIHRoZSB0aGVtZSB3aWxsIGJlIG1hcmtlZCBhcyBkYXJrLFxuICAgIHdoaWNoIHdpbGwgY2F1c2UgdGhlIGAmZGFya2AgcnVsZXMgZnJvbSBbYmFzZVxuICAgIHRoZW1lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeYmFzZVRoZW1lKSB0byBiZSB1c2VkIChhcyBvcHBvc2VkIHRvXG4gICAgYCZsaWdodGAgd2hlbiBhIGxpZ2h0IHRoZW1lIGlzIGFjdGl2ZSkuXG4gICAgKi9cbiAgICBzdGF0aWMgdGhlbWUoc3BlYywgb3B0aW9ucykge1xuICAgICAgICBsZXQgcHJlZml4ID0gU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW3RoZW1lLm9mKHByZWZpeCksIHN0eWxlTW9kdWxlLm9mKGJ1aWxkVGhlbWUoYC4ke3ByZWZpeH1gLCBzcGVjKSldO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRhcmspXG4gICAgICAgICAgICByZXN1bHQucHVzaChkYXJrVGhlbWUub2YodHJ1ZSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBzdHlsZXMgdG8gdGhlIGJhc2UgdGhlbWUuIExpa2VcbiAgICB3aXRoIFtgdGhlbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld150aGVtZSksIHVzZSBgJmAgdG8gaW5kaWNhdGUgdGhlXG4gICAgcGxhY2Ugb2YgdGhlIGVkaXRvciB3cmFwcGVyIGVsZW1lbnQgd2hlbiBkaXJlY3RseSB0YXJnZXRpbmdcbiAgICB0aGF0LiBZb3UgY2FuIGFsc28gdXNlIGAmZGFya2Agb3IgYCZsaWdodGAgaW5zdGVhZCB0byBvbmx5XG4gICAgdGFyZ2V0IGVkaXRvcnMgd2l0aCBhIGRhcmsgb3IgbGlnaHQgdGhlbWUuXG4gICAgKi9cbiAgICBzdGF0aWMgYmFzZVRoZW1lKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIFByZWMubG93ZXN0KHN0eWxlTW9kdWxlLm9mKGJ1aWxkVGhlbWUoXCIuXCIgKyBiYXNlVGhlbWVJRCwgc3BlYywgbGlnaHREYXJrSURzKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSBhbiBlZGl0b3IgdmlldyBpbnN0YW5jZSBmcm9tIHRoZSB2aWV3J3MgRE9NXG4gICAgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEZyb21ET00oZG9tKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBkb20ucXVlcnlTZWxlY3RvcihcIi5jbS1jb250ZW50XCIpO1xuICAgICAgICBsZXQgY1ZpZXcgPSBjb250ZW50ICYmIENvbnRlbnRWaWV3LmdldChjb250ZW50KSB8fCBDb250ZW50Vmlldy5nZXQoZG9tKTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBjVmlldyA9PT0gbnVsbCB8fCBjVmlldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY1ZpZXcucm9vdFZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52aWV3KSB8fCBudWxsO1xuICAgIH1cbn1cbi8qKlxuRmFjZXQgdG8gYWRkIGEgW3N0eWxlXG5tb2R1bGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKSB0b1xuYW4gZWRpdG9yIHZpZXcuIFRoZSB2aWV3IHdpbGwgZW5zdXJlIHRoYXQgdGhlIG1vZHVsZSBpc1xubW91bnRlZCBpbiBpdHMgW2RvY3VtZW50XG5yb290XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5jb25zdHJ1Y3Rvcl5jb25maWcucm9vdCkuXG4qL1xuRWRpdG9yVmlldy5zdHlsZU1vZHVsZSA9IHN0eWxlTW9kdWxlO1xuLyoqXG5BbiBpbnB1dCBoYW5kbGVyIGNhbiBvdmVycmlkZSB0aGUgd2F5IGNoYW5nZXMgdG8gdGhlIGVkaXRhYmxlXG5ET00gY29udGVudCBhcmUgaGFuZGxlZC4gSGFuZGxlcnMgYXJlIHBhc3NlZCB0aGUgZG9jdW1lbnRcbnBvc2l0aW9ucyBiZXR3ZWVuIHdoaWNoIHRoZSBjaGFuZ2Ugd2FzIGZvdW5kLCBhbmQgdGhlIG5ld1xuY29udGVudC4gV2hlbiBvbmUgcmV0dXJucyB0cnVlLCBubyBmdXJ0aGVyIGlucHV0IGhhbmRsZXJzIGFyZVxuY2FsbGVkIGFuZCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBwcmV2ZW50ZWQuXG4qL1xuRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIgPSBpbnB1dEhhbmRsZXI7XG4vKipcblRoaXMgZmFjZXQgY2FuIGJlIHVzZWQgdG8gcHJvdmlkZSBmdW5jdGlvbnMgdGhhdCBjcmVhdGUgZWZmZWN0c1xudG8gYmUgZGlzcGF0Y2hlZCB3aGVuIHRoZSBlZGl0b3IncyBmb2N1cyBzdGF0ZSBjaGFuZ2VzLlxuKi9cbkVkaXRvclZpZXcuZm9jdXNDaGFuZ2VFZmZlY3QgPSBmb2N1c0NoYW5nZUVmZmVjdDtcbi8qKlxuQnkgZGVmYXVsdCwgdGhlIGVkaXRvciBhc3N1bWVzIGFsbCBpdHMgY29udGVudCBoYXMgdGhlIHNhbWVcblt0ZXh0IGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRpcmVjdGlvbikuIENvbmZpZ3VyZSB0aGlzIHdpdGggYSBgdHJ1ZWBcbnZhbHVlIHRvIG1ha2UgaXQgcmVhZCB0aGUgdGV4dCBkaXJlY3Rpb24gb2YgZXZlcnkgKHJlbmRlcmVkKVxubGluZSBzZXBhcmF0ZWx5LlxuKi9cbkVkaXRvclZpZXcucGVyTGluZVRleHREaXJlY3Rpb24gPSBwZXJMaW5lVGV4dERpcmVjdGlvbjtcbi8qKlxuQWxsb3dzIHlvdSB0byBwcm92aWRlIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlXG5saWJyYXJ5IGNhdGNoZXMgYW4gZXhjZXB0aW9uIGZyb20gYW4gZXh0ZW5zaW9uIChtb3N0bHkgZnJvbSB2aWV3XG5wbHVnaW5zLCBidXQgbWF5IGJlIHVzZWQgYnkgb3RoZXIgZXh0ZW5zaW9ucyB0byByb3V0ZSBleGNlcHRpb25zXG5mcm9tIHVzZXItY29kZS1wcm92aWRlZCBjYWxsYmFja3MpLiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgZm9yXG5kZWJ1Z2dpbmcgYW5kIGxvZ2dpbmcuIFNlZSBbYGxvZ0V4Y2VwdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5sb2dFeGNlcHRpb24pLlxuKi9cbkVkaXRvclZpZXcuZXhjZXB0aW9uU2luayA9IGV4Y2VwdGlvblNpbms7XG4vKipcbkEgZmFjZXQgdGhhdCBjYW4gYmUgdXNlZCB0byByZWdpc3RlciBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuZXZlcnkgdGltZSB0aGUgdmlldyB1cGRhdGVzLlxuKi9cbkVkaXRvclZpZXcudXBkYXRlTGlzdGVuZXIgPSB1cGRhdGVMaXN0ZW5lcjtcbi8qKlxuRmFjZXQgdGhhdCBjb250cm9scyB3aGV0aGVyIHRoZSBlZGl0b3IgY29udGVudCBET00gaXMgZWRpdGFibGUuXG5XaGVuIGl0cyBoaWdoZXN0LXByZWNlZGVuY2UgdmFsdWUgaXMgYGZhbHNlYCwgdGhlIGVsZW1lbnQgd2lsbFxubm90IGhhdmUgaXRzIGBjb250ZW50ZWRpdGFibGVgIGF0dHJpYnV0ZSBzZXQuIChOb3RlIHRoYXQgdGhpc1xuZG9lc24ndCBhZmZlY3QgQVBJIGNhbGxzIHRoYXQgY2hhbmdlIHRoZSBlZGl0b3IgY29udGVudCwgZXZlblxud2hlbiB0aG9zZSBhcmUgYm91bmQgdG8ga2V5cyBvciBidXR0b25zLiBTZWUgdGhlXG5bYHJlYWRPbmx5YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5yZWFkT25seSkgZmFjZXQgZm9yIHRoYXQuKVxuKi9cbkVkaXRvclZpZXcuZWRpdGFibGUgPSBlZGl0YWJsZTtcbi8qKlxuQWxsb3dzIHlvdSB0byBpbmZsdWVuY2UgdGhlIHdheSBtb3VzZSBzZWxlY3Rpb24gaGFwcGVucy4gVGhlXG5mdW5jdGlvbnMgaW4gdGhpcyBmYWNldCB3aWxsIGJlIGNhbGxlZCBmb3IgYSBgbW91c2Vkb3duYCBldmVudFxub24gdGhlIGVkaXRvciwgYW5kIGNhbiByZXR1cm4gYW4gb2JqZWN0IHRoYXQgb3ZlcnJpZGVzIHRoZSB3YXkgYVxuc2VsZWN0aW9uIGlzIGNvbXB1dGVkIGZyb20gdGhhdCBtb3VzZSBjbGljayBvciBkcmFnLlxuKi9cbkVkaXRvclZpZXcubW91c2VTZWxlY3Rpb25TdHlsZSA9IG1vdXNlU2VsZWN0aW9uU3R5bGU7XG4vKipcbkZhY2V0IHVzZWQgdG8gY29uZmlndXJlIHdoZXRoZXIgYSBnaXZlbiBzZWxlY3Rpb24gZHJhZyBldmVudFxuc2hvdWxkIG1vdmUgb3IgY29weSB0aGUgc2VsZWN0aW9uLiBUaGUgZ2l2ZW4gcHJlZGljYXRlIHdpbGwgYmVcbmNhbGxlZCB3aXRoIHRoZSBgbW91c2Vkb3duYCBldmVudCwgYW5kIGNhbiByZXR1cm4gYHRydWVgIHdoZW5cbnRoZSBkcmFnIHNob3VsZCBtb3ZlIHRoZSBjb250ZW50LlxuKi9cbkVkaXRvclZpZXcuZHJhZ01vdmVzU2VsZWN0aW9uID0gZHJhZ01vdmVzU2VsZWN0aW9uJDE7XG4vKipcbkZhY2V0IHVzZWQgdG8gY29uZmlndXJlIHdoZXRoZXIgYSBnaXZlbiBzZWxlY3RpbmcgY2xpY2sgYWRkcyBhXG5uZXcgcmFuZ2UgdG8gdGhlIGV4aXN0aW5nIHNlbGVjdGlvbiBvciByZXBsYWNlcyBpdCBlbnRpcmVseS4gVGhlXG5kZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGNoZWNrIGBldmVudC5tZXRhS2V5YCBvbiBtYWNPUywgYW5kXG5gZXZlbnQuY3RybEtleWAgZWxzZXdoZXJlLlxuKi9cbkVkaXRvclZpZXcuY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UgPSBjbGlja0FkZHNTZWxlY3Rpb25SYW5nZTtcbi8qKlxuQSBmYWNldCB0aGF0IGRldGVybWluZXMgd2hpY2ggW2RlY29yYXRpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbilcbmFyZSBzaG93biBpbiB0aGUgdmlldy4gRGVjb3JhdGlvbnMgY2FuIGJlIHByb3ZpZGVkIGluIHR3b1xud2F5c1x1MjAxNGRpcmVjdGx5LCBvciB2aWEgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIGVkaXRvciB2aWV3LlxuXG5Pbmx5IGRlY29yYXRpb24gc2V0cyBwcm92aWRlZCBkaXJlY3RseSBhcmUgYWxsb3dlZCB0byBpbmZsdWVuY2VcbnRoZSBlZGl0b3IncyB2ZXJ0aWNhbCBsYXlvdXQgc3RydWN0dXJlLiBUaGUgb25lcyBwcm92aWRlZCBhc1xuZnVuY3Rpb25zIGFyZSBjYWxsZWQgX2FmdGVyXyB0aGUgbmV3IHZpZXdwb3J0IGhhcyBiZWVuIGNvbXB1dGVkLFxuYW5kIHRodXMgKiptdXN0IG5vdCoqIGludHJvZHVjZSBibG9jayB3aWRnZXRzIG9yIHJlcGxhY2luZ1xuZGVjb3JhdGlvbnMgdGhhdCBjb3ZlciBsaW5lIGJyZWFrcy5cblxuSWYgeW91IHdhbnQgZGVjb3JhdGVkIHJhbmdlcyB0byBiZWhhdmUgbGlrZSBhdG9taWMgdW5pdHMgZm9yXG5jdXJzb3IgbW90aW9uIGFuZCBkZWxldGlvbiBwdXJwb3NlcywgYWxzbyBwcm92aWRlIHRoZSByYW5nZSBzZXRcbmNvbnRhaW5pbmcgdGhlIGRlY29yYXRpb25zIHRvXG5bYEVkaXRvclZpZXcuYXRvbWljUmFuZ2VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeYXRvbWljUmFuZ2VzKS5cbiovXG5FZGl0b3JWaWV3LmRlY29yYXRpb25zID0gZGVjb3JhdGlvbnM7XG4vKipcblVzZWQgdG8gcHJvdmlkZSByYW5nZXMgdGhhdCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhdG9tcyBhcyBmYXIgYXNcbmN1cnNvciBtb3Rpb24gaXMgY29uY2VybmVkLiBUaGlzIGNhdXNlcyBtZXRob2RzIGxpa2VcbltgbW92ZUJ5Q2hhcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVCeUNoYXIpIGFuZFxuW2Btb3ZlVmVydGljYWxseWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVWZXJ0aWNhbGx5KSAoYW5kIHRoZVxuY29tbWFuZHMgYnVpbHQgb24gdG9wIG9mIHRoZW0pIHRvIHNraXAgYWNyb3NzIHN1Y2ggcmVnaW9ucyB3aGVuXG5hIHNlbGVjdGlvbiBlbmRwb2ludCB3b3VsZCBlbnRlciB0aGVtLiBUaGlzIGRvZXMgX25vdF8gcHJldmVudFxuZGlyZWN0IHByb2dyYW1tYXRpYyBbc2VsZWN0aW9uXG51cGRhdGVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZWxlY3Rpb24pIGZyb20gbW92aW5nIGludG8gc3VjaFxucmVnaW9ucy5cbiovXG5FZGl0b3JWaWV3LmF0b21pY1JhbmdlcyA9IGF0b21pY1Jhbmdlcztcbi8qKlxuRmFjZXQgdGhhdCBhbGxvd3MgZXh0ZW5zaW9ucyB0byBwcm92aWRlIGFkZGl0aW9uYWwgc2Nyb2xsXG5tYXJnaW5zIChzcGFjZSBhcm91bmQgdGhlIHNpZGVzIG9mIHRoZSBzY3JvbGxpbmcgZWxlbWVudCB0aGF0XG5zaG91bGQgYmUgY29uc2lkZXJlZCBpbnZpc2libGUpLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB0aGVcbnBsdWdpbiBpbnRyb2R1Y2VzIGVsZW1lbnRzIHRoYXQgY292ZXIgcGFydCBvZiB0aGF0IGVsZW1lbnQgKGZvclxuZXhhbXBsZSBhIGhvcml6b250YWxseSBmaXhlZCBndXR0ZXIpLlxuKi9cbkVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucyA9IHNjcm9sbE1hcmdpbnM7XG4vKipcblRoaXMgZmFjZXQgcmVjb3JkcyB3aGV0aGVyIGEgZGFyayB0aGVtZSBpcyBhY3RpdmUuIFRoZSBleHRlbnNpb25cbnJldHVybmVkIGJ5IFtgdGhlbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld150aGVtZSkgYXV0b21hdGljYWxseVxuaW5jbHVkZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyB3aGVuIHRoZSBgZGFya2Agb3B0aW9uIGlzIHNldCB0b1xudHJ1ZS5cbiovXG5FZGl0b3JWaWV3LmRhcmtUaGVtZSA9IGRhcmtUaGVtZTtcbi8qKlxuRmFjZXQgdGhhdCBwcm92aWRlcyBhZGRpdGlvbmFsIERPTSBhdHRyaWJ1dGVzIGZvciB0aGUgZWRpdG9yJ3NcbmVkaXRhYmxlIERPTSBlbGVtZW50LlxuKi9cbkVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMgPSBjb250ZW50QXR0cmlidXRlcztcbi8qKlxuRmFjZXQgdGhhdCBwcm92aWRlcyBET00gYXR0cmlidXRlcyBmb3IgdGhlIGVkaXRvcidzIG91dGVyXG5lbGVtZW50LlxuKi9cbkVkaXRvclZpZXcuZWRpdG9yQXR0cmlidXRlcyA9IGVkaXRvckF0dHJpYnV0ZXM7XG4vKipcbkFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgbGluZSB3cmFwcGluZyBpbiB0aGUgZWRpdG9yIChieVxuc2V0dGluZyBDU1MgYHdoaXRlLXNwYWNlYCB0byBgcHJlLXdyYXBgIGluIHRoZSBjb250ZW50KS5cbiovXG5FZGl0b3JWaWV3LmxpbmVXcmFwcGluZyA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLm9mKHsgXCJjbGFzc1wiOiBcImNtLWxpbmVXcmFwcGluZ1wiIH0pO1xuLyoqXG5TdGF0ZSBlZmZlY3QgdXNlZCB0byBpbmNsdWRlIHNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50cyBpbiBhXG50cmFuc2FjdGlvbi4gVGhlc2Ugd2lsbCBiZSBhZGRlZCB0byB0aGUgRE9NIGluIGEgdmlzdWFsbHkgaGlkZGVuXG5lbGVtZW50IHdpdGggYGFyaWEtbGl2ZT1cInBvbGl0ZVwiYCBzZXQsIGFuZCBzaG91bGQgYmUgdXNlZCB0b1xuZGVzY3JpYmUgZWZmZWN0cyB0aGF0IGFyZSB2aXN1YWxseSBvYnZpb3VzIGJ1dCBtYXkgbm90IGJlXG5ub3RpY2VkIGJ5IHNjcmVlbiByZWFkZXIgdXNlcnMgKHN1Y2ggYXMgbW92aW5nIHRvIHRoZSBuZXh0XG5zZWFyY2ggbWF0Y2gpLlxuKi9cbkVkaXRvclZpZXcuYW5ub3VuY2UgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vLyBNYXhpbXVtIGxpbmUgbGVuZ3RoIGZvciB3aGljaCB3ZSBjb21wdXRlIGFjY3VyYXRlIGJpZGkgaW5mb1xuY29uc3QgTWF4QmlkaUxpbmUgPSA0MDk2O1xuY29uc3QgQmFkTWVhc3VyZSA9IHt9O1xuY2xhc3MgQ2FjaGVkT3JkZXIge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCBkaXIsIG9yZGVyKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgIHRoaXMub3JkZXIgPSBvcmRlcjtcbiAgICB9XG4gICAgc3RhdGljIHVwZGF0ZShjYWNoZSwgY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBsYXN0RGlyID0gY2FjaGUubGVuZ3RoID8gY2FjaGVbY2FjaGUubGVuZ3RoIC0gMV0uZGlyIDogRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgZm9yIChsZXQgaSA9IE1hdGgubWF4KDAsIGNhY2hlLmxlbmd0aCAtIDEwKTsgaSA8IGNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZW50cnkgPSBjYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5kaXIgPT0gbGFzdERpciAmJiAhY2hhbmdlcy50b3VjaGVzUmFuZ2UoZW50cnkuZnJvbSwgZW50cnkudG8pKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBDYWNoZWRPcmRlcihjaGFuZ2VzLm1hcFBvcyhlbnRyeS5mcm9tLCAxKSwgY2hhbmdlcy5tYXBQb3MoZW50cnkudG8sIC0xKSwgZW50cnkuZGlyLCBlbnRyeS5vcmRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYXR0cnNGcm9tRmFjZXQodmlldywgZmFjZXQsIGJhc2UpIHtcbiAgICBmb3IgKGxldCBzb3VyY2VzID0gdmlldy5zdGF0ZS5mYWNldChmYWNldCksIGkgPSBzb3VyY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSBzb3VyY2VzW2ldLCB2YWx1ZSA9IHR5cGVvZiBzb3VyY2UgPT0gXCJmdW5jdGlvblwiID8gc291cmNlKHZpZXcpIDogc291cmNlO1xuICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICBjb21iaW5lQXR0cnModmFsdWUsIGJhc2UpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbn1cblxuY29uc3QgY3VycmVudFBsYXRmb3JtID0gYnJvd3Nlci5tYWMgPyBcIm1hY1wiIDogYnJvd3Nlci53aW5kb3dzID8gXCJ3aW5cIiA6IGJyb3dzZXIubGludXggPyBcImxpbnV4XCIgOiBcImtleVwiO1xuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lLCBwbGF0Zm9ybSkge1xuICAgIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyk7XG4gICAgbGV0IHJlc3VsdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChyZXN1bHQgPT0gXCJTcGFjZVwiKVxuICAgICAgICByZXN1bHQgPSBcIiBcIjtcbiAgICBsZXQgYWx0LCBjdHJsLCBzaGlmdCwgbWV0YTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBtb2QgPSBwYXJ0c1tpXTtcbiAgICAgICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBhbHQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgc2hpZnQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIGlmIChwbGF0Zm9ybSA9PSBcIm1hY1wiKVxuICAgICAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcIiArIG1vZCk7XG4gICAgfVxuICAgIGlmIChhbHQpXG4gICAgICAgIHJlc3VsdCA9IFwiQWx0LVwiICsgcmVzdWx0O1xuICAgIGlmIChjdHJsKVxuICAgICAgICByZXN1bHQgPSBcIkN0cmwtXCIgKyByZXN1bHQ7XG4gICAgaWYgKG1ldGEpXG4gICAgICAgIHJlc3VsdCA9IFwiTWV0YS1cIiArIHJlc3VsdDtcbiAgICBpZiAoc2hpZnQpXG4gICAgICAgIHJlc3VsdCA9IFwiU2hpZnQtXCIgKyByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZGlmaWVycyhuYW1lLCBldmVudCwgc2hpZnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KVxuICAgICAgICBuYW1lID0gXCJBbHQtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5jdHJsS2V5KVxuICAgICAgICBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgbmFtZSA9IFwiTWV0YS1cIiArIG5hbWU7XG4gICAgaWYgKHNoaWZ0ICE9PSBmYWxzZSAmJiBldmVudC5zaGlmdEtleSlcbiAgICAgICAgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lO1xuICAgIHJldHVybiBuYW1lO1xufVxuY29uc3QgaGFuZGxlS2V5RXZlbnRzID0gLypAX19QVVJFX18qL1ByZWMuZGVmYXVsdCgvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcbiAgICBrZXlkb3duKGV2ZW50LCB2aWV3KSB7XG4gICAgICAgIHJldHVybiBydW5IYW5kbGVycyhnZXRLZXltYXAodmlldy5zdGF0ZSksIGV2ZW50LCB2aWV3LCBcImVkaXRvclwiKTtcbiAgICB9XG59KSk7XG4vKipcbkZhY2V0IHVzZWQgZm9yIHJlZ2lzdGVyaW5nIGtleW1hcHMuXG5cbllvdSBjYW4gYWRkIG11bHRpcGxlIGtleW1hcHMgdG8gYW4gZWRpdG9yLiBUaGVpciBwcmlvcml0aWVzXG5kZXRlcm1pbmUgdGhlaXIgcHJlY2VkZW5jZSAodGhlIG9uZXMgc3BlY2lmaWVkIGVhcmx5IG9yIHdpdGggaGlnaFxucHJpb3JpdHkgZ2V0IGNoZWNrZWQgZmlyc3QpLiBXaGVuIGEgaGFuZGxlciBoYXMgcmV0dXJuZWQgYHRydWVgXG5mb3IgYSBnaXZlbiBrZXksIG5vIGZ1cnRoZXIgaGFuZGxlcnMgYXJlIGNhbGxlZC5cbiovXG5jb25zdCBrZXltYXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgZW5hYmxlczogaGFuZGxlS2V5RXZlbnRzIH0pO1xuY29uc3QgS2V5bWFwcyA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuLy8gVGhpcyBpcyBoaWRkZW4gYmVoaW5kIGFuIGluZGlyZWN0aW9uLCByYXRoZXIgdGhhbiBkaXJlY3RseSBjb21wdXRlZFxuLy8gYnkgdGhlIGZhY2V0LCB0byBrZWVwIGludGVybmFsIHR5cGVzIG91dCBvZiB0aGUgZmFjZXQncyB0eXBlLlxuZnVuY3Rpb24gZ2V0S2V5bWFwKHN0YXRlKSB7XG4gICAgbGV0IGJpbmRpbmdzID0gc3RhdGUuZmFjZXQoa2V5bWFwKTtcbiAgICBsZXQgbWFwID0gS2V5bWFwcy5nZXQoYmluZGluZ3MpO1xuICAgIGlmICghbWFwKVxuICAgICAgICBLZXltYXBzLnNldChiaW5kaW5ncywgbWFwID0gYnVpbGRLZXltYXAoYmluZGluZ3MucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pKSk7XG4gICAgcmV0dXJuIG1hcDtcbn1cbi8qKlxuUnVuIHRoZSBrZXkgaGFuZGxlcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBzY29wZS4gVGhlIGV2ZW50XG5vYmplY3Qgc2hvdWxkIGJlIGEgYFwia2V5ZG93blwiYCBldmVudC4gUmV0dXJucyB0cnVlIGlmIGFueSBvZiB0aGVcbmhhbmRsZXJzIGhhbmRsZWQgaXQuXG4qL1xuZnVuY3Rpb24gcnVuU2NvcGVIYW5kbGVycyh2aWV3LCBldmVudCwgc2NvcGUpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlcnMoZ2V0S2V5bWFwKHZpZXcuc3RhdGUpLCBldmVudCwgdmlldywgc2NvcGUpO1xufVxubGV0IHN0b3JlZFByZWZpeCA9IG51bGw7XG5jb25zdCBQcmVmaXhUaW1lb3V0ID0gNDAwMDtcbmZ1bmN0aW9uIGJ1aWxkS2V5bWFwKGJpbmRpbmdzLCBwbGF0Zm9ybSA9IGN1cnJlbnRQbGF0Zm9ybSkge1xuICAgIGxldCBib3VuZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGlzUHJlZml4ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgY2hlY2tQcmVmaXggPSAobmFtZSwgaXMpID0+IHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBpc1ByZWZpeFtuYW1lXTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIGlzUHJlZml4W25hbWVdID0gaXM7XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnQgIT0gaXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgYmluZGluZyBcIiArIG5hbWUgKyBcIiBpcyB1c2VkIGJvdGggYXMgYSByZWd1bGFyIGJpbmRpbmcgYW5kIGFzIGEgbXVsdGktc3Ryb2tlIHByZWZpeFwiKTtcbiAgICB9O1xuICAgIGxldCBhZGQgPSAoc2NvcGUsIGtleSwgY29tbWFuZCwgcHJldmVudERlZmF1bHQpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHNjb3BlT2JqID0gYm91bmRbc2NvcGVdIHx8IChib3VuZFtzY29wZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgbGV0IHBhcnRzID0ga2V5LnNwbGl0KC8gKD8hJCkvKS5tYXAoayA9PiBub3JtYWxpemVLZXlOYW1lKGssIHBsYXRmb3JtKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwcmVmaXggPSBwYXJ0cy5zbGljZSgwLCBpKS5qb2luKFwiIFwiKTtcbiAgICAgICAgICAgIGNoZWNrUHJlZml4KHByZWZpeCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIXNjb3BlT2JqW3ByZWZpeF0pXG4gICAgICAgICAgICAgICAgc2NvcGVPYmpbcHJlZml4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHJ1bjogWyh2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG91ck9iaiA9IHN0b3JlZFByZWZpeCA9IHsgdmlldywgcHJlZml4LCBzY29wZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyBpZiAoc3RvcmVkUHJlZml4ID09IG91ck9iailcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkUHJlZml4ID0gbnVsbDsgfSwgUHJlZml4VGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bGwgPSBwYXJ0cy5qb2luKFwiIFwiKTtcbiAgICAgICAgY2hlY2tQcmVmaXgoZnVsbCwgZmFsc2UpO1xuICAgICAgICBsZXQgYmluZGluZyA9IHNjb3BlT2JqW2Z1bGxdIHx8IChzY29wZU9ialtmdWxsXSA9IHsgcHJldmVudERlZmF1bHQ6IGZhbHNlLCBydW46ICgoX2IgPSAoX2EgPSBzY29wZU9iai5fYW55KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucnVuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2xpY2UoKSkgfHwgW10gfSk7XG4gICAgICAgIGlmIChjb21tYW5kKVxuICAgICAgICAgICAgYmluZGluZy5ydW4ucHVzaChjb21tYW5kKTtcbiAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KVxuICAgICAgICAgICAgYmluZGluZy5wcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgfTtcbiAgICBmb3IgKGxldCBiIG9mIGJpbmRpbmdzKSB7XG4gICAgICAgIGxldCBzY29wZXMgPSBiLnNjb3BlID8gYi5zY29wZS5zcGxpdChcIiBcIikgOiBbXCJlZGl0b3JcIl07XG4gICAgICAgIGlmIChiLmFueSlcbiAgICAgICAgICAgIGZvciAobGV0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgICAgICAgICAgICAgIGxldCBzY29wZU9iaiA9IGJvdW5kW3Njb3BlXSB8fCAoYm91bmRbc2NvcGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZU9iai5fYW55KVxuICAgICAgICAgICAgICAgICAgICBzY29wZU9iai5fYW55ID0geyBwcmV2ZW50RGVmYXVsdDogZmFsc2UsIHJ1bjogW10gfTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc2NvcGVPYmopXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlT2JqW2tleV0ucnVuLnB1c2goYi5hbnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgbmFtZSA9IGJbcGxhdGZvcm1dIHx8IGIua2V5O1xuICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgICAgICAgICBhZGQoc2NvcGUsIG5hbWUsIGIucnVuLCBiLnByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgICAgIGlmIChiLnNoaWZ0KVxuICAgICAgICAgICAgICAgIGFkZChzY29wZSwgXCJTaGlmdC1cIiArIG5hbWUsIGIuc2hpZnQsIGIucHJldmVudERlZmF1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3VuZDtcbn1cbmZ1bmN0aW9uIHJ1bkhhbmRsZXJzKG1hcCwgZXZlbnQsIHZpZXcsIHNjb3BlKSB7XG4gICAgbGV0IG5hbWUgPSBrZXlOYW1lKGV2ZW50KTtcbiAgICBsZXQgY2hhckNvZGUgPSBjb2RlUG9pbnRBdChuYW1lLCAwKSwgaXNDaGFyID0gY29kZVBvaW50U2l6ZShjaGFyQ29kZSkgPT0gbmFtZS5sZW5ndGggJiYgbmFtZSAhPSBcIiBcIjtcbiAgICBsZXQgcHJlZml4ID0gXCJcIiwgZmFsbHRocm91Z2ggPSBmYWxzZTtcbiAgICBpZiAoc3RvcmVkUHJlZml4ICYmIHN0b3JlZFByZWZpeC52aWV3ID09IHZpZXcgJiYgc3RvcmVkUHJlZml4LnNjb3BlID09IHNjb3BlKSB7XG4gICAgICAgIHByZWZpeCA9IHN0b3JlZFByZWZpeC5wcmVmaXggKyBcIiBcIjtcbiAgICAgICAgaWYgKGZhbGx0aHJvdWdoID0gbW9kaWZpZXJDb2Rlcy5pbmRleE9mKGV2ZW50LmtleUNvZGUpIDwgMClcbiAgICAgICAgICAgIHN0b3JlZFByZWZpeCA9IG51bGw7XG4gICAgfVxuICAgIGxldCByYW4gPSBuZXcgU2V0O1xuICAgIGxldCBydW5Gb3IgPSAoYmluZGluZykgPT4ge1xuICAgICAgICBpZiAoYmluZGluZykge1xuICAgICAgICAgICAgZm9yIChsZXQgY21kIG9mIGJpbmRpbmcucnVuKVxuICAgICAgICAgICAgICAgIGlmICghcmFuLmhhcyhjbWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbi5hZGQoY21kKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtZCh2aWV3LCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmluZGluZy5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICAgICAgICBmYWxsdGhyb3VnaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgbGV0IHNjb3BlT2JqID0gbWFwW3Njb3BlXSwgYmFzZU5hbWUsIHNoaWZ0TmFtZTtcbiAgICBpZiAoc2NvcGVPYmopIHtcbiAgICAgICAgaWYgKHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMobmFtZSwgZXZlbnQsICFpc0NoYXIpXSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGlzQ2hhciAmJiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSkgJiZcbiAgICAgICAgICAgIC8vIEN0cmwtQWx0IG1heSBiZSB1c2VkIGZvciBBbHRHciBvbiBXaW5kb3dzXG4gICAgICAgICAgICAhKGJyb3dzZXIud2luZG93cyAmJiBldmVudC5jdHJsS2V5ICYmIGV2ZW50LmFsdEtleSkgJiZcbiAgICAgICAgICAgIChiYXNlTmFtZSA9IGJhc2VbZXZlbnQua2V5Q29kZV0pICYmIGJhc2VOYW1lICE9IG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKGJhc2VOYW1lLCBldmVudCwgdHJ1ZSldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIChzaGlmdE5hbWUgPSBzaGlmdFtldmVudC5rZXlDb2RlXSkgIT0gbmFtZSAmJiBzaGlmdE5hbWUgIT0gYmFzZU5hbWUgJiZcbiAgICAgICAgICAgICAgICBydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKHNoaWZ0TmFtZSwgZXZlbnQsIGZhbHNlKV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2hhciAmJiBldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgaWYgKHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMobmFtZSwgZXZlbnQsIHRydWUpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bkZvcihzY29wZU9iai5fYW55KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbHRocm91Z2g7XG59XG5cbi8qKlxuSW1wbGVtZW50YXRpb24gb2YgW2BMYXllck1hcmtlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5MYXllck1hcmtlcikgdGhhdCBjcmVhdGVzXG5hIHJlY3RhbmdsZSBhdCBhIGdpdmVuIHNldCBvZiBjb29yZGluYXRlcy5cbiovXG5jbGFzcyBSZWN0YW5nbGVNYXJrZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmtlciB3aXRoIHRoZSBnaXZlbiBjbGFzcyBhbmQgZGltZW5zaW9ucy4gSWYgYHdpZHRoYFxuICAgIGlzIG51bGwsIHRoZSBET00gZWxlbWVudCB3aWxsIGdldCBubyB3aWR0aCBzdHlsZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsYXNzTmFtZSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgZHJhdygpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsdC5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5hZGp1c3QoZWx0KTtcbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgdXBkYXRlKGVsdCwgcHJldikge1xuICAgICAgICBpZiAocHJldi5jbGFzc05hbWUgIT0gdGhpcy5jbGFzc05hbWUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRqdXN0KGVsdCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhZGp1c3QoZWx0KSB7XG4gICAgICAgIGVsdC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgXCJweFwiO1xuICAgICAgICBlbHQuc3R5bGUudG9wID0gdGhpcy50b3AgKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLndpZHRoICE9IG51bGwpXG4gICAgICAgICAgICBlbHQuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgXCJweFwiO1xuICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgfVxuICAgIGVxKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdCA9PSBwLmxlZnQgJiYgdGhpcy50b3AgPT0gcC50b3AgJiYgdGhpcy53aWR0aCA9PSBwLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09IHAuaGVpZ2h0ICYmXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9PSBwLmNsYXNzTmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIHJlY3RhbmdsZXMgZm9yIHRoZSBnaXZlbiBzZWxlY3Rpb24gcmFuZ2UsXG4gICAgYXNzaWduaW5nIHRoZW0gdGhlY2xhc3NgY2xhc3NOYW1lYC4gV2lsbCBjcmVhdGUgYSBzaW5nbGVcbiAgICByZWN0YW5nbGUgZm9yIGVtcHR5IHJhbmdlcywgYW5kIGEgc2V0IG9mIHNlbGVjdGlvbi1zdHlsZVxuICAgIHJlY3RhbmdsZXMgY292ZXJpbmcgdGhlIHJhbmdlJ3MgY29udGVudCAoaW4gYSBiaWRpLWF3YXJlXG4gICAgd2F5KSBmb3Igbm9uLWVtcHR5IG9uZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKHJhbmdlLmhlYWQsIHJhbmdlLmFzc29jIHx8IDEpO1xuICAgICAgICAgICAgaWYgKCFwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBnZXRCYXNlKHZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgUmVjdGFuZ2xlTWFya2VyKGNsYXNzTmFtZSwgcG9zLmxlZnQgLSBiYXNlLmxlZnQsIHBvcy50b3AgLSBiYXNlLnRvcCwgbnVsbCwgcG9zLmJvdHRvbSAtIHBvcy50b3ApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0YW5nbGVzRm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRCYXNlKHZpZXcpIHtcbiAgICBsZXQgcmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBsZWZ0ID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0IC0gdmlldy5zY3JvbGxET00uY2xpZW50V2lkdGg7XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCAtIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQsIHRvcDogcmVjdC50b3AgLSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgfTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRMaW5lKHZpZXcsIHBvcywgaW5zaWRlKSB7XG4gICAgbGV0IHJhbmdlID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpO1xuICAgIHJldHVybiB7IGZyb206IE1hdGgubWF4KGluc2lkZS5mcm9tLCB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgZmFsc2UsIHRydWUpLmZyb20pLFxuICAgICAgICB0bzogTWF0aC5taW4oaW5zaWRlLnRvLCB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgdHJ1ZSwgdHJ1ZSkuZnJvbSksXG4gICAgICAgIHR5cGU6IEJsb2NrVHlwZS5UZXh0IH07XG59XG5mdW5jdGlvbiBibG9ja0F0KHZpZXcsIHBvcykge1xuICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChwb3MpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxpbmUudHlwZSkpXG4gICAgICAgIGZvciAobGV0IGwgb2YgbGluZS50eXBlKSB7XG4gICAgICAgICAgICBpZiAobC50byA+IHBvcyB8fCBsLnRvID09IHBvcyAmJiAobC50byA9PSBsaW5lLnRvIHx8IGwudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbGluZTtcbn1cbmZ1bmN0aW9uIHJlY3RhbmdsZXNGb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLnRvIDw9IHZpZXcudmlld3BvcnQuZnJvbSB8fCByYW5nZS5mcm9tID49IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgZnJvbSA9IE1hdGgubWF4KHJhbmdlLmZyb20sIHZpZXcudmlld3BvcnQuZnJvbSksIHRvID0gTWF0aC5taW4ocmFuZ2UudG8sIHZpZXcudmlld3BvcnQudG8pO1xuICAgIGxldCBsdHIgPSB2aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUjtcbiAgICBsZXQgY29udGVudCA9IHZpZXcuY29udGVudERPTSwgY29udGVudFJlY3QgPSBjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBiYXNlID0gZ2V0QmFzZSh2aWV3KTtcbiAgICBsZXQgbGluZVN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGVudC5maXJzdENoaWxkKTtcbiAgICBsZXQgbGVmdFNpZGUgPSBjb250ZW50UmVjdC5sZWZ0ICsgcGFyc2VJbnQobGluZVN0eWxlLnBhZGRpbmdMZWZ0KSArIE1hdGgubWluKDAsIHBhcnNlSW50KGxpbmVTdHlsZS50ZXh0SW5kZW50KSk7XG4gICAgbGV0IHJpZ2h0U2lkZSA9IGNvbnRlbnRSZWN0LnJpZ2h0IC0gcGFyc2VJbnQobGluZVN0eWxlLnBhZGRpbmdSaWdodCk7XG4gICAgbGV0IHN0YXJ0QmxvY2sgPSBibG9ja0F0KHZpZXcsIGZyb20pLCBlbmRCbG9jayA9IGJsb2NrQXQodmlldywgdG8pO1xuICAgIGxldCB2aXN1YWxTdGFydCA9IHN0YXJ0QmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCA/IHN0YXJ0QmxvY2sgOiBudWxsO1xuICAgIGxldCB2aXN1YWxFbmQgPSBlbmRCbG9jay50eXBlID09IEJsb2NrVHlwZS5UZXh0ID8gZW5kQmxvY2sgOiBudWxsO1xuICAgIGlmICh2aWV3LmxpbmVXcmFwcGluZykge1xuICAgICAgICBpZiAodmlzdWFsU3RhcnQpXG4gICAgICAgICAgICB2aXN1YWxTdGFydCA9IHdyYXBwZWRMaW5lKHZpZXcsIGZyb20sIHZpc3VhbFN0YXJ0KTtcbiAgICAgICAgaWYgKHZpc3VhbEVuZClcbiAgICAgICAgICAgIHZpc3VhbEVuZCA9IHdyYXBwZWRMaW5lKHZpZXcsIHRvLCB2aXN1YWxFbmQpO1xuICAgIH1cbiAgICBpZiAodmlzdWFsU3RhcnQgJiYgdmlzdWFsRW5kICYmIHZpc3VhbFN0YXJ0LmZyb20gPT0gdmlzdWFsRW5kLmZyb20pIHtcbiAgICAgICAgcmV0dXJuIHBpZWNlcyhkcmF3Rm9yTGluZShyYW5nZS5mcm9tLCByYW5nZS50bywgdmlzdWFsU3RhcnQpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB0b3AgPSB2aXN1YWxTdGFydCA/IGRyYXdGb3JMaW5lKHJhbmdlLmZyb20sIG51bGwsIHZpc3VhbFN0YXJ0KSA6IGRyYXdGb3JXaWRnZXQoc3RhcnRCbG9jaywgZmFsc2UpO1xuICAgICAgICBsZXQgYm90dG9tID0gdmlzdWFsRW5kID8gZHJhd0ZvckxpbmUobnVsbCwgcmFuZ2UudG8sIHZpc3VhbEVuZCkgOiBkcmF3Rm9yV2lkZ2V0KGVuZEJsb2NrLCB0cnVlKTtcbiAgICAgICAgbGV0IGJldHdlZW4gPSBbXTtcbiAgICAgICAgaWYgKCh2aXN1YWxTdGFydCB8fCBzdGFydEJsb2NrKS50byA8ICh2aXN1YWxFbmQgfHwgZW5kQmxvY2spLmZyb20gLSAxKVxuICAgICAgICAgICAgYmV0d2Vlbi5wdXNoKHBpZWNlKGxlZnRTaWRlLCB0b3AuYm90dG9tLCByaWdodFNpZGUsIGJvdHRvbS50b3ApKTtcbiAgICAgICAgZWxzZSBpZiAodG9wLmJvdHRvbSA8IGJvdHRvbS50b3AgJiYgdmlldy5lbGVtZW50QXRIZWlnaHQoKHRvcC5ib3R0b20gKyBib3R0b20udG9wKSAvIDIpLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpXG4gICAgICAgICAgICB0b3AuYm90dG9tID0gYm90dG9tLnRvcCA9ICh0b3AuYm90dG9tICsgYm90dG9tLnRvcCkgLyAyO1xuICAgICAgICByZXR1cm4gcGllY2VzKHRvcCkuY29uY2F0KGJldHdlZW4pLmNvbmNhdChwaWVjZXMoYm90dG9tKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBpZWNlKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZU1hcmtlcihjbGFzc05hbWUsIGxlZnQgLSBiYXNlLmxlZnQsIHRvcCAtIGJhc2UudG9wIC0gMC4wMSAvKiBDLkVwc2lsb24gKi8sIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wICsgMC4wMSAvKiBDLkVwc2lsb24gKi8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaWVjZXMoeyB0b3AsIGJvdHRvbSwgaG9yaXpvbnRhbCB9KSB7XG4gICAgICAgIGxldCBwaWVjZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob3Jpem9udGFsLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgcGllY2VzLnB1c2gocGllY2UoaG9yaXpvbnRhbFtpXSwgdG9wLCBob3Jpem9udGFsW2kgKyAxXSwgYm90dG9tKSk7XG4gICAgICAgIHJldHVybiBwaWVjZXM7XG4gICAgfVxuICAgIC8vIEdldHMgcGFzc2VkIGZyb20vdG8gaW4gbGluZS1sb2NhbCBwb3NpdGlvbnNcbiAgICBmdW5jdGlvbiBkcmF3Rm9yTGluZShmcm9tLCB0bywgbGluZSkge1xuICAgICAgICBsZXQgdG9wID0gMWU5LCBib3R0b20gPSAtMWU5LCBob3Jpem9udGFsID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGFkZFNwYW4oZnJvbSwgZnJvbU9wZW4sIHRvLCB0b09wZW4sIGRpcikge1xuICAgICAgICAgICAgLy8gUGFzc2luZyAyLy0yIGlzIGEga2x1ZGdlIHRvIGZvcmNlIHRoZSB2aWV3IHRvIHJldHVyblxuICAgICAgICAgICAgLy8gY29vcmRpbmF0ZXMgb24gdGhlIHByb3BlciBzaWRlIG9mIGJsb2NrIHdpZGdldHMsIHNpbmNlXG4gICAgICAgICAgICAvLyBub3JtYWxpemluZyB0aGUgc2lkZSB0aGVyZSwgdGhvdWdoIGFwcHJvcHJpYXRlIGZvciBtb3N0XG4gICAgICAgICAgICAvLyBjb29yZHNBdFBvcyBxdWVyaWVzLCB3b3VsZCBicmVhayBzZWxlY3Rpb24gZHJhd2luZy5cbiAgICAgICAgICAgIGxldCBmcm9tQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhmcm9tLCAoZnJvbSA9PSBsaW5lLnRvID8gLTIgOiAyKSk7XG4gICAgICAgICAgICBsZXQgdG9Db29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHRvLCAodG8gPT0gbGluZS5mcm9tID8gMiA6IC0yKSk7XG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1pbihmcm9tQ29vcmRzLnRvcCwgdG9Db29yZHMudG9wLCB0b3ApO1xuICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoZnJvbUNvb3Jkcy5ib3R0b20sIHRvQ29vcmRzLmJvdHRvbSwgYm90dG9tKTtcbiAgICAgICAgICAgIGlmIChkaXIgPT0gRGlyZWN0aW9uLkxUUilcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsLnB1c2gobHRyICYmIGZyb21PcGVuID8gbGVmdFNpZGUgOiBmcm9tQ29vcmRzLmxlZnQsIGx0ciAmJiB0b09wZW4gPyByaWdodFNpZGUgOiB0b0Nvb3Jkcy5yaWdodCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbC5wdXNoKCFsdHIgJiYgdG9PcGVuID8gbGVmdFNpZGUgOiB0b0Nvb3Jkcy5sZWZ0LCAhbHRyICYmIGZyb21PcGVuID8gcmlnaHRTaWRlIDogZnJvbUNvb3Jkcy5yaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gZnJvbSAhPT0gbnVsbCAmJiBmcm9tICE9PSB2b2lkIDAgPyBmcm9tIDogbGluZS5mcm9tLCBlbmQgPSB0byAhPT0gbnVsbCAmJiB0byAhPT0gdm9pZCAwID8gdG8gOiBsaW5lLnRvO1xuICAgICAgICAvLyBTcGxpdCB0aGUgcmFuZ2UgYnkgdmlzaWJsZSByYW5nZSBhbmQgZG9jdW1lbnQgbGluZVxuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcylcbiAgICAgICAgICAgIGlmIChyLnRvID4gc3RhcnQgJiYgci5mcm9tIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gTWF0aC5tYXgoci5mcm9tLCBzdGFydCksIGVuZFBvcyA9IE1hdGgubWluKHIudG8sIGVuZCk7Oykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZG9jTGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzcGFuIG9mIHZpZXcuYmlkaVNwYW5zKGRvY0xpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhbkZyb20gPSBzcGFuLmZyb20gKyBkb2NMaW5lLmZyb20sIHNwYW5UbyA9IHNwYW4udG8gKyBkb2NMaW5lLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhbkZyb20gPj0gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW5UbyA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTcGFuKE1hdGgubWF4KHNwYW5Gcm9tLCBwb3MpLCBmcm9tID09IG51bGwgJiYgc3BhbkZyb20gPD0gc3RhcnQsIE1hdGgubWluKHNwYW5UbywgZW5kUG9zKSwgdG8gPT0gbnVsbCAmJiBzcGFuVG8gPj0gZW5kLCBzcGFuLmRpcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zID0gZG9jTGluZS50byArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoaG9yaXpvbnRhbC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGFkZFNwYW4oc3RhcnQsIGZyb20gPT0gbnVsbCwgZW5kLCB0byA9PSBudWxsLCB2aWV3LnRleHREaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4geyB0b3AsIGJvdHRvbSwgaG9yaXpvbnRhbCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkcmF3Rm9yV2lkZ2V0KGJsb2NrLCB0b3ApIHtcbiAgICAgICAgbGV0IHkgPSBjb250ZW50UmVjdC50b3AgKyAodG9wID8gYmxvY2sudG9wIDogYmxvY2suYm90dG9tKTtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB5LCBib3R0b206IHksIGhvcml6b250YWw6IFtdIH07XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZU1hcmtlcihhLCBiKSB7XG4gICAgcmV0dXJuIGEuY29uc3RydWN0b3IgPT0gYi5jb25zdHJ1Y3RvciAmJiBhLmVxKGIpO1xufVxuY2xhc3MgTGF5ZXJWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBsYXllcikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuZHJhd24gPSBbXTtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLm1lYXN1cmUuYmluZCh0aGlzKSwgd3JpdGU6IHRoaXMuZHJhdy5iaW5kKHRoaXMpIH07XG4gICAgICAgIHRoaXMuZG9tID0gdmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1sYXllclwiKTtcbiAgICAgICAgaWYgKGxheWVyLmFib3ZlKVxuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChcImNtLWxheWVyLWFib3ZlXCIpO1xuICAgICAgICBpZiAobGF5ZXIuY2xhc3MpXG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKGxheWVyLmNsYXNzKTtcbiAgICAgICAgdGhpcy5kb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICB0aGlzLnNldE9yZGVyKHZpZXcuc3RhdGUpO1xuICAgICAgICB2aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIGlmIChsYXllci5tb3VudClcbiAgICAgICAgICAgIGxheWVyLm1vdW50KHRoaXMuZG9tLCB2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGF5ZXJPcmRlcikgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGxheWVyT3JkZXIpKVxuICAgICAgICAgICAgdGhpcy5zZXRPcmRlcih1cGRhdGUuc3RhdGUpO1xuICAgICAgICBpZiAodGhpcy5sYXllci51cGRhdGUodXBkYXRlLCB0aGlzLmRvbSkgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZClcbiAgICAgICAgICAgIHVwZGF0ZS52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgfVxuICAgIHNldE9yZGVyKHN0YXRlKSB7XG4gICAgICAgIGxldCBwb3MgPSAwLCBvcmRlciA9IHN0YXRlLmZhY2V0KGxheWVyT3JkZXIpO1xuICAgICAgICB3aGlsZSAocG9zIDwgb3JkZXIubGVuZ3RoICYmIG9yZGVyW3Bvc10gIT0gdGhpcy5sYXllcilcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS56SW5kZXggPSBTdHJpbmcoKHRoaXMubGF5ZXIuYWJvdmUgPyAxNTAgOiAtMSkgLSBwb3MpO1xuICAgIH1cbiAgICBtZWFzdXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXllci5tYXJrZXJzKHRoaXMudmlldyk7XG4gICAgfVxuICAgIGRyYXcobWFya2Vycykge1xuICAgICAgICBpZiAobWFya2Vycy5sZW5ndGggIT0gdGhpcy5kcmF3bi5sZW5ndGggfHwgbWFya2Vycy5zb21lKChwLCBpKSA9PiAhc2FtZU1hcmtlcihwLCB0aGlzLmRyYXduW2ldKSkpIHtcbiAgICAgICAgICAgIGxldCBvbGQgPSB0aGlzLmRvbS5maXJzdENoaWxkLCBvbGRJID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IG1hcmtlciBvZiBtYXJrZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci51cGRhdGUgJiYgb2xkICYmIG1hcmtlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmRyYXduW29sZEldLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci51cGRhdGUob2xkLCB0aGlzLmRyYXduW29sZEldKSkge1xuICAgICAgICAgICAgICAgICAgICBvbGQgPSBvbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIG9sZEkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShtYXJrZXIuZHJhdygpLCBvbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChvbGQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG9sZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBvbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgb2xkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHJhd24gPSBtYXJrZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmxheWVyLmRlc3Ryb3kpXG4gICAgICAgICAgICB0aGlzLmxheWVyLmRlc3Ryb3kodGhpcy5kb20sIHRoaXMudmlldyk7XG4gICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgIH1cbn1cbmNvbnN0IGxheWVyT3JkZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkRlZmluZSBhIGxheWVyLlxuKi9cbmZ1bmN0aW9uIGxheWVyKGNvbmZpZykge1xuICAgIHJldHVybiBbXG4gICAgICAgIFZpZXdQbHVnaW4uZGVmaW5lKHYgPT4gbmV3IExheWVyVmlldyh2LCBjb25maWcpKSxcbiAgICAgICAgbGF5ZXJPcmRlci5vZihjb25maWcpXG4gICAgXTtcbn1cblxuY29uc3QgQ2FuSGlkZVByaW1hcnkgPSAhYnJvd3Nlci5pb3M7IC8vIEZJWE1FIHRlc3QgSUVcbmNvbnN0IHNlbGVjdGlvbkNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBjdXJzb3JCbGlua1JhdGU6IDEyMDAsXG4gICAgICAgICAgICBkcmF3UmFuZ2VDdXJzb3I6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY3Vyc29yQmxpbmtSYXRlOiAoYSwgYikgPT4gTWF0aC5taW4oYSwgYiksXG4gICAgICAgICAgICBkcmF3UmFuZ2VDdXJzb3I6IChhLCBiKSA9PiBhIHx8IGJcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaGlkZXMgdGhlIGJyb3dzZXIncyBuYXRpdmUgc2VsZWN0aW9uIGFuZFxuY3Vyc29yLCByZXBsYWNpbmcgdGhlIHNlbGVjdGlvbiB3aXRoIGEgYmFja2dyb3VuZCBiZWhpbmQgdGhlIHRleHRcbih3aXRoIHRoZSBgY20tc2VsZWN0aW9uQmFja2dyb3VuZGAgY2xhc3MpLCBhbmQgdGhlXG5jdXJzb3JzIHdpdGggZWxlbWVudHMgb3ZlcmxhaWQgb3ZlciB0aGUgY29kZSAodXNpbmdcbmBjbS1jdXJzb3ItcHJpbWFyeWAgYW5kIGBjbS1jdXJzb3Itc2Vjb25kYXJ5YCkuXG5cblRoaXMgYWxsb3dzIHRoZSBlZGl0b3IgdG8gZGlzcGxheSBzZWNvbmRhcnkgc2VsZWN0aW9uIHJhbmdlcywgYW5kXG50ZW5kcyB0byBwcm9kdWNlIGEgdHlwZSBvZiBzZWxlY3Rpb24gbW9yZSBpbiBsaW5lIHdpdGggdGhhdCB1c2Vyc1xuZXhwZWN0IGluIGEgdGV4dCBlZGl0b3IgKHRoZSBuYXRpdmUgc2VsZWN0aW9uIHN0eWxpbmcgd2lsbCBvZnRlblxubGVhdmUgZ2FwcyBiZXR3ZWVuIGxpbmVzIGFuZCB3b24ndCBmaWxsIHRoZSBob3Jpem9udGFsIHNwYWNlIGFmdGVyXG5hIGxpbmUgd2hlbiB0aGUgc2VsZWN0aW9uIGNvbnRpbnVlcyBwYXN0IGl0KS5cblxuSXQgZG9lcyBoYXZlIGEgcGVyZm9ybWFuY2UgY29zdCwgaW4gdGhhdCBpdCByZXF1aXJlcyBhbiBleHRyYSBET01cbmxheW91dCBjeWNsZSBmb3IgbWFueSB1cGRhdGVzICh0aGUgc2VsZWN0aW9uIGlzIGRyYXduIGJhc2VkIG9uIERPTVxubGF5b3V0IGluZm9ybWF0aW9uIHRoYXQncyBvbmx5IGF2YWlsYWJsZSBhZnRlciBsYXlpbmcgb3V0IHRoZVxuY29udGVudCkuXG4qL1xuZnVuY3Rpb24gZHJhd1NlbGVjdGlvbihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHNlbGVjdGlvbkNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBjdXJzb3JMYXllcixcbiAgICAgICAgc2VsZWN0aW9uTGF5ZXIsXG4gICAgICAgIGhpZGVOYXRpdmVTZWxlY3Rpb24sXG4gICAgICAgIG5hdGl2ZVNlbGVjdGlvbkhpZGRlbi5vZih0cnVlKVxuICAgIF07XG59XG5mdW5jdGlvbiBjb25maWdDaGFuZ2VkKHVwZGF0ZSkge1xuICAgIHJldHVybiB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpO1xufVxuY29uc3QgY3Vyc29yTGF5ZXIgPSAvKkBfX1BVUkVfXyovbGF5ZXIoe1xuICAgIGFib3ZlOiB0cnVlLFxuICAgIG1hcmtlcnModmlldykge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY29uZiA9IHN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZyk7XG4gICAgICAgIGxldCBjdXJzb3JzID0gW107XG4gICAgICAgIGZvciAobGV0IHIgb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IHByaW0gPSByID09IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAgICAgaWYgKHIuZW1wdHkgPyAhcHJpbSB8fCBDYW5IaWRlUHJpbWFyeSA6IGNvbmYuZHJhd1JhbmdlQ3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNsYXNzTmFtZSA9IHByaW0gPyBcImNtLWN1cnNvciBjbS1jdXJzb3ItcHJpbWFyeVwiIDogXCJjbS1jdXJzb3IgY20tY3Vyc29yLXNlY29uZGFyeVwiO1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3IgPSByLmVtcHR5ID8gciA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioci5oZWFkLCByLmhlYWQgPiByLmFuY2hvciA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcGllY2Ugb2YgUmVjdGFuZ2xlTWFya2VyLmZvclJhbmdlKHZpZXcsIGNsYXNzTmFtZSwgY3Vyc29yKSlcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29ycy5wdXNoKHBpZWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3Vyc29ycztcbiAgICB9LFxuICAgIHVwZGF0ZSh1cGRhdGUsIGRvbSkge1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLnNlbGVjdGlvbikpXG4gICAgICAgICAgICBkb20uc3R5bGUuYW5pbWF0aW9uTmFtZSA9IGRvbS5zdHlsZS5hbmltYXRpb25OYW1lID09IFwiY20tYmxpbmtcIiA/IFwiY20tYmxpbmsyXCIgOiBcImNtLWJsaW5rXCI7XG4gICAgICAgIGxldCBjb25mQ2hhbmdlID0gY29uZmlnQ2hhbmdlZCh1cGRhdGUpO1xuICAgICAgICBpZiAoY29uZkNoYW5nZSlcbiAgICAgICAgICAgIHNldEJsaW5rUmF0ZSh1cGRhdGUuc3RhdGUsIGRvbSk7XG4gICAgICAgIHJldHVybiB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IGNvbmZDaGFuZ2U7XG4gICAgfSxcbiAgICBtb3VudChkb20sIHZpZXcpIHtcbiAgICAgICAgc2V0QmxpbmtSYXRlKHZpZXcuc3RhdGUsIGRvbSk7XG4gICAgfSxcbiAgICBjbGFzczogXCJjbS1jdXJzb3JMYXllclwiXG59KTtcbmZ1bmN0aW9uIHNldEJsaW5rUmF0ZShzdGF0ZSwgZG9tKSB7XG4gICAgZG9tLnN0eWxlLmFuaW1hdGlvbkR1cmF0aW9uID0gc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKS5jdXJzb3JCbGlua1JhdGUgKyBcIm1zXCI7XG59XG5jb25zdCBzZWxlY3Rpb25MYXllciA9IC8qQF9fUFVSRV9fKi9sYXllcih7XG4gICAgYWJvdmU6IGZhbHNlLFxuICAgIG1hcmtlcnModmlldykge1xuICAgICAgICByZXR1cm4gdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLm1hcChyID0+IHIuZW1wdHkgPyBbXSA6IFJlY3RhbmdsZU1hcmtlci5mb3JSYW5nZSh2aWV3LCBcImNtLXNlbGVjdGlvbkJhY2tncm91bmRcIiwgcikpXG4gICAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSk7XG4gICAgfSxcbiAgICB1cGRhdGUodXBkYXRlLCBkb20pIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fCBjb25maWdDaGFuZ2VkKHVwZGF0ZSk7XG4gICAgfSxcbiAgICBjbGFzczogXCJjbS1zZWxlY3Rpb25MYXllclwiXG59KTtcbmNvbnN0IHRoZW1lU3BlYyA9IHtcbiAgICBcIi5jbS1saW5lXCI6IHtcbiAgICAgICAgXCImIDo6c2VsZWN0aW9uXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIiB9LFxuICAgICAgICBcIiY6OnNlbGVjdGlvblwiOiB7IGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCIgfVxuICAgIH1cbn07XG5pZiAoQ2FuSGlkZVByaW1hcnkpXG4gICAgdGhlbWVTcGVjW1wiLmNtLWxpbmVcIl0uY2FyZXRDb2xvciA9IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiO1xuY29uc3QgaGlkZU5hdGl2ZVNlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL0VkaXRvclZpZXcudGhlbWUodGhlbWVTcGVjKSk7XG5cbmNvbnN0IHNldERyb3BDdXJzb3JQb3MgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAocG9zLCBtYXBwaW5nKSB7IHJldHVybiBwb3MgPT0gbnVsbCA/IG51bGwgOiBtYXBwaW5nLm1hcFBvcyhwb3MpOyB9XG59KTtcbmNvbnN0IGRyb3BDdXJzb3JQb3MgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgdXBkYXRlKHBvcywgdHIpIHtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxuICAgICAgICAgICAgcG9zID0gdHIuY2hhbmdlcy5tYXBQb3MocG9zKTtcbiAgICAgICAgcmV0dXJuIHRyLmVmZmVjdHMucmVkdWNlKChwb3MsIGUpID0+IGUuaXMoc2V0RHJvcEN1cnNvclBvcykgPyBlLnZhbHVlIDogcG9zLCBwb3MpO1xuICAgIH1cbn0pO1xuY29uc3QgZHJhd0Ryb3BDdXJzb3IgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZFBvcy5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy5kcmF3Q3Vyc29yLmJpbmQodGhpcykgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjdXJzb3JQb3MgPSB1cGRhdGUuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XG4gICAgICAgIGlmIChjdXJzb3JQb3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3Vyc29yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmN1cnNvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jdXJzb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMudmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IuY2xhc3NOYW1lID0gXCJjbS1kcm9wQ3Vyc29yXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gY3Vyc29yUG9zIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZFBvcygpIHtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKTtcbiAgICAgICAgbGV0IHJlY3QgPSBwb3MgIT0gbnVsbCAmJiB0aGlzLnZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgaWYgKCFyZWN0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBvdXRlciA9IHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBvdXRlci5sZWZ0ICsgdGhpcy52aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAtIG91dGVyLnRvcCArIHRoaXMudmlldy5zY3JvbGxET00uc2Nyb2xsVG9wLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRyYXdDdXJzb3IocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvcikge1xuICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmxlZnQgPSBwb3MubGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS50b3AgPSBwb3MudG9wICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmhlaWdodCA9IHBvcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gXCItMTAwMDAwcHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3IpXG4gICAgICAgICAgICB0aGlzLmN1cnNvci5yZW1vdmUoKTtcbiAgICB9XG4gICAgc2V0RHJvcFBvcyhwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKSAhPSBwb3MpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXREcm9wQ3Vyc29yUG9zLm9mKHBvcykgfSk7XG4gICAgfVxufSwge1xuICAgIGV2ZW50SGFuZGxlcnM6IHtcbiAgICAgICAgZHJhZ292ZXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyh0aGlzLnZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ2xlYXZlKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09IHRoaXMudmlldy5jb250ZW50RE9NIHx8ICF0aGlzLnZpZXcuY29udGVudERPTS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdlbmQoKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyb3AoKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbi8qKlxuRHJhd3MgYSBjdXJzb3IgYXQgdGhlIGN1cnJlbnQgZHJvcCBwb3NpdGlvbiB3aGVuIHNvbWV0aGluZyBpc1xuZHJhZ2dlZCBvdmVyIHRoZSBlZGl0b3IuXG4qL1xuZnVuY3Rpb24gZHJvcEN1cnNvcigpIHtcbiAgICByZXR1cm4gW2Ryb3BDdXJzb3JQb3MsIGRyYXdEcm9wQ3Vyc29yXTtcbn1cblxuZnVuY3Rpb24gaXRlck1hdGNoZXMoZG9jLCByZSwgZnJvbSwgdG8sIGYpIHtcbiAgICByZS5sYXN0SW5kZXggPSAwO1xuICAgIGZvciAobGV0IGN1cnNvciA9IGRvYy5pdGVyUmFuZ2UoZnJvbSwgdG8pLCBwb3MgPSBmcm9tLCBtOyAhY3Vyc29yLm5leHQoKS5kb25lOyBwb3MgKz0gY3Vyc29yLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICBpZiAoIWN1cnNvci5saW5lQnJlYWspXG4gICAgICAgICAgICB3aGlsZSAobSA9IHJlLmV4ZWMoY3Vyc29yLnZhbHVlKSlcbiAgICAgICAgICAgICAgICBmKHBvcyArIG0uaW5kZXgsIG0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hdGNoUmFuZ2VzKHZpZXcsIG1heExlbmd0aCkge1xuICAgIGxldCB2aXNpYmxlID0gdmlldy52aXNpYmxlUmFuZ2VzO1xuICAgIGlmICh2aXNpYmxlLmxlbmd0aCA9PSAxICYmIHZpc2libGVbMF0uZnJvbSA9PSB2aWV3LnZpZXdwb3J0LmZyb20gJiZcbiAgICAgICAgdmlzaWJsZVswXS50byA9PSB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHZpc2libGUpIHtcbiAgICAgICAgZnJvbSA9IE1hdGgubWF4KHZpZXcuc3RhdGUuZG9jLmxpbmVBdChmcm9tKS5mcm9tLCBmcm9tIC0gbWF4TGVuZ3RoKTtcbiAgICAgICAgdG8gPSBNYXRoLm1pbih2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pLnRvLCB0byArIG1heExlbmd0aCk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICYmIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0udG8gPj0gZnJvbSlcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0udG8gPSB0bztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuSGVscGVyIGNsYXNzIHVzZWQgdG8gbWFrZSBpdCBlYXNpZXIgdG8gbWFpbnRhaW4gZGVjb3JhdGlvbnMgb25cbnZpc2libGUgY29kZSB0aGF0IG1hdGNoZXMgYSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24uIFRvIGJlIHVzZWRcbmluIGEgW3ZpZXcgcGx1Z2luXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuVmlld1BsdWdpbikuIEluc3RhbmNlcyBvZiB0aGlzIG9iamVjdFxucmVwcmVzZW50IGEgbWF0Y2hpbmcgY29uZmlndXJhdGlvbi5cbiovXG5jbGFzcyBNYXRjaERlY29yYXRvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZGVjb3JhdG9yLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHsgcmVnZXhwLCBkZWNvcmF0aW9uLCBkZWNvcmF0ZSwgYm91bmRhcnksIG1heExlbmd0aCA9IDEwMDAgfSA9IGNvbmZpZztcbiAgICAgICAgaWYgKCFyZWdleHAuZ2xvYmFsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgcmVndWxhciBleHByZXNzaW9uIGdpdmVuIHRvIE1hdGNoRGVjb3JhdG9yIHNob3VsZCBoYXZlIGl0cyAnZycgZmxhZyBzZXRcIik7XG4gICAgICAgIHRoaXMucmVnZXhwID0gcmVnZXhwO1xuICAgICAgICBpZiAoZGVjb3JhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIHZpZXcsIGZyb20sIGFkZCkgPT4gZGVjb3JhdGUoYWRkLCBmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBtYXRjaCwgdmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlY29yYXRpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE1hdGNoID0gKG1hdGNoLCB2aWV3LCBmcm9tLCBhZGQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZGVjbyA9IGRlY29yYXRpb24obWF0Y2gsIHZpZXcsIGZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChkZWNvKVxuICAgICAgICAgICAgICAgICAgICBhZGQoZnJvbSwgZnJvbSArIG1hdGNoWzBdLmxlbmd0aCwgZGVjbyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlY29yYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIF92aWV3LCBmcm9tLCBhZGQpID0+IGFkZChmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBkZWNvcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRWl0aGVyICdkZWNvcmF0ZScgb3IgJ2RlY29yYXRpb24nIHNob3VsZCBiZSBwcm92aWRlZCB0byBNYXRjaERlY29yYXRvclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvdW5kYXJ5ID0gYm91bmRhcnk7XG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wdXRlIHRoZSBmdWxsIHNldCBvZiBkZWNvcmF0aW9ucyBmb3IgbWF0Y2hlcyBpbiB0aGUgZ2l2ZW5cbiAgICB2aWV3J3Mgdmlld3BvcnQuIFlvdSdsbCB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIGluaXRpYWxpemluZyB5b3VyXG4gICAgcGx1Z2luLlxuICAgICovXG4gICAgY3JlYXRlRGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBidWlsZCA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKSwgYWRkID0gYnVpbGQuYWRkLmJpbmQoYnVpbGQpO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgbWF0Y2hSYW5nZXModmlldywgdGhpcy5tYXhMZW5ndGgpKVxuICAgICAgICAgICAgaXRlck1hdGNoZXModmlldy5zdGF0ZS5kb2MsIHRoaXMucmVnZXhwLCBmcm9tLCB0bywgKGZyb20sIG0pID0+IHRoaXMuYWRkTWF0Y2gobSwgdmlldywgZnJvbSwgYWRkKSk7XG4gICAgICAgIHJldHVybiBidWlsZC5maW5pc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIGEgc2V0IG9mIGRlY29yYXRpb25zIGZvciBhIHZpZXcgdXBkYXRlLiBgZGVjb2AgX211c3RfIGJlXG4gICAgdGhlIHNldCBvZiBkZWNvcmF0aW9ucyBwcm9kdWNlZCBieSBfdGhpc18gYE1hdGNoRGVjb3JhdG9yYCBmb3JcbiAgICB0aGUgdmlldyBzdGF0ZSBiZWZvcmUgdGhlIHVwZGF0ZS5cbiAgICAqL1xuICAgIHVwZGF0ZURlY28odXBkYXRlLCBkZWNvKSB7XG4gICAgICAgIGxldCBjaGFuZ2VGcm9tID0gMWU5LCBjaGFuZ2VUbyA9IC0xO1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB1cGRhdGUuY2hhbmdlcy5pdGVyQ2hhbmdlcygoX2YsIF90LCBmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0byA+IHVwZGF0ZS52aWV3LnZpZXdwb3J0LmZyb20gJiYgZnJvbSA8IHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUZyb20gPSBNYXRoLm1pbihmcm9tLCBjaGFuZ2VGcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlVG8gPSBNYXRoLm1heCh0bywgY2hhbmdlVG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAodXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fCBjaGFuZ2VUbyAtIGNoYW5nZUZyb20gPiAxMDAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGVjbyh1cGRhdGUudmlldyk7XG4gICAgICAgIGlmIChjaGFuZ2VUbyA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlUmFuZ2UodXBkYXRlLnZpZXcsIGRlY28ubWFwKHVwZGF0ZS5jaGFuZ2VzKSwgY2hhbmdlRnJvbSwgY2hhbmdlVG8pO1xuICAgICAgICByZXR1cm4gZGVjbztcbiAgICB9XG4gICAgdXBkYXRlUmFuZ2UodmlldywgZGVjbywgdXBkYXRlRnJvbSwgdXBkYXRlVG8pIHtcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoci5mcm9tLCB1cGRhdGVGcm9tKSwgdG8gPSBNYXRoLm1pbihyLnRvLCB1cGRhdGVUbyk7XG4gICAgICAgICAgICBpZiAodG8gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb21MaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLCB0b0xpbmUgPSBmcm9tTGluZS50byA8IHRvID8gdmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKSA6IGZyb21MaW5lO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHIuZnJvbSwgZnJvbUxpbmUuZnJvbSksIGVuZCA9IE1hdGgubWluKHIudG8sIHRvTGluZS50byk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGZyb20gPiBmcm9tTGluZS5mcm9tOyBmcm9tLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeS50ZXN0KGZyb21MaW5lLnRleHRbZnJvbSAtIDEgLSBmcm9tTGluZS5mcm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyB0byA8IHRvTGluZS50bzsgdG8rKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QodG9MaW5lLnRleHRbdG8gLSB0b0xpbmUuZnJvbV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBbXSwgbTtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gKGZyb20sIHRvLCBkZWNvKSA9PiByYW5nZXMucHVzaChkZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21MaW5lID09IHRvTGluZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2V4cC5sYXN0SW5kZXggPSBzdGFydCAtIGZyb21MaW5lLmZyb207XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgobSA9IHRoaXMucmVnZXhwLmV4ZWMoZnJvbUxpbmUudGV4dCkpICYmIG0uaW5kZXggPCBlbmQgLSBmcm9tTGluZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBtLmluZGV4ICsgZnJvbUxpbmUuZnJvbSwgYWRkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJNYXRjaGVzKHZpZXcuc3RhdGUuZG9jLCB0aGlzLnJlZ2V4cCwgc3RhcnQsIGVuZCwgKGZyb20sIG0pID0+IHRoaXMuYWRkTWF0Y2gobSwgdmlldywgZnJvbSwgYWRkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY28gPSBkZWNvLnVwZGF0ZSh7IGZpbHRlckZyb206IHN0YXJ0LCBmaWx0ZXJUbzogZW5kLCBmaWx0ZXI6IChmcm9tLCB0bykgPT4gZnJvbSA8IHN0YXJ0IHx8IHRvID4gZW5kLCBhZGQ6IHJhbmdlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjbztcbiAgICB9XG59XG5cbmNvbnN0IFVuaWNvZGVSZWdleHBTdXBwb3J0ID0gL3gvLnVuaWNvZGUgIT0gbnVsbCA/IFwiZ3VcIiA6IFwiZ1wiO1xuY29uc3QgU3BlY2lhbHMgPSAvKkBfX1BVUkVfXyovbmV3IFJlZ0V4cChcIltcXHUwMDAwLVxcdTAwMDhcXHUwMDBhLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYxY1xcdTIwMGJcXHUyMDBlXFx1MjAwZlxcdTIwMjhcXHUyMDI5XFx1MjAyZFxcdTIwMmVcXHUyMDY2XFx1MjA2N1xcdTIwNjlcXHVmZWZmXFx1ZmZmOS1cXHVmZmZjXVwiLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG5jb25zdCBOYW1lcyA9IHtcbiAgICAwOiBcIm51bGxcIixcbiAgICA3OiBcImJlbGxcIixcbiAgICA4OiBcImJhY2tzcGFjZVwiLFxuICAgIDEwOiBcIm5ld2xpbmVcIixcbiAgICAxMTogXCJ2ZXJ0aWNhbCB0YWJcIixcbiAgICAxMzogXCJjYXJyaWFnZSByZXR1cm5cIixcbiAgICAyNzogXCJlc2NhcGVcIixcbiAgICA4MjAzOiBcInplcm8gd2lkdGggc3BhY2VcIixcbiAgICA4MjA0OiBcInplcm8gd2lkdGggbm9uLWpvaW5lclwiLFxuICAgIDgyMDU6IFwiemVybyB3aWR0aCBqb2luZXJcIixcbiAgICA4MjA2OiBcImxlZnQtdG8tcmlnaHQgbWFya1wiLFxuICAgIDgyMDc6IFwicmlnaHQtdG8tbGVmdCBtYXJrXCIsXG4gICAgODIzMjogXCJsaW5lIHNlcGFyYXRvclwiLFxuICAgIDgyMzc6IFwibGVmdC10by1yaWdodCBvdmVycmlkZVwiLFxuICAgIDgyMzg6IFwicmlnaHQtdG8tbGVmdCBvdmVycmlkZVwiLFxuICAgIDgyOTQ6IFwibGVmdC10by1yaWdodCBpc29sYXRlXCIsXG4gICAgODI5NTogXCJyaWdodC10by1sZWZ0IGlzb2xhdGVcIixcbiAgICA4Mjk3OiBcInBvcCBkaXJlY3Rpb25hbCBpc29sYXRlXCIsXG4gICAgODIzMzogXCJwYXJhZ3JhcGggc2VwYXJhdG9yXCIsXG4gICAgNjUyNzk6IFwiemVybyB3aWR0aCBuby1icmVhayBzcGFjZVwiLFxuICAgIDY1NTMyOiBcIm9iamVjdCByZXBsYWNlbWVudFwiXG59O1xubGV0IF9zdXBwb3J0c1RhYlNpemUgPSBudWxsO1xuZnVuY3Rpb24gc3VwcG9ydHNUYWJTaXplKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoX3N1cHBvcnRzVGFiU2l6ZSA9PSBudWxsICYmIHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgbGV0IHN0eWxlcyA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gICAgICAgIF9zdXBwb3J0c1RhYlNpemUgPSAoKF9hID0gc3R5bGVzLnRhYlNpemUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHN0eWxlcy5Nb3pUYWJTaXplKSAhPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gX3N1cHBvcnRzVGFiU2l6ZSB8fCBmYWxzZTtcbn1cbmNvbnN0IHNwZWNpYWxDaGFyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIGxldCBjb25maWcgPSBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgICAgICAgIHNwZWNpYWxDaGFyczogU3BlY2lhbHMsXG4gICAgICAgICAgICBhZGRTcGVjaWFsQ2hhcnM6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcucmVwbGFjZVRhYnMgPSAhc3VwcG9ydHNUYWJTaXplKCkpXG4gICAgICAgICAgICBjb25maWcuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChcIlxcdHxcIiArIGNvbmZpZy5zcGVjaWFsQ2hhcnMuc291cmNlLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG4gICAgICAgIGlmIChjb25maWcuYWRkU3BlY2lhbENoYXJzKVxuICAgICAgICAgICAgY29uZmlnLnNwZWNpYWxDaGFycyA9IG5ldyBSZWdFeHAoY29uZmlnLnNwZWNpYWxDaGFycy5zb3VyY2UgKyBcInxcIiArIGNvbmZpZy5hZGRTcGVjaWFsQ2hhcnMuc291cmNlLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaW5zdGFsbHMgaGlnaGxpZ2h0aW5nIG9mIHNwZWNpYWxcbmNoYXJhY3RlcnMuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0U3BlY2lhbENoYXJzKFxuLyoqXG5Db25maWd1cmF0aW9uIG9wdGlvbnMuXG4qL1xuY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW3NwZWNpYWxDaGFyQ29uZmlnLm9mKGNvbmZpZyksIHNwZWNpYWxDaGFyUGx1Z2luKCldO1xufVxubGV0IF9wbHVnaW4gPSBudWxsO1xuZnVuY3Rpb24gc3BlY2lhbENoYXJQbHVnaW4oKSB7XG4gICAgcmV0dXJuIF9wbHVnaW4gfHwgKF9wbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9uQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3Iodmlldy5zdGF0ZS5mYWNldChzcGVjaWFsQ2hhckNvbmZpZykpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgbWFrZURlY29yYXRvcihjb25mKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICAgICAgICAgICAgICByZWdleHA6IGNvbmYuc3BlY2lhbENoYXJzLFxuICAgICAgICAgICAgICAgIGRlY29yYXRpb246IChtLCB2aWV3LCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZG9jIH0gPSB2aWV3LnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZSA9IGNvZGVQb2ludEF0KG1bMF0sIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gdmlldy5zdGF0ZS50YWJTaXplLCBjb2wgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIHNpemUsIHBvcyAtIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgVGFiV2lkZ2V0KChzaXplIC0gKGNvbCAlIHNpemUpKSAqIHRoaXMudmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZGVjb3JhdGlvbkNhY2hlW2NvZGVdID0gRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgU3BlY2lhbENoYXJXaWRnZXQoY29uZiwgY29kZSkgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm91bmRhcnk6IGNvbmYucmVwbGFjZVRhYnMgPyB1bmRlZmluZWQgOiAvW15dL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQoc3BlY2lhbENoYXJDb25maWcpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSAhPSBjb25mKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3IoY29uZik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLnVwZGF0ZURlY28odXBkYXRlLCB0aGlzLmRlY29yYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xuICAgIH0pKTtcbn1cbmNvbnN0IERlZmF1bHRQbGFjZWhvbGRlciA9IFwiXFx1MjAyMlwiO1xuLy8gQXNzaWducyBwbGFjZWhvbGRlciBjaGFyYWN0ZXJzIGZyb20gdGhlIENvbnRyb2wgUGljdHVyZXMgYmxvY2sgdG9cbi8vIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVyc1xuZnVuY3Rpb24gcGxhY2Vob2xkZXIkMShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPj0gMzIpXG4gICAgICAgIHJldHVybiBEZWZhdWx0UGxhY2Vob2xkZXI7XG4gICAgaWYgKGNvZGUgPT0gMTApXG4gICAgICAgIHJldHVybiBcIlxcdTI0MjRcIjtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5MjE2ICsgY29kZSk7XG59XG5jbGFzcyBTcGVjaWFsQ2hhcldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLmNvZGUgPT0gdGhpcy5jb2RlOyB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBsZXQgcGggPSBwbGFjZWhvbGRlciQxKHRoaXMuY29kZSk7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5zdGF0ZS5waHJhc2UoXCJDb250cm9sIGNoYXJhY3RlclwiKSArIFwiIFwiICsgKE5hbWVzW3RoaXMuY29kZV0gfHwgXCIweFwiICsgdGhpcy5jb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGxldCBjdXN0b20gPSB0aGlzLm9wdGlvbnMucmVuZGVyICYmIHRoaXMub3B0aW9ucy5yZW5kZXIodGhpcy5jb2RlLCBkZXNjLCBwaCk7XG4gICAgICAgIGlmIChjdXN0b20pXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gcGg7XG4gICAgICAgIHNwYW4udGl0bGUgPSBkZXNjO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgZGVzYyk7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zcGVjaWFsQ2hhclwiO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuY2xhc3MgVGFiV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Iod2lkdGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIud2lkdGggPT0gdGhpcy53aWR0aDsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gXCJcXHRcIjtcbiAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLXRhYlwiO1xuICAgICAgICBzcGFuLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cblxuY29uc3QgcGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxMDAwO1xuICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogXCJwYWRkaW5nLWJvdHRvbTogMTAwMHB4XCIgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB1cGRhdGU7XG4gICAgICAgIGxldCBoZWlnaHQgPSB2aWV3LnZpZXdTdGF0ZS5lZGl0b3JIZWlnaHQgLSB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC0gdmlldy5kb2N1bWVudFBhZGRpbmcudG9wIC0gMC41O1xuICAgICAgICBpZiAoaGVpZ2h0ICE9IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSB7IHN0eWxlOiBgcGFkZGluZy1ib3R0b206ICR7aGVpZ2h0fXB4YCB9O1xuICAgICAgICB9XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgbWFrZXMgc3VyZSB0aGUgY29udGVudCBoYXMgYSBib3R0b21cbm1hcmdpbiBlcXVpdmFsZW50IHRvIHRoZSBoZWlnaHQgb2YgdGhlIGVkaXRvciwgbWludXMgb25lIGxpbmVcbmhlaWdodCwgc28gdGhhdCBldmVyeSBsaW5lIGluIHRoZSBkb2N1bWVudCBjYW4gYmUgc2Nyb2xsZWQgdG8gdGhlXG50b3Agb2YgdGhlIGVkaXRvci5cblxuVGhpcyBpcyBvbmx5IG1lYW5pbmdmdWwgd2hlbiB0aGUgZWRpdG9yIGlzIHNjcm9sbGFibGUsIGFuZCBzaG91bGRcbm5vdCBiZSBlbmFibGVkIGluIGVkaXRvcnMgdGhhdCB0YWtlIHRoZSBzaXplIG9mIHRoZWlyIGNvbnRlbnQuXG4qL1xuZnVuY3Rpb24gc2Nyb2xsUGFzdEVuZCgpIHtcbiAgICByZXR1cm4gW3BsdWdpbiwgY29udGVudEF0dHJpYnV0ZXMub2YodmlldyA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0cnMpIHx8IG51bGw7IH0pXTtcbn1cblxuLyoqXG5NYXJrIGxpbmVzIHRoYXQgaGF2ZSBhIGN1cnNvciBvbiB0aGVtIHdpdGggdGhlIGBcImNtLWFjdGl2ZUxpbmVcImBcbkRPTSBjbGFzcy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRBY3RpdmVMaW5lKCkge1xuICAgIHJldHVybiBhY3RpdmVMaW5lSGlnaGxpZ2h0ZXI7XG59XG5jb25zdCBsaW5lRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLmxpbmUoeyBjbGFzczogXCJjbS1hY3RpdmVMaW5lXCIgfSk7XG5jb25zdCBhY3RpdmVMaW5lSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldClcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odXBkYXRlLnZpZXcpO1xuICAgIH1cbiAgICBnZXREZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGxhc3RMaW5lU3RhcnQgPSAtMSwgZGVjbyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHIuaGVhZCk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID4gbGFzdExpbmVTdGFydCkge1xuICAgICAgICAgICAgICAgIGRlY28ucHVzaChsaW5lRGVjby5yYW5nZShsaW5lLmZyb20pKTtcbiAgICAgICAgICAgICAgICBsYXN0TGluZVN0YXJ0ID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5cbmNsYXNzIFBsYWNlaG9sZGVyIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoY29udGVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgd3JhcC5jbGFzc05hbWUgPSBcImNtLXBsYWNlaG9sZGVyXCI7XG4gICAgICAgIHdyYXAuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICB3cmFwLmFwcGVuZENoaWxkKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuY29udGVudCkgOiB0aGlzLmNvbnRlbnQpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29udGVudCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgd3JhcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwicGxhY2Vob2xkZXIgXCIgKyB0aGlzLmNvbnRlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cmFwLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgcmV0dXJuIHdyYXA7XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8qKlxuRXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBhIHBsYWNlaG9sZGVyXHUyMDE0YSBwaWVjZSBvZiBleGFtcGxlIGNvbnRlbnRcbnRvIHNob3cgd2hlbiB0aGUgZWRpdG9yIGlzIGVtcHR5LlxuKi9cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKGNvbnRlbnQpIHtcbiAgICByZXR1cm4gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IERlY29yYXRpb24uc2V0KFtEZWNvcmF0aW9uLndpZGdldCh7IHdpZGdldDogbmV3IFBsYWNlaG9sZGVyKGNvbnRlbnQpLCBzaWRlOiAxIH0pLnJhbmdlKDApXSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGRlY29yYXRpb25zKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGggPyBEZWNvcmF0aW9uLm5vbmUgOiB0aGlzLnBsYWNlaG9sZGVyOyB9XG4gICAgfSwgeyBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zIH0pO1xufVxuXG4vLyBEb24ndCBjb21wdXRlIHByZWNpc2UgY29sdW1uIHBvc2l0aW9ucyBmb3IgbGluZSBvZmZzZXRzIGFib3ZlIHRoaXNcbi8vIChzaW5jZSBpdCBjb3VsZCBnZXQgZXhwZW5zaXZlKS4gQXNzdW1lIG9mZnNldD09Y29sdW1uIGZvciB0aGVtLlxuY29uc3QgTWF4T2ZmID0gMjAwMDtcbmZ1bmN0aW9uIHJlY3RhbmdsZUZvcihzdGF0ZSwgYSwgYikge1xuICAgIGxldCBzdGFydExpbmUgPSBNYXRoLm1pbihhLmxpbmUsIGIubGluZSksIGVuZExpbmUgPSBNYXRoLm1heChhLmxpbmUsIGIubGluZSk7XG4gICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgIGlmIChhLm9mZiA+IE1heE9mZiB8fCBiLm9mZiA+IE1heE9mZiB8fCBhLmNvbCA8IDAgfHwgYi5jb2wgPCAwKSB7XG4gICAgICAgIGxldCBzdGFydE9mZiA9IE1hdGgubWluKGEub2ZmLCBiLm9mZiksIGVuZE9mZiA9IE1hdGgubWF4KGEub2ZmLCBiLm9mZik7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmU7IGkgPD0gZW5kTGluZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lKGkpO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDw9IGVuZE9mZilcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2UobGluZS5mcm9tICsgc3RhcnRPZmYsIGxpbmUudG8gKyBlbmRPZmYpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHN0YXJ0Q29sID0gTWF0aC5taW4oYS5jb2wsIGIuY29sKSwgZW5kQ29sID0gTWF0aC5tYXgoYS5jb2wsIGIuY29sKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmUoaSk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBmaW5kQ29sdW1uKGxpbmUudGV4dCwgc3RhcnRDb2wsIHN0YXRlLnRhYlNpemUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobGluZS50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGZpbmRDb2x1bW4obGluZS50ZXh0LCBlbmRDb2wsIHN0YXRlLnRhYlNpemUpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShsaW5lLmZyb20gKyBzdGFydCwgbGluZS5mcm9tICsgZW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbmZ1bmN0aW9uIGFic29sdXRlQ29sdW1uKHZpZXcsIHgpIHtcbiAgICBsZXQgcmVmID0gdmlldy5jb29yZHNBdFBvcyh2aWV3LnZpZXdwb3J0LmZyb20pO1xuICAgIHJldHVybiByZWYgPyBNYXRoLnJvdW5kKE1hdGguYWJzKChyZWYubGVmdCAtIHgpIC8gdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpKSA6IC0xO1xufVxuZnVuY3Rpb24gZ2V0UG9zKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IG9mZnNldCA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIGZhbHNlKTtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChvZmZzZXQpLCBvZmYgPSBvZmZzZXQgLSBsaW5lLmZyb207XG4gICAgbGV0IGNvbCA9IG9mZiA+IE1heE9mZiA/IC0xXG4gICAgICAgIDogb2ZmID09IGxpbmUubGVuZ3RoID8gYWJzb2x1dGVDb2x1bW4odmlldywgZXZlbnQuY2xpZW50WClcbiAgICAgICAgICAgIDogY291bnRDb2x1bW4obGluZS50ZXh0LCB2aWV3LnN0YXRlLnRhYlNpemUsIG9mZnNldCAtIGxpbmUuZnJvbSk7XG4gICAgcmV0dXJuIHsgbGluZTogbGluZS5udW1iZXIsIGNvbCwgb2ZmIH07XG59XG5mdW5jdGlvbiByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkge1xuICAgIGxldCBzdGFydCA9IGdldFBvcyh2aWV3LCBldmVudCksIHN0YXJ0U2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCFzdGFydClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1N0YXJ0ID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5saW5lKHN0YXJ0LmxpbmUpLmZyb20pO1xuICAgICAgICAgICAgICAgIGxldCBuZXdMaW5lID0gdXBkYXRlLnN0YXRlLmRvYy5saW5lQXQobmV3U3RhcnQpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0geyBsaW5lOiBuZXdMaW5lLm51bWJlciwgY29sOiBzdGFydC5jb2wsIG9mZjogTWF0aC5taW4oc3RhcnQub2ZmLCBuZXdMaW5lLmxlbmd0aCkgfTtcbiAgICAgICAgICAgICAgICBzdGFydFNlbCA9IHN0YXJ0U2VsLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldChldmVudCwgX2V4dGVuZCwgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSBnZXRQb3ModmlldywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFjdXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsO1xuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHJlY3RhbmdsZUZvcih2aWV3LnN0YXRlLCBzdGFydCwgY3VyKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWw7XG4gICAgICAgICAgICBpZiAobXVsdGlwbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLmNvbmNhdChzdGFydFNlbC5yYW5nZXMpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgcmVjdGFuZ3VsYXIgc2VsZWN0aW9ucy4gQnlcbmRlZmF1bHQsIGl0IHdpbGwgcmVhY3QgdG8gbGVmdCBtb3VzZSBkcmFnIHdpdGggdGhlIEFsdCBrZXkgaGVsZFxuZG93bi4gV2hlbiBzdWNoIGEgc2VsZWN0aW9uIG9jY3VycywgdGhlIHRleHQgd2l0aGluIHRoZSByZWN0YW5nbGVcbnRoYXQgd2FzIGRyYWdnZWQgb3ZlciB3aWxsIGJlIHNlbGVjdGVkLCBhcyBvbmUgc2VsZWN0aW9uXG5bcmFuZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UpIHBlciBsaW5lLlxuKi9cbmZ1bmN0aW9uIHJlY3Rhbmd1bGFyU2VsZWN0aW9uKG9wdGlvbnMpIHtcbiAgICBsZXQgZmlsdGVyID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ldmVudEZpbHRlcikgfHwgKGUgPT4gZS5hbHRLZXkgJiYgZS5idXR0b24gPT0gMCk7XG4gICAgcmV0dXJuIEVkaXRvclZpZXcubW91c2VTZWxlY3Rpb25TdHlsZS5vZigodmlldywgZXZlbnQpID0+IGZpbHRlcihldmVudCkgPyByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkgOiBudWxsKTtcbn1cbmNvbnN0IGtleXMgPSB7XG4gICAgQWx0OiBbMTgsIGUgPT4gZS5hbHRLZXldLFxuICAgIENvbnRyb2w6IFsxNywgZSA9PiBlLmN0cmxLZXldLFxuICAgIFNoaWZ0OiBbMTYsIGUgPT4gZS5zaGlmdEtleV0sXG4gICAgTWV0YTogWzkxLCBlID0+IGUubWV0YUtleV1cbn07XG5jb25zdCBzaG93Q3Jvc3NoYWlyID0geyBzdHlsZTogXCJjdXJzb3I6IGNyb3NzaGFpclwiIH07XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgdHVybnMgdGhlIHBvaW50ZXIgY3Vyc29yIGludG8gYVxuY3Jvc3NoYWlyIHdoZW4gYSBnaXZlbiBtb2RpZmllciBrZXksIGRlZmF1bHRpbmcgdG8gQWx0LCBpcyBoZWxkXG5kb3duLiBDYW4gc2VydmUgYXMgYSB2aXN1YWwgaGludCB0aGF0IHJlY3Rhbmd1bGFyIHNlbGVjdGlvbiBpc1xuZ29pbmcgdG8gaGFwcGVuIHdoZW4gcGFpcmVkIHdpdGhcbltgcmVjdGFuZ3VsYXJTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcucmVjdGFuZ3VsYXJTZWxlY3Rpb24pLlxuKi9cbmZ1bmN0aW9uIGNyb3NzaGFpckN1cnNvcihvcHRpb25zID0ge30pIHtcbiAgICBsZXQgW2NvZGUsIGdldHRlcl0gPSBrZXlzW29wdGlvbnMua2V5IHx8IFwiQWx0XCJdO1xuICAgIGxldCBwbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLmlzRG93biA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNldChpc0Rvd24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRG93biAhPSBpc0Rvd24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRG93biA9IGlzRG93bjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZXZlbnRIYW5kbGVyczoge1xuICAgICAgICAgICAga2V5ZG93bihlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoZS5rZXlDb2RlID09IGNvZGUgfHwgZ2V0dGVyKGUpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXl1cChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSBjb2RlIHx8ICFnZXR0ZXIoZSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3VzZW1vdmUoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGdldHRlcihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBwbHVnaW4sXG4gICAgICAgIEVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMub2YodmlldyA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNEb3duKSA/IHNob3dDcm9zc2hhaXIgOiBudWxsOyB9KVxuICAgIF07XG59XG5cbmNvbnN0IE91dHNpZGUgPSBcIi0xMDAwMHB4XCI7XG5jbGFzcyBUb29sdGlwVmlld01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGZhY2V0LCBjcmVhdGVUb29sdGlwVmlldykge1xuICAgICAgICB0aGlzLmZhY2V0ID0gZmFjZXQ7XG4gICAgICAgIHRoaXMuY3JlYXRlVG9vbHRpcFZpZXcgPSBjcmVhdGVUb29sdGlwVmlldztcbiAgICAgICAgdGhpcy5pbnB1dCA9IHZpZXcuc3RhdGUuZmFjZXQoZmFjZXQpO1xuICAgICAgICB0aGlzLnRvb2x0aXBzID0gdGhpcy5pbnB1dC5maWx0ZXIodCA9PiB0KTtcbiAgICAgICAgdGhpcy50b29sdGlwVmlld3MgPSB0aGlzLnRvb2x0aXBzLm1hcChjcmVhdGVUb29sdGlwVmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgaW5wdXQgPSB1cGRhdGUuc3RhdGUuZmFjZXQodGhpcy5mYWNldCk7XG4gICAgICAgIGxldCB0b29sdGlwcyA9IGlucHV0LmZpbHRlcih4ID0+IHgpO1xuICAgICAgICBpZiAoaW5wdXQgPT09IHRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgaWYgKHQudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICB0LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b29sdGlwVmlld3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b29sdGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRpcCA9IHRvb2x0aXBzW2ldLCBrbm93biA9IC0xO1xuICAgICAgICAgICAgaWYgKCF0aXApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSB0aGlzLnRvb2x0aXBzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvdGhlciAmJiBvdGhlci5jcmVhdGUgPT0gdGlwLmNyZWF0ZSlcbiAgICAgICAgICAgICAgICAgICAga25vd24gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBWaWV3c1tpXSA9IHRoaXMuY3JlYXRlVG9vbHRpcFZpZXcodGlwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0b29sdGlwVmlldyA9IHRvb2x0aXBWaWV3c1tpXSA9IHRoaXMudG9vbHRpcFZpZXdzW2tub3duXTtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcFZpZXcudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgaWYgKHRvb2x0aXBWaWV3cy5pbmRleE9mKHQpIDwgMCkge1xuICAgICAgICAgICAgICAgIHQuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIChfYSA9IHQuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy50b29sdGlwcyA9IHRvb2x0aXBzO1xuICAgICAgICB0aGlzLnRvb2x0aXBWaWV3cyA9IHRvb2x0aXBWaWV3cztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLyoqXG5DcmVhdGVzIGFuIGV4dGVuc2lvbiB0aGF0IGNvbmZpZ3VyZXMgdG9vbHRpcCBiZWhhdmlvci5cbiovXG5mdW5jdGlvbiB0b29sdGlwcyhjb25maWcgPSB7fSkge1xuICAgIHJldHVybiB0b29sdGlwQ29uZmlnLm9mKGNvbmZpZyk7XG59XG5mdW5jdGlvbiB3aW5kb3dTcGFjZSh2aWV3KSB7XG4gICAgbGV0IHsgd2luIH0gPSB2aWV3O1xuICAgIHJldHVybiB7IHRvcDogMCwgbGVmdDogMCwgYm90dG9tOiB3aW4uaW5uZXJIZWlnaHQsIHJpZ2h0OiB3aW4uaW5uZXJXaWR0aCB9O1xufVxuY29uc3QgdG9vbHRpcENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBicm93c2VyLmlvcyA/IFwiYWJzb2x1dGVcIiA6ICgoX2EgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYucG9zaXRpb24pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9zaXRpb24pIHx8IFwiZml4ZWRcIixcbiAgICAgICAgICAgIHBhcmVudDogKChfYiA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi5wYXJlbnQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGFyZW50KSB8fCBudWxsLFxuICAgICAgICAgICAgdG9vbHRpcFNwYWNlOiAoKF9jID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnRvb2x0aXBTcGFjZSkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b29sdGlwU3BhY2UpIHx8IHdpbmRvd1NwYWNlLFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmNvbnN0IGtub3duSGVpZ2h0ID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG5jb25zdCB0b29sdGlwUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuaW5WaWV3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb24gPSAwO1xuICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gLTE7XG4gICAgICAgIGxldCBjb25maWcgPSB2aWV3LnN0YXRlLmZhY2V0KHRvb2x0aXBDb25maWcpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gY29uZmlnLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLnBhcmVudCA9IGNvbmZpZy5wYXJlbnQ7XG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IHZpZXcudGhlbWVDbGFzc2VzO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZE1lYXN1cmUuYmluZCh0aGlzKSwgd3JpdGU6IHRoaXMud3JpdGVNZWFzdXJlLmJpbmQodGhpcyksIGtleTogdGhpcyB9O1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBuZXcgVG9vbHRpcFZpZXdNYW5hZ2VyKHZpZXcsIHNob3dUb29sdGlwLCB0ID0+IHRoaXMuY3JlYXRlVG9vbHRpcCh0KSk7XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiID8gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgaWYgKERhdGUubm93KCkgPiB0aGlzLmxhc3RUcmFuc2FjdGlvbiAtIDUwICYmXG4gICAgICAgICAgICAgICAgZW50cmllcy5sZW5ndGggPiAwICYmIGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXS5pbnRlcnNlY3Rpb25SYXRpbyA8IDEpXG4gICAgICAgICAgICAgICAgdGhpcy5tZWFzdXJlU29vbigpO1xuICAgICAgICB9LCB7IHRocmVzaG9sZDogWzFdIH0pIDogbnVsbDtcbiAgICAgICAgdGhpcy5vYnNlcnZlSW50ZXJzZWN0aW9uKCk7XG4gICAgICAgIHZpZXcud2luLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5tZWFzdXJlU29vbiA9IHRoaXMubWVhc3VyZVNvb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgfVxuICAgIGNyZWF0ZUNvbnRhaW5lcigpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMudmlldy50aGVtZUNsYXNzZXM7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMudmlldy5kb207XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2JzZXJ2ZUludGVyc2VjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgdG9vbHRpcCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0b29sdGlwLmRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZVNvb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbiA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCB1cGRhdGVkID0gdGhpcy5tYW5hZ2VyLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICBpZiAodXBkYXRlZClcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUludGVyc2VjdGlvbigpO1xuICAgICAgICBsZXQgc2hvdWxkTWVhc3VyZSA9IHVwZGF0ZWQgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZDtcbiAgICAgICAgbGV0IG5ld0NvbmZpZyA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKTtcbiAgICAgICAgaWYgKG5ld0NvbmZpZy5wb3NpdGlvbiAhPSB0aGlzLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gbmV3Q29uZmlnLnBvc2l0aW9uO1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHQuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgICAgIHNob3VsZE1lYXN1cmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdDb25maWcucGFyZW50ICE9IHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IG5ld0NvbmZpZy5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUNvbnRhaW5lcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHQuZG9tKTtcbiAgICAgICAgICAgIHNob3VsZE1lYXN1cmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMudmlldy50aGVtZUNsYXNzZXMgIT0gdGhpcy5jbGFzc2VzKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzZXMgPSB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRNZWFzdXJlKVxuICAgICAgICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcbiAgICB9XG4gICAgY3JlYXRlVG9vbHRpcCh0b29sdGlwKSB7XG4gICAgICAgIGxldCB0b29sdGlwVmlldyA9IHRvb2x0aXAuY3JlYXRlKHRoaXMudmlldyk7XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcFwiKTtcbiAgICAgICAgaWYgKHRvb2x0aXAuYXJyb3cgJiYgIXRvb2x0aXBWaWV3LmRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLXRvb2x0aXAgPiAuY20tdG9vbHRpcC1hcnJvd1wiKSkge1xuICAgICAgICAgICAgbGV0IGFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGFycm93LmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcC1hcnJvd1wiO1xuICAgICAgICAgICAgdG9vbHRpcFZpZXcuZG9tLmFwcGVuZENoaWxkKGFycm93KTtcbiAgICAgICAgfVxuICAgICAgICB0b29sdGlwVmlldy5kb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0b29sdGlwVmlldy5kb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodG9vbHRpcFZpZXcuZG9tKTtcbiAgICAgICAgaWYgKHRvb2x0aXBWaWV3Lm1vdW50KVxuICAgICAgICAgICAgdG9vbHRpcFZpZXcubW91bnQodGhpcy52aWV3KTtcbiAgICAgICAgcmV0dXJuIHRvb2x0aXBWaWV3O1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLnZpZXcud2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5tZWFzdXJlU29vbik7XG4gICAgICAgIGZvciAobGV0IHRvb2x0aXBWaWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3LmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgIChfYSA9IHRvb2x0aXBWaWV3LmRlc3Ryb3kpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRvb2x0aXBWaWV3KTtcbiAgICAgICAgfVxuICAgICAgICAoX2IgPSB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tZWFzdXJlVGltZW91dCk7XG4gICAgfVxuICAgIHJlYWRNZWFzdXJlKCkge1xuICAgICAgICBsZXQgZWRpdG9yID0gdGhpcy52aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQgPyB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IGVkaXRvcixcbiAgICAgICAgICAgIHBvczogdGhpcy5tYW5hZ2VyLnRvb2x0aXBzLm1hcCgodCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0diA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3NbaV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR2LmdldENvb3JkcyA/IHR2LmdldENvb3Jkcyh0LnBvcykgOiB0aGlzLnZpZXcuY29vcmRzQXRQb3ModC5wb3MpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzaXplOiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzLm1hcCgoeyBkb20gfSkgPT4gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSxcbiAgICAgICAgICAgIHNwYWNlOiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQodG9vbHRpcENvbmZpZykudG9vbHRpcFNwYWNlKHRoaXMudmlldyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHdyaXRlTWVhc3VyZShtZWFzdXJlZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCB7IGVkaXRvciwgc3BhY2UgfSA9IG1lYXN1cmVkO1xuICAgICAgICBsZXQgb3RoZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYW5hZ2VyLnRvb2x0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdG9vbHRpcCA9IHRoaXMubWFuYWdlci50b29sdGlwc1tpXSwgdFZpZXcgPSB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzW2ldLCB7IGRvbSB9ID0gdFZpZXc7XG4gICAgICAgICAgICBsZXQgcG9zID0gbWVhc3VyZWQucG9zW2ldLCBzaXplID0gbWVhc3VyZWQuc2l6ZVtpXTtcbiAgICAgICAgICAgIC8vIEhpZGUgdG9vbHRpcHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgZWRpdG9yLlxuICAgICAgICAgICAgaWYgKCFwb3MgfHwgcG9zLmJvdHRvbSA8PSBNYXRoLm1heChlZGl0b3IudG9wLCBzcGFjZS50b3ApIHx8XG4gICAgICAgICAgICAgICAgcG9zLnRvcCA+PSBNYXRoLm1pbihlZGl0b3IuYm90dG9tLCBzcGFjZS5ib3R0b20pIHx8XG4gICAgICAgICAgICAgICAgcG9zLnJpZ2h0IDwgTWF0aC5tYXgoZWRpdG9yLmxlZnQsIHNwYWNlLmxlZnQpIC0gLjEgfHxcbiAgICAgICAgICAgICAgICBwb3MubGVmdCA+IE1hdGgubWluKGVkaXRvci5yaWdodCwgc3BhY2UucmlnaHQpICsgLjEpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhcnJvdyA9IHRvb2x0aXAuYXJyb3cgPyB0Vmlldy5kb20ucXVlcnlTZWxlY3RvcihcIi5jbS10b29sdGlwLWFycm93XCIpIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBhcnJvd0hlaWdodCA9IGFycm93ID8gNyAvKiBBcnJvdy5TaXplICovIDogMDtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHNpemUucmlnaHQgLSBzaXplLmxlZnQsIGhlaWdodCA9IChfYSA9IGtub3duSGVpZ2h0LmdldCh0VmlldykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNpemUuYm90dG9tIC0gc2l6ZS50b3A7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gdFZpZXcub2Zmc2V0IHx8IG5vT2Zmc2V0LCBsdHIgPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSO1xuICAgICAgICAgICAgbGV0IGxlZnQgPSBzaXplLndpZHRoID4gc3BhY2UucmlnaHQgLSBzcGFjZS5sZWZ0ID8gKGx0ciA/IHNwYWNlLmxlZnQgOiBzcGFjZS5yaWdodCAtIHNpemUud2lkdGgpXG4gICAgICAgICAgICAgICAgOiBsdHIgPyBNYXRoLm1pbihwb3MubGVmdCAtIChhcnJvdyA/IDE0IC8qIEFycm93Lk9mZnNldCAqLyA6IDApICsgb2Zmc2V0LngsIHNwYWNlLnJpZ2h0IC0gd2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIDogTWF0aC5tYXgoc3BhY2UubGVmdCwgcG9zLmxlZnQgLSB3aWR0aCArIChhcnJvdyA/IDE0IC8qIEFycm93Lk9mZnNldCAqLyA6IDApIC0gb2Zmc2V0LngpO1xuICAgICAgICAgICAgbGV0IGFib3ZlID0gISF0b29sdGlwLmFib3ZlO1xuICAgICAgICAgICAgaWYgKCF0b29sdGlwLnN0cmljdFNpZGUgJiYgKGFib3ZlXG4gICAgICAgICAgICAgICAgPyBwb3MudG9wIC0gKHNpemUuYm90dG9tIC0gc2l6ZS50b3ApIC0gb2Zmc2V0LnkgPCBzcGFjZS50b3BcbiAgICAgICAgICAgICAgICA6IHBvcy5ib3R0b20gKyAoc2l6ZS5ib3R0b20gLSBzaXplLnRvcCkgKyBvZmZzZXQueSA+IHNwYWNlLmJvdHRvbSkgJiZcbiAgICAgICAgICAgICAgICBhYm92ZSA9PSAoc3BhY2UuYm90dG9tIC0gcG9zLmJvdHRvbSA+IHBvcy50b3AgLSBzcGFjZS50b3ApKVxuICAgICAgICAgICAgICAgIGFib3ZlID0gIWFib3ZlO1xuICAgICAgICAgICAgbGV0IHNwYWNlVmVydCA9IChhYm92ZSA/IHBvcy50b3AgLSBzcGFjZS50b3AgOiBzcGFjZS5ib3R0b20gLSBwb3MuYm90dG9tKSAtIGFycm93SGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHNwYWNlVmVydCA8IGhlaWdodCAmJiB0Vmlldy5yZXNpemUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlVmVydCA8IHRoaXMudmlldy5kZWZhdWx0TGluZUhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtub3duSGVpZ2h0LnNldCh0VmlldywgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUuaGVpZ2h0ID0gKGhlaWdodCA9IHNwYWNlVmVydCkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb20uc3R5bGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLmhlaWdodCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG9wID0gYWJvdmUgPyBwb3MudG9wIC0gaGVpZ2h0IC0gYXJyb3dIZWlnaHQgLSBvZmZzZXQueSA6IHBvcy5ib3R0b20gKyBhcnJvd0hlaWdodCArIG9mZnNldC55O1xuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgICAgICAgICAgaWYgKHRWaWV3Lm92ZXJsYXAgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBvdGhlcnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmxlZnQgPCByaWdodCAmJiByLnJpZ2h0ID4gbGVmdCAmJiByLnRvcCA8IHRvcCArIGhlaWdodCAmJiByLmJvdHRvbSA+IHRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IGFib3ZlID8gci50b3AgLSBoZWlnaHQgLSAyIC0gYXJyb3dIZWlnaHQgOiByLmJvdHRvbSArIGFycm93SGVpZ2h0ICsgMjtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09IFwiYWJzb2x1dGVcIikge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSAodG9wIC0gbWVhc3VyZWQucGFyZW50LnRvcCkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLmxlZnQgPSAobGVmdCAtIG1lYXN1cmVkLnBhcmVudC5sZWZ0KSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFycm93KVxuICAgICAgICAgICAgICAgIGFycm93LnN0eWxlLmxlZnQgPSBgJHtwb3MubGVmdCArIChsdHIgPyBvZmZzZXQueCA6IC1vZmZzZXQueCkgLSAobGVmdCArIDE0IC8qIEFycm93Lk9mZnNldCAqLyAtIDcgLyogQXJyb3cuU2l6ZSAqLyl9cHhgO1xuICAgICAgICAgICAgaWYgKHRWaWV3Lm92ZXJsYXAgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgb3RoZXJzLnB1c2goeyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b206IHRvcCArIGhlaWdodCB9KTtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QudG9nZ2xlKFwiY20tdG9vbHRpcC1hYm92ZVwiLCBhYm92ZSk7XG4gICAgICAgICAgICBkb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYmVsb3dcIiwgIWFib3ZlKTtcbiAgICAgICAgICAgIGlmICh0Vmlldy5wb3NpdGlvbmVkKVxuICAgICAgICAgICAgICAgIHRWaWV3LnBvc2l0aW9uZWQobWVhc3VyZWQuc3BhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1heWJlTWVhc3VyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFuYWdlci50b29sdGlwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaW5WaWV3KVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5WaWV3ICE9IHRoaXMudmlldy5pblZpZXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluVmlldyA9IHRoaXMudmlldy5pblZpZXc7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluVmlldylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdHYgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICAgICAgICAgIHR2LmRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIGV2ZW50SGFuZGxlcnM6IHtcbiAgICAgICAgc2Nyb2xsKCkgeyB0aGlzLm1heWJlTWVhc3VyZSgpOyB9XG4gICAgfVxufSk7XG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICB6SW5kZXg6IDEwMCxcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICNiYmJcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXAtc2VjdGlvbjpub3QoOmZpcnN0LWNoaWxkKVwiOiB7XG4gICAgICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgI2JiYlwiLFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAtYXJyb3dcIjoge1xuICAgICAgICBoZWlnaHQ6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weGAsXG4gICAgICAgIHdpZHRoOiBgJHs3IC8qIEFycm93LlNpemUgKi8gKiAyfXB4YCxcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgekluZGV4OiAtMSxcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgIFwiJjpiZWZvcmUsICY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgY29udGVudDogXCInJ1wiLFxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgYm9yZGVyTGVmdDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcbiAgICAgICAgICAgIGJvcmRlclJpZ2h0OiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgdHJhbnNwYXJlbnRgLFxuICAgICAgICB9LFxuICAgICAgICBcIi5jbS10b29sdGlwLWFib3ZlICZcIjoge1xuICAgICAgICAgICAgYm90dG9tOiBgLSR7NyAvKiBBcnJvdy5TaXplICovfXB4YCxcbiAgICAgICAgICAgIFwiJjpiZWZvcmVcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlclRvcDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNiYmJgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyVG9wOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2Y1ZjVmNWAsXG4gICAgICAgICAgICAgICAgYm90dG9tOiBcIjFweFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiLmNtLXRvb2x0aXAtYmVsb3cgJlwiOiB7XG4gICAgICAgICAgICB0b3A6IGAtJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxuICAgICAgICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2JiYmAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjZjVmNWY1YCxcbiAgICAgICAgICAgICAgICB0b3A6IFwiMXB4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAgLmNtLXRvb2x0aXAtYXJyb3dcIjoge1xuICAgICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgICAgIGJvcmRlclRvcENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBcIiMzMzMzMzhcIlxuICAgICAgICB9LFxuICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgYm9yZGVyVG9wQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBcInRyYW5zcGFyZW50XCJcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuY29uc3Qgbm9PZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbi8qKlxuRmFjZXQgdG8gd2hpY2ggYW4gZXh0ZW5zaW9uIGNhbiBhZGQgYSB2YWx1ZSB0byBzaG93IGEgdG9vbHRpcC5cbiovXG5jb25zdCBzaG93VG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGVuYWJsZXM6IFt0b29sdGlwUGx1Z2luLCBiYXNlVGhlbWVdXG59KTtcbmNvbnN0IHNob3dIb3ZlclRvb2x0aXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jbGFzcyBIb3ZlclRvb2x0aXBIb3N0IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwLWhvdmVyXCIpO1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBuZXcgVG9vbHRpcFZpZXdNYW5hZ2VyKHZpZXcsIHNob3dIb3ZlclRvb2x0aXAsIHQgPT4gdGhpcy5jcmVhdGVIb3N0ZWRWaWV3KHQpKTtcbiAgICB9XG4gICAgLy8gTmVlZHMgdG8gYmUgc3RhdGljIHNvIHRoYXQgaG9zdCB0b29sdGlwIGluc3RhbmNlcyBhbHdheXMgbWF0Y2hcbiAgICBzdGF0aWMgY3JlYXRlKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIb3ZlclRvb2x0aXBIb3N0KHZpZXcpO1xuICAgIH1cbiAgICBjcmVhdGVIb3N0ZWRWaWV3KHRvb2x0aXApIHtcbiAgICAgICAgbGV0IGhvc3RlZFZpZXcgPSB0b29sdGlwLmNyZWF0ZSh0aGlzLnZpZXcpO1xuICAgICAgICBob3N0ZWRWaWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcC1zZWN0aW9uXCIpO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChob3N0ZWRWaWV3LmRvbSk7XG4gICAgICAgIGlmICh0aGlzLm1vdW50ZWQgJiYgaG9zdGVkVmlldy5tb3VudClcbiAgICAgICAgICAgIGhvc3RlZFZpZXcubW91bnQodGhpcy52aWV3KTtcbiAgICAgICAgcmV0dXJuIGhvc3RlZFZpZXc7XG4gICAgfVxuICAgIG1vdW50KHZpZXcpIHtcbiAgICAgICAgZm9yIChsZXQgaG9zdGVkVmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICBpZiAoaG9zdGVkVmlldy5tb3VudClcbiAgICAgICAgICAgICAgICBob3N0ZWRWaWV3Lm1vdW50KHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHBvc2l0aW9uZWQoc3BhY2UpIHtcbiAgICAgICAgZm9yIChsZXQgaG9zdGVkVmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICBpZiAoaG9zdGVkVmlldy5wb3NpdGlvbmVkKVxuICAgICAgICAgICAgICAgIGhvc3RlZFZpZXcucG9zaXRpb25lZChzcGFjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB0aGlzLm1hbmFnZXIudXBkYXRlKHVwZGF0ZSk7XG4gICAgfVxufVxuY29uc3Qgc2hvd0hvdmVyVG9vbHRpcEhvc3QgPSAvKkBfX1BVUkVfXyovc2hvd1Rvb2x0aXAuY29tcHV0ZShbc2hvd0hvdmVyVG9vbHRpcF0sIHN0YXRlID0+IHtcbiAgICBsZXQgdG9vbHRpcHMgPSBzdGF0ZS5mYWNldChzaG93SG92ZXJUb29sdGlwKS5maWx0ZXIodCA9PiB0KTtcbiAgICBpZiAodG9vbHRpcHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IE1hdGgubWluKC4uLnRvb2x0aXBzLm1hcCh0ID0+IHQucG9zKSksXG4gICAgICAgIGVuZDogTWF0aC5tYXgoLi4udG9vbHRpcHMuZmlsdGVyKHQgPT4gdC5lbmQgIT0gbnVsbCkubWFwKHQgPT4gdC5lbmQpKSxcbiAgICAgICAgY3JlYXRlOiBIb3ZlclRvb2x0aXBIb3N0LmNyZWF0ZSxcbiAgICAgICAgYWJvdmU6IHRvb2x0aXBzWzBdLmFib3ZlLFxuICAgICAgICBhcnJvdzogdG9vbHRpcHMuc29tZSh0ID0+IHQuYXJyb3cpLFxuICAgIH07XG59KTtcbmNsYXNzIEhvdmVyUGx1Z2luIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzb3VyY2UsIGZpZWxkLCBzZXRIb3ZlciwgaG92ZXJUaW1lKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMuc2V0SG92ZXIgPSBzZXRIb3ZlcjtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWUgPSBob3ZlclRpbWU7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucmVzdGFydFRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0TW92ZSA9IHsgeDogMCwgeTogMCwgdGFyZ2V0OiB2aWV3LmRvbSwgdGltZTogMCB9O1xuICAgICAgICB0aGlzLmNoZWNrSG92ZXIgPSB0aGlzLmNoZWNrSG92ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5tb3VzZWxlYXZlID0gdGhpcy5tb3VzZWxlYXZlLmJpbmQodGhpcykpO1xuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW91c2Vtb3ZlID0gdGhpcy5tb3VzZW1vdmUuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMucmVzdGFydFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RhcnRIb3ZlcigpLCAyMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLmZpZWxkKTtcbiAgICB9XG4gICAgY2hlY2tIb3ZlcigpIHtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgaG92ZXJlZCA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RNb3ZlLnRpbWU7XG4gICAgICAgIGlmIChob3ZlcmVkIDwgdGhpcy5ob3ZlclRpbWUpXG4gICAgICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5jaGVja0hvdmVyLCB0aGlzLmhvdmVyVGltZSAtIGhvdmVyZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnN0YXJ0SG92ZXIoKTtcbiAgICB9XG4gICAgc3RhcnRIb3ZlcigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzdGFydFRpbWVvdXQpO1xuICAgICAgICBsZXQgeyBsYXN0TW92ZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMudmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGxhc3RNb3ZlLnRhcmdldCkgPyB0aGlzLnZpZXcucG9zQXRDb29yZHMobGFzdE1vdmUpIDogbnVsbDtcbiAgICAgICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zQ29vcmRzID0gdGhpcy52aWV3LmNvb3Jkc0F0UG9zKHBvcyk7XG4gICAgICAgIGlmIChwb3NDb29yZHMgPT0gbnVsbCB8fCBsYXN0TW92ZS55IDwgcG9zQ29vcmRzLnRvcCB8fCBsYXN0TW92ZS55ID4gcG9zQ29vcmRzLmJvdHRvbSB8fFxuICAgICAgICAgICAgbGFzdE1vdmUueCA8IHBvc0Nvb3Jkcy5sZWZ0IC0gdGhpcy52aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCB8fFxuICAgICAgICAgICAgbGFzdE1vdmUueCA+IHBvc0Nvb3Jkcy5yaWdodCArIHRoaXMudmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBiaWRpID0gdGhpcy52aWV3LmJpZGlTcGFucyh0aGlzLnZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpKS5maW5kKHMgPT4gcy5mcm9tIDw9IHBvcyAmJiBzLnRvID49IHBvcyk7XG4gICAgICAgIGxldCBydGwgPSBiaWRpICYmIGJpZGkuZGlyID09IERpcmVjdGlvbi5SVEwgPyAtMSA6IDE7XG4gICAgICAgIGxldCBvcGVuID0gdGhpcy5zb3VyY2UodGhpcy52aWV3LCBwb3MsIChsYXN0TW92ZS54IDwgcG9zQ29vcmRzLmxlZnQgPyAtcnRsIDogcnRsKSk7XG4gICAgICAgIGlmIChvcGVuID09PSBudWxsIHx8IG9wZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wZW4udGhlbikge1xuICAgICAgICAgICAgbGV0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmcgPSB7IHBvcyB9O1xuICAgICAgICAgICAgb3Blbi50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZyA9PSBwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKHJlc3VsdCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZSA9PiBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlLCBcImhvdmVyIHRvb2x0aXBcIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2Yob3BlbikgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW91c2Vtb3ZlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5sYXN0TW92ZSA9IHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSwgdGFyZ2V0OiBldmVudC50YXJnZXQsIHRpbWU6IERhdGUubm93KCkgfTtcbiAgICAgICAgaWYgKHRoaXMuaG92ZXJUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNoZWNrSG92ZXIsIHRoaXMuaG92ZXJUaW1lKTtcbiAgICAgICAgbGV0IHRvb2x0aXAgPSB0aGlzLmFjdGl2ZTtcbiAgICAgICAgaWYgKHRvb2x0aXAgJiYgIWlzSW5Ub29sdGlwKHRoaXMubGFzdE1vdmUudGFyZ2V0KSB8fCB0aGlzLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIGxldCB7IHBvcyB9ID0gdG9vbHRpcCB8fCB0aGlzLnBlbmRpbmcsIGVuZCA9IChfYSA9IHRvb2x0aXAgPT09IG51bGwgfHwgdG9vbHRpcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9vbHRpcC5lbmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBvcztcbiAgICAgICAgICAgIGlmICgocG9zID09IGVuZCA/IHRoaXMudmlldy5wb3NBdENvb3Jkcyh0aGlzLmxhc3RNb3ZlKSAhPSBwb3NcbiAgICAgICAgICAgICAgICA6ICFpc092ZXJSYW5nZSh0aGlzLnZpZXcsIHBvcywgZW5kLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZLCA2IC8qIEhvdmVyLk1heERpc3QgKi8pKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YobnVsbCkgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3VzZWxlYXZlKGUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmICFpc0luVG9vbHRpcChlLnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihudWxsKSB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLm1vdXNlbGVhdmUpO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3VzZW1vdmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzSW5Ub29sdGlwKGVsdCkge1xuICAgIGZvciAobGV0IGN1ciA9IGVsdDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA9PSAxICYmIGN1ci5jbGFzc0xpc3QuY29udGFpbnMoXCJjbS10b29sdGlwXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNPdmVyUmFuZ2UodmlldywgZnJvbSwgdG8sIHgsIHksIG1hcmdpbikge1xuICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgbGV0IGZyb21ET00gPSB2aWV3LmRvbUF0UG9zKGZyb20pLCB0b0RPTSA9IHZpZXcuZG9tQXRQb3ModG8pO1xuICAgIHJhbmdlLnNldEVuZCh0b0RPTS5ub2RlLCB0b0RPTS5vZmZzZXQpO1xuICAgIHJhbmdlLnNldFN0YXJ0KGZyb21ET00ubm9kZSwgZnJvbURPTS5vZmZzZXQpO1xuICAgIGxldCByZWN0cyA9IHJhbmdlLmdldENsaWVudFJlY3RzKCk7XG4gICAgcmFuZ2UuZGV0YWNoKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICBsZXQgZGlzdCA9IE1hdGgubWF4KHJlY3QudG9wIC0geSwgeSAtIHJlY3QuYm90dG9tLCByZWN0LmxlZnQgLSB4LCB4IC0gcmVjdC5yaWdodCk7XG4gICAgICAgIGlmIChkaXN0IDw9IG1hcmdpbilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcblNldCB1cCBhIGhvdmVyIHRvb2x0aXAsIHdoaWNoIHNob3dzIHVwIHdoZW4gdGhlIHBvaW50ZXIgaG92ZXJzXG5vdmVyIHJhbmdlcyBvZiB0ZXh0LiBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGhvdmVyc1xub3ZlciB0aGUgZG9jdW1lbnQgdGV4dC4gSXQgc2hvdWxkLCBpZiB0aGVyZSBpcyBhIHRvb2x0aXBcbmFzc29jaWF0ZWQgd2l0aCBwb3NpdGlvbiBgcG9zYCwgcmV0dXJuIHRoZSB0b29sdGlwIGRlc2NyaXB0aW9uXG4oZWl0aGVyIGRpcmVjdGx5IG9yIGluIGEgcHJvbWlzZSkuIFRoZSBgc2lkZWAgYXJndW1lbnQgaW5kaWNhdGVzXG5vbiB3aGljaCBzaWRlIG9mIHRoZSBwb3NpdGlvbiB0aGUgcG9pbnRlciBpc1x1MjAxNGl0IHdpbGwgYmUgLTEgaWYgdGhlXG5wb2ludGVyIGlzIGJlZm9yZSB0aGUgcG9zaXRpb24sIDEgaWYgYWZ0ZXIgdGhlIHBvc2l0aW9uLlxuXG5Ob3RlIHRoYXQgYWxsIGhvdmVyIHRvb2x0aXBzIGFyZSBob3N0ZWQgd2l0aGluIGEgc2luZ2xlIHRvb2x0aXBcbmNvbnRhaW5lciBlbGVtZW50LiBUaGlzIGFsbG93cyBtdWx0aXBsZSB0b29sdGlwcyBvdmVyIHRoZSBzYW1lXG5yYW5nZSB0byBiZSBcIm1lcmdlZFwiIHRvZ2V0aGVyIHdpdGhvdXQgb3ZlcmxhcHBpbmcuXG4qL1xuZnVuY3Rpb24gaG92ZXJUb29sdGlwKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHNldEhvdmVyID0gU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4gICAgbGV0IGhvdmVyU3RhdGUgPSBTdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAob3B0aW9ucy5oaWRlT25DaGFuZ2UgJiYgKHRyLmRvY0NoYW5nZWQgfHwgdHIuc2VsZWN0aW9uKSB8fFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGlkZU9uICYmIG9wdGlvbnMuaGlkZU9uKHRyLCB2YWx1ZSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHRyLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3UG9zID0gdHIuY2hhbmdlcy5tYXBQb3ModmFsdWUucG9zLCAtMSwgTWFwTW9kZS5UcmFja0RlbCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1BvcyA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvcHkucG9zID0gbmV3UG9zO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5lbmQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgY29weS5lbmQgPSB0ci5jaGFuZ2VzLm1hcFBvcyh2YWx1ZS5lbmQpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29weTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRIb3ZlcikpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3QpKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGU6IGYgPT4gc2hvd0hvdmVyVG9vbHRpcC5mcm9tKGYpXG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgaG92ZXJTdGF0ZSxcbiAgICAgICAgVmlld1BsdWdpbi5kZWZpbmUodmlldyA9PiBuZXcgSG92ZXJQbHVnaW4odmlldywgc291cmNlLCBob3ZlclN0YXRlLCBzZXRIb3Zlciwgb3B0aW9ucy5ob3ZlclRpbWUgfHwgMzAwIC8qIEhvdmVyLlRpbWUgKi8pKSxcbiAgICAgICAgc2hvd0hvdmVyVG9vbHRpcEhvc3RcbiAgICBdO1xufVxuLyoqXG5HZXQgdGhlIGFjdGl2ZSB0b29sdGlwIHZpZXcgZm9yIGEgZ2l2ZW4gdG9vbHRpcCwgaWYgYXZhaWxhYmxlLlxuKi9cbmZ1bmN0aW9uIGdldFRvb2x0aXAodmlldywgdG9vbHRpcCkge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKTtcbiAgICBpZiAoIXBsdWdpbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZvdW5kID0gcGx1Z2luLm1hbmFnZXIudG9vbHRpcHMuaW5kZXhPZih0b29sdGlwKTtcbiAgICByZXR1cm4gZm91bmQgPCAwID8gbnVsbCA6IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tmb3VuZF07XG59XG4vKipcblJldHVybnMgdHJ1ZSBpZiBhbnkgaG92ZXIgdG9vbHRpcHMgYXJlIGN1cnJlbnRseSBhY3RpdmUuXG4qL1xuZnVuY3Rpb24gaGFzSG92ZXJUb29sdGlwcyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5mYWNldChzaG93SG92ZXJUb29sdGlwKS5zb21lKHggPT4geCk7XG59XG5jb25zdCBjbG9zZUhvdmVyVG9vbHRpcEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuVHJhbnNhY3Rpb24gZWZmZWN0IHRoYXQgY2xvc2VzIGFsbCBob3ZlciB0b29sdGlwcy5cbiovXG5jb25zdCBjbG9zZUhvdmVyVG9vbHRpcHMgPSAvKkBfX1BVUkVfXyovY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3Qub2YobnVsbCk7XG4vKipcblRlbGwgdGhlIHRvb2x0aXAgZXh0ZW5zaW9uIHRvIHJlY29tcHV0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGFjdGl2ZVxudG9vbHRpcHMuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIChzdWNoIGFzIGFcbnJlLXBvc2l0aW9uaW5nIG9yIENTUyBjaGFuZ2UgYWZmZWN0aW5nIHRoZSBlZGl0b3IpIHRoYXQgY291bGRcbmludmFsaWRhdGUgdGhlIGV4aXN0aW5nIHRvb2x0aXAgcG9zaXRpb25zLlxuKi9cbmZ1bmN0aW9uIHJlcG9zaXRpb25Ub29sdGlwcyh2aWV3KSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHZpZXcucGx1Z2luKHRvb2x0aXBQbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF5YmVNZWFzdXJlKCk7XG59XG5cbmNvbnN0IHBhbmVsQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIGxldCB0b3BDb250YWluZXIsIGJvdHRvbUNvbnRhaW5lcjtcbiAgICAgICAgZm9yIChsZXQgYyBvZiBjb25maWdzKSB7XG4gICAgICAgICAgICB0b3BDb250YWluZXIgPSB0b3BDb250YWluZXIgfHwgYy50b3BDb250YWluZXI7XG4gICAgICAgICAgICBib3R0b21Db250YWluZXIgPSBib3R0b21Db250YWluZXIgfHwgYy5ib3R0b21Db250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdG9wQ29udGFpbmVyLCBib3R0b21Db250YWluZXIgfTtcbiAgICB9XG59KTtcbi8qKlxuQ29uZmlndXJlcyB0aGUgcGFuZWwtbWFuYWdpbmcgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIHBhbmVscyhjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnID8gW3BhbmVsQ29uZmlnLm9mKGNvbmZpZyldIDogW107XG59XG4vKipcbkdldCB0aGUgYWN0aXZlIHBhbmVsIGNyZWF0ZWQgYnkgdGhlIGdpdmVuIGNvbnN0cnVjdG9yLCBpZiBhbnkuXG5UaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3UgbmVlZCBhY2Nlc3MgdG8geW91ciBwYW5lbHMnIERPTVxuc3RydWN0dXJlLlxuKi9cbmZ1bmN0aW9uIGdldFBhbmVsKHZpZXcsIHBhbmVsKSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKHBhbmVsUGx1Z2luKTtcbiAgICBsZXQgaW5kZXggPSBwbHVnaW4gPyBwbHVnaW4uc3BlY3MuaW5kZXhPZihwYW5lbCkgOiAtMTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IHBsdWdpbi5wYW5lbHNbaW5kZXhdIDogbnVsbDtcbn1cbmNvbnN0IHBhbmVsUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSB2aWV3LnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XG4gICAgICAgIHRoaXMuc3BlY3MgPSB0aGlzLmlucHV0LmZpbHRlcihzID0+IHMpO1xuICAgICAgICB0aGlzLnBhbmVscyA9IHRoaXMuc3BlY3MubWFwKHNwZWMgPT4gc3BlYyh2aWV3KSk7XG4gICAgICAgIGxldCBjb25mID0gdmlldy5zdGF0ZS5mYWNldChwYW5lbENvbmZpZyk7XG4gICAgICAgIHRoaXMudG9wID0gbmV3IFBhbmVsR3JvdXAodmlldywgdHJ1ZSwgY29uZi50b3BDb250YWluZXIpO1xuICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMudG9wLnN5bmModGhpcy5wYW5lbHMuZmlsdGVyKHAgPT4gcC50b3ApKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luYyh0aGlzLnBhbmVscy5maWx0ZXIocCA9PiAhcC50b3ApKTtcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgcC5kb20uY2xhc3NMaXN0LmFkZChcImNtLXBhbmVsXCIpO1xuICAgICAgICAgICAgaWYgKHAubW91bnQpXG4gICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQocGFuZWxDb25maWcpO1xuICAgICAgICBpZiAodGhpcy50b3AuY29udGFpbmVyICE9IGNvbmYudG9wQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnRvcC5zeW5jKFtdKTtcbiAgICAgICAgICAgIHRoaXMudG9wID0gbmV3IFBhbmVsR3JvdXAodXBkYXRlLnZpZXcsIHRydWUsIGNvbmYudG9wQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib3R0b20uY29udGFpbmVyICE9IGNvbmYuYm90dG9tQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKFtdKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gbmV3IFBhbmVsR3JvdXAodXBkYXRlLnZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3Auc3luY0NsYXNzZXMoKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luY0NsYXNzZXMoKTtcbiAgICAgICAgbGV0IGlucHV0ID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSB0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICBsZXQgc3BlY3MgPSBpbnB1dC5maWx0ZXIoeCA9PiB4KTtcbiAgICAgICAgICAgIGxldCBwYW5lbHMgPSBbXSwgdG9wID0gW10sIGJvdHRvbSA9IFtdLCBtb3VudCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc3BlYyBvZiBzcGVjcykge1xuICAgICAgICAgICAgICAgIGxldCBrbm93biA9IHRoaXMuc3BlY3MuaW5kZXhPZihzcGVjKSwgcGFuZWw7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbCA9IHNwZWModXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBtb3VudC5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsID0gdGhpcy5wYW5lbHNba25vd25dO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFuZWwudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWwudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhbmVscy5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgICAgICAocGFuZWwudG9wID8gdG9wIDogYm90dG9tKS5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjcztcbiAgICAgICAgICAgIHRoaXMucGFuZWxzID0gcGFuZWxzO1xuICAgICAgICAgICAgdGhpcy50b3Auc3luYyh0b3ApO1xuICAgICAgICAgICAgdGhpcy5ib3R0b20uc3luYyhib3R0b20pO1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBtb3VudCkge1xuICAgICAgICAgICAgICAgIHAuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1wYW5lbFwiKTtcbiAgICAgICAgICAgICAgICBpZiAocC5tb3VudClcbiAgICAgICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscylcbiAgICAgICAgICAgICAgICBpZiAocC51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHAudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50b3Auc3luYyhbXSk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmMoW10pO1xuICAgIH1cbn0sIHtcbiAgICBwcm92aWRlOiBwbHVnaW4gPT4gRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zLm9mKHZpZXcgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSB2aWV3LnBsdWdpbihwbHVnaW4pO1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgeyB0b3A6IHZhbHVlLnRvcC5zY3JvbGxNYXJnaW4oKSwgYm90dG9tOiB2YWx1ZS5ib3R0b20uc2Nyb2xsTWFyZ2luKCkgfTtcbiAgICB9KVxufSk7XG5jbGFzcyBQYW5lbEdyb3VwIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCB0b3AsIGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuZG9tID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSBcIlwiO1xuICAgICAgICB0aGlzLnBhbmVscyA9IFtdO1xuICAgICAgICB0aGlzLnN5bmNDbGFzc2VzKCk7XG4gICAgfVxuICAgIHN5bmMocGFuZWxzKSB7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpXG4gICAgICAgICAgICBpZiAocC5kZXN0cm95ICYmIHBhbmVscy5pbmRleE9mKHApIDwgMClcbiAgICAgICAgICAgICAgICBwLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSBwYW5lbHM7XG4gICAgICAgIHRoaXMuc3luY0RPTSgpO1xuICAgIH1cbiAgICBzeW5jRE9NKCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lbHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IHRoaXMudG9wID8gXCJjbS1wYW5lbHMgY20tcGFuZWxzLXRvcFwiIDogXCJjbS1wYW5lbHMgY20tcGFuZWxzLWJvdHRvbVwiO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGVbdGhpcy50b3AgPyBcInRvcFwiIDogXCJib3R0b21cIl0gPSBcIjBcIjtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmNvbnRhaW5lciB8fCB0aGlzLnZpZXcuZG9tO1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdGhpcy50b3AgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJET00gPSB0aGlzLmRvbS5maXJzdENoaWxkO1xuICAgICAgICBmb3IgKGxldCBwYW5lbCBvZiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgaWYgKHBhbmVsLmRvbS5wYXJlbnROb2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ckRPTSAhPSBwYW5lbC5kb20pXG4gICAgICAgICAgICAgICAgICAgIGN1ckRPTSA9IHJtKGN1ckRPTSk7XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gY3VyRE9NLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKHBhbmVsLmRvbSwgY3VyRE9NKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY3VyRE9NKVxuICAgICAgICAgICAgY3VyRE9NID0gcm0oY3VyRE9NKTtcbiAgICB9XG4gICAgc2Nyb2xsTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZG9tIHx8IHRoaXMuY29udGFpbmVyID8gMFxuICAgICAgICAgICAgOiBNYXRoLm1heCgwLCB0aGlzLnRvcCA/XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gTWF0aC5tYXgoMCwgdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApIDpcbiAgICAgICAgICAgICAgICBNYXRoLm1pbihpbm5lckhlaWdodCwgdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20pIC0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKTtcbiAgICB9XG4gICAgc3luY0NsYXNzZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250YWluZXIgfHwgdGhpcy5jbGFzc2VzID09IHRoaXMudmlldy50aGVtZUNsYXNzZXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGNscyBvZiB0aGlzLmNsYXNzZXMuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgICAgIGZvciAobGV0IGNscyBvZiAodGhpcy5jbGFzc2VzID0gdGhpcy52aWV3LnRoZW1lQ2xhc3Nlcykuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcm0obm9kZSkge1xuICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICBub2RlLnJlbW92ZSgpO1xuICAgIHJldHVybiBuZXh0O1xufVxuLyoqXG5PcGVuaW5nIGEgcGFuZWwgaXMgZG9uZSBieSBwcm92aWRpbmcgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3JcbnRoZSBwYW5lbCB0aHJvdWdoIHRoaXMgZmFjZXQuIChUaGUgcGFuZWwgaXMgY2xvc2VkIGFnYWluIHdoZW4gaXRzXG5jb25zdHJ1Y3RvciBpcyBubyBsb25nZXIgcHJvdmlkZWQuKSBWYWx1ZXMgb2YgYG51bGxgIGFyZSBpZ25vcmVkLlxuKi9cbmNvbnN0IHNob3dQYW5lbCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGVuYWJsZXM6IHBhbmVsUGx1Z2luXG59KTtcblxuLyoqXG5BIGd1dHRlciBtYXJrZXIgcmVwcmVzZW50cyBhIGJpdCBvZiBpbmZvcm1hdGlvbiBhdHRhY2hlZCB0byBhIGxpbmVcbmluIGEgc3BlY2lmaWMgZ3V0dGVyLiBZb3VyIG93biBjdXN0b20gbWFya2VycyBoYXZlIHRvIGV4dGVuZCB0aGlzXG5jbGFzcy5cbiovXG5jbGFzcyBHdXR0ZXJNYXJrZXIgZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBvdGhlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmVxKG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIG1hcmtlciB0byBhbm90aGVyIG1hcmtlciBvZiB0aGUgc2FtZSB0eXBlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQ2FsbGVkIGlmIHRoZSBtYXJrZXIgaGFzIGEgYHRvRE9NYCBtZXRob2QgYW5kIGl0cyByZXByZXNlbnRhdGlvblxuICAgIHdhcyByZW1vdmVkIGZyb20gYSBndXR0ZXIuXG4gICAgKi9cbiAgICBkZXN0cm95KGRvbSkgeyB9XG59XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLmVsZW1lbnRDbGFzcyA9IFwiXCI7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnRvRE9NID0gdW5kZWZpbmVkO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0JlZm9yZTtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUuc3RhcnRTaWRlID0gR3V0dGVyTWFya2VyLnByb3RvdHlwZS5lbmRTaWRlID0gLTE7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbi8qKlxuRmFjZXQgdXNlZCB0byBhZGQgYSBjbGFzcyB0byBhbGwgZ3V0dGVyIGVsZW1lbnRzIGZvciBhIGdpdmVuIGxpbmUuXG5NYXJrZXJzIGdpdmVuIHRvIHRoaXMgZmFjZXQgc2hvdWxkIF9vbmx5XyBkZWZpbmUgYW5cbltgZWxlbWVudGNsYXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3Lkd1dHRlck1hcmtlci5lbGVtZW50Q2xhc3MpLCBub3QgYVxuW2B0b0RPTWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5HdXR0ZXJNYXJrZXIudG9ET00pIChvciB0aGUgbWFya2VyIHdpbGwgYXBwZWFyXG5pbiBhbGwgZ3V0dGVycyBmb3IgdGhlIGxpbmUpLlxuKi9cbmNvbnN0IGd1dHRlckxpbmVDbGFzcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGRlZmF1bHRzID0ge1xuICAgIGNsYXNzOiBcIlwiLFxuICAgIHJlbmRlckVtcHR5RWxlbWVudHM6IGZhbHNlLFxuICAgIGVsZW1lbnRTdHlsZTogXCJcIixcbiAgICBtYXJrZXJzOiAoKSA9PiBSYW5nZVNldC5lbXB0eSxcbiAgICBsaW5lTWFya2VyOiAoKSA9PiBudWxsLFxuICAgIGxpbmVNYXJrZXJDaGFuZ2U6IG51bGwsXG4gICAgaW5pdGlhbFNwYWNlcjogbnVsbCxcbiAgICB1cGRhdGVTcGFjZXI6IG51bGwsXG4gICAgZG9tRXZlbnRIYW5kbGVyczoge31cbn07XG5jb25zdCBhY3RpdmVHdXR0ZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5EZWZpbmUgYW4gZWRpdG9yIGd1dHRlci4gVGhlIG9yZGVyIGluIHdoaWNoIHRoZSBndXR0ZXJzIGFwcGVhciBpc1xuZGV0ZXJtaW5lZCBieSB0aGVpciBleHRlbnNpb24gcHJpb3JpdHkuXG4qL1xuZnVuY3Rpb24gZ3V0dGVyKGNvbmZpZykge1xuICAgIHJldHVybiBbZ3V0dGVycygpLCBhY3RpdmVHdXR0ZXJzLm9mKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMpLCBjb25maWcpKV07XG59XG5jb25zdCB1bmZpeEd1dHRlcnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG4vKipcblRoZSBndXR0ZXItZHJhd2luZyBwbHVnaW4gaXMgYXV0b21hdGljYWxseSBlbmFibGVkIHdoZW4geW91IGFkZCBhXG5ndXR0ZXIsIGJ1dCB5b3UgY2FuIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGV4cGxpY2l0bHkgY29uZmlndXJlIGl0LlxuXG5Vbmxlc3MgYGZpeGVkYCBpcyBleHBsaWNpdGx5IHNldCB0byBgZmFsc2VgLCB0aGUgZ3V0dGVycyBhcmVcbmZpeGVkLCBtZWFuaW5nIHRoZXkgZG9uJ3Qgc2Nyb2xsIGFsb25nIHdpdGggdGhlIGNvbnRlbnRcbmhvcml6b250YWxseSAoZXhjZXB0IG9uIEludGVybmV0IEV4cGxvcmVyLCB3aGljaCBkb2Vzbid0IHN1cHBvcnRcbkNTUyBbYHBvc2l0aW9uOlxuc3RpY2t5YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3Bvc2l0aW9uI3N0aWNreSkpLlxuKi9cbmZ1bmN0aW9uIGd1dHRlcnMoY29uZmlnKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtcbiAgICAgICAgZ3V0dGVyVmlldyxcbiAgICBdO1xuICAgIGlmIChjb25maWcgJiYgY29uZmlnLmZpeGVkID09PSBmYWxzZSlcbiAgICAgICAgcmVzdWx0LnB1c2godW5maXhHdXR0ZXJzLm9mKHRydWUpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZ3V0dGVyVmlldyA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnByZXZWaWV3cG9ydCA9IHZpZXcudmlld3BvcnQ7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJzXCI7XG4gICAgICAgIHRoaXMuZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdGhpcy5kb20uc3R5bGUubWluSGVpZ2h0ID0gdGhpcy52aWV3LmNvbnRlbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZ3V0dGVycyA9IHZpZXcuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycykubWFwKGNvbmYgPT4gbmV3IFNpbmdsZUd1dHRlclZpZXcodmlldywgY29uZikpO1xuICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZ3V0dGVyLmRvbSk7XG4gICAgICAgIHRoaXMuZml4ZWQgPSAhdmlldy5zdGF0ZS5mYWNldCh1bmZpeEd1dHRlcnMpO1xuICAgICAgICBpZiAodGhpcy5maXhlZCkge1xuICAgICAgICAgICAgLy8gRklYTUUgSUUxMSBmYWxsYmFjaywgd2hpY2ggZG9lc24ndCBzdXBwb3J0IHBvc2l0aW9uOiBzdGlja3ksXG4gICAgICAgICAgICAvLyBieSB1c2luZyBwb3NpdGlvbjogcmVsYXRpdmUgKyBldmVudCBoYW5kbGVycyB0aGF0IHJlYWxpZ24gdGhlXG4gICAgICAgICAgICAvLyBndXR0ZXIgKG9yIGp1c3QgZm9yY2UgZml4ZWQ9ZmFsc2Ugb24gSUUxMT8pXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5wb3NpdGlvbiA9IFwic3RpY2t5XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zeW5jR3V0dGVycyhmYWxzZSk7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdmlldy5jb250ZW50RE9NKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVHdXR0ZXJzKHVwZGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIERldGFjaCBkdXJpbmcgc3luYyB3aGVuIHRoZSB2aWV3cG9ydCBjaGFuZ2VkIHNpZ25pZmljYW50bHlcbiAgICAgICAgICAgIC8vIChzdWNoIGFzIGR1cmluZyBzY3JvbGxpbmcpLCBzaW5jZSBmb3IgbGFyZ2UgdXBkYXRlcyB0aGF0IGlzXG4gICAgICAgICAgICAvLyBmYXN0ZXIuXG4gICAgICAgICAgICBsZXQgdnBBID0gdGhpcy5wcmV2Vmlld3BvcnQsIHZwQiA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xuICAgICAgICAgICAgbGV0IHZwT3ZlcmxhcCA9IE1hdGgubWluKHZwQS50bywgdnBCLnRvKSAtIE1hdGgubWF4KHZwQS5mcm9tLCB2cEIuZnJvbSk7XG4gICAgICAgICAgICB0aGlzLnN5bmNHdXR0ZXJzKHZwT3ZlcmxhcCA8ICh2cEIudG8gLSB2cEIuZnJvbSkgKiAwLjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUubWluSGVpZ2h0ID0gdGhpcy52aWV3LmNvbnRlbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZmFjZXQodW5maXhHdXR0ZXJzKSAhPSAhdGhpcy5maXhlZCkge1xuICAgICAgICAgICAgdGhpcy5maXhlZCA9ICF0aGlzLmZpeGVkO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLmZpeGVkID8gXCJzdGlja3lcIiA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2Vmlld3BvcnQgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICB9XG4gICAgc3luY0d1dHRlcnMoZGV0YWNoKSB7XG4gICAgICAgIGxldCBhZnRlciA9IHRoaXMuZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoZGV0YWNoKVxuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgIGxldCBsaW5lQ2xhc3NlcyA9IFJhbmdlU2V0Lml0ZXIodGhpcy52aWV3LnN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHRoaXMudmlldy52aWV3cG9ydC5mcm9tKTtcbiAgICAgICAgbGV0IGNsYXNzU2V0ID0gW107XG4gICAgICAgIGxldCBjb250ZXh0cyA9IHRoaXMuZ3V0dGVycy5tYXAoZ3V0dGVyID0+IG5ldyBVcGRhdGVDb250ZXh0KGd1dHRlciwgdGhpcy52aWV3LnZpZXdwb3J0LCAtdGhpcy52aWV3LmRvY3VtZW50UGFkZGluZy50b3ApKTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnZpZXcudmlld3BvcnRMaW5lQmxvY2tzKSB7XG4gICAgICAgICAgICBsZXQgdGV4dDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpbmUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiIG9mIGxpbmUudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGxpbmUudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCA/IGxpbmUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRleHQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoY2xhc3NTZXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNsYXNzU2V0ID0gW107XG4gICAgICAgICAgICBhZHZhbmNlQ3Vyc29yKGxpbmVDbGFzc2VzLCBjbGFzc1NldCwgbGluZS5mcm9tKTtcbiAgICAgICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgICAgIGN4LmxpbmUodGhpcy52aWV3LCB0ZXh0LCBjbGFzc1NldCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICBjeC5maW5pc2goKTtcbiAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgIHRoaXMudmlldy5zY3JvbGxET00uaW5zZXJ0QmVmb3JlKHRoaXMuZG9tLCBhZnRlcik7XG4gICAgfVxuICAgIHVwZGF0ZUd1dHRlcnModXBkYXRlKSB7XG4gICAgICAgIGxldCBwcmV2ID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycyksIGN1ciA9IHVwZGF0ZS5zdGF0ZS5mYWNldChhY3RpdmVHdXR0ZXJzKTtcbiAgICAgICAgbGV0IGNoYW5nZSA9IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5oZWlnaHRDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHxcbiAgICAgICAgICAgICFSYW5nZVNldC5lcSh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB1cGRhdGUuc3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdXBkYXRlLnZpZXcudmlld3BvcnQuZnJvbSwgdXBkYXRlLnZpZXcudmlld3BvcnQudG8pO1xuICAgICAgICBpZiAocHJldiA9PSBjdXIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGd1dHRlciBvZiB0aGlzLmd1dHRlcnMpXG4gICAgICAgICAgICAgICAgaWYgKGd1dHRlci51cGRhdGUodXBkYXRlKSlcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZ3V0dGVycyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY29uZiBvZiBjdXIpIHtcbiAgICAgICAgICAgICAgICBsZXQga25vd24gPSBwcmV2LmluZGV4T2YoY29uZik7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBndXR0ZXJzLnB1c2gobmV3IFNpbmdsZUd1dHRlclZpZXcodGhpcy52aWV3LCBjb25mKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmd1dHRlcnNba25vd25dLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICBndXR0ZXJzLnB1c2godGhpcy5ndXR0ZXJzW2tub3duXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZyBvZiB0aGlzLmd1dHRlcnMpIHtcbiAgICAgICAgICAgICAgICBnLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3V0dGVycy5pbmRleE9mKGcpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgZy5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBnIG9mIGd1dHRlcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZy5kb20pO1xuICAgICAgICAgICAgdGhpcy5ndXR0ZXJzID0gZ3V0dGVycztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuZ3V0dGVycylcbiAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICB9XG59LCB7XG4gICAgcHJvdmlkZTogcGx1Z2luID0+IEVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucy5vZih2aWV3ID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5ndXR0ZXJzLmxlbmd0aCA9PSAwIHx8ICF2YWx1ZS5maXhlZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIgPyB7IGxlZnQ6IHZhbHVlLmRvbS5vZmZzZXRXaWR0aCB9IDogeyByaWdodDogdmFsdWUuZG9tLm9mZnNldFdpZHRoIH07XG4gICAgfSlcbn0pO1xuZnVuY3Rpb24gYXNBcnJheSh2YWwpIHsgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSk7IH1cbmZ1bmN0aW9uIGFkdmFuY2VDdXJzb3IoY3Vyc29yLCBjb2xsZWN0LCBwb3MpIHtcbiAgICB3aGlsZSAoY3Vyc29yLnZhbHVlICYmIGN1cnNvci5mcm9tIDw9IHBvcykge1xuICAgICAgICBpZiAoY3Vyc29yLmZyb20gPT0gcG9zKVxuICAgICAgICAgICAgY29sbGVjdC5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgfVxufVxuY2xhc3MgVXBkYXRlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoZ3V0dGVyLCB2aWV3cG9ydCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZ3V0dGVyID0gZ3V0dGVyO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBSYW5nZVNldC5pdGVyKGd1dHRlci5tYXJrZXJzLCB2aWV3cG9ydC5mcm9tKTtcbiAgICB9XG4gICAgbGluZSh2aWV3LCBsaW5lLCBleHRyYU1hcmtlcnMpIHtcbiAgICAgICAgbGV0IGxvY2FsTWFya2VycyA9IFtdO1xuICAgICAgICBhZHZhbmNlQ3Vyc29yKHRoaXMuY3Vyc29yLCBsb2NhbE1hcmtlcnMsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChleHRyYU1hcmtlcnMubGVuZ3RoKVxuICAgICAgICAgICAgbG9jYWxNYXJrZXJzID0gbG9jYWxNYXJrZXJzLmNvbmNhdChleHRyYU1hcmtlcnMpO1xuICAgICAgICBsZXQgZm9yTGluZSA9IHRoaXMuZ3V0dGVyLmNvbmZpZy5saW5lTWFya2VyKHZpZXcsIGxpbmUsIGxvY2FsTWFya2Vycyk7XG4gICAgICAgIGlmIChmb3JMaW5lKVxuICAgICAgICAgICAgbG9jYWxNYXJrZXJzLnVuc2hpZnQoZm9yTGluZSk7XG4gICAgICAgIGxldCBndXR0ZXIgPSB0aGlzLmd1dHRlcjtcbiAgICAgICAgaWYgKGxvY2FsTWFya2Vycy5sZW5ndGggPT0gMCAmJiAhZ3V0dGVyLmNvbmZpZy5yZW5kZXJFbXB0eUVsZW1lbnRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgYWJvdmUgPSBsaW5lLnRvcCAtIHRoaXMuaGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5pID09IGd1dHRlci5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBuZXdFbHQgPSBuZXcgR3V0dGVyRWxlbWVudCh2aWV3LCBsaW5lLmhlaWdodCwgYWJvdmUsIGxvY2FsTWFya2Vycyk7XG4gICAgICAgICAgICBndXR0ZXIuZWxlbWVudHMucHVzaChuZXdFbHQpO1xuICAgICAgICAgICAgZ3V0dGVyLmRvbS5hcHBlbmRDaGlsZChuZXdFbHQuZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGd1dHRlci5lbGVtZW50c1t0aGlzLmldLnVwZGF0ZSh2aWV3LCBsaW5lLmhlaWdodCwgYWJvdmUsIGxvY2FsTWFya2Vycyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBsaW5lLmJvdHRvbTtcbiAgICAgICAgdGhpcy5pKys7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICB3aGlsZSAoZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCA+IHRoaXMuaSkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBndXR0ZXIuZWxlbWVudHMucG9wKCk7XG4gICAgICAgICAgICBndXR0ZXIuZG9tLnJlbW92ZUNoaWxkKGxhc3QuZG9tKTtcbiAgICAgICAgICAgIGxhc3QuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2luZ2xlR3V0dGVyVmlldyB7XG4gICAgY29uc3RydWN0b3IodmlldywgY29uZmlnKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuc3BhY2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWd1dHRlclwiICsgKHRoaXMuY29uZmlnLmNsYXNzID8gXCIgXCIgKyB0aGlzLmNvbmZpZy5jbGFzcyA6IFwiXCIpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIGNvbmZpZy5kb21FdmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKHByb3AsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQsIHk7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSB0aGlzLmRvbSAmJiB0aGlzLmRvbS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0YXJnZXQucGFyZW50Tm9kZSAhPSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0SGVpZ2h0KHkgLSB2aWV3LmRvY3VtZW50VG9wKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRvbUV2ZW50SGFuZGxlcnNbcHJvcF0odmlldywgbGluZSwgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheShjb25maWcubWFya2Vycyh2aWV3KSk7XG4gICAgICAgIGlmIChjb25maWcuaW5pdGlhbFNwYWNlcikge1xuICAgICAgICAgICAgdGhpcy5zcGFjZXIgPSBuZXcgR3V0dGVyRWxlbWVudCh2aWV3LCAwLCAwLCBbY29uZmlnLmluaXRpYWxTcGFjZXIodmlldyldKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuc3BhY2VyLmRvbSk7XG4gICAgICAgICAgICB0aGlzLnNwYWNlci5kb20uc3R5bGUuY3NzVGV4dCArPSBcInZpc2liaWxpdHk6IGhpZGRlbjsgcG9pbnRlci1ldmVudHM6IG5vbmVcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBwcmV2TWFya2VycyA9IHRoaXMubWFya2VycztcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheSh0aGlzLmNvbmZpZy5tYXJrZXJzKHVwZGF0ZS52aWV3KSk7XG4gICAgICAgIGlmICh0aGlzLnNwYWNlciAmJiB0aGlzLmNvbmZpZy51cGRhdGVTcGFjZXIpIHtcbiAgICAgICAgICAgIGxldCB1cGRhdGVkID0gdGhpcy5jb25maWcudXBkYXRlU3BhY2VyKHRoaXMuc3BhY2VyLm1hcmtlcnNbMF0sIHVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodXBkYXRlZCAhPSB0aGlzLnNwYWNlci5tYXJrZXJzWzBdKVxuICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VyLnVwZGF0ZSh1cGRhdGUudmlldywgMCwgMCwgW3VwZGF0ZWRdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdnAgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICAgICAgcmV0dXJuICFSYW5nZVNldC5lcSh0aGlzLm1hcmtlcnMsIHByZXZNYXJrZXJzLCB2cC5mcm9tLCB2cC50bykgfHxcbiAgICAgICAgICAgICh0aGlzLmNvbmZpZy5saW5lTWFya2VyQ2hhbmdlID8gdGhpcy5jb25maWcubGluZU1hcmtlckNoYW5nZSh1cGRhdGUpIDogZmFsc2UpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBlbHQgb2YgdGhpcy5lbGVtZW50cylcbiAgICAgICAgICAgIGVsdC5kZXN0cm95KCk7XG4gICAgfVxufVxuY2xhc3MgR3V0dGVyRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xuICAgICAgICB0aGlzLmhlaWdodCA9IC0xO1xuICAgICAgICB0aGlzLmFib3ZlID0gMDtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJFbGVtZW50XCI7XG4gICAgICAgIHRoaXMudXBkYXRlKHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgIH1cbiAgICB1cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT0gaGVpZ2h0KVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gKHRoaXMuaGVpZ2h0ID0gaGVpZ2h0KSArIFwicHhcIjtcbiAgICAgICAgaWYgKHRoaXMuYWJvdmUgIT0gYWJvdmUpXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5tYXJnaW5Ub3AgPSAodGhpcy5hYm92ZSA9IGFib3ZlKSA/IGFib3ZlICsgXCJweFwiIDogXCJcIjtcbiAgICAgICAgaWYgKCFzYW1lTWFya2Vycyh0aGlzLm1hcmtlcnMsIG1hcmtlcnMpKVxuICAgICAgICAgICAgdGhpcy5zZXRNYXJrZXJzKHZpZXcsIG1hcmtlcnMpO1xuICAgIH1cbiAgICBzZXRNYXJrZXJzKHZpZXcsIG1hcmtlcnMpIHtcbiAgICAgICAgbGV0IGNscyA9IFwiY20tZ3V0dGVyRWxlbWVudFwiLCBkb21Qb3MgPSB0aGlzLmRvbS5maXJzdENoaWxkO1xuICAgICAgICBmb3IgKGxldCBpTmV3ID0gMCwgaU9sZCA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IHNraXBUbyA9IGlPbGQsIG1hcmtlciA9IGlOZXcgPCBtYXJrZXJzLmxlbmd0aCA/IG1hcmtlcnNbaU5ldysrXSA6IG51bGwsIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgYyA9IG1hcmtlci5lbGVtZW50Q2xhc3M7XG4gICAgICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgICAgIGNscyArPSBcIiBcIiArIGM7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGlPbGQ7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlcnNbaV0uY29tcGFyZShtYXJrZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwVG8gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2tpcFRvID0gdGhpcy5tYXJrZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpT2xkIDwgc2tpcFRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLm1hcmtlcnNbaU9sZCsrXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC50b0RPTSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0LmRlc3Ryb3koZG9tUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gZG9tUG9zLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBkb21Qb3MucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcyA9IGFmdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWFya2VyKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKG1hcmtlci50b0RPTSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkKVxuICAgICAgICAgICAgICAgICAgICBkb21Qb3MgPSBkb21Qb3MubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUobWFya2VyLnRvRE9NKHZpZXcpLCBkb21Qb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoZWQpXG4gICAgICAgICAgICAgICAgaU9sZCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IGNscztcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gbWFya2VycztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXRNYXJrZXJzKG51bGwsIFtdKTsgLy8gRmlyc3QgYXJndW1lbnQgbm90IHVzZWQgdW5sZXNzIGNyZWF0aW5nIG1hcmtlcnNcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lTWFya2VycyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0uY29tcGFyZShiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuRmFjZXQgdXNlZCB0byBwcm92aWRlIG1hcmtlcnMgdG8gdGhlIGxpbmUgbnVtYmVyIGd1dHRlci5cbiovXG5jb25zdCBsaW5lTnVtYmVyTWFya2VycyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGxpbmVOdW1iZXJDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyh2YWx1ZXMsIHsgZm9ybWF0TnVtYmVyOiBTdHJpbmcsIGRvbUV2ZW50SGFuZGxlcnM6IHt9IH0sIHtcbiAgICAgICAgICAgIGRvbUV2ZW50SGFuZGxlcnMoYSwgYikge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBhKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBldmVudCBpbiBiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBleGlzdHMgPSByZXN1bHRbZXZlbnRdLCBhZGQgPSBiW2V2ZW50XTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2V2ZW50XSA9IGV4aXN0cyA/ICh2aWV3LCBsaW5lLCBldmVudCkgPT4gZXhpc3RzKHZpZXcsIGxpbmUsIGV2ZW50KSB8fCBhZGQodmlldywgbGluZSwgZXZlbnQpIDogYWRkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmNsYXNzIE51bWJlck1hcmtlciBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IobnVtYmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy5udW1iZXIgPT0gb3RoZXIubnVtYmVyOyB9XG4gICAgdG9ET00oKSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLm51bWJlcik7IH1cbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcih2aWV3LCBudW1iZXIpIHtcbiAgICByZXR1cm4gdmlldy5zdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKS5mb3JtYXROdW1iZXIobnVtYmVyLCB2aWV3LnN0YXRlKTtcbn1cbmNvbnN0IGxpbmVOdW1iZXJHdXR0ZXIgPSAvKkBfX1BVUkVfXyovYWN0aXZlR3V0dGVycy5jb21wdXRlKFtsaW5lTnVtYmVyQ29uZmlnXSwgc3RhdGUgPT4gKHtcbiAgICBjbGFzczogXCJjbS1saW5lTnVtYmVyc1wiLFxuICAgIHJlbmRlckVtcHR5RWxlbWVudHM6IGZhbHNlLFxuICAgIG1hcmtlcnModmlldykgeyByZXR1cm4gdmlldy5zdGF0ZS5mYWNldChsaW5lTnVtYmVyTWFya2Vycyk7IH0sXG4gICAgbGluZU1hcmtlcih2aWV3LCBsaW5lLCBvdGhlcnMpIHtcbiAgICAgICAgaWYgKG90aGVycy5zb21lKG0gPT4gbS50b0RPTSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJNYXJrZXIoZm9ybWF0TnVtYmVyKHZpZXcsIHZpZXcuc3RhdGUuZG9jLmxpbmVBdChsaW5lLmZyb20pLm51bWJlcikpO1xuICAgIH0sXG4gICAgbGluZU1hcmtlckNoYW5nZTogdXBkYXRlID0+IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKSxcbiAgICBpbml0aWFsU3BhY2VyKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJNYXJrZXIoZm9ybWF0TnVtYmVyKHZpZXcsIG1heExpbmVOdW1iZXIodmlldy5zdGF0ZS5kb2MubGluZXMpKSk7XG4gICAgfSxcbiAgICB1cGRhdGVTcGFjZXIoc3BhY2VyLCB1cGRhdGUpIHtcbiAgICAgICAgbGV0IG1heCA9IGZvcm1hdE51bWJlcih1cGRhdGUudmlldywgbWF4TGluZU51bWJlcih1cGRhdGUudmlldy5zdGF0ZS5kb2MubGluZXMpKTtcbiAgICAgICAgcmV0dXJuIG1heCA9PSBzcGFjZXIubnVtYmVyID8gc3BhY2VyIDogbmV3IE51bWJlck1hcmtlcihtYXgpO1xuICAgIH0sXG4gICAgZG9tRXZlbnRIYW5kbGVyczogc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykuZG9tRXZlbnRIYW5kbGVyc1xufSkpO1xuLyoqXG5DcmVhdGUgYSBsaW5lIG51bWJlciBndXR0ZXIgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIGxpbmVOdW1iZXJzKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbGluZU51bWJlckNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBndXR0ZXJzKCksXG4gICAgICAgIGxpbmVOdW1iZXJHdXR0ZXJcbiAgICBdO1xufVxuZnVuY3Rpb24gbWF4TGluZU51bWJlcihsaW5lcykge1xuICAgIGxldCBsYXN0ID0gOTtcbiAgICB3aGlsZSAobGFzdCA8IGxpbmVzKVxuICAgICAgICBsYXN0ID0gbGFzdCAqIDEwICsgOTtcbiAgICByZXR1cm4gbGFzdDtcbn1cbmNvbnN0IGFjdGl2ZUxpbmVHdXR0ZXJNYXJrZXIgPSAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5lbGVtZW50Q2xhc3MgPSBcImNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjtcbiAgICB9XG59O1xuY29uc3QgYWN0aXZlTGluZUd1dHRlckhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL2d1dHRlckxpbmVDbGFzcy5jb21wdXRlKFtcInNlbGVjdGlvblwiXSwgc3RhdGUgPT4ge1xuICAgIGxldCBtYXJrcyA9IFtdLCBsYXN0ID0gLTE7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBsZXQgbGluZVBvcyA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuaGVhZCkuZnJvbTtcbiAgICAgICAgaWYgKGxpbmVQb3MgPiBsYXN0KSB7XG4gICAgICAgICAgICBsYXN0ID0gbGluZVBvcztcbiAgICAgICAgICAgIG1hcmtzLnB1c2goYWN0aXZlTGluZUd1dHRlck1hcmtlci5yYW5nZShsaW5lUG9zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFJhbmdlU2V0Lm9mKG1hcmtzKTtcbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgYSBgY20tYWN0aXZlTGluZUd1dHRlcmAgY2xhc3MgdG9cbmFsbCBndXR0ZXIgZWxlbWVudHMgb24gdGhlIFthY3RpdmVcbmxpbmVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5oaWdobGlnaHRBY3RpdmVMaW5lKS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyKCkge1xuICAgIHJldHVybiBhY3RpdmVMaW5lR3V0dGVySGlnaGxpZ2h0ZXI7XG59XG5cbmNvbnN0IFdoaXRlc3BhY2VEZWNvID0gLypAX19QVVJFX18qL25ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldFdoaXRlc3BhY2VEZWNvKHNwYWNlKSB7XG4gICAgbGV0IGRlY28gPSBXaGl0ZXNwYWNlRGVjby5nZXQoc3BhY2UpO1xuICAgIGlmICghZGVjbylcbiAgICAgICAgV2hpdGVzcGFjZURlY28uc2V0KHNwYWNlLCBkZWNvID0gRGVjb3JhdGlvbi5tYXJrKHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNwYWNlID09PSBcIlxcdFwiID8ge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBcImNtLWhpZ2hsaWdodFRhYlwiLFxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogXCJjbS1oaWdobGlnaHRTcGFjZVwiLFxuICAgICAgICAgICAgICAgIFwiZGF0YS1kaXNwbGF5XCI6IHNwYWNlLnJlcGxhY2UoLyAvZywgXCJcdTAwQjdcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIHJldHVybiBkZWNvO1xufVxuZnVuY3Rpb24gbWF0Y2hlcihkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUodmlldyA9PiAoe1xuICAgICAgICBkZWNvcmF0aW9uczogZGVjb3JhdG9yLmNyZWF0ZURlY28odmlldyksXG4gICAgICAgIHVwZGF0ZSh1KSB7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gZGVjb3JhdG9yLnVwZGF0ZURlY28odSwgdGhpcy5kZWNvcmF0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgfSksIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xuICAgIH0pO1xufVxuY29uc3Qgd2hpdGVzcGFjZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL21hdGNoZXIoLypAX19QVVJFX18qL25ldyBNYXRjaERlY29yYXRvcih7XG4gICAgcmVnZXhwOiAvXFx0fCArL2csXG4gICAgZGVjb3JhdGlvbjogbWF0Y2ggPT4gZ2V0V2hpdGVzcGFjZURlY28obWF0Y2hbMF0pLFxuICAgIGJvdW5kYXJ5OiAvXFxTLyxcbn0pKTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBoaWdobGlnaHRzIHdoaXRlc3BhY2UsIGFkZGluZyBhXG5gY20taGlnaGxpZ2h0U3BhY2VgIGNsYXNzIHRvIHN0cmV0Y2hlcyBvZiBzcGFjZXMsIGFuZCBhXG5gY20taGlnaGxpZ2h0VGFiYCBjbGFzcyB0byBpbmRpdmlkdWFsIHRhYiBjaGFyYWN0ZXJzLiBCeSBkZWZhdWx0LFxudGhlIGZvcm1lciBhcmUgc2hvd24gYXMgZmFpbnQgZG90cywgYW5kIHRoZSBsYXR0ZXIgYXMgYXJyb3dzLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFdoaXRlc3BhY2UoKSB7XG4gICAgcmV0dXJuIHdoaXRlc3BhY2VIaWdobGlnaHRlcjtcbn1cbmNvbnN0IHRyYWlsaW5nSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovbWF0Y2hlcigvKkBfX1BVUkVfXyovbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICByZWdleHA6IC9cXHMrJC9nLFxuICAgIGRlY29yYXRpb246IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS10cmFpbGluZ1NwYWNlXCIgfSksXG4gICAgYm91bmRhcnk6IC9cXFMvLFxufSkpO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgYSBgY20tdHJhaWxpbmdTcGFjZWAgY2xhc3MgdG8gYWxsXG50cmFpbGluZyB3aGl0ZXNwYWNlLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFRyYWlsaW5nV2hpdGVzcGFjZSgpIHtcbiAgICByZXR1cm4gdHJhaWxpbmdIaWdobGlnaHRlcjtcbn1cblxuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX3Rlc3QgPSB7IEhlaWdodE1hcCwgSGVpZ2h0T3JhY2xlLCBNZWFzdXJlZEhlaWdodHMsIFF1ZXJ5VHlwZSwgQ2hhbmdlZFJhbmdlLCBjb21wdXRlT3JkZXIsIG1vdmVWaXN1YWxseSB9O1xuXG5leHBvcnQgeyBCaWRpU3BhbiwgQmxvY2tJbmZvLCBCbG9ja1R5cGUsIERlY29yYXRpb24sIERpcmVjdGlvbiwgRWRpdG9yVmlldywgR3V0dGVyTWFya2VyLCBNYXRjaERlY29yYXRvciwgUmVjdGFuZ2xlTWFya2VyLCBWaWV3UGx1Z2luLCBWaWV3VXBkYXRlLCBXaWRnZXRUeXBlLCBfX3Rlc3QsIGNsb3NlSG92ZXJUb29sdGlwcywgY3Jvc3NoYWlyQ3Vyc29yLCBkcmF3U2VsZWN0aW9uLCBkcm9wQ3Vyc29yLCBnZXRQYW5lbCwgZ2V0VG9vbHRpcCwgZ3V0dGVyLCBndXR0ZXJMaW5lQ2xhc3MsIGd1dHRlcnMsIGhhc0hvdmVyVG9vbHRpcHMsIGhpZ2hsaWdodEFjdGl2ZUxpbmUsIGhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIsIGhpZ2hsaWdodFNwZWNpYWxDaGFycywgaGlnaGxpZ2h0VHJhaWxpbmdXaGl0ZXNwYWNlLCBoaWdobGlnaHRXaGl0ZXNwYWNlLCBob3ZlclRvb2x0aXAsIGtleW1hcCwgbGF5ZXIsIGxpbmVOdW1iZXJNYXJrZXJzLCBsaW5lTnVtYmVycywgbG9nRXhjZXB0aW9uLCBwYW5lbHMsIHBsYWNlaG9sZGVyLCByZWN0YW5ndWxhclNlbGVjdGlvbiwgcmVwb3NpdGlvblRvb2x0aXBzLCBydW5TY29wZUhhbmRsZXJzLCBzY3JvbGxQYXN0RW5kLCBzaG93UGFuZWwsIHNob3dUb29sdGlwLCB0b29sdGlwcyB9O1xuIiwgIi8vIEZJWE1FIHByb2ZpbGUgYWRkaW5nIGEgcGVyLVRyZWUgVHJlZU5vZGUgY2FjaGUsIHZhbGlkYXRpbmcgaXQgYnlcbi8vIHBhcmVudCBwb2ludGVyXG4vLy8gVGhlIGRlZmF1bHQgbWF4aW11bSBsZW5ndGggb2YgYSBgVHJlZUJ1ZmZlcmAgbm9kZS5cbmNvbnN0IERlZmF1bHRCdWZmZXJMZW5ndGggPSAxMDI0O1xubGV0IG5leHRQcm9wSUQgPSAwO1xuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG4vLy8gRWFjaCBbbm9kZSB0eXBlXSgjY29tbW9uLk5vZGVUeXBlKSBvciBbaW5kaXZpZHVhbCB0cmVlXSgjY29tbW9uLlRyZWUpXG4vLy8gY2FuIGhhdmUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGl0IGluIHByb3BzLiBJbnN0YW5jZXMgb2YgdGhpc1xuLy8vIGNsYXNzIHJlcHJlc2VudCBwcm9wIG5hbWVzLlxuY2xhc3MgTm9kZVByb3Age1xuICAgIC8vLyBDcmVhdGUgYSBuZXcgbm9kZSBwcm9wIHR5cGUuXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5wZXJOb2RlID0gISFjb25maWcucGVyTm9kZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vLyBUaGlzIGlzIG1lYW50IHRvIGJlIHVzZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVTZXQuZXh0ZW5kYF0oI2NvbW1vbi5Ob2RlU2V0LmV4dGVuZCkgb3JcbiAgICAvLy8gW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXG4gICAgLy8vIHByb3AgdmFsdWVzIGZvciBlYWNoIG5vZGUgdHlwZSBpbiB0aGUgc2V0LiBUYWtlcyBhIFttYXRjaFxuICAgIC8vLyBvYmplY3RdKCNjb21tb24uTm9kZVR5cGVebWF0Y2gpIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB1bmRlZmluZWRcbiAgICAvLy8gaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgLy8vIGl0IGRvZXMuXG4gICAgYWRkKG1hdGNoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlck5vZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IGFkZCBwZXItbm9kZSBwcm9wcyB0byBub2RlIHR5cGVzXCIpO1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIG1hdGNoID0gTm9kZVR5cGUubWF0Y2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtYXRjaCh0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBbdGhpcywgcmVzdWx0XTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gUHJvcCB0aGF0IGlzIHVzZWQgdG8gZGVzY3JpYmUgbWF0Y2hpbmcgZGVsaW1pdGVycy4gRm9yIG9wZW5pbmdcbi8vLyBkZWxpbWl0ZXJzLCB0aGlzIGhvbGRzIGFuIGFycmF5IG9mIG5vZGUgbmFtZXMgKHdyaXR0ZW4gYXMgYVxuLy8vIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbi8vLyBmb3IgdGhlIG5vZGUgdHlwZXMgb2YgY2xvc2luZyBkZWxpbWl0ZXJzIHRoYXQgbWF0Y2ggaXQuXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBUaGUgaW52ZXJzZSBvZiBbYGNsb3NlZEJ5YF0oI2NvbW1vbi5Ob2RlUHJvcF5jbG9zZWRCeSkuIFRoaXMgaXNcbi8vLyBhdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xuLy8vIG9mIHR5cGVzIG9mIG1hdGNoaW5nIG9wZW5pbmcgZGVsaW1pdGVycy5cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFVzZWQgdG8gYXNzaWduIG5vZGUgdHlwZXMgdG8gZ3JvdXBzIChmb3IgZXhhbXBsZSwgYWxsIG5vZGVcbi8vLyB0eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG4vLy8gYFwiRXhwcmVzc2lvblwiYCBncm91cCkuXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBUaGUgaGFzaCBvZiB0aGUgW2NvbnRleHRdKCNsci5Db250ZXh0VHJhY2tlci5jb25zdHJ1Y3Rvcilcbi8vLyB0aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxuLy8vIGNvbnRleHR1YWwgbm9kZXMuXG5Ob2RlUHJvcC5jb250ZXh0SGFzaCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vLy8gVGhlIGRpc3RhbmNlIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBub2RlIHRoYXQgdGhlIHRva2VuaXplclxuLy8vIGxvb2tlZCBhaGVhZCBmb3IgYW55IG9mIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBub2RlLiAoVGhlIExSXG4vLy8gcGFyc2VyIG9ubHkgc3RvcmVzIHRoaXMgd2hlbiBpdCBpcyBsYXJnZXIgdGhhbiAyNSwgZm9yXG4vLy8gZWZmaWNpZW5jeSByZWFzb25zLilcbk5vZGVQcm9wLmxvb2tBaGVhZCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vLy8gVGhpcyBwZXItbm9kZSBwcm9wIGlzIHVzZWQgdG8gcmVwbGFjZSBhIGdpdmVuIG5vZGUsIG9yIHBhcnQgb2YgYVxuLy8vIG5vZGUsIHdpdGggYW5vdGhlciB0cmVlLiBUaGlzIGlzIHVzZWZ1bCB0byBpbmNsdWRlIHRyZWVzIGZyb21cbi8vLyBkaWZmZXJlbnQgbGFuZ3VhZ2VzIGluIG1peGVkLWxhbmd1YWdlIHBhcnNlcnMuXG5Ob2RlUHJvcC5tb3VudGVkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8vLyBBIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cbi8vLyBhIHRyZWUgbm9kZSB0byBpbmRpY2F0ZSB0aGF0IHBhcnRzIG9mIGl0cyBjb250ZW50IGFyZVxuLy8vIHJlcHJlc2VudGVkIGJ5IGFub3RoZXIgdHJlZS5cbmNsYXNzIE1vdW50ZWRUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIGlubmVyIHRyZWUuXG4gICAgdHJlZSwgXG4gICAgLy8vIElmIHRoaXMgaXMgbnVsbCwgdGhpcyB0cmVlIHJlcGxhY2VzIHRoZSBlbnRpcmUgbm9kZSAoaXQgd2lsbFxuICAgIC8vLyBiZSBpbmNsdWRlZCBpbiB0aGUgcmVndWxhciBpdGVyYXRpb24gaW5zdGVhZCBvZiBpdHMgaG9zdFxuICAgIC8vLyBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcbiAgICAvLy8gY292ZXJlZCBieSB0aGlzIHRyZWUuIFRoaXMgaXMgdXNlZCBmb3IgdHJlZXMgdGhhdCBhcmUgbWl4ZWQgaW5cbiAgICAvLy8gYSB3YXkgdGhhdCBpc24ndCBzdHJpY3RseSBoaWVyYXJjaGljYWwuIFN1Y2ggbW91bnRlZCB0cmVlcyBhcmVcbiAgICAvLy8gb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcbiAgICAvLy8gYW5kIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLlxuICAgIG92ZXJsYXksIFxuICAgIC8vLyBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cbiAgICBwYXJzZXIpIHtcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxufVxuY29uc3Qgbm9Qcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vLy8gRWFjaCBub2RlIGluIGEgc3ludGF4IHRyZWUgaGFzIGEgbm9kZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCBpdC5cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUuIE5vdCBuZWNlc3NhcmlseSB1bmlxdWUsIGJ1dCBpZiB0aGVcbiAgICAvLy8gZ3JhbW1hciB3YXMgd3JpdHRlbiBwcm9wZXJseSwgZGlmZmVyZW50IG5vZGUgdHlwZXMgd2l0aCB0aGVcbiAgICAvLy8gc2FtZSBuYW1lIHdpdGhpbiBhIG5vZGUgc2V0IHNob3VsZCBwbGF5IHRoZSBzYW1lIHNlbWFudGljXG4gICAgLy8vIHJvbGUuXG4gICAgbmFtZSwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHByb3BzLCBcbiAgICAvLy8gVGhlIGlkIG9mIHRoaXMgbm9kZSBpbiBpdHMgc2V0LiBDb3JyZXNwb25kcyB0byB0aGUgdGVybSBpZHNcbiAgICAvLy8gdXNlZCBpbiB0aGUgcGFyc2VyLlxuICAgIGlkLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgZmxhZ3MgPSAwKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIC8vLyBEZWZpbmUgYSBub2RlIHR5cGUuXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHNwZWMucHJvcHMgJiYgc3BlYy5wcm9wcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbm9Qcm9wcztcbiAgICAgICAgbGV0IGZsYWdzID0gKHNwZWMudG9wID8gMSAvKiBOb2RlRmxhZy5Ub3AgKi8gOiAwKSB8IChzcGVjLnNraXBwZWQgPyAyIC8qIE5vZGVGbGFnLlNraXBwZWQgKi8gOiAwKSB8XG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogTm9kZUZsYWcuRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovIDogMCk7XG4gICAgICAgIGxldCB0eXBlID0gbmV3IE5vZGVUeXBlKHNwZWMubmFtZSB8fCBcIlwiLCBwcm9wcywgc3BlYy5pZCwgZmxhZ3MpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYyh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNbMF0ucGVyTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3Qgc3RvcmUgYSBwZXItbm9kZSBwcm9wIG9uIGEgbm9kZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tzcmNbMF0uaWRdID0gc3JjWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIC8vLyBSZXRyaWV2ZXMgYSBub2RlIHByb3AgZm9yIHRoaXMgdHlwZS4gV2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaWZcbiAgICAvLy8gdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgcHJvcChwcm9wKSB7IHJldHVybiB0aGlzLnByb3BzW3Byb3AuaWRdOyB9XG4gICAgLy8vIFRydWUgd2hlbiB0aGlzIGlzIHRoZSB0b3Agbm9kZSBvZiBhIGdyYW1tYXIuXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIE5vZGVGbGFnLlRvcCAqLykgPiAwOyB9XG4gICAgLy8vIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgcHJvZHVjZWQgYnkgYSBza2lwIHJ1bGUuXG4gICAgZ2V0IGlzU2tpcHBlZCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBOb2RlRmxhZy5Ta2lwcGVkICovKSA+IDA7IH1cbiAgICAvLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgIGdldCBpc0Vycm9yKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIE5vZGVGbGFnLkVycm9yICovKSA+IDA7IH1cbiAgICAvLy8gV2hlbiB0cnVlLCB0aGlzIG5vZGUgdHlwZSBkb2Vzbid0IGNvcnJlc3BvbmQgdG8gYSB1c2VyLWRlY2xhcmVkXG4gICAgLy8vIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgIGdldCBpc0Fub255bW91cygpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8pID4gMDsgfVxuICAgIC8vLyBSZXR1cm5zIHRydWUgd2hlbiB0aGlzIG5vZGUncyBuYW1lIG9yIG9uZSBvZiBpdHNcbiAgICAvLy8gW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLnByb3AoTm9kZVByb3AuZ3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbmFtZTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGZ1bmN0aW9uIGZyb20gbm9kZSB0eXBlcyB0byBhcmJpdHJhcnkgdmFsdWVzIGJ5XG4gICAgLy8vIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgLy8vIFtncm91cF0oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXG4gICAgLy8vIFtgTm9kZVByb3AuYWRkYF0oI2NvbW1vbi5Ob2RlUHJvcC5hZGQpLiBZb3UgY2FuIHB1dCBtdWx0aXBsZVxuICAgIC8vLyBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICAvLy8gbXVsdGlwbGUgbm9kZSBuYW1lcyB0byBhIHNpbmdsZSB2YWx1ZS5cbiAgICBzdGF0aWMgbWF0Y2gobWFwKSB7XG4gICAgICAgIGxldCBkaXJlY3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG1hcClcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgZGlyZWN0W25hbWVdID0gbWFwW3Byb3BdO1xuICAgICAgICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGdyb3VwcyA9IG5vZGUucHJvcChOb2RlUHJvcC5ncm91cCksIGkgPSAtMTsgaSA8IChncm91cHMgPyBncm91cHMubGVuZ3RoIDogMCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGRpcmVjdFtpIDwgMCA/IG5vZGUubmFtZSA6IGdyb3Vwc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuLy8vIEFuIGVtcHR5IGR1bW15IG5vZGUgdHlwZSB0byB1c2Ugd2hlbiBubyBhY3R1YWwgdHlwZSBpcyBhdmFpbGFibGUuXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovKTtcbi8vLyBBIG5vZGUgc2V0IGhvbGRzIGEgY29sbGVjdGlvbiBvZiBub2RlIHR5cGVzLiBJdCBpcyB1c2VkIHRvXG4vLy8gY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG4vLy8gZnVsbCBwb2ludGVyIHRvIHRoZSB0eXBlIG9iamVjdCwgaW4gYSBudW1lcmljIGFycmF5LiBFYWNoIHBhcnNlclxuLy8vIFtoYXNdKCNsci5MUlBhcnNlci5ub2RlU2V0KSBhIG5vZGUgc2V0LCBhbmQgW3RyZWVcbi8vLyBidWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG4vLy8gZnJvbSB0aGUgc2FtZSBzZXQuIEEgc2V0IGNhbiBoYXZlIGEgbWF4aW11bSBvZiAyKioxNiAoNjU1MzYpIG5vZGVcbi8vLyB0eXBlcyBpbiBpdCwgc28gdGhhdCB0aGUgaWRzIGZpdCBpbnRvIDE2LWJpdCB0eXBlZCBhcnJheSBzbG90cy5cbmNsYXNzIE5vZGVTZXQge1xuICAgIC8vLyBDcmVhdGUgYSBzZXQgd2l0aCB0aGUgZ2l2ZW4gdHlwZXMuIFRoZSBgaWRgIHByb3BlcnR5IG9mIGVhY2hcbiAgICAvLy8gdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5vZGUgdHlwZXMgaW4gdGhpcyBzZXQsIGJ5IGlkLlxuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIHNldCB3aXRoIHNvbWUgbm9kZSBwcm9wZXJ0aWVzIGFkZGVkLiBUaGVcbiAgICAvLy8gYXJndW1lbnRzIHRvIHRoaXMgbWV0aG9kIGNhbiBiZSBjcmVhdGVkIHdpdGhcbiAgICAvLy8gW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgZXh0ZW5kKC4uLnByb3BzKSB7XG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gc291cmNlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW2FkZFswXS5pZF0gPSBhZGRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuY29uc3QgQ2FjaGVkTm9kZSA9IG5ldyBXZWFrTWFwKCksIENhY2hlZElubmVyTm9kZSA9IG5ldyBXZWFrTWFwKCk7XG4vLy8gT3B0aW9ucyB0aGF0IGNvbnRyb2wgaXRlcmF0aW9uLiBDYW4gYmUgY29tYmluZWQgd2l0aCB0aGUgYHxgXG4vLy8gb3BlcmF0b3IgdG8gZW5hYmxlIG11bHRpcGxlIG9uZXMuXG52YXIgSXRlck1vZGU7XG4oZnVuY3Rpb24gKEl0ZXJNb2RlKSB7XG4gICAgLy8vIFdoZW4gZW5hYmxlZCwgaXRlcmF0aW9uIHdpbGwgb25seSB2aXNpdCBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgLy8vIG9iamVjdHMsIG5vdCBub2RlcyBwYWNrZWQgaW50b1xuICAgIC8vLyBbYFRyZWVCdWZmZXJgXSgjY29tbW9uLlRyZWVCdWZmZXIpcy5cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkV4Y2x1ZGVCdWZmZXJzXCJdID0gMV0gPSBcIkV4Y2x1ZGVCdWZmZXJzXCI7XG4gICAgLy8vIEVuYWJsZSB0aGlzIHRvIG1ha2UgaXRlcmF0aW9uIGluY2x1ZGUgYW5vbnltb3VzIG5vZGVzIChzdWNoIGFzXG4gICAgLy8vIHRoZSBub2RlcyB0aGF0IHdyYXAgcmVwZWF0ZWQgZ3JhbW1hciBjb25zdHJ1Y3RzIGludG8gYSBiYWxhbmNlZFxuICAgIC8vLyB0cmVlKS5cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkluY2x1ZGVBbm9ueW1vdXNcIl0gPSAyXSA9IFwiSW5jbHVkZUFub255bW91c1wiO1xuICAgIC8vLyBCeSBkZWZhdWx0LCByZWd1bGFyIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIG5vZGVzXG4gICAgLy8vIHJlcGxhY2UgdGhlaXIgYmFzZSBub2RlIGluIGl0ZXJhdGlvbi4gRW5hYmxlIHRoaXMgdG8gaWdub3JlIHRoZW1cbiAgICAvLy8gaW5zdGVhZC5cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIklnbm9yZU1vdW50c1wiXSA9IDRdID0gXCJJZ25vcmVNb3VudHNcIjtcbiAgICAvLy8gVGhpcyBvcHRpb24gb25seSBhcHBsaWVzIGluXG4gICAgLy8vIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLXN0eWxlIG1ldGhvZHMuIEl0IHRlbGxzIHRoZVxuICAgIC8vLyBsaWJyYXJ5IHRvIG5vdCBlbnRlciBtb3VudGVkIG92ZXJsYXlzIGlmIG9uZSBjb3ZlcnMgdGhlIGdpdmVuXG4gICAgLy8vIHBvc2l0aW9uLlxuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSWdub3JlT3ZlcmxheXNcIl0gPSA4XSA9IFwiSWdub3JlT3ZlcmxheXNcIjtcbn0pKEl0ZXJNb2RlIHx8IChJdGVyTW9kZSA9IHt9KSk7XG4vLy8gQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXG4vLy8gdHJlZXM6IHRoZSB3YXkgdGhleSBhcmUgYWN0dWFsbHkgc3RvcmVkIGluIG1lbW9yeSwgYW5kIHRoZVxuLy8vIGNvbnZlbmllbnQgd2F5LlxuLy8vXG4vLy8gU3ludGF4IHRyZWVzIGFyZSBzdG9yZWQgYXMgYSB0cmVlIG9mIGBUcmVlYCBhbmQgYFRyZWVCdWZmZXJgXG4vLy8gb2JqZWN0cy4gQnkgcGFja2luZyBkZXRhaWwgaW5mb3JtYXRpb24gaW50byBgVHJlZUJ1ZmZlcmAgbGVhZlxuLy8vIG5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG4vLy9cbi8vLyBIb3dldmVyLCB3aGVuIHlvdSB3YW50IHRvIGFjdHVhbGx5IHdvcmsgd2l0aCB0cmVlIG5vZGVzLCB0aGlzXG4vLy8gcmVwcmVzZW50YXRpb24gaXMgdmVyeSBhd2t3YXJkLCBzbyBtb3N0IGNsaWVudCBjb2RlIHdpbGwgd2FudCB0b1xuLy8vIHVzZSB0aGUgW2BUcmVlQ3Vyc29yYF0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBvclxuLy8vIFtgU3ludGF4Tm9kZWBdKCNjb21tb24uU3ludGF4Tm9kZSkgaW50ZXJmYWNlIGluc3RlYWQsIHdoaWNoIHByb3ZpZGVzXG4vLy8gYSB2aWV3IG9uIHNvbWUgcGFydCBvZiB0aGlzIGRhdGEgc3RydWN0dXJlLCBhbmQgY2FuIGJlIHVzZWQgdG9cbi8vLyBtb3ZlIGFyb3VuZCB0byBhZGphY2VudCBub2Rlcy5cbmNsYXNzIFRyZWUge1xuICAgIC8vLyBDb25zdHJ1Y3QgYSBuZXcgdHJlZS4gU2VlIGFsc28gW2BUcmVlLmJ1aWxkYF0oI2NvbW1vbi5UcmVlXmJ1aWxkKS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHR5cGUgb2YgdGhlIHRvcCBub2RlLlxuICAgIHR5cGUsIFxuICAgIC8vLyBUaGlzIG5vZGUncyBjaGlsZCBub2Rlcy5cbiAgICBjaGlsZHJlbiwgXG4gICAgLy8vIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICAvLy8gdGhlIGNoaWxkcmVuLlxuICAgIHBvc2l0aW9ucywgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gUGVyLW5vZGUgW25vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3ApIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgbm9kZS5cbiAgICBwcm9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHByb3BzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHNbdHlwZW9mIHByb3AgPT0gXCJudW1iZXJcIiA/IHByb3AgOiBwcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSB0aGlzLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgIGlmIChtb3VudGVkICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICByZXR1cm4gbW91bnRlZC50cmVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBjaC50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gXCIsXCI7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdGhpcy50eXBlLm5hbWUgPyBjaGlsZHJlbiA6XG4gICAgICAgICAgICAoL1xcVy8udGVzdCh0aGlzLnR5cGUubmFtZSkgJiYgIXRoaXMudHlwZS5pc0Vycm9yID8gSlNPTi5zdHJpbmdpZnkodGhpcy50eXBlLm5hbWUpIDogdGhpcy50eXBlLm5hbWUpICtcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyBjaGlsZHJlbiArIFwiKVwiIDogXCJcIik7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9zaXRpb25lZCBhdCB0aGUgdG9wIG9mXG4gICAgLy8vIHRoZSB0cmVlLiBNb2RlIGNhbiBiZSB1c2VkIHRvIFtjb250cm9sXSgjY29tbW9uLkl0ZXJNb2RlKSB3aGljaFxuICAgIC8vLyBub2RlcyB0aGUgY3Vyc29yIHZpc2l0cy5cbiAgICBjdXJzb3IobW9kZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMudG9wTm9kZSwgbW9kZSk7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9pbnRpbmcgaW50byB0aGlzIHRyZWVcbiAgICAvLy8gYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBzaWRlIChzZWVcbiAgICAvLy8gW2Btb3ZlVG9gXSgjY29tbW9uLlRyZWVDdXJzb3IubW92ZVRvKS5cbiAgICBjdXJzb3JBdChwb3MsIHNpZGUgPSAwLCBtb2RlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSBDYWNoZWROb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGU7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihzY29wZSk7XG4gICAgICAgIGN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgY3Vyc29yLl90cmVlKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICB9XG4gICAgLy8vIEdldCBhIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBvYmplY3QgZm9yIHRoZSB0b3Agb2YgdGhlXG4gICAgLy8vIHRyZWUuXG4gICAgZ2V0IHRvcE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUodGhpcywgMCwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgLy8vIElmIGBzaWRlYCBpcyAtMSwgdGhpcyB3aWxsIG1vdmUgaW50byBub2RlcyB0aGF0IGVuZCBhdCB0aGVcbiAgICAvLy8gcG9zaXRpb24uIElmIDEsIGl0J2xsIG1vdmUgaW50byBub2RlcyB0aGF0IHN0YXJ0IGF0IHRoZVxuICAgIC8vLyBwb3NpdGlvbi4gV2l0aCAwLCBpdCdsbCBvbmx5IGVudGVyIG5vZGVzIHRoYXQgY292ZXIgdGhlIHBvc2l0aW9uXG4gICAgLy8vIGZyb20gYm90aCBzaWRlcy5cbiAgICAvLy9cbiAgICAvLy8gTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgZW50ZXJcbiAgICAvLy8gW292ZXJsYXlzXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpLCBhbmQgeW91IG9mdGVuIHdhbnRcbiAgICAvLy8gW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKSBpbnN0ZWFkLlxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZSwgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLy8vIExpa2UgW2ByZXNvbHZlYF0oI2NvbW1vbi5UcmVlLnJlc29sdmUpLCBidXQgd2lsbCBlbnRlclxuICAgIC8vLyBbb3ZlcmxhaWRdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSkgbm9kZXMsIHByb2R1Y2luZyBhIHN5bnRheCBub2RlXG4gICAgLy8vIHBvaW50aW5nIGludG8gdGhlIGlubmVybW9zdCBvdmVybGFpZCB0cmVlIGF0IHRoZSBnaXZlbiBwb3NpdGlvblxuICAgIC8vLyAod2l0aCBwYXJlbnQgbGlua3MgZ29pbmcgdGhyb3VnaCBhbGwgcGFyZW50IHN0cnVjdHVyZSwgaW5jbHVkaW5nXG4gICAgLy8vIHRoZSBob3N0IHRyZWVzKS5cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZElubmVyTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgICAgICBDYWNoZWRJbm5lck5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLy8vIEl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBhbmQgaXRzIGNoaWxkcmVuLCBjYWxsaW5nIGBlbnRlcmAgZm9yIGFueVxuICAgIC8vLyBub2RlIHRoYXQgdG91Y2hlcyB0aGUgYGZyb21gL2B0b2AgcmVnaW9uIChpZiBnaXZlbikgYmVmb3JlXG4gICAgLy8vIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICAvLy8gbGVhdmluZyB0aGUgbm9kZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgdGhhdCBub2RlIHdpbGxcbiAgICAvLy8gbm90IGhhdmUgaXRzIGNoaWxkcmVuIGl0ZXJhdGVkIG92ZXIgKG9yIGBsZWF2ZWAgY2FsbGVkKS5cbiAgICBpdGVyYXRlKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgZW50ZXIsIGxlYXZlLCBmcm9tID0gMCwgdG8gPSB0aGlzLmxlbmd0aCB9ID0gc3BlYztcbiAgICAgICAgZm9yIChsZXQgYyA9IHRoaXMuY3Vyc29yKChzcGVjLm1vZGUgfHwgMCkgfCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKTs7KSB7XG4gICAgICAgICAgICBsZXQgZW50ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGMuZnJvbSA8PSB0byAmJiBjLnRvID49IGZyb20gJiYgKGMudHlwZS5pc0Fub255bW91cyB8fCBlbnRlcihjKSAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuZmlyc3RDaGlsZCgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50ZXJlZCAmJiBsZWF2ZSAmJiAhYy50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjKTtcbiAgICAgICAgICAgICAgICBpZiAoYy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gW25vZGUgcHJvcF0oI2NvbW1vbi5Ob2RlUHJvcCkgZm9yIHRoaXNcbiAgICAvLy8gbm9kZS4gV29ya3Mgd2l0aCBib3RoIHBlci1ub2RlIGFuZCBwZXItdHlwZSBwcm9wcy5cbiAgICBwcm9wKHByb3ApIHtcbiAgICAgICAgcmV0dXJuICFwcm9wLnBlck5vZGUgPyB0aGlzLnR5cGUucHJvcChwcm9wKSA6IHRoaXMucHJvcHMgPyB0aGlzLnByb3BzW3Byb3AuaWRdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLy8gUmV0dXJucyB0aGUgbm9kZSdzIFtwZXItbm9kZSBwcm9wc10oI2NvbW1vbi5Ob2RlUHJvcC5wZXJOb2RlKSBpbiBhXG4gICAgLy8vIGZvcm1hdCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIFtgVHJlZWBdKCNjb21tb24uVHJlZSlcbiAgICAvLy8gY29uc3RydWN0b3IuXG4gICAgZ2V0IHByb3BWYWx1ZXMoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnByb3BzKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFsraWQsIHRoaXMucHJvcHNbaWRdXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vLyBCYWxhbmNlIHRoZSBkaXJlY3QgY2hpbGRyZW4gb2YgdGhpcyB0cmVlLCBwcm9kdWNpbmcgYSBjb3B5IG9mXG4gICAgLy8vIHdoaWNoIG1heSBoYXZlIGNoaWxkcmVuIGdyb3VwZWQgaW50byBzdWJ0cmVlcyB3aXRoIHR5cGVcbiAgICAvLy8gW2BOb2RlVHlwZS5ub25lYF0oI2NvbW1vbi5Ob2RlVHlwZV5ub25lKS5cbiAgICBiYWxhbmNlKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSA4IC8qIEJhbGFuY2UuQnJhbmNoRmFjdG9yICovID8gdGhpcyA6XG4gICAgICAgICAgICBiYWxhbmNlUmFuZ2UoTm9kZVR5cGUubm9uZSwgdGhpcy5jaGlsZHJlbiwgdGhpcy5wb3NpdGlvbnMsIDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoLCAwLCB0aGlzLmxlbmd0aCwgKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4gbmV3IFRyZWUodGhpcy50eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIHRoaXMucHJvcFZhbHVlcyksIGNvbmZpZy5tYWtlVHJlZSB8fCAoKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSkpO1xuICAgIH1cbiAgICAvLy8gQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgLy8vIG9yIGEgY3Vyc29yIG92ZXIgc3VjaCBhIGJ1ZmZlci5cbiAgICBzdGF0aWMgYnVpbGQoZGF0YSkgeyByZXR1cm4gYnVpbGRUcmVlKGRhdGEpOyB9XG59XG4vLy8gVGhlIGVtcHR5IHRyZWVcblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbi8vLyBUcmVlIGJ1ZmZlcnMgY29udGFpbiAodHlwZSwgc3RhcnQsIGVuZCwgZW5kSW5kZXgpIHF1YWRzIGZvciBlYWNoXG4vLy8gbm9kZS4gSW4gc3VjaCBhIGJ1ZmZlciwgbm9kZXMgYXJlIHN0b3JlZCBpbiBwcmVmaXggb3JkZXIgKHBhcmVudHNcbi8vLyBiZWZvcmUgY2hpbGRyZW4sIHdpdGggdGhlIGVuZEluZGV4IG9mIHRoZSBwYXJlbnQgaW5kaWNhdGluZyB3aGljaFxuLy8vIGNoaWxkcmVuIGJlbG9uZyB0byBpdCkuXG5jbGFzcyBUcmVlQnVmZmVyIHtcbiAgICAvLy8gQ3JlYXRlIGEgdHJlZSBidWZmZXIuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBidWZmZXIncyBjb250ZW50LlxuICAgIGJ1ZmZlciwgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gVGhlIG5vZGUgc2V0IHVzZWQgaW4gdGhpcyBidWZmZXIuXG4gICAgc2V0KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIE5vZGVUeXBlLm5vbmU7IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZpbmRDaGlsZChzdGFydEluZGV4LCBlbmRJbmRleCwgZGlyLCBwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLCBwaWNrID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpICE9IGVuZEluZGV4OyBpID0gYnVmZmVyW2kgKyAzXSkge1xuICAgICAgICAgICAgaWYgKGNoZWNrU2lkZShzaWRlLCBwb3MsIGJ1ZmZlcltpICsgMV0sIGJ1ZmZlcltpICsgMl0pKSB7XG4gICAgICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWNrO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tKSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBjb3B5ID0gbmV3IFVpbnQxNkFycmF5KGVuZEkgLSBzdGFydEkpLCBsZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJLCBqID0gMDsgaSA8IGVuZEk7KSB7XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK107XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgbGV0IHRvID0gY29weVtqKytdID0gYltpKytdIC0gZnJvbTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIHN0YXJ0STtcbiAgICAgICAgICAgIGxlbiA9IE1hdGgubWF4KGxlbiwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUJ1ZmZlcihjb3B5LCBsZW4sIHRoaXMuc2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NpZGUoc2lkZSwgcG9zLCBmcm9tLCB0bykge1xuICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlIC0yIC8qIFNpZGUuQmVmb3JlICovOiByZXR1cm4gZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAtMSAvKiBTaWRlLkF0T3JCZWZvcmUgKi86IHJldHVybiB0byA+PSBwb3MgJiYgZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAwIC8qIFNpZGUuQXJvdW5kICovOiByZXR1cm4gZnJvbSA8IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAxIC8qIFNpZGUuQXRPckFmdGVyICovOiByZXR1cm4gZnJvbSA8PSBwb3MgJiYgdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgMiAvKiBTaWRlLkFmdGVyICovOiByZXR1cm4gdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgNCAvKiBTaWRlLkRvbnRDYXJlICovOiByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShub2RlLCBwb3MpIHtcbiAgICBsZXQgc2NhbiA9IG5vZGUuY2hpbGRCZWZvcmUocG9zKTtcbiAgICB3aGlsZSAoc2Nhbikge1xuICAgICAgICBsZXQgbGFzdCA9IHNjYW4ubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC50byAhPSBzY2FuLnRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChsYXN0LnR5cGUuaXNFcnJvciAmJiBsYXN0LmZyb20gPT0gbGFzdC50bykge1xuICAgICAgICAgICAgbm9kZSA9IHNjYW47XG4gICAgICAgICAgICBzY2FuID0gbGFzdC5wcmV2U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjYW4gPSBsYXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU5vZGUobm9kZSwgcG9zLCBzaWRlLCBvdmVybGF5cykge1xuICAgIHZhciBfYTtcbiAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICB3aGlsZSAobm9kZS5mcm9tID09IG5vZGUudG8gfHxcbiAgICAgICAgKHNpZGUgPCAxID8gbm9kZS5mcm9tID49IHBvcyA6IG5vZGUuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgKHNpZGUgPiAtMSA/IG5vZGUudG8gPD0gcG9zIDogbm9kZS50byA8IHBvcykpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICFvdmVybGF5cyAmJiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgbm9kZS5pbmRleCA8IDAgPyBudWxsIDogbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGxldCBtb2RlID0gb3ZlcmxheXMgPyAwIDogSXRlck1vZGUuSWdub3JlT3ZlcmxheXM7XG4gICAgLy8gTXVzdCBnbyB1cCBvdXQgb2Ygb3ZlcmxheXMgd2hlbiB0aG9zZSBkbyBub3Qgb3ZlcmxhcCB3aXRoIHBvc1xuICAgIGlmIChvdmVybGF5cylcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IG5vZGUsIHBhcmVudCA9IHNjYW4ucGFyZW50OyBwYXJlbnQ7IHNjYW4gPSBwYXJlbnQsIHBhcmVudCA9IHNjYW4ucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoc2NhbiBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIHNjYW4uaW5kZXggPCAwICYmICgoX2EgPSBwYXJlbnQuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZyb20pICE9IHNjYW4uZnJvbSlcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgaW5uZXIgPSBub2RlLmVudGVyKHBvcywgc2lkZSwgbW9kZSk7XG4gICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IGlubmVyO1xuICAgIH1cbn1cbmNsYXNzIFRyZWVOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihfdHJlZSwgZnJvbSwgXG4gICAgLy8gSW5kZXggaW4gcGFyZW50IG5vZGUsIHNldCB0byAtMSBpZiB0aGUgbm9kZSBpcyBub3QgYSBkaXJlY3QgY2hpbGQgb2YgX3BhcmVudC5ub2RlIChvdmVybGF5KVxuICAgIGluZGV4LCBfcGFyZW50KSB7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBfdHJlZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWUudHlwZTsgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50eXBlLm5hbWU7IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLl90cmVlLmxlbmd0aDsgfVxuICAgIG5leHRDaGlsZChpLCBkaXIsIHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IGNoaWxkcmVuLCBwb3NpdGlvbnMgfSA9IHBhcmVudC5fdHJlZSwgZSA9IGRpciA+IDAgPyBjaGlsZHJlbi5sZW5ndGggOiAtMTsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baV0sIHN0YXJ0ID0gcG9zaXRpb25zW2ldICsgcGFyZW50LmZyb207XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja1NpZGUoc2lkZSwgcG9zLCBzdGFydCwgc3RhcnQgKyBuZXh0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSAmIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IG5leHQuZmluZENoaWxkKDAsIG5leHQuYnVmZmVyLmxlbmd0aCwgZGlyLCBwb3MgLSBzdGFydCwgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKG5ldyBCdWZmZXJDb250ZXh0KHBhcmVudCwgbmV4dCwgaSwgc3RhcnQpLCBudWxsLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlTW91bnRzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5wcm9wcyAmJiAobW91bnRlZCA9IG5leHQucHJvcChOb2RlUHJvcC5tb3VudGVkKSkgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyID0gbmV3IFRyZWVOb2RlKG5leHQsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAhaW5uZXIudHlwZS5pc0Fub255bW91cyA/IGlubmVyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlubmVyLm5leHRDaGlsZChkaXIgPCAwID8gbmV4dC5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICFwYXJlbnQudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaW5kZXggPj0gMClcbiAgICAgICAgICAgICAgICBpID0gcGFyZW50LmluZGV4ICsgZGlyO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGkgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3BhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlT3ZlcmxheXMpICYmIChtb3VudGVkID0gdGhpcy5fdHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpKSAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCByUG9zID0gcG9zIC0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA+IDAgPyBmcm9tIDw9IHJQb3MgOiBmcm9tIDwgclBvcykgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNpZGUgPCAwID8gdG8gPj0gclBvcyA6IHRvID4gclBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHRoaXMuZnJvbSwgLTEsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIHNpZGUsIG1vZGUpO1xuICAgIH1cbiAgICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXG4gICAgICAgICAgICB2YWwgPSB2YWwuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggKyAxLCAxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLCBtb2RlKTsgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIHRvVHJlZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWU7IH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7IHJldHVybiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZSh0aGlzLCBwb3MpOyB9XG4gICAgZ2V0Q2hpbGQodHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIGxldCByID0gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICAgIHJldHVybiByLmxlbmd0aCA/IHJbMF0gOiBudWxsO1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbih0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7IH1cbiAgICBnZXQgbm9kZSgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkgeyByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLCBjb250ZXh0KTsgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obm9kZSwgdHlwZSwgYmVmb3JlLCBhZnRlcikge1xuICAgIGxldCBjdXIgPSBub2RlLmN1cnNvcigpLCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIWN1ci5maXJzdENoaWxkKCkpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGJlZm9yZSAhPSBudWxsKVxuICAgICAgICB3aGlsZSAoIWN1ci50eXBlLmlzKGJlZm9yZSkpXG4gICAgICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoYWZ0ZXIgIT0gbnVsbCAmJiBjdXIudHlwZS5pcyhhZnRlcikpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoY3VyLnR5cGUuaXModHlwZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXIubm9kZSk7XG4gICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIgPT0gbnVsbCA/IHJlc3VsdCA6IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hdGNoTm9kZUNvbnRleHQobm9kZSwgY29udGV4dCwgaSA9IGNvbnRleHQubGVuZ3RoIC0gMSkge1xuICAgIGZvciAobGV0IHAgPSBub2RlLnBhcmVudDsgaSA+PSAwOyBwID0gcC5wYXJlbnQpIHtcbiAgICAgICAgaWYgKCFwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXAudHlwZS5pc0Fub255bW91cykge1xuICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSBwLm5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgQnVmZmVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBidWZmZXIsIGluZGV4LCBzdGFydCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlck5vZGUge1xuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTsgfVxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBjaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBzaWRlID4gMCA/IDEgOiAtMSwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBjdXJzb3IobW9kZSA9IDApIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMsIG1vZGUpOyB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiBudWxsOyB9XG4gICAgdG9UcmVlKCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgc3RhcnRJID0gdGhpcy5pbmRleCArIDQsIGVuZEkgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgaWYgKGVuZEkgPiBzdGFydEkpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGJ1ZmZlci5zbGljZShzdGFydEksIGVuZEksIGZyb20pKTtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIHRoaXMudG8gLSB0aGlzLmZyb20pO1xuICAgIH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7IHJldHVybiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZSh0aGlzLCBwb3MpOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgZ2V0IG5vZGUoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgbWF0Y2hDb250ZXh0KGNvbnRleHQpIHsgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcywgY29udGV4dCk7IH1cbn1cbi8vLyBBIHRyZWUgY3Vyc29yIG9iamVjdCBmb2N1c2VzIG9uIGEgZ2l2ZW4gbm9kZSBpbiBhIHN5bnRheCB0cmVlLCBhbmRcbi8vLyBhbGxvd3MgeW91IHRvIG1vdmUgdG8gYWRqYWNlbnQgbm9kZXMuXG5jbGFzcyBUcmVlQ3Vyc29yIHtcbiAgICAvLy8gU2hvcnRoYW5kIGZvciBgLnR5cGUubmFtZWAuXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgbW9kZSA9IDApIHtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbnVsbDtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlID0gbm9kZS5jb250ZXh0LnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbm9kZS5jb250ZXh0O1xuICAgICAgICAgICAgZm9yIChsZXQgbiA9IG5vZGUuX3BhcmVudDsgbjsgbiA9IG4uX3BhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnVuc2hpZnQobi5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy55aWVsZEJ1Zihub2RlLmluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB5aWVsZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBub2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IG5vZGUuZnJvbTtcbiAgICAgICAgdGhpcy50byA9IG5vZGUudG87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZEJ1ZihpbmRleCwgdHlwZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IGJ1ZmZlci5zZXQudHlwZXNbYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgICAgICB0aGlzLmZyb20gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAxXTtcbiAgICAgICAgdGhpcy50byA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDJdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGQobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCwgbm9kZS50eXBlKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCkgOiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUsIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmJ1ZmZlci5zdGFydCwgc2lkZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLiBXaGVuIHRoaXMgcmV0dXJuc1xuICAgIC8vLyBmYWxzZSwgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBhbmQgdGhlIGN1cnNvciBoYXMgbm90IGJlZW4gbW92ZWQuXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLlxuICAgIGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgZW5kcyBhZnRlciBgcG9zYC5cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBsYXN0IGNoaWxkIHRoYXQgc3RhcnRzIGJlZm9yZSBgcG9zYC5cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBjaGlsZCBhcm91bmQgYHBvc2AuIElmIHNpZGUgaXMgLTEgdGhlXG4gICAgLy8vIGNoaWxkIG1heSBlbmQgYXQgdGhhdCBwb3NpdGlvbiwgd2hlbiAxIGl0IG1heSBzdGFydCB0aGVyZS4gVGhpc1xuICAgIC8vLyB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgLy8vIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRyZWVzIHVubGVzcyBgb3ZlcmxheXNgIGlzXG4gICAgLy8vIHNldCB0byBmYWxzZS5cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSB0aGlzLm1vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSk7XG4gICAgICAgIHJldHVybiBtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMgPyBmYWxzZSA6IHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbm9kZSdzIHBhcmVudCBub2RlLCBpZiB0aGlzIGlzbid0IHRoZSB0b3Agbm9kZS5cbiAgICBwYXJlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUoKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpID8gdGhpcy5fdHJlZS5fcGFyZW50IDogdGhpcy5fdHJlZS5wYXJlbnQpO1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1Zih0aGlzLnN0YWNrLnBvcCgpKTtcbiAgICAgICAgbGV0IHBhcmVudCA9ICh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuYnVmZmVyLnBhcmVudCA6IHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUocGFyZW50KTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNpYmxpbmcoZGlyKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX3RyZWUuX3BhcmVudCA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuaW5kZXggPCAwID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX3RyZWUuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5fdHJlZS5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8sIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoZGlyIDwgMCkge1xuICAgICAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gZCA8IDAgPyAwIDogdGhpcy5zdGFja1tkXSArIDQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCAhPSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgICAgIGlmIChhZnRlciA8IChkIDwgMCA/IGJ1ZmZlci5idWZmZXIubGVuZ3RoIDogYnVmZmVyLmJ1ZmZlclt0aGlzLnN0YWNrW2RdICsgM10pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZCA8IDAgPyB0aGlzLnlpZWxkKHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0Q2hpbGQodGhpcy5idWZmZXIuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovLCB0aGlzLm1vZGUpKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGlzIG5vZGUncyBuZXh0IHNpYmxpbmcsIGlmIGFueS5cbiAgICBuZXh0U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygxKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoaXMgbm9kZSdzIHByZXZpb3VzIHNpYmxpbmcsIGlmIGFueS5cbiAgICBwcmV2U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygtMSk7IH1cbiAgICBhdExhc3ROb2RlKGRpcikge1xuICAgICAgICBsZXQgaW5kZXgsIHBhcmVudCwgeyBidWZmZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPCBidWZmZXIuYnVmZmVyLmJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmRleDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLmJ1ZmZlci5idWZmZXJbaSArIDNdIDwgdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICh7IGluZGV4LCBwYXJlbnQgfSA9IGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSB0aGlzLl90cmVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgcGFyZW50OyB7IGluZGV4LCBfcGFyZW50OiBwYXJlbnQgfSA9IHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4ICsgZGlyLCBlID0gZGlyIDwgMCA/IC0xIDogcGFyZW50Ll90cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQuX3RyZWUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWNoaWxkLnR5cGUuaXNBbm9ueW1vdXMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoaWxkKGNoaWxkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG1vdmUoZGlyLCBlbnRlcikge1xuICAgICAgICBpZiAoZW50ZXIgJiYgdGhpcy5lbnRlckNoaWxkKGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaWJsaW5nKGRpcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5hdExhc3ROb2RlKGRpcikgfHwgIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYVxuICAgIC8vLyBbcHJlLW9yZGVyXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmVlX3RyYXZlcnNhbCNQcmUtb3JkZXIsX05MUilcbiAgICAvLy8gdHJhdmVyc2FsLCBnb2luZyBmcm9tIGEgbm9kZSB0byBpdHMgZmlyc3QgY2hpbGQgb3IsIGlmIHRoZVxuICAgIC8vLyBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIC8vLyB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnQgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgbmV4dChlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgxLCBlbnRlcik7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcbiAgICAvLy8gbm9kZSBpcyBmb2xsb3dlZCBieSBpdHMgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIC8vLyBwcmV2aW91cyBzaWJsaW5nIG9yIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnRcbiAgICAvLy8gbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgcHJldihlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSwgZW50ZXIpOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgaW5uZXJtb3N0IG5vZGUgdGhhdCBjb3ZlcnMgYHBvc2AuIElmXG4gICAgLy8vIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcbiAgICAvLy8gaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IHN0YXJ0IGF0IGBwb3NgLlxuICAgIG1vdmVUbyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5mcm9tID09IHRoaXMudG8gfHxcbiAgICAgICAgICAgIChzaWRlIDwgMSA/IHRoaXMuZnJvbSA+PSBwb3MgOiB0aGlzLmZyb20gPiBwb3MpIHx8XG4gICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSlcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVGhlbiBzY2FuIGRvd24gaW50byBjaGlsZCBub2RlcyBhcyBmYXIgYXMgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICAvLy8gcG9zaXRpb24uXG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5idWZmZXJOb2RlLCByZXN1bHQgPSBudWxsLCBkZXB0aCA9IDA7XG4gICAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5jb250ZXh0ID09IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICBzY2FuOiBmb3IgKGxldCBpbmRleCA9IHRoaXMuaW5kZXgsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aDsgZCA+PSAwOykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjYWNoZTsgYzsgYyA9IGMuX3BhcmVudClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnN0YWNrWy0tZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlcHRoOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuc3RhY2tbaV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJOb2RlID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFt0cmVlXSgjY29tbW9uLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxuICAgIC8vLyBhbnkuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiB0aGUgbm9kZSBpcyBpbiBhIFt0cmVlXG4gICAgLy8vIGJ1ZmZlcl0oI2NvbW1vbi5UcmVlQnVmZmVyKS5cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUuX3RyZWU7XG4gICAgfVxuICAgIC8vLyBJdGVyYXRlIG92ZXIgdGhlIGN1cnJlbnQgbm9kZSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cywgY2FsbGluZ1xuICAgIC8vLyBgZW50ZXJgIHdoZW4gZW50ZXJpbmcgYSBub2RlIGFuZCBgbGVhdmVgLCBpZiBnaXZlbiwgd2hlbiBsZWF2aW5nXG4gICAgLy8vIG9uZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgYW55IGNoaWxkcmVuIG9mIHRoYXQgbm9kZSBhcmVcbiAgICAvLy8gc2tpcHBlZCwgYW5kIGBsZWF2ZWAgaXNuJ3QgY2FsbGVkIGZvciBpdC5cbiAgICBpdGVyYXRlKGVudGVyLCBsZWF2ZSkge1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG11c3RMZWF2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZS5pc0Fub255bW91cyB8fCBlbnRlcih0aGlzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChtdXN0TGVhdmUgJiYgbGVhdmUpXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKHRoaXMpO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRoaXMudHlwZS5pc0Fub255bW91cztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIFRlc3Qgd2hldGhlciB0aGUgY3VycmVudCBub2RlIG1hdGNoZXMgYSBnaXZlbiBjb250ZXh0XHUyMDE0YSBzZXF1ZW5jZVxuICAgIC8vLyBvZiBkaXJlY3QgcGFyZW50IG5vZGUgbmFtZXMuIEVtcHR5IHN0cmluZ3MgaW4gdGhlIGNvbnRleHQgYXJyYXlcbiAgICAvLy8gYXJlIHRyZWF0ZWQgYXMgd2lsZGNhcmRzLlxuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLm5vZGUsIGNvbnRleHQpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCB7IHR5cGVzIH0gPSBidWZmZXIuc2V0O1xuICAgICAgICBmb3IgKGxldCBpID0gY29udGV4dC5sZW5ndGggLSAxLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGQtLSkge1xuICAgICAgICAgICAgaWYgKGQgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMubm9kZSwgY29udGV4dCwgaSk7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2J1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXV1dO1xuICAgICAgICAgICAgaWYgKCF0eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSB0eXBlLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ2hpbGQodHJlZSkge1xuICAgIHJldHVybiB0cmVlLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8ICFjaC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKGNoKSk7XG59XG5mdW5jdGlvbiBidWlsZFRyZWUoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBidWZmZXIsIG5vZGVTZXQsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XG4gICAgbGV0IGN1cnNvciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IG5ldyBGbGF0QnVmZmVyQ3Vyc29yKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCkgOiBidWZmZXI7XG4gICAgbGV0IHR5cGVzID0gbm9kZVNldC50eXBlcztcbiAgICBsZXQgY29udGV4dEhhc2ggPSAwLCBsb29rQWhlYWQgPSAwO1xuICAgIGZ1bmN0aW9uIHRha2VOb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGluUmVwZWF0KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGxldCBsb29rQWhlYWRBdFN0YXJ0ID0gbG9va0FoZWFkO1xuICAgICAgICB3aGlsZSAoc2l6ZSA8IDApIHtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PSAtMSAvKiBTcGVjaWFsUmVjb3JkLlJldXNlICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSByZXVzZWRbaWRdO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQgLSBwYXJlbnRTdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBTcGVjaWFsUmVjb3JkLkNvbnRleHRDaGFuZ2UgKi8pIHsgLy8gQ29udGV4dCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogU3BlY2lhbFJlY29yZC5Mb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5yZWNvZ25pemVkIHJlY29yZCBzaXplOiAke3NpemV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpZF0sIG5vZGUsIGJ1ZmZlcjtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgaWYgKGVuZCAtIHN0YXJ0IDw9IG1heEJ1ZmZlckxlbmd0aCAmJiAoYnVmZmVyID0gZmluZEJ1ZmZlclNpemUoY3Vyc29yLnBvcyAtIG1pblBvcywgaW5SZXBlYXQpKSkge1xuICAgICAgICAgICAgLy8gU21hbGwgZW5vdWdoIGZvciBhIGJ1ZmZlciwgYW5kIG5vIHJldXNlZCBub2RlcyBpbnNpZGVcbiAgICAgICAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlci5zaXplIC0gYnVmZmVyLnNraXApO1xuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBidWZmZXIuc2l6ZSwgaW5kZXggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlci5zdGFydCwgZGF0YSwgaW5kZXgpO1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBUcmVlQnVmZmVyKGRhdGEsIGVuZCAtIGJ1ZmZlci5zdGFydCwgbm9kZVNldCk7XG4gICAgICAgICAgICBzdGFydFBvcyA9IGJ1ZmZlci5zdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBNYWtlIGl0IGEgbm9kZVxuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBzaXplO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgICAgICBsZXQgbG9jYWxJblJlcGVhdCA9IGlkID49IG1pblJlcGVhdFR5cGUgPyBpZCA6IC0xO1xuICAgICAgICAgICAgbGV0IGxhc3RHcm91cCA9IDAsIGxhc3RFbmQgPSBlbmQ7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID49IDAgJiYgY3Vyc29yLmlkID09IGxvY2FsSW5SZXBlYXQgJiYgY3Vyc29yLnNpemUgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmVuZCA8PSBsYXN0RW5kIC0gbWF4QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUmVwZWF0TGVhZihsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgc3RhcnQsIGxhc3RHcm91cCwgY3Vyc29yLmVuZCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0R3JvdXAgPSBsb2NhbENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RFbmQgPSBjdXJzb3IuZW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YWtlTm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbG9jYWxJblJlcGVhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBsYXN0R3JvdXAgPiAwICYmIGxhc3RHcm91cCA8IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIG1ha2VSZXBlYXRMZWFmKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBzdGFydCwgbGFzdEdyb3VwLCBzdGFydCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCk7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID4gLTEgJiYgbGFzdEdyb3VwID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBtYWtlID0gbWFrZUJhbGFuY2VkKHR5cGUpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBiYWxhbmNlUmFuZ2UodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIDAsIGxvY2FsQ2hpbGRyZW4ubGVuZ3RoLCAwLCBlbmQgLSBzdGFydCwgbWFrZSwgbWFrZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbWFrZVRyZWUodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGVuZCAtIHN0YXJ0LCBsb29rQWhlYWRBdFN0YXJ0IC0gZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydFBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VCYWxhbmNlZCh0eXBlKSB7XG4gICAgICAgIHJldHVybiAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbG9va0FoZWFkID0gMCwgbGFzdEkgPSBjaGlsZHJlbi5sZW5ndGggLSAxLCBsYXN0LCBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgaWYgKGxhc3RJID49IDAgJiYgKGxhc3QgPSBjaGlsZHJlbltsYXN0SV0pIGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmICghbGFzdEkgJiYgbGFzdC50eXBlID09IHR5cGUgJiYgbGFzdC5sZW5ndGggPT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgICAgICAgICBpZiAobG9va0FoZWFkUHJvcCA9IGxhc3QucHJvcChOb2RlUHJvcC5sb29rQWhlYWQpKVxuICAgICAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBwb3NpdGlvbnNbbGFzdEldICsgbGFzdC5sZW5ndGggKyBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVJlcGVhdExlYWYoY2hpbGRyZW4sIHBvc2l0aW9ucywgYmFzZSwgaSwgZnJvbSwgdG8sIHR5cGUsIGxvb2tBaGVhZCkge1xuICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB3aGlsZSAoY2hpbGRyZW4ubGVuZ3RoID4gaSkge1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuLnBvcCgpKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2gocG9zaXRpb25zLnBvcCgpICsgYmFzZSAtIGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobWFrZVRyZWUobm9kZVNldC50eXBlc1t0eXBlXSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHRvIC0gZnJvbSwgbG9va0FoZWFkIC0gdG8pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGJhc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCA9IDAsIHByb3BzKSB7XG4gICAgICAgIGlmIChjb250ZXh0SGFzaCkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AuY29udGV4dEhhc2gsIGNvbnRleHRIYXNoXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9va0FoZWFkID4gMjUpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmxvb2tBaGVhZCwgbG9va0FoZWFkXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBwcm9wcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRCdWZmZXJTaXplKG1heFNpemUsIGluUmVwZWF0KSB7XG4gICAgICAgIC8vIFNjYW4gdGhyb3VnaCB0aGUgYnVmZmVyIHRvIGZpbmQgcHJldmlvdXMgc2libGluZ3MgdGhhdCBmaXRcbiAgICAgICAgLy8gdG9nZXRoZXIgaW4gYSBUcmVlQnVmZmVyLCBhbmQgZG9uJ3QgY29udGFpbiBhbnkgcmV1c2VkIG5vZGVzXG4gICAgICAgIC8vICh3aGljaCBjYW4ndCBiZSBzdG9yZWQgaW4gYSBidWZmZXIpLlxuICAgICAgICAvLyBJZiBgaW5SZXBlYXRgIGlzID4gLTEsIGlnbm9yZSBub2RlIGJvdW5kYXJpZXMgb2YgdGhhdCB0eXBlIGZvclxuICAgICAgICAvLyBuZXN0aW5nLCBidXQgbWFrZSBzdXJlIHRoZSBlbmQgZmFsbHMgZWl0aGVyIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyAoYG1heFNpemVgKSBvciBiZWZvcmUgc3VjaCBhIG5vZGUuXG4gICAgICAgIGxldCBmb3JrID0gY3Vyc29yLmZvcmsoKTtcbiAgICAgICAgbGV0IHNpemUgPSAwLCBzdGFydCA9IDAsIHNraXAgPSAwLCBtaW5TdGFydCA9IGZvcmsuZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBzaXplOiAwLCBzdGFydDogMCwgc2tpcDogMCB9O1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBtaW5Qb3MgPSBmb3JrLnBvcyAtIG1heFNpemU7IGZvcmsucG9zID4gbWluUG9zOykge1xuICAgICAgICAgICAgbGV0IG5vZGVTaXplID0gZm9yay5zaXplO1xuICAgICAgICAgICAgLy8gUHJldGVuZCBuZXN0ZWQgcmVwZWF0IG5vZGVzIG9mIHRoZSBzYW1lIHR5cGUgZG9uJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmIChmb3JrLmlkID09IGluUmVwZWF0ICYmIG5vZGVTaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHQgdGhhdCB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBhcyBhIHZhbGlkIHJldHVyblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgICAgICAgICAgc2tpcCArPSA0O1xuICAgICAgICAgICAgICAgIHNpemUgKz0gNDtcbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydFBvcyA9IGZvcmsucG9zIC0gbm9kZVNpemU7XG4gICAgICAgICAgICBpZiAobm9kZVNpemUgPCAwIHx8IHN0YXJ0UG9zIDwgbWluUG9zIHx8IGZvcmsuc3RhcnQgPCBtaW5TdGFydClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBsb2NhbFNraXBwZWQgPSBmb3JrLmlkID49IG1pblJlcGVhdFR5cGUgPyA0IDogMDtcbiAgICAgICAgICAgIGxldCBub2RlU3RhcnQgPSBmb3JrLnN0YXJ0O1xuICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9yay5wb3MgPiBzdGFydFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IG5vZGVTdGFydDtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemU7XG4gICAgICAgICAgICBza2lwICs9IGxvY2FsU2tpcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5SZXBlYXQgPCAwIHx8IHNpemUgPT0gbWF4U2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaXplID4gNCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIGlmIChzaXplID49IDAgJiYgaWQgPCBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKHNpemUgPiA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSAoc2l6ZSAtIDQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydEluZGV4O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gZW5kIC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBTcGVjaWFsUmVjb3JkLkNvbnRleHRDaGFuZ2UgKi8pIHtcbiAgICAgICAgICAgIGNvbnRleHRIYXNoID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtNCAvKiBTcGVjaWFsUmVjb3JkLkxvb2tBaGVhZCAqLykge1xuICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgd2hpbGUgKGN1cnNvci5wb3MgPiAwKVxuICAgICAgICB0YWtlTm9kZShkYXRhLnN0YXJ0IHx8IDAsIGRhdGEuYnVmZmVyU3RhcnQgfHwgMCwgY2hpbGRyZW4sIHBvc2l0aW9ucywgLTEpO1xuICAgIGxldCBsZW5ndGggPSAoX2EgPSBkYXRhLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGNoaWxkcmVuLmxlbmd0aCA/IHBvc2l0aW9uc1swXSArIGNoaWxkcmVuWzBdLmxlbmd0aCA6IDApO1xuICAgIHJldHVybiBuZXcgVHJlZSh0eXBlc1tkYXRhLnRvcElEXSwgY2hpbGRyZW4ucmV2ZXJzZSgpLCBwb3NpdGlvbnMucmV2ZXJzZSgpLCBsZW5ndGgpO1xufVxuY29uc3Qgbm9kZVNpemVDYWNoZSA9IG5ldyBXZWFrTWFwO1xuZnVuY3Rpb24gbm9kZVNpemUoYmFsYW5jZVR5cGUsIG5vZGUpIHtcbiAgICBpZiAoIWJhbGFuY2VUeXBlLmlzQW5vbnltb3VzIHx8IG5vZGUgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8IG5vZGUudHlwZSAhPSBiYWxhbmNlVHlwZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgbGV0IHNpemUgPSBub2RlU2l6ZUNhY2hlLmdldChub2RlKTtcbiAgICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPSBiYWxhbmNlVHlwZSB8fCAhKGNoaWxkIGluc3RhbmNlb2YgVHJlZSkpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlU2l6ZUNhY2hlLnNldChub2RlLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5mdW5jdGlvbiBiYWxhbmNlUmFuZ2UoXG4vLyBUaGUgdHlwZSB0aGUgYmFsYW5jZWQgdHJlZSdzIGlubmVyIG5vZGVzLlxuYmFsYW5jZVR5cGUsIFxuLy8gVGhlIGRpcmVjdCBjaGlsZHJlbiBhbmQgdGhlaXIgcG9zaXRpb25zXG5jaGlsZHJlbiwgcG9zaXRpb25zLCBcbi8vIFRoZSBpbmRleCByYW5nZSBpbiBjaGlsZHJlbi9wb3NpdGlvbnMgdG8gdXNlXG5mcm9tLCB0bywgXG4vLyBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIG5vZGVzLCByZWxhdGl2ZSB0byB0aGVpciBwYXJlbnQuXG5zdGFydCwgXG4vLyBMZW5ndGggb2YgdGhlIG91dGVyIG5vZGVcbmxlbmd0aCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCB0aGUgdG9wIG5vZGUgb2YgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVG9wLCBcbi8vIEZ1bmN0aW9uIHRvIGJ1aWxkIGludGVybmFsIG5vZGVzIGZvciB0aGUgYmFsYW5jZWQgdHJlZVxubWtUcmVlKSB7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspXG4gICAgICAgIHRvdGFsICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgbGV0IG1heENoaWxkID0gTWF0aC5jZWlsKCh0b3RhbCAqIDEuNSkgLyA4IC8qIEJhbGFuY2UuQnJhbmNoRmFjdG9yICovKTtcbiAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgIGZ1bmN0aW9uIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBGcm9tID0gaSwgZ3JvdXBTdGFydCA9IHBvc2l0aW9uc1tpXSwgZ3JvdXBTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0U2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSArIG5leHRTaXplID49IG1heENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBncm91cFNpemUgKz0gbmV4dFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSA+IG1heENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbmx5ID0gY2hpbGRyZW5bZ3JvdXBGcm9tXTsgLy8gT25seSB0cmVlcyBjYW4gaGF2ZSBhIHNpemUgPiAxXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZShvbmx5LmNoaWxkcmVuLCBvbmx5LnBvc2l0aW9ucywgMCwgb25seS5jaGlsZHJlbi5sZW5ndGgsIHBvc2l0aW9uc1tncm91cEZyb21dICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbltncm91cEZyb21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSBwb3NpdGlvbnNbaSAtIDFdICsgY2hpbGRyZW5baSAtIDFdLmxlbmd0aCAtIGdyb3VwU3RhcnQ7XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGJhbGFuY2VSYW5nZShiYWxhbmNlVHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgZ3JvdXBGcm9tLCBpLCBncm91cFN0YXJ0LCBsZW5ndGgsIG51bGwsIG1rVHJlZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChncm91cFN0YXJ0ICsgb2Zmc2V0IC0gc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgMCk7XG4gICAgcmV0dXJuIChta1RvcCB8fCBta1RyZWUpKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsZW5ndGgpO1xufVxuLy8vIFByb3ZpZGVzIGEgd2F5IHRvIGFzc29jaWF0ZSB2YWx1ZXMgd2l0aCBwaWVjZXMgb2YgdHJlZXMuIEFzIGxvbmdcbi8vLyBhcyB0aGF0IHBhcnQgb2YgdGhlIHRyZWUgaXMgcmV1c2VkLCB0aGUgYXNzb2NpYXRlZCB2YWx1ZXMgY2FuIGJlXG4vLy8gcmV0cmlldmVkIGZyb20gYW4gdXBkYXRlZCB0cmVlLlxuY2xhc3MgTm9kZVdlYWtNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgfVxuICAgIHNldEJ1ZmZlcihidWZmZXIsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLm1hcC5nZXQoYnVmZmVyKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChidWZmZXIsIGlubmVyID0gbmV3IE1hcCk7XG4gICAgICAgIGlubmVyLnNldChpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgICBnZXRCdWZmZXIoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLm1hcC5nZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIGlubmVyICYmIGlubmVyLmdldChpbmRleCk7XG4gICAgfVxuICAgIC8vLyBTZXQgdGhlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLlxuICAgIHNldChub2RlLCB2YWx1ZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUpXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4LCB2YWx1ZSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSlcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChub2RlLnRyZWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLy8vIFJldHJpZXZlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLCBpZiBpdCBleGlzdHMgaW4gdGhlIG1hcC5cbiAgICBnZXQobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUgPyB0aGlzLmdldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4KVxuICAgICAgICAgICAgOiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgPyB0aGlzLm1hcC5nZXQobm9kZS50cmVlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8vIFNldCB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50cyB0by5cbiAgICBjdXJzb3JTZXQoY3Vyc29yLCB2YWx1ZSkge1xuICAgICAgICBpZiAoY3Vyc29yLmJ1ZmZlcilcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKGN1cnNvci5idWZmZXIuYnVmZmVyLCBjdXJzb3IuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGN1cnNvci50cmVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vLyBSZXRyaWV2ZSB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50c1xuICAgIC8vLyB0by5cbiAgICBjdXJzb3JHZXQoY3Vyc29yKSB7XG4gICAgICAgIHJldHVybiBjdXJzb3IuYnVmZmVyID8gdGhpcy5nZXRCdWZmZXIoY3Vyc29yLmJ1ZmZlci5idWZmZXIsIGN1cnNvci5pbmRleCkgOiB0aGlzLm1hcC5nZXQoY3Vyc29yLnRyZWUpO1xuICAgIH1cbn1cblxuLy8vIFRyZWUgZnJhZ21lbnRzIGFyZSB1c2VkIGR1cmluZyBbaW5jcmVtZW50YWxcbi8vLyBwYXJzaW5nXSgjY29tbW9uLlBhcnNlci5zdGFydFBhcnNlKSB0byB0cmFjayBwYXJ0cyBvZiBvbGQgdHJlZXNcbi8vLyB0aGF0IGNhbiBiZSByZXVzZWQgaW4gYSBuZXcgcGFyc2UuIEFuIGFycmF5IG9mIGZyYWdtZW50cyBpcyB1c2VkXG4vLy8gdG8gdHJhY2sgcmVnaW9ucyBvZiBhbiBvbGQgdHJlZSB3aG9zZSBub2RlcyBtaWdodCBiZSByZXVzZWQgaW4gbmV3XG4vLy8gcGFyc2VzLiBVc2UgdGhlIHN0YXRpY1xuLy8vIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBtZXRob2QgdG9cbi8vLyB1cGRhdGUgZnJhZ21lbnRzIGZvciBkb2N1bWVudCBjaGFuZ2VzLlxuY2xhc3MgVHJlZUZyYWdtZW50IHtcbiAgICAvLy8gQ29uc3RydWN0IGEgdHJlZSBmcmFnbWVudC4gWW91J2xsIHVzdWFsbHkgd2FudCB0byB1c2VcbiAgICAvLy8gW2BhZGRUcmVlYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYWRkVHJlZSkgYW5kXG4gICAgLy8vIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBpbnN0ZWFkIG9mXG4gICAgLy8vIGNhbGxpbmcgdGhpcyBkaXJlY3RseS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHN0YXJ0IG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UgcG9pbnRlZCB0byBieSB0aGlzIGZyYWdtZW50LlxuICAgIC8vLyBUaGlzIHJlZmVycyB0byBhbiBvZmZzZXQgaW4gdGhlIF91cGRhdGVkXyBkb2N1bWVudCAoYXMgb3Bwb3NlZFxuICAgIC8vLyB0byB0aGUgb3JpZ2luYWwgdHJlZSkuXG4gICAgZnJvbSwgXG4gICAgLy8vIFRoZSBlbmQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZS5cbiAgICB0bywgXG4gICAgLy8vIFRoZSB0cmVlIHRoYXQgdGhpcyBmcmFnbWVudCBpcyBiYXNlZCBvbi5cbiAgICB0cmVlLCBcbiAgICAvLy8gVGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBmcmFnbWVudCdzIHRyZWUgYW5kIHRoZSBkb2N1bWVudCB0aGF0XG4gICAgLy8vIHRoaXMgZnJhZ21lbnQgY2FuIGJlIHVzZWQgYWdhaW5zdC4gQWRkIHRoaXMgd2hlbiBnb2luZyBmcm9tXG4gICAgLy8vIGRvY3VtZW50IHRvIHRyZWUgcG9zaXRpb25zLCBzdWJ0cmFjdCBpdCB0byBnbyBmcm9tIHRyZWUgdG9cbiAgICAvLy8gZG9jdW1lbnQgcG9zaXRpb25zLlxuICAgIG9mZnNldCwgb3BlblN0YXJ0ID0gZmFsc2UsIG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLm9wZW4gPSAob3BlblN0YXJ0ID8gMSAvKiBPcGVuLlN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogT3Blbi5FbmQgKi8gOiAwKTtcbiAgICB9XG4gICAgLy8vIFdoZXRoZXIgdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiBhXG4gICAgLy8vIHBhcnNlLCBvciB0aGUgZW5kIG9mIGEgY2hhbmdlLiAoSW4gdGhlIHNlY29uZCBjYXNlLCBpdCBtYXkgbm90XG4gICAgLy8vIGJlIHNhZmUgdG8gcmV1c2Ugc29tZSBub2RlcyBhdCB0aGUgc3RhcnQsIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLy8gcGFyc2luZyBhbGdvcml0aG0uKVxuICAgIGdldCBvcGVuU3RhcnQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMSAvKiBPcGVuLlN0YXJ0ICovKSA+IDA7IH1cbiAgICAvLy8gV2hldGhlciB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBlbmQgb2YgYVxuICAgIC8vLyBmdWxsLWRvY3VtZW50IHBhcnNlLCBvciB0aGUgc3RhcnQgb2YgYSBjaGFuZ2UuXG4gICAgZ2V0IG9wZW5FbmQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMiAvKiBPcGVuLkVuZCAqLykgPiAwOyB9XG4gICAgLy8vIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIC8vLyBhbiBleGlzdGluZyBzZXQgb2YgZnJhZ21lbnRzIGJ5IHJlcGxhY2luZyB0aGUgb25lcyB0aGF0IG92ZXJsYXBcbiAgICAvLy8gd2l0aCBhIHRyZWUgd2l0aCBjb250ZW50IGZyb20gdGhlIG5ldyB0cmVlLiBXaGVuIGBwYXJ0aWFsYCBpc1xuICAgIC8vLyB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIC8vLyBmcmFnbWVudCBoYXMgW2BvcGVuRW5kYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQub3BlbkVuZCkgc2V0IHRvXG4gICAgLy8vIHRydWUuXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEFwcGx5IGEgc2V0IG9mIGVkaXRzIHRvIGFuIGFycmF5IG9mIGZyYWdtZW50cywgcmVtb3Zpbmcgb3JcbiAgICAvLy8gc3BsaXR0aW5nIGZyYWdtZW50cyBhcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIGVkaXRlZCByYW5nZXMsIGFuZFxuICAgIC8vLyBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgc3RhdGljIGFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIGNoYW5nZXMsIG1pbkdhcCA9IDEyOCkge1xuICAgICAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZkkgPSAxLCBuZXh0RiA9IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbMF0gOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBjSSA9IDAsIHBvcyA9IDAsIG9mZiA9IDA7OyBjSSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dEMgPSBjSSA8IGNoYW5nZXMubGVuZ3RoID8gY2hhbmdlc1tjSV0gOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0QyA/IG5leHRDLmZyb21BIDogMWU5O1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgLSBwb3MgPj0gbWluR2FwKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3V0ID0gbmV4dEY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gY3V0LmZyb20gfHwgbmV4dFBvcyA8PSBjdXQudG8gfHwgb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dCA9IGZGcm9tID49IGZUbyA/IG51bGwgOiBuZXcgVHJlZUZyYWdtZW50KGZGcm9tLCBmVG8sIGN1dC50cmVlLCBjdXQub2Zmc2V0ICsgb2ZmLCBjSSA+IDAsICEhbmV4dEMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEYudG8gPiBuZXh0UG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGID0gZkkgPCBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzW2ZJKytdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHRDKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dEMudG9BO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEMudG9BIC0gbmV4dEMudG9CO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8vIEEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbmNsYXNzIFBhcnNlciB7XG4gICAgLy8vIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICAvLy8gb2JqZWN0LiBbYGZyYWdtZW50c2BdKCNjb21tb24uVHJlZUZyYWdtZW50KSBjYW4gYmUgcGFzc2VkIGluIHRvXG4gICAgLy8vIG1ha2UgdGhlIHBhcnNlIGluY3JlbWVudGFsLlxuICAgIC8vL1xuICAgIC8vLyBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIC8vLyB3aGljaCBzaG91bGQgYmUgYSBzb3J0ZWQgYXJyYXkgb2Ygbm9uLWVtcHR5LCBub24tb3ZlcmxhcHBpbmdcbiAgICAvLy8gcmFuZ2VzLCB0byBwYXJzZSBvbmx5IHRob3NlIHJhbmdlcy4gVGhlIHRyZWUgcmV0dXJuZWQgaW4gdGhhdFxuICAgIC8vLyBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICBzdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbnB1dCA9IG5ldyBTdHJpbmdJbnB1dChpbnB1dCk7XG4gICAgICAgIHJhbmdlcyA9ICFyYW5nZXMgPyBbbmV3IFJhbmdlKDAsIGlucHV0Lmxlbmd0aCldIDogcmFuZ2VzLmxlbmd0aCA/IHJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tLCByLnRvKSkgOiBbbmV3IFJhbmdlKDAsIDApXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cyB8fCBbXSwgcmFuZ2VzKTtcbiAgICB9XG4gICAgLy8vIFJ1biBhIGZ1bGwgcGFyc2UsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIHRyZWUuXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vLy8gQ3JlYXRlIGEgcGFyc2Ugd3JhcHBlciB0aGF0LCBhZnRlciB0aGUgaW5uZXIgcGFyc2UgY29tcGxldGVzLFxuLy8vIHNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuLy8vIGZ1bmN0aW9uLCBydW5zIHRoZSByZXN1bHRpbmcgW2lubmVyIHBhcnNlc10oI2NvbW1vbi5OZXN0ZWRQYXJzZSksXG4vLy8gYW5kIHRoZW4gW21vdW50c10oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0aGVpciByZXN1bHRzIG9udG8gdGhlXG4vLy8gdHJlZS5cbmZ1bmN0aW9uIHBhcnNlTWl4ZWQobmVzdCkge1xuICAgIHJldHVybiAocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykgPT4gbmV3IE1peGVkUGFyc2UocGFyc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG59XG5jbGFzcyBJbm5lclBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcnNlLCBvdmVybGF5LCB0YXJnZXQsIHJhbmdlcykge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHBhcnNlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgfVxufVxuY2xhc3MgQWN0aXZlT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwcmVkaWNhdGUsIG1vdW50cywgaW5kZXgsIHN0YXJ0LCB0YXJnZXQsIHByZXYpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLm1vdW50cyA9IG1vdW50cztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICB9XG59XG5jb25zdCBzdG9wcGVkSW5uZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuY2xhc3MgTWl4ZWRQYXJzZSB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmVzdCA9IG5lc3Q7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmlubmVyID0gW107XG4gICAgICAgIHRoaXMuaW5uZXJEb25lID0gMDtcbiAgICAgICAgdGhpcy5iYXNlVHJlZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBiYXNlO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5iYXNlUGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlVHJlZSA9IGRvbmU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5uZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlubmVyIG9mIHRoaXMuaW5uZXIpXG4gICAgICAgICAgICAgICAgICAgIGlubmVyLnBhcnNlLnN0b3BBdCh0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5uZXJEb25lID09IHRoaXMuaW5uZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5iYXNlVHJlZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUcmVlKHJlc3VsdC50eXBlLCByZXN1bHQuY2hpbGRyZW4sIHJlc3VsdC5wb3NpdGlvbnMsIHJlc3VsdC5sZW5ndGgsIHJlc3VsdC5wcm9wVmFsdWVzLmNvbmNhdChbW3N0b3BwZWRJbm5lciwgdGhpcy5zdG9wcGVkQXRdXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLmlubmVyW3RoaXMuaW5uZXJEb25lXSwgZG9uZSA9IGlubmVyLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEb25lKys7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc29tZXdoYXQgZG9kZ3kgYnV0IHN1cGVyIGhlbHBmdWwgaGFjayB3aGVyZSB3ZVxuICAgICAgICAgICAgLy8gcGF0Y2ggdXAgbm9kZXMgY3JlYXRlZCBieSB0aGUgaW5uZXIgcGFyc2UgKGFuZCB0aHVzXG4gICAgICAgICAgICAvLyBwcmVzdW1hYmx5IG5vdCBhbGlhc2VkIGFueXdoZXJlIGVsc2UpIHRvIGhvbGQgdGhlIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyBhYm91dCB0aGUgaW5uZXIgcGFyc2UuXG4gICAgICAgICAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGlubmVyLnRhcmdldC5wcm9wcyk7XG4gICAgICAgICAgICBwcm9wc1tOb2RlUHJvcC5tb3VudGVkLmlkXSA9IG5ldyBNb3VudGVkVHJlZShkb25lLCBpbm5lci5vdmVybGF5LCBpbm5lci5wYXJzZXIpO1xuICAgICAgICAgICAgaW5uZXIudGFyZ2V0LnByb3BzID0gcHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlubmVyW2ldLnJhbmdlc1swXS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWluKHBvcywgdGhpcy5pbm5lcltpXS5wYXJzZS5wYXJzZWRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJbaV0ucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgfVxuICAgIHN0YXJ0SW5uZXIoKSB7XG4gICAgICAgIGxldCBmcmFnbWVudEN1cnNvciA9IG5ldyBGcmFnbWVudEN1cnNvcih0aGlzLmZyYWdtZW50cyk7XG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgbGV0IGNvdmVyZWQgPSBudWxsO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3IobmV3IFRyZWVOb2RlKHRoaXMuYmFzZVRyZWUsIHRoaXMucmFuZ2VzWzBdLmZyb20sIDAsIG51bGwpLCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbmVzdCwgaXNDb3ZlcmVkOyB0aGlzLnN0b3BwZWRBdCA9PSBudWxsIHx8IGN1cnNvci5mcm9tIDwgdGhpcy5zdG9wcGVkQXQ7KSB7XG4gICAgICAgICAgICBsZXQgZW50ZXIgPSB0cnVlLCByYW5nZTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudEN1cnNvci5oYXNOb2RlKGN1cnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBvdmVybGF5Lm1vdW50cy5maW5kKG0gPT4gbS5mcmFnLmZyb20gPD0gY3Vyc29yLmZyb20gJiYgbS5mcmFnLnRvID49IGN1cnNvci50byAmJiBtLm1vdW50Lm92ZXJsYXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1hdGNoLm1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHIuZnJvbSArIG1hdGNoLnBvcywgdG8gPSByLnRvICsgbWF0Y2gucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGN1cnNvci5mcm9tICYmIHRvIDw9IGN1cnNvci50byAmJiAhb3ZlcmxheS5yYW5nZXMuc29tZShyID0+IHIuZnJvbSA8IHRvICYmIHIudG8gPiBmcm9tKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY292ZXJlZCAmJiAoaXNDb3ZlcmVkID0gY2hlY2tDb3Zlcihjb3ZlcmVkLnJhbmdlcywgY3Vyc29yLmZyb20sIGN1cnNvci50bykpKSB7XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBpc0NvdmVyZWQgIT0gMiAvKiBDb3Zlci5GdWxsICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci50eXBlLmlzQW5vbnltb3VzICYmIGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvICYmIChuZXN0ID0gdGhpcy5uZXN0KGN1cnNvciwgdGhpcy5pbnB1dCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxpemUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBsZXQgb2xkTW91bnRzID0gZnJhZ21lbnRDdXJzb3IuZmluZE1vdW50cyhjdXJzb3IuZnJvbSwgbmVzdC5wYXJzZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmVzdC5vdmVybGF5ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gbmV3IEFjdGl2ZU92ZXJsYXkobmVzdC5wYXJzZXIsIG5lc3Qub3ZlcmxheSwgb2xkTW91bnRzLCB0aGlzLmlubmVyLmxlbmd0aCwgY3Vyc29yLmZyb20sIGN1cnNvci50cmVlLCBvdmVybGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgbmVzdC5vdmVybGF5IHx8IFtuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnB1c2gobmV3IElubmVyUGFyc2UobmVzdC5wYXJzZXIsIG5lc3QucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob2xkTW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBuZXN0Lm92ZXJsYXkgPyBuZXN0Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIGN1cnNvci5mcm9tLCByLnRvIC0gY3Vyc29yLmZyb20pKSA6IG51bGwsIGN1cnNvci50cmVlLCByYW5nZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IHsgcmFuZ2VzLCBkZXB0aDogMCwgcHJldjogY292ZXJlZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJsYXkgJiYgKHJhbmdlID0gb3ZlcmxheS5wcmVkaWNhdGUoY3Vyc29yKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tIDwgcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGVyICYmIGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5kZXB0aCsrO1xuICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkKVxuICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkLmRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICYmICEtLW92ZXJsYXkuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgb3ZlcmxheS5yYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lci5zcGxpY2Uob3ZlcmxheS5pbmRleCwgMCwgbmV3IElubmVyUGFyc2Uob3ZlcmxheS5wYXJzZXIsIG92ZXJsYXkucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob3ZlcmxheS5tb3VudHMsIHJhbmdlcyksIHJhbmdlcyksIG92ZXJsYXkucmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBvdmVybGF5LnN0YXJ0LCByLnRvIC0gb3ZlcmxheS5zdGFydCkpLCBvdmVybGF5LnRhcmdldCwgcmFuZ2VzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gb3ZlcmxheS5wcmV2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkICYmICEtLWNvdmVyZWQuZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0gY292ZXJlZC5wcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ292ZXIoY292ZXJlZCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBjb3ZlcmVkKSB7XG4gICAgICAgIGlmIChyYW5nZS5mcm9tID49IHRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChyYW5nZS50byA+IGZyb20pXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UuZnJvbSA8PSBmcm9tICYmIHJhbmdlLnRvID49IHRvID8gMiAvKiBDb3Zlci5GdWxsICovIDogMSAvKiBDb3Zlci5QYXJ0aWFsICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBDb3Zlci5Ob25lICovO1xufVxuLy8gVGFrZSBhIHBpZWNlIG9mIGJ1ZmZlciBhbmQgY29udmVydCBpdCBpbnRvIGEgc3RhbmQtYWxvbmVcbi8vIFRyZWVCdWZmZXIuXG5mdW5jdGlvbiBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgZW5kSSwgbm9kZXMsIHBvc2l0aW9ucywgb2ZmKSB7XG4gICAgaWYgKHN0YXJ0SSA8IGVuZEkpIHtcbiAgICAgICAgbGV0IGZyb20gPSBidWYuYnVmZmVyW3N0YXJ0SSArIDFdO1xuICAgICAgICBub2Rlcy5wdXNoKGJ1Zi5zbGljZShzdGFydEksIGVuZEksIGZyb20pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIG9mZik7XG4gICAgfVxufVxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgdGhhdCdzIGluIGEgYnVmZmVyLCBhbmQgY29udmVydHMgaXQsIGFuZFxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcbi8vIGFzc3VtcHRpb24gdGhhdCB0aGUgdHJlZXMgYW5kIGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGJ5IHRoZVxuLy8gcGFyc2UgdGhhdCB3YXMgcmFuIHZpYSB0aGUgbWl4IHBhcnNlciwgYW5kIHRodXMgYXJlbid0IHNoYXJlZCB3aXRoXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoY3Vyc29yKSB7XG4gICAgbGV0IHsgbm9kZSB9ID0gY3Vyc29yLCBkZXB0aCA9IDA7XG4gICAgLy8gU2NhbiB1cCB0byB0aGUgbmVhcmVzdCB0cmVlXG4gICAgZG8ge1xuICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIGRlcHRoKys7XG4gICAgfSB3aGlsZSAoIWN1cnNvci50cmVlKTtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGluIHRoYXQgdHJlZVxuICAgIGxldCBpID0gMCwgYmFzZSA9IGN1cnNvci50cmVlLCBvZmYgPSAwO1xuICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgIG9mZiA9IGJhc2UucG9zaXRpb25zW2ldICsgY3Vyc29yLmZyb207XG4gICAgICAgIGlmIChvZmYgPD0gbm9kZS5mcm9tICYmIG9mZiArIGJhc2UuY2hpbGRyZW5baV0ubGVuZ3RoID49IG5vZGUudG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGJ1ZiA9IGJhc2UuY2hpbGRyZW5baV0sIGIgPSBidWYuYnVmZmVyO1xuICAgIC8vIFNwbGl0IGEgbGV2ZWwgaW4gdGhlIGJ1ZmZlciwgcHV0dGluZyB0aGUgbm9kZXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIC8vIHRoZSBjaGlsZCB0aGF0IGNvbnRhaW5zIGBub2RlYCBpbnRvIG5ldyBidWZmZXJzLlxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0YXJ0SSwgZW5kSSwgdHlwZSwgaW5uZXJPZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICBsZXQgaSA9IHN0YXJ0STtcbiAgICAgICAgd2hpbGUgKGJbaSArIDJdICsgb2ZmIDw9IG5vZGUuZnJvbSlcbiAgICAgICAgICAgIGkgPSBiW2kgKyAzXTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgaSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICBsZXQgZnJvbSA9IGJbaSArIDFdLCB0byA9IGJbaSArIDJdO1xuICAgICAgICBsZXQgaXNUYXJnZXQgPSBmcm9tICsgb2ZmID09IG5vZGUuZnJvbSAmJiB0byArIG9mZiA9PSBub2RlLnRvICYmIGJbaV0gPT0gbm9kZS50eXBlLmlkO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGlzVGFyZ2V0ID8gbm9kZS50b1RyZWUoKSA6IHNwbGl0KGkgKyA0LCBiW2kgKyAzXSwgYnVmLnNldC50eXBlc1tiW2ldXSwgZnJvbSwgdG8gLSBmcm9tKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBpbm5lck9mZnNldCk7XG4gICAgICAgIHNsaWNlQnVmKGJ1ZiwgYltpICsgM10sIGVuZEksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCk7XG4gICAgfVxuICAgIGJhc2UuY2hpbGRyZW5baV0gPSBzcGxpdCgwLCBiLmxlbmd0aCwgTm9kZVR5cGUubm9uZSwgMCwgYnVmLmxlbmd0aCk7XG4gICAgLy8gTW92ZSB0aGUgY3Vyc29yIGJhY2sgdG8gdGhlIHRhcmdldCBub2RlXG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPD0gZGVwdGg7IGQrKylcbiAgICAgICAgY3Vyc29yLmNoaWxkQWZ0ZXIobm9kZS5mcm9tKTtcbn1cbmNsYXNzIFN0cnVjdHVyZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3Iocm9vdCwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSByb290LmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICB9XG4gICAgLy8gTW92ZSB0byB0aGUgZmlyc3Qgbm9kZSAoaW4gcHJlLW9yZGVyKSB0aGF0IHN0YXJ0cyBhdCBvciBhZnRlciBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zKSB7XG4gICAgICAgIGxldCB7IGN1cnNvciB9ID0gdGhpcywgcCA9IHBvcyAtIHRoaXMub2Zmc2V0O1xuICAgICAgICB3aGlsZSAoIXRoaXMuZG9uZSAmJiBjdXJzb3IuZnJvbSA8IHApIHtcbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gcG9zICYmIGN1cnNvci5lbnRlcihwLCAxLCBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cyB8IEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci5uZXh0KGZhbHNlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUoY3Vyc29yKSB7XG4gICAgICAgIHRoaXMubW92ZVRvKGN1cnNvci5mcm9tKTtcbiAgICAgICAgaWYgKCF0aGlzLmRvbmUgJiYgdGhpcy5jdXJzb3IuZnJvbSArIHRoaXMub2Zmc2V0ID09IGN1cnNvci5mcm9tICYmIHRoaXMuY3Vyc29yLnRyZWUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHRyZWUgPSB0aGlzLmN1cnNvci50cmVlOzspIHtcbiAgICAgICAgICAgICAgICBpZiAodHJlZSA9PSBjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUuY2hpbGRyZW4ubGVuZ3RoICYmIHRyZWUucG9zaXRpb25zWzBdID09IDAgJiYgdHJlZS5jaGlsZHJlblswXSBpbnN0YW5jZW9mIFRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHRyZWUgPSB0cmVlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5jdXJUbyA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ0kgPSAwO1xuICAgICAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdGhpcy5jdXJGcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5jdXJUbyA9IChfYSA9IGZpcnN0LnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaXJzdC50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZpcnN0LnRyZWUsIC1maXJzdC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShub2RlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmN1ckZyYWcgJiYgbm9kZS5mcm9tID49IHRoaXMuY3VyVG8pXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1ckZyYWcgJiYgdGhpcy5jdXJGcmFnLmZyb20gPD0gbm9kZS5mcm9tICYmIHRoaXMuY3VyVG8gPj0gbm9kZS50byAmJiB0aGlzLmlubmVyLmhhc05vZGUobm9kZSk7XG4gICAgfVxuICAgIG5leHRGcmFnKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ0krKztcbiAgICAgICAgaWYgKHRoaXMuZnJhZ0kgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5jdXJGcmFnID0gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnSV07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZnJhZy50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnJhZy50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZyYWcudHJlZSwgLWZyYWcub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kTW91bnRzKHBvcywgcGFyc2VyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5pbm5lcikge1xuICAgICAgICAgICAgdGhpcy5pbm5lci5jdXJzb3IubW92ZVRvKHBvcywgMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3MgPSB0aGlzLmlubmVyLmN1cnNvci5ub2RlOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbW91bnQgPSAoX2EgPSBwb3MudHJlZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdW50ICYmIG1vdW50LnBhcnNlciA9PSBwYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJhZ0k7IGkgPCB0aGlzLmZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLmZyb20gPj0gcG9zLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcudHJlZSA9PSB0aGlzLmN1ckZyYWcudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogcG9zLmZyb20gLSBmcmFnLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1bmNoUmFuZ2VzKG91dGVyLCByYW5nZXMpIHtcbiAgICBsZXQgY29weSA9IG51bGwsIGN1cnJlbnQgPSByYW5nZXM7XG4gICAgZm9yIChsZXQgaSA9IDEsIGogPSAwOyBpIDwgb3V0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGdhcEZyb20gPSBvdXRlcltpIC0gMV0udG8sIGdhcFRvID0gb3V0ZXJbaV0uZnJvbTtcbiAgICAgICAgZm9yICg7IGogPCBjdXJyZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgciA9IGN1cnJlbnRbal07XG4gICAgICAgICAgICBpZiAoci5mcm9tID49IGdhcFRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHIudG8gPD0gZ2FwRnJvbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY29weSA9IHJhbmdlcy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA8IGdhcEZyb20pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2pdID0gbmV3IFJhbmdlKHIuZnJvbSwgZ2FwRnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKHIudG8gPiBnYXBUbylcbiAgICAgICAgICAgICAgICAgICAgY29weS5zcGxpY2UoaiArIDEsIDAsIG5ldyBSYW5nZShnYXBUbywgci50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoci50byA+IGdhcFRvKSB7XG4gICAgICAgICAgICAgICAgY29weVtqLS1dID0gbmV3IFJhbmdlKGdhcFRvLCByLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBmaW5kQ292ZXJDaGFuZ2VzKGEsIGIsIGZyb20sIHRvKSB7XG4gICAgbGV0IGlBID0gMCwgaUIgPSAwLCBpbkEgPSBmYWxzZSwgaW5CID0gZmFsc2UsIHBvcyA9IC0xZTk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG5leHRBID0gaUEgPT0gYS5sZW5ndGggPyAxZTkgOiBpbkEgPyBhW2lBXS50byA6IGFbaUFdLmZyb207XG4gICAgICAgIGxldCBuZXh0QiA9IGlCID09IGIubGVuZ3RoID8gMWU5IDogaW5CID8gYltpQl0udG8gOiBiW2lCXS5mcm9tO1xuICAgICAgICBpZiAoaW5BICE9IGluQikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgocG9zLCBmcm9tKSwgZW5kID0gTWF0aC5taW4obmV4dEEsIG5leHRCLCB0byk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFJhbmdlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIpO1xuICAgICAgICBpZiAocG9zID09IDFlOSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobmV4dEEgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQSlcbiAgICAgICAgICAgICAgICBpbkEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5BID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUErKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dEIgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQilcbiAgICAgICAgICAgICAgICBpbkIgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5CID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gR2l2ZW4gYSBudW1iZXIgb2YgZnJhZ21lbnRzIGZvciB0aGUgb3V0ZXIgdHJlZSwgYW5kIGEgc2V0IG9mIHJhbmdlc1xuLy8gdG8gcGFyc2UsIGZpbmQgZnJhZ21lbnRzIGZvciBpbm5lciB0cmVlcyBtb3VudGVkIGFyb3VuZCB0aG9zZVxuLy8gcmFuZ2VzLCBpZiBhbnkuXG5mdW5jdGlvbiBlbnRlckZyYWdtZW50cyhtb3VudHMsIHJhbmdlcykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IHBvcywgbW91bnQsIGZyYWcgfSBvZiBtb3VudHMpIHtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gcG9zICsgKG1vdW50Lm92ZXJsYXkgPyBtb3VudC5vdmVybGF5WzBdLmZyb20gOiAwKSwgZW5kUG9zID0gc3RhcnRQb3MgKyBtb3VudC50cmVlLmxlbmd0aDtcbiAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChmcmFnLmZyb20sIHN0YXJ0UG9zKSwgdG8gPSBNYXRoLm1pbihmcmFnLnRvLCBlbmRQb3MpO1xuICAgICAgICBpZiAobW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IG92ZXJsYXkgPSBtb3VudC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gKyBwb3MsIHIudG8gKyBwb3MpKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VzID0gZmluZENvdmVyQ2hhbmdlcyhyYW5nZXMsIG92ZXJsYXksIGZyb20sIHRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBmcm9tOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGNoYW5nZXMubGVuZ3RoLCBlbmQgPSBsYXN0ID8gdG8gOiBjaGFuZ2VzW2ldLmZyb207XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChwb3MsIGVuZCwgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gcG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZCB8fCBmcmFnLm9wZW5FbmQpKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gY2hhbmdlc1tpXS50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQoZnJvbSwgdG8sIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHN0YXJ0UG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZFBvcyB8fCBmcmFnLm9wZW5FbmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBJdGVyTW9kZSwgTW91bnRlZFRyZWUsIE5vZGVQcm9wLCBOb2RlU2V0LCBOb2RlVHlwZSwgTm9kZVdlYWtNYXAsIFBhcnNlciwgVHJlZSwgVHJlZUJ1ZmZlciwgVHJlZUN1cnNvciwgVHJlZUZyYWdtZW50LCBwYXJzZU1peGVkIH07XG4iLCAiaW1wb3J0IHsgTm9kZVByb3AgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxubGV0IG5leHRUYWdJRCA9IDA7XG4vLy8gSGlnaGxpZ2h0aW5nIHRhZ3MgYXJlIG1hcmtlcnMgdGhhdCBkZW5vdGUgYSBoaWdobGlnaHRpbmcgY2F0ZWdvcnkuXG4vLy8gVGhleSBhcmUgW2Fzc29jaWF0ZWRdKCNoaWdobGlnaHQuc3R5bGVUYWdzKSB3aXRoIHBhcnRzIG9mIGEgc3ludGF4XG4vLy8gdHJlZSBieSBhIGxhbmd1YWdlIG1vZGUsIGFuZCB0aGVuIG1hcHBlZCB0byBhbiBhY3R1YWwgQ1NTIHN0eWxlIGJ5XG4vLy8gYSBbaGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLlxuLy8vXG4vLy8gQmVjYXVzZSBzeW50YXggdHJlZSBub2RlIHR5cGVzIGFuZCBoaWdobGlnaHQgc3R5bGVzIGhhdmUgdG8gYmVcbi8vLyBhYmxlIHRvIHRhbGsgdGhlIHNhbWUgbGFuZ3VhZ2UsIENvZGVNaXJyb3IgdXNlcyBhIG1vc3RseSBfY2xvc2VkX1xuLy8vIFt2b2NhYnVsYXJ5XSgjaGlnaGxpZ2h0LnRhZ3MpIG9mIHN5bnRheCB0YWdzIChhcyBvcHBvc2VkIHRvXG4vLy8gdHJhZGl0aW9uYWwgb3BlbiBzdHJpbmctYmFzZWQgc3lzdGVtcywgd2hpY2ggbWFrZSBpdCBoYXJkIGZvclxuLy8vIGhpZ2hsaWdodGluZyB0aGVtZXMgdG8gY292ZXIgYWxsIHRoZSB0b2tlbnMgcHJvZHVjZWQgYnkgdGhlXG4vLy8gdmFyaW91cyBsYW5ndWFnZXMpLlxuLy8vXG4vLy8gSXQgX2lzXyBwb3NzaWJsZSB0byBbZGVmaW5lXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIHlvdXIgb3duXG4vLy8gaGlnaGxpZ2h0aW5nIHRhZ3MgZm9yIHN5c3RlbS1pbnRlcm5hbCB1c2UgKHdoZXJlIHlvdSBjb250cm9sIGJvdGhcbi8vLyB0aGUgbGFuZ3VhZ2UgcGFja2FnZSBhbmQgdGhlIGhpZ2hsaWdodGVyKSwgYnV0IHN1Y2ggdGFncyB3aWxsIG5vdFxuLy8vIGJlIHBpY2tlZCB1cCBieSByZWd1bGFyIGhpZ2hsaWdodGVycyAodGhvdWdoIHlvdSBjYW4gZGVyaXZlIHRoZW1cbi8vLyBmcm9tIHN0YW5kYXJkIHRhZ3MgdG8gYWxsb3cgaGlnaGxpZ2h0ZXJzIHRvIGZhbGwgYmFjayB0byB0aG9zZSkuXG5jbGFzcyBUYWcge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHNldCBvZiB0aGlzIHRhZyBhbmQgYWxsIGl0cyBwYXJlbnQgdGFncywgc3RhcnRpbmcgd2l0aFxuICAgIC8vLyB0aGlzIG9uZSBpdHNlbGYgYW5kIHNvcnRlZCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nIHNwZWNpZmljaXR5LlxuICAgIHNldCwgXG4gICAgLy8vIFRoZSBiYXNlIHVubW9kaWZpZWQgdGFnIHRoYXQgdGhpcyBvbmUgaXMgYmFzZWQgb24sIGlmIGl0J3NcbiAgICAvLy8gbW9kaWZpZWQgQGludGVybmFsXG4gICAgYmFzZSwgXG4gICAgLy8vIFRoZSBtb2RpZmllcnMgYXBwbGllZCB0byB0aGlzLmJhc2UgQGludGVybmFsXG4gICAgbW9kaWZpZWQpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSBtb2RpZmllZDtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmlkID0gbmV4dFRhZ0lEKys7XG4gICAgfVxuICAgIC8vLyBEZWZpbmUgYSBuZXcgdGFnLiBJZiBgcGFyZW50YCBpcyBnaXZlbiwgdGhlIHRhZyBpcyB0cmVhdGVkIGFzIGFcbiAgICAvLy8gc3ViLXRhZyBvZiB0aGF0IHBhcmVudCwgYW5kXG4gICAgLy8vIFtoaWdobGlnaHRlcnNdKCNoaWdobGlnaHQudGFnSGlnaGxpZ2h0ZXIpIHRoYXQgZG9uJ3QgbWVudGlvblxuICAgIC8vLyB0aGlzIHRhZyB3aWxsIHRyeSB0byBmYWxsIGJhY2sgdG8gdGhlIHBhcmVudCB0YWcgKG9yIGdyYW5kcGFyZW50XG4gICAgLy8vIHRhZywgZXRjKS5cbiAgICBzdGF0aWMgZGVmaW5lKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmJhc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRlcml2ZSBmcm9tIGEgbW9kaWZpZWQgdGFnXCIpO1xuICAgICAgICBsZXQgdGFnID0gbmV3IFRhZyhbXSwgbnVsbCwgW10pO1xuICAgICAgICB0YWcuc2V0LnB1c2godGFnKTtcbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgcGFyZW50LnNldClcbiAgICAgICAgICAgICAgICB0YWcuc2V0LnB1c2godCk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8vLyBEZWZpbmUgYSB0YWcgX21vZGlmaWVyXywgd2hpY2ggaXMgYSBmdW5jdGlvbiB0aGF0LCBnaXZlbiBhIHRhZyxcbiAgICAvLy8gd2lsbCByZXR1cm4gYSB0YWcgdGhhdCBpcyBhIHN1YnRhZyBvZiB0aGUgb3JpZ2luYWwuIEFwcGx5aW5nIHRoZVxuICAgIC8vLyBzYW1lIG1vZGlmaWVyIHRvIGEgdHdpY2UgdGFnIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIChgbTEodDEpXG4gICAgLy8vID09IG0xKHQxKWApIGFuZCBhcHBseWluZyBtdWx0aXBsZSBtb2RpZmllcnMgd2lsbCwgcmVnYXJkbGVzcyBvclxuICAgIC8vLyBvcmRlciwgcHJvZHVjZSB0aGUgc2FtZSB0YWcgKGBtMShtMih0MSkpID09IG0yKG0xKHQxKSlgKS5cbiAgICAvLy9cbiAgICAvLy8gV2hlbiBtdWx0aXBsZSBtb2RpZmllcnMgYXJlIGFwcGxpZWQgdG8gYSBnaXZlbiBiYXNlIHRhZywgZWFjaFxuICAgIC8vLyBzbWFsbGVyIHNldCBvZiBtb2RpZmllcnMgaXMgcmVnaXN0ZXJlZCBhcyBhIHBhcmVudCwgc28gdGhhdCBmb3JcbiAgICAvLy8gZXhhbXBsZSBgbTEobTIobTModDEpKSlgIGlzIGEgc3VidHlwZSBvZiBgbTEobTIodDEpKWAsXG4gICAgLy8vIGBtMShtMyh0MSlgLCBhbmQgc28gb24uXG4gICAgc3RhdGljIGRlZmluZU1vZGlmaWVyKCkge1xuICAgICAgICBsZXQgbW9kID0gbmV3IE1vZGlmaWVyO1xuICAgICAgICByZXR1cm4gKHRhZykgPT4ge1xuICAgICAgICAgICAgaWYgKHRhZy5tb2RpZmllZC5pbmRleE9mKG1vZCkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICAgICAgcmV0dXJuIE1vZGlmaWVyLmdldCh0YWcuYmFzZSB8fCB0YWcsIHRhZy5tb2RpZmllZC5jb25jYXQobW9kKS5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCkpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmxldCBuZXh0TW9kaWZpZXJJRCA9IDA7XG5jbGFzcyBNb2RpZmllciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0gW107XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0TW9kaWZpZXJJRCsrO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KGJhc2UsIG1vZHMpIHtcbiAgICAgICAgaWYgKCFtb2RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICBsZXQgZXhpc3RzID0gbW9kc1swXS5pbnN0YW5jZXMuZmluZCh0ID0+IHQuYmFzZSA9PSBiYXNlICYmIHNhbWVBcnJheShtb2RzLCB0Lm1vZGlmaWVkKSk7XG4gICAgICAgIGlmIChleGlzdHMpXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RzO1xuICAgICAgICBsZXQgc2V0ID0gW10sIHRhZyA9IG5ldyBUYWcoc2V0LCBiYXNlLCBtb2RzKTtcbiAgICAgICAgZm9yIChsZXQgbSBvZiBtb2RzKVxuICAgICAgICAgICAgbS5pbnN0YW5jZXMucHVzaCh0YWcpO1xuICAgICAgICBsZXQgY29uZmlncyA9IHBvd2VyU2V0KG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgb2YgYmFzZS5zZXQpXG4gICAgICAgICAgICBpZiAoIXBhcmVudC5tb2RpZmllZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpXG4gICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKE1vZGlmaWVyLmdldChwYXJlbnQsIGNvbmZpZykpO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVBcnJheShhLCBiKSB7XG4gICAgcmV0dXJuIGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoKHgsIGkpID0+IHggPT0gYltpXSk7XG59XG5mdW5jdGlvbiBwb3dlclNldChhcnJheSkge1xuICAgIGxldCBzZXRzID0gW1tdXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBlID0gc2V0cy5sZW5ndGg7IGogPCBlOyBqKyspIHtcbiAgICAgICAgICAgIHNldHMucHVzaChzZXRzW2pdLmNvbmNhdChhcnJheVtpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXRzLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpO1xufVxuLy8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhZGQgYSBzZXQgb2YgdGFncyB0byBhIGxhbmd1YWdlIHN5bnRheFxuLy8vIHZpYSBbYE5vZGVTZXQuZXh0ZW5kYF0oI2NvbW1vbi5Ob2RlU2V0LmV4dGVuZCkgb3Jcbi8vLyBbYExSUGFyc2VyLmNvbmZpZ3VyZWBdKCNsci5MUlBhcnNlci5jb25maWd1cmUpLlxuLy8vXG4vLy8gVGhlIGFyZ3VtZW50IG9iamVjdCBtYXBzIG5vZGUgc2VsZWN0b3JzIHRvIFtoaWdobGlnaHRpbmdcbi8vLyB0YWdzXSgjaGlnaGxpZ2h0LlRhZykgb3IgYXJyYXlzIG9mIHRhZ3MuXG4vLy9cbi8vLyBOb2RlIHNlbGVjdG9ycyBtYXkgaG9sZCBvbmUgb3IgbW9yZSAoc3BhY2Utc2VwYXJhdGVkKSBub2RlIHBhdGhzLlxuLy8vIFN1Y2ggYSBwYXRoIGNhbiBiZSBhIFtub2RlIG5hbWVdKCNjb21tb24uTm9kZVR5cGUubmFtZSksIG9yXG4vLy8gbXVsdGlwbGUgbm9kZSBuYW1lcyAob3IgYCpgIHdpbGRjYXJkcykgc2VwYXJhdGVkIGJ5IHNsYXNoXG4vLy8gY2hhcmFjdGVycywgYXMgaW4gYFwiQmxvY2svRGVjbGFyYXRpb24vVmFyaWFibGVOYW1lXCJgLiBTdWNoIGEgcGF0aFxuLy8vIG1hdGNoZXMgdGhlIGZpbmFsIG5vZGUgYnV0IG9ubHkgaWYgaXRzIGRpcmVjdCBwYXJlbnQgbm9kZXMgYXJlIHRoZVxuLy8vIG90aGVyIG5vZGVzIG1lbnRpb25lZC4gQSBgKmAgaW4gc3VjaCBhIHBhdGggbWF0Y2hlcyBhbnkgcGFyZW50LFxuLy8vIGJ1dCBvbmx5IGEgc2luZ2xlIGxldmVsXHUyMDE0d2lsZGNhcmRzIHRoYXQgbWF0Y2ggbXVsdGlwbGUgcGFyZW50c1xuLy8vIGFyZW4ndCBzdXBwb3J0ZWQsIGJvdGggZm9yIGVmZmljaWVuY3kgcmVhc29ucyBhbmQgYmVjYXVzZSBMZXplclxuLy8vIHRyZWVzIG1ha2UgaXQgcmF0aGVyIGhhcmQgdG8gcmVhc29uIGFib3V0IHdoYXQgdGhleSB3b3VsZCBtYXRjaC4pXG4vLy9cbi8vLyBBIHBhdGggY2FuIGJlIGVuZGVkIHdpdGggYC8uLi5gIHRvIGluZGljYXRlIHRoYXQgdGhlIHRhZyBhc3NpZ25lZFxuLy8vIHRvIHRoZSBub2RlIHNob3VsZCBhbHNvIGFwcGx5IHRvIGFsbCBjaGlsZCBub2RlcywgZXZlbiBpZiB0aGV5XG4vLy8gbWF0Y2ggdGhlaXIgb3duIHN0eWxlIChieSBkZWZhdWx0LCBvbmx5IHRoZSBpbm5lcm1vc3Qgc3R5bGUgaXNcbi8vLyB1c2VkKS5cbi8vL1xuLy8vIFdoZW4gYSBwYXRoIGVuZHMgaW4gYCFgLCBhcyBpbiBgQXR0cmlidXRlIWAsIG5vIGZ1cnRoZXIgbWF0Y2hpbmdcbi8vLyBoYXBwZW5zIGZvciB0aGUgbm9kZSdzIGNoaWxkIG5vZGVzLCBhbmQgdGhlIGVudGlyZSBub2RlIGdldHMgdGhlXG4vLy8gZ2l2ZW4gc3R5bGUuXG4vLy9cbi8vLyBJbiB0aGlzIG5vdGF0aW9uLCBub2RlIG5hbWVzIHRoYXQgY29udGFpbiBgL2AsIGAhYCwgYCpgLCBvciBgLi4uYFxuLy8vIG11c3QgYmUgcXVvdGVkIGFzIEpTT04gc3RyaW5ncy5cbi8vL1xuLy8vIEZvciBleGFtcGxlOlxuLy8vXG4vLy8gYGBgamF2YXNjcmlwdFxuLy8vIHBhcnNlci53aXRoUHJvcHMoXG4vLy8gICBzdHlsZVRhZ3Moe1xuLy8vICAgICAvLyBTdHlsZSBOdW1iZXIgYW5kIEJpZ051bWJlciBub2Rlc1xuLy8vICAgICBcIk51bWJlciBCaWdOdW1iZXJcIjogdGFncy5udW1iZXIsXG4vLy8gICAgIC8vIFN0eWxlIEVzY2FwZSBub2RlcyB3aG9zZSBwYXJlbnQgaXMgU3RyaW5nXG4vLy8gICAgIFwiU3RyaW5nL0VzY2FwZVwiOiB0YWdzLmVzY2FwZSxcbi8vLyAgICAgLy8gU3R5bGUgYW55dGhpbmcgaW5zaWRlIEF0dHJpYnV0ZXMgbm9kZXNcbi8vLyAgICAgXCJBdHRyaWJ1dGVzIVwiOiB0YWdzLm1ldGEsXG4vLy8gICAgIC8vIEFkZCBhIHN0eWxlIHRvIGFsbCBjb250ZW50IGluc2lkZSBJdGFsaWMgbm9kZXNcbi8vLyAgICAgXCJJdGFsaWMvLi4uXCI6IHRhZ3MuZW1waGFzaXMsXG4vLy8gICAgIC8vIFN0eWxlIEludmFsaWRTdHJpbmcgbm9kZXMgYXMgYm90aCBgc3RyaW5nYCBhbmQgYGludmFsaWRgXG4vLy8gICAgIFwiSW52YWxpZFN0cmluZ1wiOiBbdGFncy5zdHJpbmcsIHRhZ3MuaW52YWxpZF0sXG4vLy8gICAgIC8vIFN0eWxlIHRoZSBub2RlIG5hbWVkIFwiL1wiIGFzIHB1bmN0dWF0aW9uXG4vLy8gICAgICdcIi9cIic6IHRhZ3MucHVuY3R1YXRpb25cbi8vLyAgIH0pXG4vLy8gKVxuLy8vIGBgYFxuZnVuY3Rpb24gc3R5bGVUYWdzKHNwZWMpIHtcbiAgICBsZXQgYnlOYW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpIHtcbiAgICAgICAgbGV0IHRhZ3MgPSBzcGVjW3Byb3BdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFncykpXG4gICAgICAgICAgICB0YWdzID0gW3RhZ3NdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGllY2VzID0gW10sIG1vZGUgPSAyIC8qIE1vZGUuTm9ybWFsICovLCByZXN0ID0gcGFydDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgPSAwOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3QgPT0gXCIuLi5cIiAmJiBwb3MgPiAwICYmIHBvcyArIDMgPT0gcGFydC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSAxIC8qIE1vZGUuSW5oZXJpdCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBtID0gL15cIig/OlteXCJcXFxcXXxcXFxcLikqP1wifFteXFwvIV0rLy5leGVjKHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcGllY2VzLnB1c2gobVswXSA9PSBcIipcIiA/IFwiXCIgOiBtWzBdWzBdID09ICdcIicgPyBKU09OLnBhcnNlKG1bMF0pIDogbVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBwYXJ0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHBhcnRbcG9zKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoICYmIG5leHQgPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSAwIC8qIE1vZGUuT3BhcXVlICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gXCIvXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHBhcnQuc2xpY2UocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBwaWVjZXMubGVuZ3RoIC0gMSwgaW5uZXIgPSBwaWVjZXNbbGFzdF07XG4gICAgICAgICAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSBuZXcgUnVsZSh0YWdzLCBtb2RlLCBsYXN0ID4gMCA/IHBpZWNlcy5zbGljZSgwLCBsYXN0KSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGJ5TmFtZVtpbm5lcl0gPSBydWxlLnNvcnQoYnlOYW1lW2lubmVyXSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydWxlTm9kZVByb3AuYWRkKGJ5TmFtZSk7XG59XG5jb25zdCBydWxlTm9kZVByb3AgPSBuZXcgTm9kZVByb3AoKTtcbmNsYXNzIFJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHRhZ3MsIG1vZGUsIGNvbnRleHQsIG5leHQpIHtcbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICB9XG4gICAgZ2V0IG9wYXF1ZSgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PSAwIC8qIE1vZGUuT3BhcXVlICovOyB9XG4gICAgZ2V0IGluaGVyaXQoKSB7IHJldHVybiB0aGlzLm1vZGUgPT0gMSAvKiBNb2RlLkluaGVyaXQgKi87IH1cbiAgICBzb3J0KG90aGVyKSB7XG4gICAgICAgIGlmICghb3RoZXIgfHwgb3RoZXIuZGVwdGggPCB0aGlzLmRlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBvdGhlcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyLm5leHQgPSB0aGlzLnNvcnQob3RoZXIubmV4dCk7XG4gICAgICAgIHJldHVybiBvdGhlcjtcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0ID8gdGhpcy5jb250ZXh0Lmxlbmd0aCA6IDA7IH1cbn1cblJ1bGUuZW1wdHkgPSBuZXcgUnVsZShbXSwgMiAvKiBNb2RlLk5vcm1hbCAqLywgbnVsbCk7XG4vLy8gRGVmaW5lIGEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKSBmcm9tIGFuIGFycmF5IG9mXG4vLy8gdGFnL2NsYXNzIHBhaXJzLiBDbGFzc2VzIGFzc29jaWF0ZWQgd2l0aCBtb3JlIHNwZWNpZmljIHRhZ3Mgd2lsbFxuLy8vIHRha2UgcHJlY2VkZW5jZS5cbmZ1bmN0aW9uIHRhZ0hpZ2hsaWdodGVyKHRhZ3MsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBzdHlsZSBvZiB0YWdzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdHlsZS50YWcpKVxuICAgICAgICAgICAgbWFwW3N0eWxlLnRhZy5pZF0gPSBzdHlsZS5jbGFzcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChsZXQgdGFnIG9mIHN0eWxlLnRhZylcbiAgICAgICAgICAgICAgICBtYXBbdGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xuICAgIH1cbiAgICBsZXQgeyBzY29wZSwgYWxsID0gbnVsbCB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZTogKHRhZ3MpID0+IHtcbiAgICAgICAgICAgIGxldCBjbHMgPSBhbGw7XG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2YgdGFncykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHN1YiBvZiB0YWcuc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YWdDbGFzcyA9IG1hcFtzdWIuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA9IGNscyA/IGNscyArIFwiIFwiICsgdGFnQ2xhc3MgOiB0YWdDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgfSxcbiAgICAgICAgc2NvcGVcbiAgICB9O1xufVxuZnVuY3Rpb24gaGlnaGxpZ2h0VGFncyhoaWdobGlnaHRlcnMsIHRhZ3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBoaWdobGlnaHRlciBvZiBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gaGlnaGxpZ2h0ZXIuc3R5bGUodGFncyk7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA/IHJlc3VsdCArIFwiIFwiICsgdmFsdWUgOiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vLyBIaWdobGlnaHQgdGhlIGdpdmVuIFt0cmVlXSgjY29tbW9uLlRyZWUpIHdpdGggdGhlIGdpdmVuXG4vLy8gW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKS5cbmZ1bmN0aW9uIGhpZ2hsaWdodFRyZWUodHJlZSwgaGlnaGxpZ2h0ZXIsIFxuLy8vIEFzc2lnbiBzdHlsaW5nIHRvIGEgcmVnaW9uIG9mIHRoZSB0ZXh0LiBXaWxsIGJlIGNhbGxlZCwgaW4gb3JkZXJcbi8vLyBvZiBwb3NpdGlvbiwgZm9yIGFueSByYW5nZXMgd2hlcmUgbW9yZSB0aGFuIHplcm8gY2xhc3NlcyBhcHBseS5cbi8vLyBgY2xhc3Nlc2AgaXMgYSBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIENTUyBjbGFzc2VzLlxucHV0U3R5bGUsIFxuLy8vIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG8gaGlnaGxpZ2h0LlxuZnJvbSA9IDAsIFxuLy8vIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxudG8gPSB0cmVlLmxlbmd0aCkge1xuICAgIGxldCBidWlsZGVyID0gbmV3IEhpZ2hsaWdodEJ1aWxkZXIoZnJvbSwgQXJyYXkuaXNBcnJheShoaWdobGlnaHRlcikgPyBoaWdobGlnaHRlciA6IFtoaWdobGlnaHRlcl0sIHB1dFN0eWxlKTtcbiAgICBidWlsZGVyLmhpZ2hsaWdodFJhbmdlKHRyZWUuY3Vyc29yKCksIGZyb20sIHRvLCBcIlwiLCBidWlsZGVyLmhpZ2hsaWdodGVycyk7XG4gICAgYnVpbGRlci5mbHVzaCh0byk7XG59XG5jbGFzcyBIaWdobGlnaHRCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhdCwgaGlnaGxpZ2h0ZXJzLCBzcGFuKSB7XG4gICAgICAgIHRoaXMuYXQgPSBhdDtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRlcnMgPSBoaWdobGlnaHRlcnM7XG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIHRoaXMuY2xhc3MgPSBcIlwiO1xuICAgIH1cbiAgICBzdGFydFNwYW4oYXQsIGNscykge1xuICAgICAgICBpZiAoY2xzICE9IHRoaXMuY2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goYXQpO1xuICAgICAgICAgICAgaWYgKGF0ID4gdGhpcy5hdClcbiAgICAgICAgICAgICAgICB0aGlzLmF0ID0gYXQ7XG4gICAgICAgICAgICB0aGlzLmNsYXNzID0gY2xzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZsdXNoKHRvKSB7XG4gICAgICAgIGlmICh0byA+IHRoaXMuYXQgJiYgdGhpcy5jbGFzcylcbiAgICAgICAgICAgIHRoaXMuc3Bhbih0aGlzLmF0LCB0bywgdGhpcy5jbGFzcyk7XG4gICAgfVxuICAgIGhpZ2hsaWdodFJhbmdlKGN1cnNvciwgZnJvbSwgdG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgbGV0IHsgdHlwZSwgZnJvbTogc3RhcnQsIHRvOiBlbmQgfSA9IGN1cnNvcjtcbiAgICAgICAgaWYgKHN0YXJ0ID49IHRvIHx8IGVuZCA8PSBmcm9tKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZS5pc1RvcClcbiAgICAgICAgICAgIGhpZ2hsaWdodGVycyA9IHRoaXMuaGlnaGxpZ2h0ZXJzLmZpbHRlcihoID0+ICFoLnNjb3BlIHx8IGguc2NvcGUodHlwZSkpO1xuICAgICAgICBsZXQgY2xzID0gaW5oZXJpdGVkQ2xhc3M7XG4gICAgICAgIGxldCBydWxlID0gZ2V0U3R5bGVUYWdzKGN1cnNvcikgfHwgUnVsZS5lbXB0eTtcbiAgICAgICAgbGV0IHRhZ0NscyA9IGhpZ2hsaWdodFRhZ3MoaGlnaGxpZ2h0ZXJzLCBydWxlLnRhZ3MpO1xuICAgICAgICBpZiAodGFnQ2xzKSB7XG4gICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgIGNscyArPSBcIiBcIjtcbiAgICAgICAgICAgIGNscyArPSB0YWdDbHM7XG4gICAgICAgICAgICBpZiAocnVsZS5tb2RlID09IDEgLyogTW9kZS5Jbmhlcml0ICovKVxuICAgICAgICAgICAgICAgIGluaGVyaXRlZENsYXNzICs9IChpbmhlcml0ZWRDbGFzcyA/IFwiIFwiIDogXCJcIikgKyB0YWdDbHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFNwYW4oY3Vyc29yLmZyb20sIGNscyk7XG4gICAgICAgIGlmIChydWxlLm9wYXF1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSBjdXJzb3IudHJlZSAmJiBjdXJzb3IudHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGN1cnNvci5ub2RlLmVudGVyKG1vdW50ZWQub3ZlcmxheVswXS5mcm9tICsgc3RhcnQsIDEpO1xuICAgICAgICAgICAgbGV0IGlubmVySGlnaGxpZ2h0ZXJzID0gdGhpcy5oaWdobGlnaHRlcnMuZmlsdGVyKGggPT4gIWguc2NvcGUgfHwgaC5zY29wZShtb3VudGVkLnRyZWUudHlwZSkpO1xuICAgICAgICAgICAgbGV0IGhhc0NoaWxkID0gY3Vyc29yLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBzdGFydDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaSA8IG1vdW50ZWQub3ZlcmxheS5sZW5ndGggPyBtb3VudGVkLm92ZXJsYXlbaV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0UG9zID0gbmV4dCA/IG5leHQuZnJvbSArIHN0YXJ0IDogZW5kO1xuICAgICAgICAgICAgICAgIGxldCByYW5nZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpLCByYW5nZVRvID0gTWF0aC5taW4odG8sIG5leHRQb3MpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZUZyb20gPCByYW5nZVRvICYmIGhhc0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IuZnJvbSA8IHJhbmdlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCByYW5nZUZyb20sIHJhbmdlVG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4ocmFuZ2VUbywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gbmV4dFBvcyB8fCAhY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHRQb3MgPiB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gbmV4dC50byArIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoaW5uZXIuY3Vyc29yKCksIE1hdGgubWF4KGZyb20sIG5leHQuZnJvbSArIHN0YXJ0KSwgTWF0aC5taW4odG8sIHBvcyksIGluaGVyaXRlZENsYXNzLCBpbm5lckhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKHBvcywgY2xzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQ2hpbGQpXG4gICAgICAgICAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLnRvIDw9IGZyb20pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZnJvbSA+PSB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnNvci5uZXh0U2libGluZygpKTtcbiAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vLyBNYXRjaCBhIHN5bnRheCBub2RlJ3MgW2hpZ2hsaWdodCBydWxlc10oI2hpZ2hsaWdodC5zdHlsZVRhZ3MpLiBJZlxuLy8vIHRoZXJlJ3MgYSBtYXRjaCwgcmV0dXJuIGl0cyBzZXQgb2YgdGFncywgYW5kIHdoZXRoZXIgaXQgaXNcbi8vLyBvcGFxdWUgKHVzZXMgYSBgIWApIG9yIGFwcGxpZXMgdG8gYWxsIGNoaWxkIG5vZGVzIChgLy4uLmApLlxuZnVuY3Rpb24gZ2V0U3R5bGVUYWdzKG5vZGUpIHtcbiAgICBsZXQgcnVsZSA9IG5vZGUudHlwZS5wcm9wKHJ1bGVOb2RlUHJvcCk7XG4gICAgd2hpbGUgKHJ1bGUgJiYgcnVsZS5jb250ZXh0ICYmICFub2RlLm1hdGNoQ29udGV4dChydWxlLmNvbnRleHQpKVxuICAgICAgICBydWxlID0gcnVsZS5uZXh0O1xuICAgIHJldHVybiBydWxlIHx8IG51bGw7XG59XG5jb25zdCB0ID0gVGFnLmRlZmluZTtcbmNvbnN0IGNvbW1lbnQgPSB0KCksIG5hbWUgPSB0KCksIHR5cGVOYW1lID0gdChuYW1lKSwgcHJvcGVydHlOYW1lID0gdChuYW1lKSwgbGl0ZXJhbCA9IHQoKSwgc3RyaW5nID0gdChsaXRlcmFsKSwgbnVtYmVyID0gdChsaXRlcmFsKSwgY29udGVudCA9IHQoKSwgaGVhZGluZyA9IHQoY29udGVudCksIGtleXdvcmQgPSB0KCksIG9wZXJhdG9yID0gdCgpLCBwdW5jdHVhdGlvbiA9IHQoKSwgYnJhY2tldCA9IHQocHVuY3R1YXRpb24pLCBtZXRhID0gdCgpO1xuLy8vIFRoZSBkZWZhdWx0IHNldCBvZiBoaWdobGlnaHRpbmcgW3RhZ3NdKCNoaWdobGlnaHQuVGFnKS5cbi8vL1xuLy8vIFRoaXMgY29sbGVjdGlvbiBpcyBoZWF2aWx5IGJpYXNlZCB0b3dhcmRzIHByb2dyYW1taW5nIGxhbmd1YWdlcyxcbi8vLyBhbmQgbmVjZXNzYXJpbHkgaW5jb21wbGV0ZS4gQSBmdWxsIG9udG9sb2d5IG9mIHN5bnRhY3RpY1xuLy8vIGNvbnN0cnVjdHMgd291bGQgZmlsbCBhIHN0YWNrIG9mIGJvb2tzLCBhbmQgYmUgaW1wcmFjdGljYWwgdG9cbi8vLyB3cml0ZSB0aGVtZXMgZm9yLiBTbyB0cnkgdG8gbWFrZSBkbyB3aXRoIHRoaXMgc2V0LiBJZiBhbGwgZWxzZVxuLy8vIGZhaWxzLCBbb3BlbiBhblxuLy8vIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9jb2RlbWlycm9yLm5leHQpIHRvIHByb3Bvc2UgYVxuLy8vIG5ldyB0YWcsIG9yIFtkZWZpbmVdKCNoaWdobGlnaHQuVGFnXmRlZmluZSkgYSBsb2NhbCBjdXN0b20gdGFnIGZvclxuLy8vIHlvdXIgdXNlIGNhc2UuXG4vLy9cbi8vLyBOb3RlIHRoYXQgaXQgaXMgbm90IG9ibGlnYXRvcnkgdG8gYWx3YXlzIGF0dGFjaCB0aGUgbW9zdCBzcGVjaWZpY1xuLy8vIHRhZyBwb3NzaWJsZSB0byBhbiBlbGVtZW50XHUyMDE0aWYgeW91ciBncmFtbWFyIGNhbid0IGVhc2lseVxuLy8vIGRpc3Rpbmd1aXNoIGEgY2VydGFpbiB0eXBlIG9mIGVsZW1lbnQgKHN1Y2ggYXMgYSBsb2NhbCB2YXJpYWJsZSksXG4vLy8gaXQgaXMgb2theSB0byBzdHlsZSBpdCBhcyBpdHMgbW9yZSBnZW5lcmFsIHZhcmlhbnQgKGEgdmFyaWFibGUpLlxuLy8vIFxuLy8vIEZvciB0YWdzIHRoYXQgZXh0ZW5kIHNvbWUgcGFyZW50IHRhZywgdGhlIGRvY3VtZW50YXRpb24gbGlua3MgdG9cbi8vLyB0aGUgcGFyZW50LlxuY29uc3QgdGFncyA9IHtcbiAgICAvLy8gQSBjb21tZW50LlxuICAgIGNvbW1lbnQsXG4gICAgLy8vIEEgbGluZSBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgIGxpbmVDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8vLyBBIGJsb2NrIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgYmxvY2tDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8vLyBBIGRvY3VtZW50YXRpb24gW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cbiAgICBkb2NDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8vLyBBbnkga2luZCBvZiBpZGVudGlmaWVyLlxuICAgIG5hbWUsXG4gICAgLy8vIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgdmFyaWFibGUuXG4gICAgdmFyaWFibGVOYW1lOiB0KG5hbWUpLFxuICAgIC8vLyBBIHR5cGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICB0eXBlTmFtZTogdHlwZU5hbWUsXG4gICAgLy8vIEEgdGFnIG5hbWUgKHN1YnRhZyBvZiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKSkuXG4gICAgdGFnTmFtZTogdCh0eXBlTmFtZSksXG4gICAgLy8vIEEgcHJvcGVydHkgb3IgZmllbGQgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAvLy8gQW4gYXR0cmlidXRlIG5hbWUgKHN1YnRhZyBvZiBbYHByb3BlcnR5TmFtZWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpKS5cbiAgICBhdHRyaWJ1dGVOYW1lOiB0KHByb3BlcnR5TmFtZSksXG4gICAgLy8vIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgY2xhc3MuXG4gICAgY2xhc3NOYW1lOiB0KG5hbWUpLFxuICAgIC8vLyBBIGxhYmVsIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgbGFiZWxOYW1lOiB0KG5hbWUpLFxuICAgIC8vLyBBIG5hbWVzcGFjZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgIG5hbWVzcGFjZTogdChuYW1lKSxcbiAgICAvLy8gVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBtYWNyby5cbiAgICBtYWNyb05hbWU6IHQobmFtZSksXG4gICAgLy8vIEEgbGl0ZXJhbCB2YWx1ZS5cbiAgICBsaXRlcmFsLFxuICAgIC8vLyBBIHN0cmluZyBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgIHN0cmluZyxcbiAgICAvLy8gQSBkb2N1bWVudGF0aW9uIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpLlxuICAgIGRvY1N0cmluZzogdChzdHJpbmcpLFxuICAgIC8vLyBBIGNoYXJhY3RlciBsaXRlcmFsIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgIGNoYXJhY3RlcjogdChzdHJpbmcpLFxuICAgIC8vLyBBbiBhdHRyaWJ1dGUgdmFsdWUgKHN1YnRhZyBvZiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSkuXG4gICAgYXR0cmlidXRlVmFsdWU6IHQoc3RyaW5nKSxcbiAgICAvLy8gQSBudW1iZXIgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICBudW1iZXIsXG4gICAgLy8vIEFuIGludGVnZXIgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICBpbnRlZ2VyOiB0KG51bWJlciksXG4gICAgLy8vIEEgZmxvYXRpbmctcG9pbnQgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICBmbG9hdDogdChudW1iZXIpLFxuICAgIC8vLyBBIGJvb2xlYW4gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICBib29sOiB0KGxpdGVyYWwpLFxuICAgIC8vLyBSZWd1bGFyIGV4cHJlc3Npb24gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICByZWdleHA6IHQobGl0ZXJhbCksXG4gICAgLy8vIEFuIGVzY2FwZSBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLCBmb3IgZXhhbXBsZSBhXG4gICAgLy8vIGJhY2tzbGFzaCBlc2NhcGUgaW4gYSBzdHJpbmcuXG4gICAgZXNjYXBlOiB0KGxpdGVyYWwpLFxuICAgIC8vLyBBIGNvbG9yIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgY29sb3I6IHQobGl0ZXJhbCksXG4gICAgLy8vIEEgVVJMIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgdXJsOiB0KGxpdGVyYWwpLFxuICAgIC8vLyBBIGxhbmd1YWdlIGtleXdvcmQuXG4gICAga2V5d29yZCxcbiAgICAvLy8gVGhlIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZm9yIHRoZSBzZWxmIG9yIHRoaXNcbiAgICAvLy8gb2JqZWN0LlxuICAgIHNlbGY6IHQoa2V5d29yZCksXG4gICAgLy8vIFRoZSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGZvciBudWxsLlxuICAgIG51bGw6IHQoa2V5d29yZCksXG4gICAgLy8vIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBkZW5vdGluZyBzb21lIGF0b21pYyB2YWx1ZS5cbiAgICBhdG9tOiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCByZXByZXNlbnRzIGEgdW5pdC5cbiAgICB1bml0OiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIG1vZGlmaWVyIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgbW9kaWZpZXI6IHQoa2V5d29yZCksXG4gICAgLy8vIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGFjdHMgYXMgYW4gb3BlcmF0b3IuXG4gICAgb3BlcmF0b3JLZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIGNvbnRyb2wtZmxvdyByZWxhdGVkIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgY29udHJvbEtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLy8vIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgIGRlZmluaXRpb25LZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgcmVsYXRlZCB0byBkZWZpbmluZyBvclxuICAgIC8vLyBpbnRlcmZhY2luZyB3aXRoIG1vZHVsZXMuXG4gICAgbW9kdWxlS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvLy8gQW4gb3BlcmF0b3IuXG4gICAgb3BlcmF0b3IsXG4gICAgLy8vIEFuIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlcmVmZXJlbmNlcyBzb21ldGhpbmcuXG4gICAgZGVyZWZPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIEFyaXRobWV0aWMtcmVsYXRlZCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgYXJpdGhtZXRpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gTG9naWNhbCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgbG9naWNPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIEJpdCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgYml0d2lzZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gQ29tcGFyaXNvbiBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgY29tcGFyZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gW09wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgdXBkYXRlcyBpdHMgb3BlcmFuZC5cbiAgICB1cGRhdGVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIFtPcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgIGRlZmluaXRpb25PcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIFR5cGUtcmVsYXRlZCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgdHlwZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gQ29udHJvbC1mbG93IFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICBjb250cm9sT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8vLyBQcm9ncmFtIG9yIG1hcmt1cCBwdW5jdHVhdGlvbi5cbiAgICBwdW5jdHVhdGlvbixcbiAgICAvLy8gW1B1bmN0dWF0aW9uXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pIHRoYXQgc2VwYXJhdGVzXG4gICAgLy8vIHRoaW5ncy5cbiAgICBzZXBhcmF0b3I6IHQocHVuY3R1YXRpb24pLFxuICAgIC8vLyBCcmFja2V0LXN0eWxlIFtwdW5jdHVhdGlvbl0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKS5cbiAgICBicmFja2V0LFxuICAgIC8vLyBBbmdsZSBbYnJhY2tldHNdKCNoaWdobGlnaHQudGFncy5icmFja2V0KSAodXN1YWxseSBgPGAgYW5kIGA+YFxuICAgIC8vLyB0b2tlbnMpLlxuICAgIGFuZ2xlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvLy8gU3F1YXJlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGBbYCBhbmQgYF1gXG4gICAgLy8vIHRva2VucykuXG4gICAgc3F1YXJlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvLy8gUGFyZW50aGVzZXMgKHVzdWFsbHkgYChgIGFuZCBgKWAgdG9rZW5zKS4gU3VidGFnIG9mXG4gICAgLy8vIFticmFja2V0XSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkuXG4gICAgcGFyZW46IHQoYnJhY2tldCksXG4gICAgLy8vIEJyYWNlcyAodXN1YWxseSBge2AgYW5kIGB9YCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICAvLy8gW2JyYWNrZXRdKCNoaWdobGlnaHQudGFncy5icmFja2V0KS5cbiAgICBicmFjZTogdChicmFja2V0KSxcbiAgICAvLy8gQ29udGVudCwgZm9yIGV4YW1wbGUgcGxhaW4gdGV4dCBpbiBYTUwgb3IgbWFya3VwIGRvY3VtZW50cy5cbiAgICBjb250ZW50LFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIGhlYWRpbmcuXG4gICAgaGVhZGluZyxcbiAgICAvLy8gQSBsZXZlbCAxIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgaGVhZGluZzE6IHQoaGVhZGluZyksXG4gICAgLy8vIEEgbGV2ZWwgMiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgIGhlYWRpbmcyOiB0KGhlYWRpbmcpLFxuICAgIC8vLyBBIGxldmVsIDMgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICBoZWFkaW5nMzogdChoZWFkaW5nKSxcbiAgICAvLy8gQSBsZXZlbCA0IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgaGVhZGluZzQ6IHQoaGVhZGluZyksXG4gICAgLy8vIEEgbGV2ZWwgNSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgIGhlYWRpbmc1OiB0KGhlYWRpbmcpLFxuICAgIC8vLyBBIGxldmVsIDYgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICBoZWFkaW5nNjogdChoZWFkaW5nKSxcbiAgICAvLy8gQSBwcm9zZSBzZXBhcmF0b3IgKHN1Y2ggYXMgYSBob3Jpem9udGFsIHJ1bGUpLlxuICAgIGNvbnRlbnRTZXBhcmF0b3I6IHQoY29udGVudCksXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgbGlzdC5cbiAgICBsaXN0OiB0KGNvbnRlbnQpLFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIHF1b3RlLlxuICAgIHF1b3RlOiB0KGNvbnRlbnQpLFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgZW1waGFzaXplZC5cbiAgICBlbXBoYXNpczogdChjb250ZW50KSxcbiAgICAvLy8gW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBzdHJvbmcuXG4gICAgc3Ryb25nOiB0KGNvbnRlbnQpLFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgcGFydCBvZiBhIGxpbmsuXG4gICAgbGluazogdChjb250ZW50KSxcbiAgICAvLy8gW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBhcyBjb2RlIG9yXG4gICAgLy8vIG1vbm9zcGFjZS5cbiAgICBtb25vc3BhY2U6IHQoY29udGVudCksXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBoYXMgYSBzdHJpa2UtdGhyb3VnaFxuICAgIC8vLyBzdHlsZS5cbiAgICBzdHJpa2V0aHJvdWdoOiB0KGNvbnRlbnQpLFxuICAgIC8vLyBJbnNlcnRlZCB0ZXh0IGluIGEgY2hhbmdlLXRyYWNraW5nIGZvcm1hdC5cbiAgICBpbnNlcnRlZDogdCgpLFxuICAgIC8vLyBEZWxldGVkIHRleHQuXG4gICAgZGVsZXRlZDogdCgpLFxuICAgIC8vLyBDaGFuZ2VkIHRleHQuXG4gICAgY2hhbmdlZDogdCgpLFxuICAgIC8vLyBBbiBpbnZhbGlkIG9yIHVuc3ludGFjdGljIGVsZW1lbnQuXG4gICAgaW52YWxpZDogdCgpLFxuICAgIC8vLyBNZXRhZGF0YSBvciBtZXRhLWluc3RydWN0aW9uLlxuICAgIG1ldGEsXG4gICAgLy8vIFtNZXRhZGF0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpIHRoYXQgYXBwbGllcyB0byB0aGUgZW50aXJlXG4gICAgLy8vIGRvY3VtZW50LlxuICAgIGRvY3VtZW50TWV0YTogdChtZXRhKSxcbiAgICAvLy8gW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhbm5vdGF0ZXMgb3IgYWRkc1xuICAgIC8vLyBhdHRyaWJ1dGVzIHRvIGEgZ2l2ZW4gc3ludGFjdGljIGVsZW1lbnQuXG4gICAgYW5ub3RhdGlvbjogdChtZXRhKSxcbiAgICAvLy8gUHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBvciBwcmVwcm9jZXNzb3IgZGlyZWN0aXZlLiBTdWJ0YWcgb2ZcbiAgICAvLy8gW21ldGFdKCNoaWdobGlnaHQudGFncy5tZXRhKS5cbiAgICBwcm9jZXNzaW5nSW5zdHJ1Y3Rpb246IHQobWV0YSksXG4gICAgLy8vIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXQgYVxuICAgIC8vLyBnaXZlbiBlbGVtZW50IGlzIGJlaW5nIGRlZmluZWQuIEV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aCB0aGVcbiAgICAvLy8gdmFyaW91cyBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRhZ3MuXG4gICAgZGVmaW5pdGlvbjogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLy8vIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXRcbiAgICAvLy8gc29tZXRoaW5nIGlzIGNvbnN0YW50LiBNb3N0bHkgZXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoXG4gICAgLy8vIFt2YXJpYWJsZSBuYW1lc10oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkuXG4gICAgY29uc3RhbnQ6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8vLyBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB1c2VkIHRvIGluZGljYXRlIHRoYXRcbiAgICAvLy8gYSBbdmFyaWFibGVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIG9yIFtwcm9wZXJ0eVxuICAgIC8vLyBuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSBpcyBiZWluZyBjYWxsZWQgb3IgZGVmaW5lZFxuICAgIC8vLyBhcyBhIGZ1bmN0aW9uLlxuICAgIGZ1bmN0aW9uOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvLy8gW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBjYW4gYmUgYXBwbGllZCB0b1xuICAgIC8vLyBbbmFtZXNdKCNoaWdobGlnaHQudGFncy5uYW1lKSB0byBpbmRpY2F0ZSB0aGF0IHRoZXkgYmVsb25nIHRvXG4gICAgLy8vIHRoZSBsYW5ndWFnZSdzIHN0YW5kYXJkIGVudmlyb25tZW50LlxuICAgIHN0YW5kYXJkOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvLy8gW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgYSBnaXZlblxuICAgIC8vLyBbbmFtZXNdKCNoaWdobGlnaHQudGFncy5uYW1lKSBpcyBsb2NhbCB0byBzb21lIHNjb3BlLlxuICAgIGxvY2FsOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvLy8gQSBnZW5lcmljIHZhcmlhbnQgW21vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdFxuICAgIC8vLyBjYW4gYmUgdXNlZCB0byB0YWcgbGFuZ3VhZ2Utc3BlY2lmaWMgYWx0ZXJuYXRpdmUgdmFyaWFudHMgb2ZcbiAgICAvLy8gc29tZSBjb21tb24gdGFnLiBJdCBpcyByZWNvbW1lbmRlZCBmb3IgdGhlbWVzIHRvIGRlZmluZSBzcGVjaWFsXG4gICAgLy8vIGZvcm1zIG9mIGF0IGxlYXN0IHRoZSBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSBhbmRcbiAgICAvLy8gW3ZhcmlhYmxlIG5hbWVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIHRhZ3MsIHNpbmNlIHRob3NlXG4gICAgLy8vIGNvbWUgdXAgYSBsb3QuXG4gICAgc3BlY2lhbDogVGFnLmRlZmluZU1vZGlmaWVyKClcbn07XG4vLy8gVGhpcyBpcyBhIGhpZ2hsaWdodGVyIHRoYXQgYWRkcyBzdGFibGUsIHByZWRpY3RhYmxlIGNsYXNzZXMgdG9cbi8vLyB0b2tlbnMsIGZvciBzdHlsaW5nIHdpdGggZXh0ZXJuYWwgQ1NTLlxuLy8vXG4vLy8gVGhlIGZvbGxvd2luZyB0YWdzIGFyZSBtYXBwZWQgdG8gdGhlaXIgbmFtZSBwcmVmaXhlZCB3aXRoIGBcInRvay1cImBcbi8vLyAoZm9yIGV4YW1wbGUgYFwidG9rLWNvbW1lbnRcImApOlxuLy8vXG4vLy8gKiBbYGxpbmtgXSgjaGlnaGxpZ2h0LnRhZ3MubGluaylcbi8vLyAqIFtgaGVhZGluZ2BdKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKVxuLy8vICogW2BlbXBoYXNpc2BdKCNoaWdobGlnaHQudGFncy5lbXBoYXNpcylcbi8vLyAqIFtgc3Ryb25nYF0oI2hpZ2hsaWdodC50YWdzLnN0cm9uZylcbi8vLyAqIFtga2V5d29yZGBdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKVxuLy8vICogW2BhdG9tYF0oI2hpZ2hsaWdodC50YWdzLmF0b20pXG4vLy8gKiBbYGJvb2xgXSgjaGlnaGxpZ2h0LnRhZ3MuYm9vbClcbi8vLyAqIFtgdXJsYF0oI2hpZ2hsaWdodC50YWdzLnVybClcbi8vLyAqIFtgbGFiZWxOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmxhYmVsTmFtZSlcbi8vLyAqIFtgaW5zZXJ0ZWRgXSgjaGlnaGxpZ2h0LnRhZ3MuaW5zZXJ0ZWQpXG4vLy8gKiBbYGRlbGV0ZWRgXSgjaGlnaGxpZ2h0LnRhZ3MuZGVsZXRlZClcbi8vLyAqIFtgbGl0ZXJhbGBdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKVxuLy8vICogW2BzdHJpbmdgXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKVxuLy8vICogW2BudW1iZXJgXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKVxuLy8vICogW2B2YXJpYWJsZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuLy8vICogW2B0eXBlTmFtZWBdKCNoaWdobGlnaHQudGFncy50eXBlTmFtZSlcbi8vLyAqIFtgbmFtZXNwYWNlYF0oI2hpZ2hsaWdodC50YWdzLm5hbWVzcGFjZSlcbi8vLyAqIFtgY2xhc3NOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmNsYXNzTmFtZSlcbi8vLyAqIFtgbWFjcm9OYW1lYF0oI2hpZ2hsaWdodC50YWdzLm1hY3JvTmFtZSlcbi8vLyAqIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbi8vLyAqIFtgb3BlcmF0b3JgXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpXG4vLy8gKiBbYGNvbW1lbnRgXSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudClcbi8vLyAqIFtgbWV0YWBdKCNoaWdobGlnaHQudGFncy5tZXRhKVxuLy8vICogW2BwdW5jdHVhdGlvbmBdKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbilcbi8vLyAqIFtgaW52YWxpZGBdKCNoaWdobGlnaHQudGFncy5pbnZhbGlkKVxuLy8vXG4vLy8gSW4gYWRkaXRpb24sIHRoZXNlIG1hcHBpbmdzIGFyZSBwcm92aWRlZDpcbi8vL1xuLy8vICogW2ByZWdleHBgXSgjaGlnaGxpZ2h0LnRhZ3MucmVnZXhwKSxcbi8vLyAgIFtgZXNjYXBlYF0oI2hpZ2hsaWdodC50YWdzLmVzY2FwZSksIGFuZFxuLy8vICAgW2BzcGVjaWFsYF0oI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2Aoc3RyaW5nKWBdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4vLy8gICBhcmUgbWFwcGVkIHRvIGBcInRvay1zdHJpbmcyXCJgXG4vLy8gKiBbYHNwZWNpYWxgXSgjaGlnaGxpZ2h0LnRhZ3Muc3BlY2lhbClbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbi8vLyAgIHRvIGBcInRvay12YXJpYWJsZU5hbWUyXCJgXG4vLy8gKiBbYGxvY2FsYF0oI2hpZ2hsaWdodC50YWdzLmxvY2FsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuLy8vICAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZSB0b2stbG9jYWxcImBcbi8vLyAqIFtgZGVmaW5pdGlvbmBdKCNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuLy8vICAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiYFxuLy8vICogW2BkZWZpbml0aW9uYF0oI2hpZ2hsaWdodC50YWdzLmRlZmluaXRpb24pW2AocHJvcGVydHlOYW1lKWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpXG4vLy8gICB0byBgXCJ0b2stcHJvcGVydHlOYW1lIHRvay1kZWZpbml0aW9uXCJgXG5jb25zdCBjbGFzc0hpZ2hsaWdodGVyID0gdGFnSGlnaGxpZ2h0ZXIoW1xuICAgIHsgdGFnOiB0YWdzLmxpbmssIGNsYXNzOiBcInRvay1saW5rXCIgfSxcbiAgICB7IHRhZzogdGFncy5oZWFkaW5nLCBjbGFzczogXCJ0b2staGVhZGluZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZW1waGFzaXMsIGNsYXNzOiBcInRvay1lbXBoYXNpc1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3Ryb25nLCBjbGFzczogXCJ0b2stc3Ryb25nXCIgfSxcbiAgICB7IHRhZzogdGFncy5rZXl3b3JkLCBjbGFzczogXCJ0b2sta2V5d29yZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuYXRvbSwgY2xhc3M6IFwidG9rLWF0b21cIiB9LFxuICAgIHsgdGFnOiB0YWdzLmJvb2wsIGNsYXNzOiBcInRvay1ib29sXCIgfSxcbiAgICB7IHRhZzogdGFncy51cmwsIGNsYXNzOiBcInRvay11cmxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxhYmVsTmFtZSwgY2xhc3M6IFwidG9rLWxhYmVsTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW5zZXJ0ZWQsIGNsYXNzOiBcInRvay1pbnNlcnRlZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVsZXRlZCwgY2xhc3M6IFwidG9rLWRlbGV0ZWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxpdGVyYWwsIGNsYXNzOiBcInRvay1saXRlcmFsXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJpbmcsIGNsYXNzOiBcInRvay1zdHJpbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm51bWJlciwgY2xhc3M6IFwidG9rLW51bWJlclwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnJlZ2V4cCwgdGFncy5lc2NhcGUsIHRhZ3Muc3BlY2lhbCh0YWdzLnN0cmluZyldLCBjbGFzczogXCJ0b2stc3RyaW5nMlwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudmFyaWFibGVOYW1lLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5sb2NhbCh0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUgdG9rLWxvY2FsXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUyXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSwgY2xhc3M6IFwidG9rLXByb3BlcnR5TmFtZSB0b2stZGVmaW5pdGlvblwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudHlwZU5hbWUsIGNsYXNzOiBcInRvay10eXBlTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubmFtZXNwYWNlLCBjbGFzczogXCJ0b2stbmFtZXNwYWNlXCIgfSxcbiAgICB7IHRhZzogdGFncy5jbGFzc05hbWUsIGNsYXNzOiBcInRvay1jbGFzc05hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm1hY3JvTmFtZSwgY2xhc3M6IFwidG9rLW1hY3JvTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MucHJvcGVydHlOYW1lLCBjbGFzczogXCJ0b2stcHJvcGVydHlOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5vcGVyYXRvciwgY2xhc3M6IFwidG9rLW9wZXJhdG9yXCIgfSxcbiAgICB7IHRhZzogdGFncy5jb21tZW50LCBjbGFzczogXCJ0b2stY29tbWVudFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubWV0YSwgY2xhc3M6IFwidG9rLW1ldGFcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmludmFsaWQsIGNsYXNzOiBcInRvay1pbnZhbGlkXCIgfSxcbiAgICB7IHRhZzogdGFncy5wdW5jdHVhdGlvbiwgY2xhc3M6IFwidG9rLXB1bmN0dWF0aW9uXCIgfVxuXSk7XG5cbmV4cG9ydCB7IFRhZywgY2xhc3NIaWdobGlnaHRlciwgZ2V0U3R5bGVUYWdzLCBoaWdobGlnaHRUcmVlLCBzdHlsZVRhZ3MsIHRhZ0hpZ2hsaWdodGVyLCB0YWdzIH07XG4iLCAiaW1wb3J0IHsgTm9kZVByb3AsIEl0ZXJNb2RlLCBUcmVlLCBUcmVlRnJhZ21lbnQsIFBhcnNlciwgTm9kZVR5cGUsIE5vZGVTZXQgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcbmltcG9ydCB7IFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBGYWNldCwgRWRpdG9yU3RhdGUsIGNvdW50Q29sdW1uLCBjb21iaW5lQ29uZmlnLCBSYW5nZVNldCwgUmFuZ2VTZXRCdWlsZGVyLCBQcmVjIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgVmlld1BsdWdpbiwgbG9nRXhjZXB0aW9uLCBFZGl0b3JWaWV3LCBEZWNvcmF0aW9uLCBXaWRnZXRUeXBlLCBndXR0ZXIsIEd1dHRlck1hcmtlciB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgdGFncywgdGFnSGlnaGxpZ2h0ZXIsIGhpZ2hsaWdodFRyZWUsIHN0eWxlVGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuaW1wb3J0IHsgU3R5bGVNb2R1bGUgfSBmcm9tICdzdHlsZS1tb2QnO1xuXG52YXIgX2E7XG4vKipcbk5vZGUgcHJvcCBzdG9yZWQgaW4gYSBwYXJzZXIncyB0b3Agc3ludGF4IG5vZGUgdG8gcHJvdmlkZSB0aGVcbmZhY2V0IHRoYXQgc3RvcmVzIGxhbmd1YWdlLXNwZWNpZmljIGRhdGEgZm9yIHRoYXQgbGFuZ3VhZ2UuXG4qL1xuY29uc3QgbGFuZ3VhZ2VEYXRhUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuSGVscGVyIGZ1bmN0aW9uIHRvIGRlZmluZSBhIGZhY2V0ICh0byBiZSBhZGRlZCB0byB0aGUgdG9wIHN5bnRheFxubm9kZShzKSBmb3IgYSBsYW5ndWFnZSB2aWFcbltgbGFuZ3VhZ2VEYXRhUHJvcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkpLCB0aGF0IHdpbGwgYmVcbnVzZWQgdG8gYXNzb2NpYXRlIGxhbmd1YWdlIGRhdGEgd2l0aCB0aGUgbGFuZ3VhZ2UuIFlvdVxucHJvYmFibHkgb25seSBuZWVkIHRoaXMgd2hlbiBzdWJjbGFzc2luZ1xuW2BMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpLlxuKi9cbmZ1bmN0aW9uIGRlZmluZUxhbmd1YWdlRmFjZXQoYmFzZURhdGEpIHtcbiAgICByZXR1cm4gRmFjZXQuZGVmaW5lKHtcbiAgICAgICAgY29tYmluZTogYmFzZURhdGEgPyB2YWx1ZXMgPT4gdmFsdWVzLmNvbmNhdChiYXNlRGF0YSkgOiB1bmRlZmluZWRcbiAgICB9KTtcbn1cbi8qKlxuU3ludGF4IG5vZGUgcHJvcCB1c2VkIHRvIHJlZ2lzdGVyIHN1YmxhbmdhdWdlcy4gU2hvdWxkIGJlIGFkZGVkIHRvXG50aGUgdG9wIGxldmVsIG5vZGUgdHlwZSBmb3IgdGhlIGxhbmd1YWdlLlxuKi9cbmNvbnN0IHN1Ymxhbmd1YWdlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuQSBsYW5ndWFnZSBvYmplY3QgbWFuYWdlcyBwYXJzaW5nIGFuZCBwZXItbGFuZ3VhZ2VcblttZXRhZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuIFBhcnNlIGRhdGEgaXNcbm1hbmFnZWQgYXMgYSBbTGV6ZXJdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQpIHRyZWUuIFRoZSBjbGFzc1xuY2FuIGJlIHVzZWQgZGlyZWN0bHksIHZpYSB0aGUgW2BMUkxhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MUkxhbmd1YWdlKVxuc3ViY2xhc3MgZm9yIFtMZXplcl0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC8pIExSIHBhcnNlcnMsIG9yXG52aWEgdGhlIFtgU3RyZWFtTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlN0cmVhbUxhbmd1YWdlKSBzdWJjbGFzc1xuZm9yIHN0cmVhbSBwYXJzZXJzLlxuKi9cbmNsYXNzIExhbmd1YWdlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBsYW5ndWFnZSBvYmplY3QuIElmIHlvdSBuZWVkIHRvIGludm9rZSB0aGlzXG4gICAgZGlyZWN0bHksIGZpcnN0IGRlZmluZSBhIGRhdGEgZmFjZXQgd2l0aFxuICAgIFtgZGVmaW5lTGFuZ3VhZ2VGYWNldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZGVmaW5lTGFuZ3VhZ2VGYWNldCksIGFuZCB0aGVuXG4gICAgY29uZmlndXJlIHlvdXIgcGFyc2VyIHRvIFthdHRhY2hdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkgaXRcbiAgICB0byB0aGUgbGFuZ3VhZ2UncyBvdXRlciBzeW50YXggbm9kZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBbbGFuZ3VhZ2UgZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkgZmFjZXRcbiAgICB1c2VkIGZvciB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgZGF0YSwgcGFyc2VyLCBleHRyYUV4dGVuc2lvbnMgPSBbXSwgXG4gICAgLyoqXG4gICAgQSBsYW5ndWFnZSBuYW1lLlxuICAgICovXG4gICAgbmFtZSA9IFwiXCIpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgLy8gS2x1ZGdlIHRvIGRlZmluZSBFZGl0b3JTdGF0ZS50cmVlIGFzIGEgZGVidWdnaW5nIGhlbHBlcixcbiAgICAgICAgLy8gd2l0aG91dCB0aGUgRWRpdG9yU3RhdGUgcGFja2FnZSBhY3R1YWxseSBrbm93aW5nIGFib3V0XG4gICAgICAgIC8vIGxhbmd1YWdlcyBhbmQgbGV6ZXIgdHJlZXMuXG4gICAgICAgIGlmICghRWRpdG9yU3RhdGUucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwidHJlZVwiKSlcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFZGl0b3JTdGF0ZS5wcm90b3R5cGUsIFwidHJlZVwiLCB7IGdldCgpIHsgcmV0dXJuIHN5bnRheFRyZWUodGhpcyk7IH0gfSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtcbiAgICAgICAgICAgIGxhbmd1YWdlLm9mKHRoaXMpLFxuICAgICAgICAgICAgRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhLm9mKChzdGF0ZSwgcG9zLCBzaWRlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRvcCA9IHRvcE5vZGVBdChzdGF0ZSwgcG9zLCBzaWRlKSwgZGF0YSA9IHRvcC50eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBzdGF0ZS5mYWNldChkYXRhKSwgc3ViID0gdG9wLnR5cGUucHJvcChzdWJsYW5ndWFnZVByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyTm9kZSA9IHRvcC5yZXNvbHZlKHBvcyAtIHRvcC5mcm9tLCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc3VibGFuZyBvZiBzdWIpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VibGFuZy50ZXN0KGlubmVyTm9kZSwgc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBzdGF0ZS5mYWNldChzdWJsYW5nLmZhY2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VibGFuZy50eXBlID09IFwicmVwbGFjZVwiID8gZGF0YSA6IGRhdGEuY29uY2F0KGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF0uY29uY2F0KGV4dHJhRXh0ZW5zaW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJ5IHdoZXRoZXIgdGhpcyBsYW5ndWFnZSBpcyBhY3RpdmUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgaXNBY3RpdmVBdChzdGF0ZSwgcG9zLCBzaWRlID0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRvcE5vZGVBdChzdGF0ZSwgcG9zLCBzaWRlKS50eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCByZWdpb25zIHRoYXQgd2VyZSBwYXJzZWQgdXNpbmcgdGhpcyBsYW5ndWFnZS5cbiAgICBUaGUgcmV0dXJuZWQgcmVnaW9ucyB3aWxsIF9pbmNsdWRlXyBhbnkgbmVzdGVkIGxhbmd1YWdlcyByb290ZWRcbiAgICBpbiB0aGlzIGxhbmd1YWdlLCB3aGVuIHRob3NlIGV4aXN0LlxuICAgICovXG4gICAgZmluZFJlZ2lvbnMoc3RhdGUpIHtcbiAgICAgICAgbGV0IGxhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSk7XG4gICAgICAgIGlmICgobGFuZyA9PT0gbnVsbCB8fCBsYW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYW5nLmRhdGEpID09IHRoaXMuZGF0YSlcbiAgICAgICAgICAgIHJldHVybiBbeyBmcm9tOiAwLCB0bzogc3RhdGUuZG9jLmxlbmd0aCB9XTtcbiAgICAgICAgaWYgKCFsYW5nIHx8ICFsYW5nLmFsbG93c05lc3RpbmcpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGV4cGxvcmUgPSAodHJlZSwgZnJvbSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRyZWUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb20sIHRvOiBmcm9tICsgdHJlZS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1vdW50ID0gdHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICAgICAgaWYgKG1vdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdW50LnRyZWUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdW50Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1vdW50Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tOiByLmZyb20gKyBmcm9tLCB0bzogci50byArIGZyb20gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbTogZnJvbSwgdG86IGZyb20gKyB0cmVlLmxlbmd0aCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9yZShtb3VudC50cmVlLCBtb3VudC5vdmVybGF5WzBdLmZyb20gKyBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiBzaXplKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IHRyZWUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoIGluc3RhbmNlb2YgVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9yZShjaCwgdHJlZS5wb3NpdGlvbnNbaV0gKyBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZXhwbG9yZShzeW50YXhUcmVlKHN0YXRlKSwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgbGFuZ3VhZ2UgYWxsb3dzIG5lc3RlZCBsYW5ndWFnZXMuIFRoZVxuICAgIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0cnVlLlxuICAgICovXG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiB0cnVlOyB9XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbkxhbmd1YWdlLnNldFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuZnVuY3Rpb24gdG9wTm9kZUF0KHN0YXRlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgdG9wTGFuZyA9IHN0YXRlLmZhY2V0KGxhbmd1YWdlKSwgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLnRvcE5vZGU7XG4gICAgaWYgKCF0b3BMYW5nIHx8IHRvcExhbmcuYWxsb3dzTmVzdGluZykge1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdHJlZTsgbm9kZTsgbm9kZSA9IG5vZGUuZW50ZXIocG9zLCBzaWRlLCBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycykpXG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLmlzVG9wKVxuICAgICAgICAgICAgICAgIHRyZWUgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gdHJlZTtcbn1cbi8qKlxuQSBzdWJjbGFzcyBvZiBbYExhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkgZm9yIHVzZSB3aXRoIExlemVyXG5bTFIgcGFyc2Vyc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNsci5MUlBhcnNlcilcbnBhcnNlcnMuXG4qL1xuY2xhc3MgTFJMYW5ndWFnZSBleHRlbmRzIExhbmd1YWdlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgc3VwZXIoZGF0YSwgcGFyc2VyLCBbXSwgbmFtZSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBsYW5ndWFnZSBmcm9tIGEgcGFyc2VyLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBkYXRhID0gZGVmaW5lTGFuZ3VhZ2VGYWNldChzcGVjLmxhbmd1YWdlRGF0YSk7XG4gICAgICAgIHJldHVybiBuZXcgTFJMYW5ndWFnZShkYXRhLCBzcGVjLnBhcnNlci5jb25maWd1cmUoe1xuICAgICAgICAgICAgcHJvcHM6IFtsYW5ndWFnZURhdGFQcm9wLmFkZCh0eXBlID0+IHR5cGUuaXNUb3AgPyBkYXRhIDogdW5kZWZpbmVkKV1cbiAgICAgICAgfSksIHNwZWMubmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIGxhbmd1YWdlIHdpdGggYSByZWNvbmZpZ3VyZWRcbiAgICB2ZXJzaW9uIG9mIGl0cyBwYXJzZXIgYW5kIG9wdGlvbmFsbHkgYSBuZXcgbmFtZS5cbiAgICAqL1xuICAgIGNvbmZpZ3VyZShvcHRpb25zLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgTFJMYW5ndWFnZSh0aGlzLmRhdGEsIHRoaXMucGFyc2VyLmNvbmZpZ3VyZShvcHRpb25zKSwgbmFtZSB8fCB0aGlzLm5hbWUpO1xuICAgIH1cbiAgICBnZXQgYWxsb3dzTmVzdGluZygpIHsgcmV0dXJuIHRoaXMucGFyc2VyLmhhc1dyYXBwZXJzKCk7IH1cbn1cbi8qKlxuR2V0IHRoZSBzeW50YXggdHJlZSBmb3IgYSBzdGF0ZSwgd2hpY2ggaXMgdGhlIGN1cnJlbnQgKHBvc3NpYmx5XG5pbmNvbXBsZXRlKSBwYXJzZSB0cmVlIG9mIHRoZSBhY3RpdmVcbltsYW5ndWFnZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSksIG9yIHRoZSBlbXB0eSB0cmVlIGlmIHRoZXJlIGlzIG5vXG5sYW5ndWFnZSBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gc3ludGF4VHJlZShzdGF0ZSkge1xuICAgIGxldCBmaWVsZCA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZpZWxkID8gZmllbGQudHJlZSA6IFRyZWUuZW1wdHk7XG59XG4vKipcblRyeSB0byBnZXQgYSBwYXJzZSB0cmVlIHRoYXQgc3BhbnMgYXQgbGVhc3QgdXAgdG8gYHVwdG9gLiBUaGVcbm1ldGhvZCB3aWxsIGRvIGF0IG1vc3QgYHRpbWVvdXRgIG1pbGxpc2Vjb25kcyBvZiB3b3JrIHRvIHBhcnNlXG51cCB0byB0aGF0IHBvaW50IGlmIHRoZSB0cmVlIGlzbid0IGFscmVhZHkgYXZhaWxhYmxlLlxuKi9cbmZ1bmN0aW9uIGVuc3VyZVN5bnRheFRyZWUoc3RhdGUsIHVwdG8sIHRpbWVvdXQgPSA1MCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgcGFyc2UgPSAoX2EgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGV4dDtcbiAgICBpZiAoIXBhcnNlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgb2xkVmllcG9ydCA9IHBhcnNlLnZpZXdwb3J0O1xuICAgIHBhcnNlLnVwZGF0ZVZpZXdwb3J0KHsgZnJvbTogMCwgdG86IHVwdG8gfSk7XG4gICAgbGV0IHJlc3VsdCA9IHBhcnNlLmlzRG9uZSh1cHRvKSB8fCBwYXJzZS53b3JrKHRpbWVvdXQsIHVwdG8pID8gcGFyc2UudHJlZSA6IG51bGw7XG4gICAgcGFyc2UudXBkYXRlVmlld3BvcnQob2xkVmllcG9ydCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuUXVlcmllcyB3aGV0aGVyIHRoZXJlIGlzIGEgZnVsbCBzeW50YXggdHJlZSBhdmFpbGFibGUgdXAgdG8gdGhlXG5naXZlbiBkb2N1bWVudCBwb3NpdGlvbi4gSWYgdGhlcmUgaXNuJ3QsIHRoZSBiYWNrZ3JvdW5kIHBhcnNlXG5wcm9jZXNzIF9taWdodF8gc3RpbGwgYmUgd29ya2luZyBhbmQgdXBkYXRlIHRoZSB0cmVlIGZ1cnRoZXIsIGJ1dFxudGhlcmUgaXMgbm8gZ3VhcmFudGVlIG9mIHRoYXRcdTIwMTR0aGUgcGFyc2VyIHdpbGwgW3N0b3BcbndvcmtpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2Uuc3ludGF4UGFyc2VyUnVubmluZykgd2hlbiBpdCBoYXMgc3BlbnQgYVxuY2VydGFpbiBhbW91bnQgb2YgdGltZSBvciBoYXMgbW92ZWQgYmV5b25kIHRoZSB2aXNpYmxlIHZpZXdwb3J0LlxuQWx3YXlzIHJldHVybnMgZmFsc2UgaWYgbm8gbGFuZ3VhZ2UgaGFzIGJlZW4gZW5hYmxlZC5cbiovXG5mdW5jdGlvbiBzeW50YXhUcmVlQXZhaWxhYmxlKHN0YXRlLCB1cHRvID0gc3RhdGUuZG9jLmxlbmd0aCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZXh0LmlzRG9uZSh1cHRvKSkgfHwgZmFsc2U7XG59XG4vKipcbk1vdmUgcGFyc2luZyBmb3J3YXJkLCBhbmQgdXBkYXRlIHRoZSBlZGl0b3Igc3RhdGUgYWZ0ZXJ3YXJkcyB0b1xucmVmbGVjdCB0aGUgbmV3IHRyZWUuIFdpbGwgd29yayBmb3IgYXQgbW9zdCBgdGltZW91dGBcbm1pbGxpc2Vjb25kcy4gUmV0dXJucyB0cnVlIGlmIHRoZSBwYXJzZXIgbWFuYWdlZCBnZXQgdG8gdGhlIGdpdmVuXG5wb3NpdGlvbiBpbiB0aGF0IHRpbWUuXG4qL1xuZnVuY3Rpb24gZm9yY2VQYXJzaW5nKHZpZXcsIHVwdG8gPSB2aWV3LnZpZXdwb3J0LnRvLCB0aW1lb3V0ID0gMTAwKSB7XG4gICAgbGV0IHN1Y2Nlc3MgPSBlbnN1cmVTeW50YXhUcmVlKHZpZXcuc3RhdGUsIHVwdG8sIHRpbWVvdXQpO1xuICAgIGlmIChzdWNjZXNzICE9IHN5bnRheFRyZWUodmlldy5zdGF0ZSkpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe30pO1xuICAgIHJldHVybiAhIXN1Y2Nlc3M7XG59XG4vKipcblRlbGxzIHlvdSB3aGV0aGVyIHRoZSBsYW5ndWFnZSBwYXJzZXIgaXMgcGxhbm5pbmcgdG8gZG8gbW9yZVxucGFyc2luZyB3b3JrIChpbiBhIGByZXF1ZXN0SWRsZUNhbGxiYWNrYCBwc2V1ZG8tdGhyZWFkKSBvciBoYXNcbnN0b3BwZWQgcnVubmluZywgZWl0aGVyIGJlY2F1c2UgaXQgcGFyc2VkIHRoZSBlbnRpcmUgZG9jdW1lbnQsXG5iZWNhdXNlIGl0IHNwZW50IHRvbyBtdWNoIHRpbWUgYW5kIHdhcyBjdXQgb2ZmLCBvciBiZWNhdXNlIHRoZXJlXG5pcyBubyBsYW5ndWFnZSBwYXJzZXIgZW5hYmxlZC5cbiovXG5mdW5jdGlvbiBzeW50YXhQYXJzZXJSdW5uaW5nKHZpZXcpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwYXJzZVdvcmtlcikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1dvcmtpbmcoKSkgfHwgZmFsc2U7XG59XG4vLyBMZXplci1zdHlsZSBJbnB1dCBvYmplY3QgZm9yIGEgVGV4dCBkb2N1bWVudC5cbmNsYXNzIERvY0lucHV0IHtcbiAgICBjb25zdHJ1Y3Rvcihkb2MpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gMDtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBcIlwiO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGRvYy5pdGVyKCk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLmRvYy5sZW5ndGg7IH1cbiAgICBzeW5jVG8ocG9zKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gdGhpcy5jdXJzb3IubmV4dChwb3MgLSB0aGlzLmN1cnNvclBvcykudmFsdWU7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gcG9zICsgdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGNodW5rKHBvcykge1xuICAgICAgICB0aGlzLnN5bmNUbyhwb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gICAgfVxuICAgIGdldCBsaW5lQ2h1bmtzKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IHN0cmluZ1N0YXJ0ID0gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgICAgIGlmIChmcm9tIDwgc3RyaW5nU3RhcnQgfHwgdG8gPj0gdGhpcy5jdXJzb3JQb3MpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSAtIHN0cmluZ1N0YXJ0LCB0byAtIHN0cmluZ1N0YXJ0KTtcbiAgICB9XG59XG5sZXQgY3VycmVudENvbnRleHQgPSBudWxsO1xuLyoqXG5BIHBhcnNlIGNvbnRleHQgcHJvdmlkZWQgdG8gcGFyc2VycyB3b3JraW5nIG9uIHRoZSBlZGl0b3IgY29udGVudC5cbiovXG5jbGFzcyBQYXJzZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRyZWUgZnJhZ21lbnRzIHRoYXQgY2FuIGJlIHJldXNlZCBieSBpbmNyZW1lbnRhbCByZS1wYXJzZXMuXG4gICAgKi9cbiAgICBmcmFnbWVudHMgPSBbXSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0cmVlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRyZWVMZW4sIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciB2aWV3cG9ydCAob3Igc29tZSBvdmVyYXBwcm94aW1hdGlvblxuICAgIHRoZXJlb2YpLiBJbnRlbmRlZCB0byBiZSB1c2VkIGZvciBvcHBvcnR1bmlzdGljYWxseSBhdm9pZGluZ1xuICAgIHdvcmsgKGluIHdoaWNoIGNhc2VcbiAgICBbYHNraXBVbnRpbEluVmlld2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuUGFyc2VDb250ZXh0LnNraXBVbnRpbEluVmlldylcbiAgICBzaG91bGQgYmUgY2FsbGVkIHRvIG1ha2Ugc3VyZSB0aGUgcGFyc2VyIGlzIHJlc3RhcnRlZCB3aGVuIHRoZVxuICAgIHNraXBwZWQgcmVnaW9uIGJlY29tZXMgdmlzaWJsZSkuXG4gICAgKi9cbiAgICB2aWV3cG9ydCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBza2lwcGVkLCBcbiAgICAvKipcbiAgICBUaGlzIGlzIHdoZXJlIHNraXBwaW5nIHBhcnNlcnMgY2FuIHJlZ2lzdGVyIGEgcHJvbWlzZSB0aGF0LFxuICAgIHdoZW4gcmVzb2x2ZWQsIHdpbGwgc2NoZWR1bGUgYSBuZXcgcGFyc2UuIEl0IGlzIGNsZWFyZWQgd2hlblxuICAgIHRoZSBwYXJzZSB3b3JrZXIgcGlja3MgdXAgdGhlIHByb21pc2UuIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2NoZWR1bGVPbikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy50cmVlTGVuID0gdHJlZUxlbjtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB0aGlzLnNraXBwZWQgPSBza2lwcGVkO1xuICAgICAgICB0aGlzLnNjaGVkdWxlT24gPSBzY2hlZHVsZU9uO1xuICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRlbXBTa2lwcGVkID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShwYXJzZXIsIHN0YXRlLCB2aWV3cG9ydCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dChwYXJzZXIsIHN0YXRlLCBbXSwgVHJlZS5lbXB0eSwgMCwgdmlld3BvcnQsIFtdLCBudWxsKTtcbiAgICB9XG4gICAgc3RhcnRQYXJzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VyLnN0YXJ0UGFyc2UobmV3IERvY0lucHV0KHRoaXMuc3RhdGUuZG9jKSwgdGhpcy5mcmFnbWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHdvcmsodW50aWwsIHVwdG8pIHtcbiAgICAgICAgaWYgKHVwdG8gIT0gbnVsbCAmJiB1cHRvID49IHRoaXMuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHVwdG8gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLnRyZWUgIT0gVHJlZS5lbXB0eSAmJiB0aGlzLmlzRG9uZSh1cHRvICE9PSBudWxsICYmIHVwdG8gIT09IHZvaWQgMCA/IHVwdG8gOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53aXRoQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVudGlsID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kVGltZSA9IERhdGUubm93KCkgKyB1bnRpbDtcbiAgICAgICAgICAgICAgICB1bnRpbCA9ICgpID0+IERhdGUubm93KCkgPiBlbmRUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoKTtcbiAgICAgICAgICAgIGlmICh1cHRvICE9IG51bGwgJiYgKHRoaXMucGFyc2Uuc3RvcHBlZEF0ID09IG51bGwgfHwgdGhpcy5wYXJzZS5zdG9wcGVkQXQgPiB1cHRvKSAmJlxuICAgICAgICAgICAgICAgIHVwdG8gPCB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZS5zdG9wQXQodXB0byk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IHRoaXMud2l0aG91dFRlbXBTa2lwcGVkKFRyZWVGcmFnbWVudC5hZGRUcmVlKGRvbmUsIHRoaXMuZnJhZ21lbnRzLCB0aGlzLnBhcnNlLnN0b3BwZWRBdCAhPSBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUxlbiA9IChfYSA9IHRoaXMucGFyc2Uuc3RvcHBlZEF0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZSA9IGRvbmU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmVlTGVuIDwgKHVwdG8gIT09IG51bGwgJiYgdXB0byAhPT0gdm9pZCAwID8gdXB0byA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5zdGFydFBhcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodW50aWwoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0YWtlVHJlZSgpIHtcbiAgICAgICAgbGV0IHBvcywgdHJlZTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2UgJiYgKHBvcyA9IHRoaXMucGFyc2UucGFyc2VkUG9zKSA+PSB0aGlzLnRyZWVMZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlLnN0b3BwZWRBdCA9PSBudWxsIHx8IHRoaXMucGFyc2Uuc3RvcHBlZEF0ID4gcG9zKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgICAgICAgICB0aGlzLndpdGhDb250ZXh0KCgpID0+IHsgd2hpbGUgKCEodHJlZSA9IHRoaXMucGFyc2UuYWR2YW5jZSgpKSkgeyB9IH0pO1xuICAgICAgICAgICAgdGhpcy50cmVlTGVuID0gcG9zO1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gdGhpcy53aXRob3V0VGVtcFNraXBwZWQoVHJlZUZyYWdtZW50LmFkZFRyZWUodGhpcy50cmVlLCB0aGlzLmZyYWdtZW50cywgdHJ1ZSkpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2l0aENvbnRleHQoZikge1xuICAgICAgICBsZXQgcHJldiA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICBjdXJyZW50Q29udGV4dCA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBwcmV2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhvdXRUZW1wU2tpcHBlZChmcmFnbWVudHMpIHtcbiAgICAgICAgZm9yIChsZXQgcjsgciA9IHRoaXMudGVtcFNraXBwZWQucG9wKCk7KVxuICAgICAgICAgICAgZnJhZ21lbnRzID0gY3V0RnJhZ21lbnRzKGZyYWdtZW50cywgci5mcm9tLCByLnRvKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGFuZ2VzKGNoYW5nZXMsIG5ld1N0YXRlKSB7XG4gICAgICAgIGxldCB7IGZyYWdtZW50cywgdHJlZSwgdHJlZUxlbiwgdmlld3BvcnQsIHNraXBwZWQgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgICAgICBjaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSA9PiByYW5nZXMucHVzaCh7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSkpO1xuICAgICAgICAgICAgZnJhZ21lbnRzID0gVHJlZUZyYWdtZW50LmFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgICAgICB0cmVlID0gVHJlZS5lbXB0eTtcbiAgICAgICAgICAgIHRyZWVMZW4gPSAwO1xuICAgICAgICAgICAgdmlld3BvcnQgPSB7IGZyb206IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LmZyb20sIC0xKSwgdG86IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKSB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcHBlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnNraXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyhyLmZyb20sIDEpLCB0byA9IGNoYW5nZXMubWFwUG9zKHIudG8sIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dCh0aGlzLnBhcnNlciwgbmV3U3RhdGUsIGZyYWdtZW50cywgdHJlZSwgdHJlZUxlbiwgdmlld3BvcnQsIHNraXBwZWQsIHRoaXMuc2NoZWR1bGVPbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdXBkYXRlVmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnQuZnJvbSA9PSB2aWV3cG9ydC5mcm9tICYmIHRoaXMudmlld3BvcnQudG8gPT0gdmlld3BvcnQudG8pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgbGV0IHN0YXJ0TGVuID0gdGhpcy5za2lwcGVkLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNraXBwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLnNraXBwZWRbaV07XG4gICAgICAgICAgICBpZiAoZnJvbSA8IHZpZXdwb3J0LnRvICYmIHRvID4gdmlld3BvcnQuZnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gY3V0RnJhZ21lbnRzKHRoaXMuZnJhZ21lbnRzLCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwcGVkLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNraXBwZWQubGVuZ3RoID49IHN0YXJ0TGVuKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5wYXJzZSkge1xuICAgICAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTm90aWZ5IHRoZSBwYXJzZSBzY2hlZHVsZXIgdGhhdCB0aGUgZ2l2ZW4gcmVnaW9uIHdhcyBza2lwcGVkXG4gICAgYmVjYXVzZSBpdCB3YXNuJ3QgaW4gdmlldywgYW5kIHRoZSBwYXJzZSBzaG91bGQgYmUgcmVzdGFydGVkXG4gICAgd2hlbiBpdCBjb21lcyBpbnRvIHZpZXcuXG4gICAgKi9cbiAgICBza2lwVW50aWxJblZpZXcoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5za2lwcGVkLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHBhcnNlciBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIHBsYWNlaG9sZGVyIHdoZW5cbiAgICBhc3luY2hyb25vdXNseSBsb2FkaW5nIGEgbmVzdGVkIHBhcnNlci4gSXQnbGwgc2tpcCBpdHMgaW5wdXQgYW5kXG4gICAgbWFyayBpdCBhcyBub3QtcmVhbGx5LXBhcnNlZCwgc28gdGhhdCB0aGUgbmV4dCB1cGRhdGUgd2lsbCBwYXJzZVxuICAgIGl0IGFnYWluLlxuICAgIFxuICAgIFdoZW4gYHVudGlsYCBpcyBnaXZlbiwgYSByZXBhcnNlIHdpbGwgYmUgc2NoZWR1bGVkIHdoZW4gdGhhdFxuICAgIHByb21pc2UgcmVzb2x2ZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0U2tpcHBpbmdQYXJzZXIodW50aWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjbGFzcyBleHRlbmRzIFBhcnNlciB7XG4gICAgICAgICAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1swXS5mcm9tLCB0byA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUG9zOiBmcm9tLFxuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN4ID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIHJhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gudGVtcFNraXBwZWQucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW50aWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LnNjaGVkdWxlT24gPSBjeC5zY2hlZHVsZU9uID8gUHJvbWlzZS5hbGwoW2N4LnNjaGVkdWxlT24sIHVudGlsXSkgOiB1bnRpbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zID0gdG87XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgW10sIFtdLCB0byAtIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkQXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN0b3BBdCgpIHsgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpc0RvbmUodXB0bykge1xuICAgICAgICB1cHRvID0gTWF0aC5taW4odXB0bywgdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgbGV0IGZyYWdzID0gdGhpcy5mcmFnbWVudHM7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVMZW4gPj0gdXB0byAmJiBmcmFncy5sZW5ndGggJiYgZnJhZ3NbMF0uZnJvbSA9PSAwICYmIGZyYWdzWzBdLnRvID49IHVwdG87XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29udGV4dCBmb3IgdGhlIGN1cnJlbnQgcGFyc2UsIG9yIGBudWxsYCBpZiBubyBlZGl0b3JcbiAgICBwYXJzZSBpcyBpbiBwcm9ncmVzcy5cbiAgICAqL1xuICAgIHN0YXRpYyBnZXQoKSB7IHJldHVybiBjdXJyZW50Q29udGV4dDsgfVxufVxuZnVuY3Rpb24gY3V0RnJhZ21lbnRzKGZyYWdtZW50cywgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gVHJlZUZyYWdtZW50LmFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIFt7IGZyb21BOiBmcm9tLCB0b0E6IHRvLCBmcm9tQjogZnJvbSwgdG9COiB0byB9XSk7XG59XG5jbGFzcyBMYW5ndWFnZVN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBBIG11dGFibGUgcGFyc2Ugc3RhdGUgdGhhdCBpcyB1c2VkIHRvIHByZXNlcnZlIHdvcmsgZG9uZSBkdXJpbmdcbiAgICAvLyB0aGUgbGlmZXRpbWUgb2YgYSBzdGF0ZSB3aGVuIG1vdmluZyB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudHJlZSA9IGNvbnRleHQudHJlZTtcbiAgICB9XG4gICAgYXBwbHkodHIpIHtcbiAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkICYmIHRoaXMudHJlZSA9PSB0aGlzLmNvbnRleHQudHJlZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgbmV3Q3ggPSB0aGlzLmNvbnRleHQuY2hhbmdlcyh0ci5jaGFuZ2VzLCB0ci5zdGF0ZSk7XG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBwYXJzZSB3YXNuJ3QgZG9uZSwgZ28gZm9yd2FyZCBvbmx5IHVwIHRvIGl0c1xuICAgICAgICAvLyBlbmQgcG9zaXRpb24gb3IgdGhlIGVuZCBvZiB0aGUgdmlld3BvcnQsIHRvIGF2b2lkIHNsb3dpbmcgZG93blxuICAgICAgICAvLyBzdGF0ZSB1cGRhdGVzIHdpdGggcGFyc2Ugd29yayBiZXlvbmQgdGhlIHZpZXdwb3J0LlxuICAgICAgICBsZXQgdXB0byA9IHRoaXMuY29udGV4dC50cmVlTGVuID09IHRyLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBNYXRoLm1heCh0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmNvbnRleHQudHJlZUxlbiksIG5ld0N4LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKCFuZXdDeC53b3JrKDIwIC8qIFdvcmsuQXBwbHkgKi8sIHVwdG8pKVxuICAgICAgICAgICAgbmV3Q3gudGFrZVRyZWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN0YXRlKG5ld0N4KTtcbiAgICB9XG4gICAgc3RhdGljIGluaXQoc3RhdGUpIHtcbiAgICAgICAgbGV0IHZwVG8gPSBNYXRoLm1pbigzMDAwIC8qIFdvcmsuSW5pdFZpZXdwb3J0ICovLCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgbGV0IHBhcnNlU3RhdGUgPSBQYXJzZUNvbnRleHQuY3JlYXRlKHN0YXRlLmZhY2V0KGxhbmd1YWdlKS5wYXJzZXIsIHN0YXRlLCB7IGZyb206IDAsIHRvOiB2cFRvIH0pO1xuICAgICAgICBpZiAoIXBhcnNlU3RhdGUud29yaygyMCAvKiBXb3JrLkFwcGx5ICovLCB2cFRvKSlcbiAgICAgICAgICAgIHBhcnNlU3RhdGUudGFrZVRyZWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN0YXRlKHBhcnNlU3RhdGUpO1xuICAgIH1cbn1cbkxhbmd1YWdlLnN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGU6IExhbmd1YWdlU3RhdGUuaW5pdCxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlLmlzKExhbmd1YWdlLnNldFN0YXRlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICAgICAgaWYgKHRyLnN0YXJ0U3RhdGUuZmFjZXQobGFuZ3VhZ2UpICE9IHRyLnN0YXRlLmZhY2V0KGxhbmd1YWdlKSlcbiAgICAgICAgICAgIHJldHVybiBMYW5ndWFnZVN0YXRlLmluaXQodHIuc3RhdGUpO1xuICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodHIpO1xuICAgIH1cbn0pO1xubGV0IHJlcXVlc3RJZGxlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgbGV0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGNhbGxiYWNrKCksIDUwMCAvKiBXb3JrLk1heFBhdXNlICovKTtcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufTtcbmlmICh0eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFjayAhPSBcInVuZGVmaW5lZFwiKVxuICAgIHJlcXVlc3RJZGxlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGxldCBpZGxlID0gLTEsIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlkbGUgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKGNhbGxiYWNrLCB7IHRpbWVvdXQ6IDUwMCAvKiBXb3JrLk1heFBhdXNlICovIC0gMTAwIC8qIFdvcmsuTWluUGF1c2UgKi8gfSk7XG4gICAgICAgIH0sIDEwMCAvKiBXb3JrLk1pblBhdXNlICovKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGlkbGUgPCAwID8gY2xlYXJUaW1lb3V0KHRpbWVvdXQpIDogY2FuY2VsSWRsZUNhbGxiYWNrKGlkbGUpO1xuICAgIH07XG5jb25zdCBpc0lucHV0UGVuZGluZyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hID0gbmF2aWdhdG9yLnNjaGVkdWxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0lucHV0UGVuZGluZylcbiAgICA/ICgpID0+IG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nKCkgOiBudWxsO1xuY29uc3QgcGFyc2VXb3JrZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3MgUGFyc2VXb3JrZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy53b3JraW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy53b3JrU2NoZWR1bGVkID0gMDtcbiAgICAgICAgLy8gRW5kIG9mIHRoZSBjdXJyZW50IHRpbWUgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua0VuZCA9IC0xO1xuICAgICAgICAvLyBNaWxsaXNlY29uZHMgb2YgYnVkZ2V0IGxlZnQgZm9yIHRoaXMgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua0J1ZGdldCA9IC0xO1xuICAgICAgICB0aGlzLndvcmsgPSB0aGlzLndvcmsuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY3ggPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpLmNvbnRleHQ7XG4gICAgICAgIGlmIChjeC51cGRhdGVWaWV3cG9ydCh1cGRhdGUudmlldy52aWV3cG9ydCkgfHwgdGhpcy52aWV3LnZpZXdwb3J0LnRvID4gY3gudHJlZUxlbilcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlldy5oYXNGb2N1cylcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ICs9IDUwIC8qIFdvcmsuQ2hhbmdlQm9udXMgKi87XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tBc3luY1NjaGVkdWxlKGN4KTtcbiAgICB9XG4gICAgc2NoZWR1bGVXb3JrKCkge1xuICAgICAgICBpZiAodGhpcy53b3JraW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBmaWVsZCA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlKTtcbiAgICAgICAgaWYgKGZpZWxkLnRyZWUgIT0gZmllbGQuY29udGV4dC50cmVlIHx8ICFmaWVsZC5jb250ZXh0LmlzRG9uZShzdGF0ZS5kb2MubGVuZ3RoKSlcbiAgICAgICAgICAgIHRoaXMud29ya2luZyA9IHJlcXVlc3RJZGxlKHRoaXMud29yayk7XG4gICAgfVxuICAgIHdvcmsoZGVhZGxpbmUpIHtcbiAgICAgICAgdGhpcy53b3JraW5nID0gbnVsbDtcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rRW5kIDwgbm93ICYmICh0aGlzLmNodW5rRW5kIDwgMCB8fCB0aGlzLnZpZXcuaGFzRm9jdXMpKSB7IC8vIFN0YXJ0IGEgbmV3IGNodW5rXG4gICAgICAgICAgICB0aGlzLmNodW5rRW5kID0gbm93ICsgMzAwMDAgLyogV29yay5DaHVua1RpbWUgKi87XG4gICAgICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ID0gMzAwMCAvKiBXb3JrLkNodW5rQnVkZ2V0ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rQnVkZ2V0IDw9IDApXG4gICAgICAgICAgICByZXR1cm47IC8vIE5vIG1vcmUgYnVkZ2V0XG4gICAgICAgIGxldCB7IHN0YXRlLCB2aWV3cG9ydDogeyB0bzogdnBUbyB9IH0gPSB0aGlzLnZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpO1xuICAgICAgICBpZiAoZmllbGQudHJlZSA9PSBmaWVsZC5jb250ZXh0LnRyZWUgJiYgZmllbGQuY29udGV4dC5pc0RvbmUodnBUbyArIDEwMDAwMCAvKiBXb3JrLk1heFBhcnNlQWhlYWQgKi8pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZW5kVGltZSA9IERhdGUubm93KCkgKyBNYXRoLm1pbih0aGlzLmNodW5rQnVkZ2V0LCAxMDAgLyogV29yay5TbGljZSAqLywgZGVhZGxpbmUgJiYgIWlzSW5wdXRQZW5kaW5nID8gTWF0aC5tYXgoMjUgLyogV29yay5NaW5TbGljZSAqLywgZGVhZGxpbmUudGltZVJlbWFpbmluZygpIC0gNSkgOiAxZTkpO1xuICAgICAgICBsZXQgdmlld3BvcnRGaXJzdCA9IGZpZWxkLmNvbnRleHQudHJlZUxlbiA8IHZwVG8gJiYgc3RhdGUuZG9jLmxlbmd0aCA+IHZwVG8gKyAxMDAwO1xuICAgICAgICBsZXQgZG9uZSA9IGZpZWxkLmNvbnRleHQud29yaygoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXNJbnB1dFBlbmRpbmcgJiYgaXNJbnB1dFBlbmRpbmcoKSB8fCBEYXRlLm5vdygpID4gZW5kVGltZTtcbiAgICAgICAgfSwgdnBUbyArICh2aWV3cG9ydEZpcnN0ID8gMCA6IDEwMDAwMCAvKiBXb3JrLk1heFBhcnNlQWhlYWQgKi8pKTtcbiAgICAgICAgdGhpcy5jaHVua0J1ZGdldCAtPSBEYXRlLm5vdygpIC0gbm93O1xuICAgICAgICBpZiAoZG9uZSB8fCB0aGlzLmNodW5rQnVkZ2V0IDw9IDApIHtcbiAgICAgICAgICAgIGZpZWxkLmNvbnRleHQudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IExhbmd1YWdlLnNldFN0YXRlLm9mKG5ldyBMYW5ndWFnZVN0YXRlKGZpZWxkLmNvbnRleHQpKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaHVua0J1ZGdldCA+IDAgJiYgIShkb25lICYmICF2aWV3cG9ydEZpcnN0KSlcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIHRoaXMuY2hlY2tBc3luY1NjaGVkdWxlKGZpZWxkLmNvbnRleHQpO1xuICAgIH1cbiAgICBjaGVja0FzeW5jU2NoZWR1bGUoY3gpIHtcbiAgICAgICAgaWYgKGN4LnNjaGVkdWxlT24pIHtcbiAgICAgICAgICAgIHRoaXMud29ya1NjaGVkdWxlZCsrO1xuICAgICAgICAgICAgY3guc2NoZWR1bGVPblxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuc2NoZWR1bGVXb3JrKCkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlcnIpKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMud29ya1NjaGVkdWxlZC0tKTtcbiAgICAgICAgICAgIGN4LnNjaGVkdWxlT24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtpbmcpXG4gICAgICAgICAgICB0aGlzLndvcmtpbmcoKTtcbiAgICB9XG4gICAgaXNXb3JraW5nKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy53b3JraW5nIHx8IHRoaXMud29ya1NjaGVkdWxlZCA+IDApO1xuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7IGZvY3VzKCkgeyB0aGlzLnNjaGVkdWxlV29yaygpOyB9IH1cbn0pO1xuLyoqXG5UaGUgZmFjZXQgdXNlZCB0byBhc3NvY2lhdGUgYSBsYW5ndWFnZSB3aXRoIGFuIGVkaXRvciBzdGF0ZS4gVXNlZFxuYnkgYExhbmd1YWdlYCBvYmplY3QncyBgZXh0ZW5zaW9uYCBwcm9wZXJ0eSAoc28geW91IGRvbid0IG5lZWQgdG9cbm1hbnVhbGx5IHdyYXAgeW91ciBsYW5ndWFnZXMgaW4gdGhpcykuIENhbiBiZSB1c2VkIHRvIGFjY2VzcyB0aGVcbmN1cnJlbnQgbGFuZ3VhZ2Ugb24gYSBzdGF0ZS5cbiovXG5jb25zdCBsYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUobGFuZ3VhZ2VzKSB7IHJldHVybiBsYW5ndWFnZXMubGVuZ3RoID8gbGFuZ3VhZ2VzWzBdIDogbnVsbDsgfSxcbiAgICBlbmFibGVzOiBsYW5ndWFnZSA9PiBbXG4gICAgICAgIExhbmd1YWdlLnN0YXRlLFxuICAgICAgICBwYXJzZVdvcmtlcixcbiAgICAgICAgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5jb21wdXRlKFtsYW5ndWFnZV0sIHN0YXRlID0+IHtcbiAgICAgICAgICAgIGxldCBsYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIGxhbmcgJiYgbGFuZy5uYW1lID8geyBcImRhdGEtbGFuZ3VhZ2VcIjogbGFuZy5uYW1lIH0gOiB7fTtcbiAgICAgICAgfSlcbiAgICBdXG59KTtcbi8qKlxuVGhpcyBjbGFzcyBidW5kbGVzIGEgW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSB3aXRoIGFuXG5vcHRpb25hbCBzZXQgb2Ygc3VwcG9ydGluZyBleHRlbnNpb25zLiBMYW5ndWFnZSBwYWNrYWdlcyBhcmVcbmVuY291cmFnZWQgdG8gZXhwb3J0IGEgZnVuY3Rpb24gdGhhdCBvcHRpb25hbGx5IHRha2VzIGFcbmNvbmZpZ3VyYXRpb24gb2JqZWN0IGFuZCByZXR1cm5zIGEgYExhbmd1YWdlU3VwcG9ydGAgaW5zdGFuY2UsIGFzXG50aGUgbWFpbiB3YXkgZm9yIGNsaWVudCBjb2RlIHRvIHVzZSB0aGUgcGFja2FnZS5cbiovXG5jbGFzcyBMYW5ndWFnZVN1cHBvcnQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxhbmd1YWdlIHN1cHBvcnQgb2JqZWN0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxhbmd1YWdlIG9iamVjdC5cbiAgICAqL1xuICAgIGxhbmd1YWdlLCBcbiAgICAvKipcbiAgICBBbiBvcHRpb25hbCBzZXQgb2Ygc3VwcG9ydGluZyBleHRlbnNpb25zLiBXaGVuIG5lc3RpbmcgYVxuICAgIGxhbmd1YWdlIGluIGFub3RoZXIgbGFuZ3VhZ2UsIHRoZSBvdXRlciBsYW5ndWFnZSBpcyBlbmNvdXJhZ2VkXG4gICAgdG8gaW5jbHVkZSB0aGUgc3VwcG9ydGluZyBleHRlbnNpb25zIGZvciBpdHMgaW5uZXIgbGFuZ3VhZ2VzXG4gICAgaW4gaXRzIG93biBzZXQgb2Ygc3VwcG9ydCBleHRlbnNpb25zLlxuICAgICovXG4gICAgc3VwcG9ydCA9IFtdKSB7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICAgICAgdGhpcy5zdXBwb3J0ID0gc3VwcG9ydDtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBbbGFuZ3VhZ2UsIHN1cHBvcnRdO1xuICAgIH1cbn1cbi8qKlxuTGFuZ3VhZ2UgZGVzY3JpcHRpb25zIGFyZSB1c2VkIHRvIHN0b3JlIG1ldGFkYXRhIGFib3V0IGxhbmd1YWdlc1xuYW5kIHRvIGR5bmFtaWNhbGx5IGxvYWQgdGhlbS4gVGhlaXIgbWFpbiByb2xlIGlzIGZpbmRpbmcgdGhlXG5hcHByb3ByaWF0ZSBsYW5ndWFnZSBmb3IgYSBmaWxlbmFtZSBvciBkeW5hbWljYWxseSBsb2FkaW5nIG5lc3RlZFxucGFyc2Vycy5cbiovXG5jbGFzcyBMYW5ndWFnZURlc2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSBvZiB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQWx0ZXJuYXRpdmUgbmFtZXMgZm9yIHRoZSBtb2RlIChsb3dlcmNhc2VkLCBpbmNsdWRlcyBgdGhpcy5uYW1lYCkuXG4gICAgKi9cbiAgICBhbGlhcywgXG4gICAgLyoqXG4gICAgRmlsZSBleHRlbnNpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgZXh0ZW5zaW9ucywgXG4gICAgLyoqXG4gICAgT3B0aW9uYWwgZmlsZW5hbWUgcGF0dGVybiB0aGF0IHNob3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggdGhpc1xuICAgIGxhbmd1YWdlLlxuICAgICovXG4gICAgZmlsZW5hbWUsIGxvYWRGdW5jLCBcbiAgICAvKipcbiAgICBJZiB0aGUgbGFuZ3VhZ2UgaGFzIGJlZW4gbG9hZGVkLCB0aGlzIHdpbGwgaG9sZCBpdHMgdmFsdWUuXG4gICAgKi9cbiAgICBzdXBwb3J0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLmxvYWRGdW5jID0gbG9hZEZ1bmM7XG4gICAgICAgIHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQ7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFN0YXJ0IGxvYWRpbmcgdGhlIHRoZSBsYW5ndWFnZS4gV2lsbCByZXR1cm4gYSBwcm9taXNlIHRoYXRcbiAgICByZXNvbHZlcyB0byBhIFtgTGFuZ3VhZ2VTdXBwb3J0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZVN1cHBvcnQpXG4gICAgb2JqZWN0IHdoZW4gdGhlIGxhbmd1YWdlIHN1Y2Nlc3NmdWxseSBsb2Fkcy5cbiAgICAqL1xuICAgIGxvYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRpbmcgfHwgKHRoaXMubG9hZGluZyA9IHRoaXMubG9hZEZ1bmMoKS50aGVuKHN1cHBvcnQgPT4gdGhpcy5zdXBwb3J0ID0gc3VwcG9ydCwgZXJyID0+IHsgdGhpcy5sb2FkaW5nID0gbnVsbDsgdGhyb3cgZXJyOyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxhbmd1YWdlIGRlc2NyaXB0aW9uLlxuICAgICovXG4gICAgc3RhdGljIG9mKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgbG9hZCwgc3VwcG9ydCB9ID0gc3BlYztcbiAgICAgICAgaWYgKCFsb2FkKSB7XG4gICAgICAgICAgICBpZiAoIXN1cHBvcnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNdXN0IHBhc3MgZWl0aGVyICdsb2FkJyBvciAnc3VwcG9ydCcgdG8gTGFuZ3VhZ2VEZXNjcmlwdGlvbi5vZlwiKTtcbiAgICAgICAgICAgIGxvYWQgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoc3VwcG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZURlc2NyaXB0aW9uKHNwZWMubmFtZSwgKHNwZWMuYWxpYXMgfHwgW10pLmNvbmNhdChzcGVjLm5hbWUpLm1hcChzID0+IHMudG9Mb3dlckNhc2UoKSksIHNwZWMuZXh0ZW5zaW9ucyB8fCBbXSwgc3BlYy5maWxlbmFtZSwgbG9hZCwgc3VwcG9ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgZm9yIGEgbGFuZ3VhZ2UgaW4gdGhlIGdpdmVuIGFycmF5IG9mIGRlc2NyaXB0aW9ucyB0aGF0XG4gICAgbWF0Y2hlcyB0aGUgZmlsZW5hbWUuIFdpbGwgZmlyc3QgbWF0Y2hcbiAgICBbYGZpbGVuYW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmZpbGVuYW1lKSBwYXR0ZXJucyxcbiAgICBhbmQgdGhlbiBbZXh0ZW5zaW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmV4dGVuc2lvbnMpLFxuICAgIGFuZCByZXR1cm4gdGhlIGZpcnN0IGxhbmd1YWdlIHRoYXQgbWF0Y2hlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaEZpbGVuYW1lKGRlc2NzLCBmaWxlbmFtZSkge1xuICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgaWYgKGQuZmlsZW5hbWUgJiYgZC5maWxlbmFtZS50ZXN0KGZpbGVuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgbGV0IGV4dCA9IC9cXC4oW14uXSspJC8uZXhlYyhmaWxlbmFtZSk7XG4gICAgICAgIGlmIChleHQpXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgICAgIGlmIChkLmV4dGVuc2lvbnMuaW5kZXhPZihleHRbMV0pID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lIG9yIGFsaWFzIG1hdGNoZXMgdGhlIHRoZSBnaXZlblxuICAgIG5hbWUgKGNhc2UtaW5zZW5zaXRpdmVseSkuIElmIGBmdXp6eWAgaXMgdHJ1ZSwgYW5kIG5vIGRpcmVjdFxuICAgIG1hdGNocyBpcyBmb3VuZCwgdGhpcydsbCBhbHNvIHNlYXJjaCBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lXG4gICAgb3IgYWxpYXMgb2NjdXJzIGluIHRoZSBzdHJpbmcgKGZvciBuYW1lcyBzaG9ydGVyIHRoYW4gdGhyZWVcbiAgICBjaGFyYWN0ZXJzLCBvbmx5IHdoZW4gc3Vycm91bmRlZCBieSBub24td29yZCBjaGFyYWN0ZXJzKS5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaExhbmd1YWdlTmFtZShkZXNjcywgbmFtZSwgZnV6enkgPSB0cnVlKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICBpZiAoZC5hbGlhcy5zb21lKGEgPT4gYSA9PSBuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgaWYgKGZ1enp5KVxuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhIG9mIGQuYWxpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gbmFtZS5pbmRleE9mKGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgPiAtMSAmJiAoYS5sZW5ndGggPiAyIHx8ICEvXFx3Ly50ZXN0KG5hbWVbZm91bmQgLSAxXSkgJiYgIS9cXHcvLnRlc3QobmFtZVtmb3VuZCArIGEubGVuZ3RoXSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuRmFjZXQgdGhhdCBkZWZpbmVzIGEgd2F5IHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIHRoZVxuYXBwcm9wcmlhdGUgaW5kZW50YXRpb24gZGVwdGgsIGFzIGEgY29sdW1uIG51bWJlciAoc2VlXG5bYGluZGVudFN0cmluZ2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U3RyaW5nKSksIGF0IHRoZSBzdGFydCBvZiBhIGdpdmVuXG5saW5lLiBBIHJldHVybiB2YWx1ZSBvZiBgbnVsbGAgaW5kaWNhdGVzIG5vIGluZGVudGF0aW9uIGNhbiBiZVxuZGV0ZXJtaW5lZCwgYW5kIHRoZSBsaW5lIHNob3VsZCBpbmhlcml0IHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgb25lXG5hYm92ZSBpdC4gQSByZXR1cm4gdmFsdWUgb2YgYHVuZGVmaW5lZGAgZGVmZXJzIHRvIHRoZSBuZXh0IGluZGVudFxuc2VydmljZS5cbiovXG5jb25zdCBpbmRlbnRTZXJ2aWNlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5GYWNldCBmb3Igb3ZlcnJpZGluZyB0aGUgdW5pdCBieSB3aGljaCBpbmRlbnRhdGlvbiBoYXBwZW5zLiBTaG91bGRcbmJlIGEgc3RyaW5nIGNvbnNpc3RpbmcgZWl0aGVyIGVudGlyZWx5IG9mIHRoZSBzYW1lIHdoaXRlc3BhY2VcbmNoYXJhY3Rlci4gV2hlbiBub3Qgc2V0LCB0aGlzIGRlZmF1bHRzIHRvIDIgc3BhY2VzLlxuKi9cbmNvbnN0IGluZGVudFVuaXQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4ge1xuICAgICAgICBpZiAoIXZhbHVlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gXCIgIFwiO1xuICAgICAgICBsZXQgdW5pdCA9IHZhbHVlc1swXTtcbiAgICAgICAgaWYgKCF1bml0IHx8IC9cXFMvLnRlc3QodW5pdCkgfHwgQXJyYXkuZnJvbSh1bml0KS5zb21lKGUgPT4gZSAhPSB1bml0WzBdKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5kZW50IHVuaXQ6IFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWVzWzBdKSk7XG4gICAgICAgIHJldHVybiB1bml0O1xuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm4gdGhlIF9jb2x1bW4gd2lkdGhfIG9mIGFuIGluZGVudCB1bml0IGluIHRoZSBzdGF0ZS5cbkRldGVybWluZWQgYnkgdGhlIFtgaW5kZW50VW5pdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdClcbmZhY2V0LCBhbmQgW2B0YWJTaXplYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSB3aGVuIHRoYXRcbmNvbnRhaW5zIHRhYnMuXG4qL1xuZnVuY3Rpb24gZ2V0SW5kZW50VW5pdChzdGF0ZSkge1xuICAgIGxldCB1bml0ID0gc3RhdGUuZmFjZXQoaW5kZW50VW5pdCk7XG4gICAgcmV0dXJuIHVuaXQuY2hhckNvZGVBdCgwKSA9PSA5ID8gc3RhdGUudGFiU2l6ZSAqIHVuaXQubGVuZ3RoIDogdW5pdC5sZW5ndGg7XG59XG4vKipcbkNyZWF0ZSBhbiBpbmRlbnRhdGlvbiBzdHJpbmcgdGhhdCBjb3ZlcnMgY29sdW1ucyAwIHRvIGBjb2xzYC5cbldpbGwgdXNlIHRhYnMgZm9yIGFzIG11Y2ggb2YgdGhlIGNvbHVtbnMgYXMgcG9zc2libGUgd2hlbiB0aGVcbltgaW5kZW50VW5pdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgZmFjZXQgY29udGFpbnNcbnRhYnMuXG4qL1xuZnVuY3Rpb24gaW5kZW50U3RyaW5nKHN0YXRlLCBjb2xzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCIsIHRzID0gc3RhdGUudGFiU2l6ZSwgY2ggPSBzdGF0ZS5mYWNldChpbmRlbnRVbml0KVswXTtcbiAgICBpZiAoY2ggPT0gXCJcXHRcIikge1xuICAgICAgICB3aGlsZSAoY29scyA+PSB0cykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFx0XCI7XG4gICAgICAgICAgICBjb2xzIC09IHRzO1xuICAgICAgICB9XG4gICAgICAgIGNoID0gXCIgXCI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sczsgaSsrKVxuICAgICAgICByZXN1bHQgKz0gY2g7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuR2V0IHRoZSBpbmRlbnRhdGlvbiwgYXMgYSBjb2x1bW4gbnVtYmVyLCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG5XaWxsIGZpcnN0IGNvbnN1bHQgYW55IFtpbmRlbnQgc2VydmljZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U2VydmljZSlcbnRoYXQgYXJlIHJlZ2lzdGVyZWQsIGFuZCBpZiBub25lIG9mIHRob3NlIHJldHVybiBhbiBpbmRlbnRhdGlvbixcbnRoaXMgd2lsbCBjaGVjayB0aGUgc3ludGF4IHRyZWUgZm9yIHRoZSBbaW5kZW50IG5vZGVcbnByb3BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50Tm9kZVByb3ApIGFuZCB1c2UgdGhhdCBpZiBmb3VuZC4gUmV0dXJucyBhXG5udW1iZXIgd2hlbiBhbiBpbmRlbnRhdGlvbiBjb3VsZCBiZSBkZXRlcm1pbmVkLCBhbmQgbnVsbFxub3RoZXJ3aXNlLlxuKi9cbmZ1bmN0aW9uIGdldEluZGVudGF0aW9uKGNvbnRleHQsIHBvcykge1xuICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgRWRpdG9yU3RhdGUpXG4gICAgICAgIGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChjb250ZXh0KTtcbiAgICBmb3IgKGxldCBzZXJ2aWNlIG9mIGNvbnRleHQuc3RhdGUuZmFjZXQoaW5kZW50U2VydmljZSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHNlcnZpY2UoY29udGV4dCwgcG9zKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpO1xuICAgIHJldHVybiB0cmVlID8gc3ludGF4SW5kZW50YXRpb24oY29udGV4dCwgdHJlZSwgcG9zKSA6IG51bGw7XG59XG4vKipcbkNyZWF0ZSBhIGNoYW5nZSBzZXQgdGhhdCBhdXRvLWluZGVudHMgYWxsIGxpbmVzIHRvdWNoZWQgYnkgdGhlXG5naXZlbiBkb2N1bWVudCByYW5nZS5cbiovXG5mdW5jdGlvbiBpbmRlbnRSYW5nZShzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgdXBkYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBvdmVycmlkZUluZGVudGF0aW9uOiBzdGFydCA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHVwZGF0ZWRbc3RhcnRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMTsgfSB9KTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IGZyb207IHBvcyA8PSB0bzspIHtcbiAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICghL1xcUy8udGVzdChsaW5lLnRleHQpKVxuICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgaWYgKGN1ciAhPSBub3JtKSB7XG4gICAgICAgICAgICB1cGRhdGVkW2xpbmUuZnJvbV0gPSBpbmRlbnQ7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmNoYW5nZXMoY2hhbmdlcyk7XG59XG4vKipcbkluZGVudGF0aW9uIGNvbnRleHRzIGFyZSB1c2VkIHdoZW4gY2FsbGluZyBbaW5kZW50YXRpb25cbnNlcnZpY2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpLiBUaGV5IHByb3ZpZGUgaGVscGVyIHV0aWxpdGllc1xudXNlZnVsIGluIGluZGVudGF0aW9uIGxvZ2ljLCBhbmQgY2FuIHNlbGVjdGl2ZWx5IG92ZXJyaWRlIHRoZVxuaW5kZW50YXRpb24gcmVwb3J0ZWQgZm9yIHNvbWUgbGluZXMuXG4qL1xuY2xhc3MgSW5kZW50Q29udGV4dCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGluZGVudCBjb250ZXh0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudW5pdCA9IGdldEluZGVudFVuaXQoc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBkZXNjcmlwdGlvbiBvZiB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIHRha2luZ1xuICAgIFtzaW11bGF0ZWQgbGluZVxuICAgIGJyZWFrc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5JbmRlbnRDb250ZXh0LmNvbnN0cnVjdG9yXm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICBpbnRvIGFjY291bnQuIElmIHRoZXJlIGlzIHN1Y2ggYSBicmVhayBhdCBgcG9zYCwgdGhlIGBiaWFzYFxuICAgIGFyZ3VtZW50IGRldGVybWluZXMgd2hldGhlciB0aGUgcGFydCBvZiB0aGUgbGluZSBsaW5lIGJlZm9yZSBvclxuICAgIGFmdGVyIHRoZSBicmVhayBpcyB1c2VkLlxuICAgICovXG4gICAgbGluZUF0KHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IHsgc2ltdWxhdGVCcmVhaywgc2ltdWxhdGVEb3VibGVCcmVhayB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoc2ltdWxhdGVCcmVhayAhPSBudWxsICYmIHNpbXVsYXRlQnJlYWsgPj0gbGluZS5mcm9tICYmIHNpbXVsYXRlQnJlYWsgPD0gbGluZS50bykge1xuICAgICAgICAgICAgaWYgKHNpbXVsYXRlRG91YmxlQnJlYWsgJiYgc2ltdWxhdGVCcmVhayA9PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogXCJcIiwgZnJvbTogcG9zIH07XG4gICAgICAgICAgICBlbHNlIGlmIChiaWFzIDwgMCA/IHNpbXVsYXRlQnJlYWsgPCBwb3MgOiBzaW11bGF0ZUJyZWFrIDw9IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBsaW5lLnRleHQuc2xpY2Uoc2ltdWxhdGVCcmVhayAtIGxpbmUuZnJvbSksIGZyb206IHNpbXVsYXRlQnJlYWsgfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBsaW5lLnRleHQuc2xpY2UoMCwgc2ltdWxhdGVCcmVhayAtIGxpbmUuZnJvbSksIGZyb206IGxpbmUuZnJvbSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHRleHQgZGlyZWN0bHkgYWZ0ZXIgYHBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICAgKi9cbiAgICB0ZXh0QWZ0ZXJQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbXVsYXRlRG91YmxlQnJlYWsgJiYgcG9zID09IHRoaXMub3B0aW9ucy5zaW11bGF0ZUJyZWFrKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKHBvcyAtIGZyb20sIE1hdGgubWluKHRleHQubGVuZ3RoLCBwb3MgKyAxMDAgLSBmcm9tKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGNvbHVtbiBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgY29sdW1uKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSB9ID0gdGhpcy5saW5lQXQocG9zLCBiaWFzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY291bnRDb2x1bW4odGV4dCwgcG9zIC0gZnJvbSk7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uID8gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb24oZnJvbSkgOiAtMTtcbiAgICAgICAgaWYgKG92ZXJyaWRlID4gLTEpXG4gICAgICAgICAgICByZXN1bHQgKz0gb3ZlcnJpZGUgLSB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHRleHQuc2VhcmNoKC9cXFN8JC8pKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY29sdW1uIHBvc2l0aW9uICh0YWtpbmcgdGFicyBpbnRvIGFjY291bnQpIG9mIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICBjb3VudENvbHVtbihsaW5lLCBwb3MgPSBsaW5lLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY291bnRDb2x1bW4obGluZSwgdGhpcy5zdGF0ZS50YWJTaXplLCBwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBpbmRlbnRhdGlvbiBjb2x1bW4gb2YgdGhlIGxpbmUgYXQgdGhlIGdpdmVuIHBvaW50LlxuICAgICovXG4gICAgbGluZUluZGVudChwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uO1xuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGxldCBvdmVycmlkZW4gPSBvdmVycmlkZShmcm9tKTtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZW4gPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHRleHQuc2VhcmNoKC9cXFN8JC8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgW3NpbXVsYXRlZCBsaW5lXG4gICAgYnJlYWtdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSW5kZW50Q29udGV4dC5jb25zdHJ1Y3Rvcl5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gICAgZm9yIHRoaXMgY29udGV4dCwgaWYgYW55LlxuICAgICovXG4gICAgZ2V0IHNpbXVsYXRlZEJyZWFrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpbXVsYXRlQnJlYWsgfHwgbnVsbDtcbiAgICB9XG59XG4vKipcbkEgc3ludGF4IHRyZWUgbm9kZSBwcm9wIHVzZWQgdG8gYXNzb2NpYXRlIGluZGVudGF0aW9uIHN0cmF0ZWdpZXNcbndpdGggbm9kZSB0eXBlcy4gU3VjaCBhIHN0cmF0ZWd5IGlzIGEgZnVuY3Rpb24gZnJvbSBhbiBpbmRlbnRhdGlvblxuY29udGV4dCB0byBhIGNvbHVtbiBudW1iZXIgKHNlZSBhbHNvXG5bYGluZGVudFN0cmluZ2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U3RyaW5nKSkgb3IgbnVsbCwgd2hlcmUgbnVsbFxuaW5kaWNhdGVzIHRoYXQgbm8gZGVmaW5pdGl2ZSBpbmRlbnRhdGlvbiBjYW4gYmUgZGV0ZXJtaW5lZC5cbiovXG5jb25zdCBpbmRlbnROb2RlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8vIENvbXB1dGUgdGhlIGluZGVudGF0aW9uIGZvciBhIGdpdmVuIHBvc2l0aW9uIGZyb20gdGhlIHN5bnRheCB0cmVlLlxuZnVuY3Rpb24gc3ludGF4SW5kZW50YXRpb24oY3gsIGFzdCwgcG9zKSB7XG4gICAgcmV0dXJuIGluZGVudEZyb20oYXN0LnJlc29sdmVJbm5lcihwb3MpLmVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcyksIHBvcywgY3gpO1xufVxuZnVuY3Rpb24gaWdub3JlQ2xvc2VkKGN4KSB7XG4gICAgcmV0dXJuIGN4LnBvcyA9PSBjeC5vcHRpb25zLnNpbXVsYXRlQnJlYWsgJiYgY3gub3B0aW9ucy5zaW11bGF0ZURvdWJsZUJyZWFrO1xufVxuZnVuY3Rpb24gaW5kZW50U3RyYXRlZ3kodHJlZSkge1xuICAgIGxldCBzdHJhdGVneSA9IHRyZWUudHlwZS5wcm9wKGluZGVudE5vZGVQcm9wKTtcbiAgICBpZiAoc3RyYXRlZ3kpXG4gICAgICAgIHJldHVybiBzdHJhdGVneTtcbiAgICBsZXQgZmlyc3QgPSB0cmVlLmZpcnN0Q2hpbGQsIGNsb3NlO1xuICAgIGlmIChmaXJzdCAmJiAoY2xvc2UgPSBmaXJzdC50eXBlLnByb3AoTm9kZVByb3AuY2xvc2VkQnkpKSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRyZWUubGFzdENoaWxkLCBjbG9zZWQgPSBsYXN0ICYmIGNsb3NlLmluZGV4T2YobGFzdC5uYW1lKSA+IC0xO1xuICAgICAgICByZXR1cm4gY3ggPT4gZGVsaW1pdGVkU3RyYXRlZ3koY3gsIHRydWUsIDEsIHVuZGVmaW5lZCwgY2xvc2VkICYmICFpZ25vcmVDbG9zZWQoY3gpID8gbGFzdC5mcm9tIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyZWUucGFyZW50ID09IG51bGwgPyB0b3BJbmRlbnQgOiBudWxsO1xufVxuZnVuY3Rpb24gaW5kZW50RnJvbShub2RlLCBwb3MsIGJhc2UpIHtcbiAgICBmb3IgKDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50KSB7XG4gICAgICAgIGxldCBzdHJhdGVneSA9IGluZGVudFN0cmF0ZWd5KG5vZGUpO1xuICAgICAgICBpZiAoc3RyYXRlZ3kpXG4gICAgICAgICAgICByZXR1cm4gc3RyYXRlZ3koVHJlZUluZGVudENvbnRleHQuY3JlYXRlKGJhc2UsIHBvcywgbm9kZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHRvcEluZGVudCgpIHsgcmV0dXJuIDA7IH1cbi8qKlxuT2JqZWN0cyBvZiB0aGlzIHR5cGUgcHJvdmlkZSBjb250ZXh0IGluZm9ybWF0aW9uIGFuZCBoZWxwZXJcbm1ldGhvZHMgdG8gaW5kZW50YXRpb24gZnVuY3Rpb25zIHJlZ2lzdGVyZWQgb24gc3ludGF4IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWVJbmRlbnRDb250ZXh0IGV4dGVuZHMgSW5kZW50Q29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHdoaWNoIGluZGVudGF0aW9uIGlzIGJlaW5nIGNvbXB1dGVkLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgc3ludGF4IHRyZWUgbm9kZSB0byB3aGljaCB0aGUgaW5kZW50YXRpb24gc3RyYXRlZ3lcbiAgICBhcHBsaWVzLlxuICAgICovXG4gICAgbm9kZSkge1xuICAgICAgICBzdXBlcihiYXNlLnN0YXRlLCBiYXNlLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGJhc2UsIHBvcywgbm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVJbmRlbnRDb250ZXh0KGJhc2UsIHBvcywgbm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdGV4dCBkaXJlY3RseSBhZnRlciBgdGhpcy5wb3NgLCBlaXRoZXIgdGhlIGVudGlyZSBsaW5lXG4gICAgb3IgdGhlIG5leHQgMTAwIGNoYXJhY3RlcnMsIHdoaWNoZXZlciBpcyBzaG9ydGVyLlxuICAgICovXG4gICAgZ2V0IHRleHRBZnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dEFmdGVyUG9zKHRoaXMucG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBhdCB0aGUgcmVmZXJlbmNlIGxpbmUgZm9yIGB0aGlzLm5vZGVgLCB3aGljaFxuICAgIGlzIHRoZSBsaW5lIG9uIHdoaWNoIGl0IHN0YXJ0cywgdW5sZXNzIHRoZXJlIGlzIGEgbm9kZSB0aGF0IGlzXG4gICAgX25vdF8gYSBwYXJlbnQgb2YgdGhpcyBub2RlIGNvdmVyaW5nIHRoZSBzdGFydCBvZiB0aGF0IGxpbmUuIElmXG4gICAgc28sIHRoZSBsaW5lIGF0IHRoZSBzdGFydCBvZiB0aGF0IG5vZGUgaXMgdHJpZWQsIGFnYWluIHNraXBwaW5nXG4gICAgb24gaWYgaXQgaXMgY292ZXJlZCBieSBhbm90aGVyIHN1Y2ggbm9kZS5cbiAgICAqL1xuICAgIGdldCBiYXNlSW5kZW50KCkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdCh0aGlzLm5vZGUuZnJvbSk7XG4gICAgICAgIC8vIFNraXAgbGluZSBzdGFydHMgdGhhdCBhcmUgY292ZXJlZCBieSBhIHNpYmxpbmcgKG9yIGNvdXNpbiwgZXRjKVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgYXRCcmVhayA9IHRoaXMubm9kZS5yZXNvbHZlKGxpbmUuZnJvbSk7XG4gICAgICAgICAgICB3aGlsZSAoYXRCcmVhay5wYXJlbnQgJiYgYXRCcmVhay5wYXJlbnQuZnJvbSA9PSBhdEJyZWFrLmZyb20pXG4gICAgICAgICAgICAgICAgYXRCcmVhayA9IGF0QnJlYWsucGFyZW50O1xuICAgICAgICAgICAgaWYgKGlzUGFyZW50KGF0QnJlYWssIHRoaXMubm9kZSkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KGF0QnJlYWsuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUluZGVudChsaW5lLmZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBDb250aW51ZSBsb29raW5nIGZvciBpbmRlbnRhdGlvbnMgaW4gdGhlIG5vZGUncyBwYXJlbnQgbm9kZXMsXG4gICAgYW5kIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoYXQuXG4gICAgKi9cbiAgICBjb250aW51ZSgpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMubm9kZS5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBwYXJlbnQgPyBpbmRlbnRGcm9tKHBhcmVudCwgdGhpcy5wb3MsIHRoaXMuYmFzZSkgOiAwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUGFyZW50KHBhcmVudCwgb2YpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBvZjsgY3VyOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICBpZiAocGFyZW50ID09IGN1cilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIENoZWNrIHdoZXRoZXIgYSBkZWxpbWl0ZWQgbm9kZSBpcyBhbGlnbmVkIChtZWFuaW5nIHRoZXJlIGFyZVxuLy8gbm9uLXNraXBwZWQgbm9kZXMgb24gdGhlIHNhbWUgbGluZSBhcyB0aGUgb3BlbmluZyBkZWxpbWl0ZXIpLiBBbmRcbi8vIGlmIHNvLCByZXR1cm4gdGhlIG9wZW5pbmcgdG9rZW4uXG5mdW5jdGlvbiBicmFja2V0ZWRBbGlnbmVkKGNvbnRleHQpIHtcbiAgICBsZXQgdHJlZSA9IGNvbnRleHQubm9kZTtcbiAgICBsZXQgb3BlblRva2VuID0gdHJlZS5jaGlsZEFmdGVyKHRyZWUuZnJvbSksIGxhc3QgPSB0cmVlLmxhc3RDaGlsZDtcbiAgICBpZiAoIW9wZW5Ub2tlbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHNpbSA9IGNvbnRleHQub3B0aW9ucy5zaW11bGF0ZUJyZWFrO1xuICAgIGxldCBvcGVuTGluZSA9IGNvbnRleHQuc3RhdGUuZG9jLmxpbmVBdChvcGVuVG9rZW4uZnJvbSk7XG4gICAgbGV0IGxpbmVFbmQgPSBzaW0gPT0gbnVsbCB8fCBzaW0gPD0gb3BlbkxpbmUuZnJvbSA/IG9wZW5MaW5lLnRvIDogTWF0aC5taW4ob3BlbkxpbmUudG8sIHNpbSk7XG4gICAgZm9yIChsZXQgcG9zID0gb3BlblRva2VuLnRvOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSB0cmVlLmNoaWxkQWZ0ZXIocG9zKTtcbiAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQgPT0gbGFzdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIW5leHQudHlwZS5pc1NraXBwZWQpXG4gICAgICAgICAgICByZXR1cm4gbmV4dC5mcm9tIDwgbGluZUVuZCA/IG9wZW5Ub2tlbiA6IG51bGw7XG4gICAgICAgIHBvcyA9IG5leHQudG87XG4gICAgfVxufVxuLyoqXG5BbiBpbmRlbnRhdGlvbiBzdHJhdGVneSBmb3IgZGVsaW1pdGVkICh1c3VhbGx5IGJyYWNrZXRlZCkgbm9kZXMuXG5XaWxsLCBieSBkZWZhdWx0LCBpbmRlbnQgb25lIHVuaXQgbW9yZSB0aGFuIHRoZSBwYXJlbnQncyBiYXNlXG5pbmRlbnQgdW5sZXNzIHRoZSBsaW5lIHN0YXJ0cyB3aXRoIGEgY2xvc2luZyB0b2tlbi4gV2hlbiBgYWxpZ25gXG5pcyB0cnVlIGFuZCB0aGVyZSBhcmUgbm9uLXNraXBwZWQgbm9kZXMgb24gdGhlIG5vZGUncyBvcGVuaW5nXG5saW5lLCB0aGUgY29udGVudCBvZiB0aGUgbm9kZSB3aWxsIGJlIGFsaWduZWQgd2l0aCB0aGUgZW5kIG9mIHRoZVxub3BlbmluZyBub2RlLCBsaWtlIHRoaXM6XG5cbiAgICBmb28oYmFyLFxuICAgICAgICBiYXopXG4qL1xuZnVuY3Rpb24gZGVsaW1pdGVkSW5kZW50KHsgY2xvc2luZywgYWxpZ24gPSB0cnVlLCB1bml0cyA9IDEgfSkge1xuICAgIHJldHVybiAoY29udGV4dCkgPT4gZGVsaW1pdGVkU3RyYXRlZ3koY29udGV4dCwgYWxpZ24sIHVuaXRzLCBjbG9zaW5nKTtcbn1cbmZ1bmN0aW9uIGRlbGltaXRlZFN0cmF0ZWd5KGNvbnRleHQsIGFsaWduLCB1bml0cywgY2xvc2luZywgY2xvc2VkQXQpIHtcbiAgICBsZXQgYWZ0ZXIgPSBjb250ZXh0LnRleHRBZnRlciwgc3BhY2UgPSBhZnRlci5tYXRjaCgvXlxccyovKVswXS5sZW5ndGg7XG4gICAgbGV0IGNsb3NlZCA9IGNsb3NpbmcgJiYgYWZ0ZXIuc2xpY2Uoc3BhY2UsIHNwYWNlICsgY2xvc2luZy5sZW5ndGgpID09IGNsb3NpbmcgfHwgY2xvc2VkQXQgPT0gY29udGV4dC5wb3MgKyBzcGFjZTtcbiAgICBsZXQgYWxpZ25lZCA9IGFsaWduID8gYnJhY2tldGVkQWxpZ25lZChjb250ZXh0KSA6IG51bGw7XG4gICAgaWYgKGFsaWduZWQpXG4gICAgICAgIHJldHVybiBjbG9zZWQgPyBjb250ZXh0LmNvbHVtbihhbGlnbmVkLmZyb20pIDogY29udGV4dC5jb2x1bW4oYWxpZ25lZC50byk7XG4gICAgcmV0dXJuIGNvbnRleHQuYmFzZUluZGVudCArIChjbG9zZWQgPyAwIDogY29udGV4dC51bml0ICogdW5pdHMpO1xufVxuLyoqXG5BbiBpbmRlbnRhdGlvbiBzdHJhdGVneSB0aGF0IGFsaWducyBhIG5vZGUncyBjb250ZW50IHRvIGl0cyBiYXNlXG5pbmRlbnRhdGlvbi5cbiovXG5jb25zdCBmbGF0SW5kZW50ID0gKGNvbnRleHQpID0+IGNvbnRleHQuYmFzZUluZGVudDtcbi8qKlxuQ3JlYXRlcyBhbiBpbmRlbnRhdGlvbiBzdHJhdGVneSB0aGF0LCBieSBkZWZhdWx0LCBpbmRlbnRzXG5jb250aW51ZWQgbGluZXMgb25lIHVuaXQgbW9yZSB0aGFuIHRoZSBub2RlJ3MgYmFzZSBpbmRlbnRhdGlvbi5cbllvdSBjYW4gcHJvdmlkZSBgZXhjZXB0YCB0byBwcmV2ZW50IGluZGVudGF0aW9uIG9mIGxpbmVzIHRoYXRcbm1hdGNoIGEgcGF0dGVybiAoZm9yIGV4YW1wbGUgYC9eZWxzZVxcYi9gIGluIGBpZmAvYGVsc2VgXG5jb25zdHJ1Y3RzKSwgYW5kIHlvdSBjYW4gY2hhbmdlIHRoZSBhbW91bnQgb2YgdW5pdHMgdXNlZCB3aXRoIHRoZVxuYHVuaXRzYCBvcHRpb24uXG4qL1xuZnVuY3Rpb24gY29udGludWVkSW5kZW50KHsgZXhjZXB0LCB1bml0cyA9IDEgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGxldCBtYXRjaEV4Y2VwdCA9IGV4Y2VwdCAmJiBleGNlcHQudGVzdChjb250ZXh0LnRleHRBZnRlcik7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmJhc2VJbmRlbnQgKyAobWF0Y2hFeGNlcHQgPyAwIDogdW5pdHMgKiBjb250ZXh0LnVuaXQpO1xuICAgIH07XG59XG5jb25zdCBEb250SW5kZW50QmV5b25kID0gMjAwO1xuLyoqXG5FbmFibGVzIHJlaW5kZW50YXRpb24gb24gaW5wdXQuIFdoZW4gYSBsYW5ndWFnZSBkZWZpbmVzIGFuXG5gaW5kZW50T25JbnB1dGAgZmllbGQgaW4gaXRzIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCksIHdoaWNoIG11c3QgaG9sZCBhIHJlZ3VsYXJcbmV4cHJlc3Npb24sIHRoZSBsaW5lIGF0IHRoZSBjdXJzb3Igd2lsbCBiZSByZWluZGVudGVkIHdoZW5ldmVyIG5ld1xudGV4dCBpcyB0eXBlZCBhbmQgdGhlIGlucHV0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lIHVwIHRvIHRoZVxuY3Vyc29yIG1hdGNoZXMgdGhhdCByZWdleHAuXG5cblRvIGF2b2lkIHVubmVjY2VzYXJ5IHJlaW5kZW50cywgaXQgaXMgcmVjb21tZW5kZWQgdG8gc3RhcnQgdGhlXG5yZWdleHAgd2l0aCBgXmAgKHVzdWFsbHkgZm9sbG93ZWQgYnkgYFxccypgKSwgYW5kIGVuZCBpdCB3aXRoIGAkYC5cbkZvciBleGFtcGxlLCBgL15cXHMqXFx9JC9gIHdpbGwgcmVpbmRlbnQgd2hlbiBhIGNsb3NpbmcgYnJhY2UgaXNcbmFkZGVkIGF0IHRoZSBzdGFydCBvZiBhIGxpbmUuXG4qL1xuZnVuY3Rpb24gaW5kZW50T25JbnB1dCgpIHtcbiAgICByZXR1cm4gRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25GaWx0ZXIub2YodHIgPT4ge1xuICAgICAgICBpZiAoIXRyLmRvY0NoYW5nZWQgfHwgIXRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKSAmJiAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC5jb21wbGV0ZVwiKSlcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IHJ1bGVzID0gdHIuc3RhcnRTdGF0ZS5sYW5ndWFnZURhdGFBdChcImluZGVudE9uSW5wdXRcIiwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgaWYgKCFydWxlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCBkb2MgPSB0ci5uZXdEb2MsIHsgaGVhZCB9ID0gdHIubmV3U2VsZWN0aW9uLm1haW4sIGxpbmUgPSBkb2MubGluZUF0KGhlYWQpO1xuICAgICAgICBpZiAoaGVhZCA+IGxpbmUuZnJvbSArIERvbnRJbmRlbnRCZXlvbmQpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSBkb2Muc2xpY2VTdHJpbmcobGluZS5mcm9tLCBoZWFkKTtcbiAgICAgICAgaWYgKCFydWxlcy5zb21lKHIgPT4gci50ZXN0KGxpbmVTdGFydCkpKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdHIsIGxhc3QgPSAtMSwgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGhlYWQgfSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoaGVhZCk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID09IGxhc3QpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsYXN0ID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKHN0YXRlLCBsaW5lLmZyb20pO1xuICAgICAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICAgICAgbGV0IG5vcm0gPSBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCk7XG4gICAgICAgICAgICBpZiAoY3VyICE9IG5vcm0pXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogbGluZS5mcm9tICsgY3VyLmxlbmd0aCwgaW5zZXJ0OiBub3JtIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmxlbmd0aCA/IFt0ciwgeyBjaGFuZ2VzLCBzZXF1ZW50aWFsOiB0cnVlIH1dIDogdHI7XG4gICAgfSk7XG59XG5cbi8qKlxuQSBmYWNldCB0aGF0IHJlZ2lzdGVycyBhIGNvZGUgZm9sZGluZyBzZXJ2aWNlLiBXaGVuIGNhbGxlZCB3aXRoXG50aGUgZXh0ZW50IG9mIGEgbGluZSwgc3VjaCBhIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBmb2xkYWJsZVxucmFuZ2UgdGhhdCBzdGFydHMgb24gdGhhdCBsaW5lIChidXQgY29udGludWVzIGJleW9uZCBpdCksIGlmIG9uZVxuY2FuIGJlIGZvdW5kLlxuKi9cbmNvbnN0IGZvbGRTZXJ2aWNlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5UaGlzIG5vZGUgcHJvcCBpcyB1c2VkIHRvIGFzc29jaWF0ZSBmb2xkaW5nIGluZm9ybWF0aW9uIHdpdGhcbnN5bnRheCBub2RlIHR5cGVzLiBHaXZlbiBhIHN5bnRheCBub2RlLCBpdCBzaG91bGQgY2hlY2sgd2hldGhlclxudGhhdCB0cmVlIGlzIGZvbGRhYmxlIGFuZCByZXR1cm4gdGhlIHJhbmdlIHRoYXQgY2FuIGJlIGNvbGxhcHNlZFxud2hlbiBpdCBpcy5cbiovXG5jb25zdCBmb2xkTm9kZVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vKipcbltGb2xkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGROb2RlUHJvcCkgZnVuY3Rpb24gdGhhdCBmb2xkcyBldmVyeXRoaW5nIGJ1dFxudGhlIGZpcnN0IGFuZCB0aGUgbGFzdCBjaGlsZCBvZiBhIHN5bnRheCBub2RlLiBVc2VmdWwgZm9yIG5vZGVzXG50aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCBkZWxpbWl0ZXJzLlxuKi9cbmZ1bmN0aW9uIGZvbGRJbnNpZGUobm9kZSkge1xuICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZCwgbGFzdCA9IG5vZGUubGFzdENoaWxkO1xuICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC50byA8IGxhc3QuZnJvbSA/IHsgZnJvbTogZmlyc3QudG8sIHRvOiBsYXN0LnR5cGUuaXNFcnJvciA/IG5vZGUudG8gOiBsYXN0LmZyb20gfSA6IG51bGw7XG59XG5mdW5jdGlvbiBzeW50YXhGb2xkaW5nKHN0YXRlLCBzdGFydCwgZW5kKSB7XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKTtcbiAgICBpZiAodHJlZS5sZW5ndGggPCBlbmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBpbm5lciA9IHRyZWUucmVzb2x2ZUlubmVyKGVuZCwgMSk7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICBmb3IgKGxldCBjdXIgPSBpbm5lcjsgY3VyOyBjdXIgPSBjdXIucGFyZW50KSB7XG4gICAgICAgIGlmIChjdXIudG8gPD0gZW5kIHx8IGN1ci5mcm9tID4gZW5kKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChmb3VuZCAmJiBjdXIuZnJvbSA8IHN0YXJ0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBwcm9wID0gY3VyLnR5cGUucHJvcChmb2xkTm9kZVByb3ApO1xuICAgICAgICBpZiAocHJvcCAmJiAoY3VyLnRvIDwgdHJlZS5sZW5ndGggLSA1MCB8fCB0cmVlLmxlbmd0aCA9PSBzdGF0ZS5kb2MubGVuZ3RoIHx8ICFpc1VuZmluaXNoZWQoY3VyKSkpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3AoY3VyLCBzdGF0ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuZnJvbSA8PSBlbmQgJiYgdmFsdWUuZnJvbSA+PSBzdGFydCAmJiB2YWx1ZS50byA+IGVuZClcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGlzVW5maW5pc2hlZChub2RlKSB7XG4gICAgbGV0IGNoID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgcmV0dXJuIGNoICYmIGNoLnRvID09IG5vZGUudG8gJiYgY2gudHlwZS5pc0Vycm9yO1xufVxuLyoqXG5DaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBsaW5lIGlzIGZvbGRhYmxlLiBGaXJzdCBhc2tzIGFueSBmb2xkXG5zZXJ2aWNlcyByZWdpc3RlcmVkIHRocm91Z2hcbltgZm9sZFNlcnZpY2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRTZXJ2aWNlKSwgYW5kIGlmIG5vbmUgb2YgdGhlbSByZXR1cm5cbmEgcmVzdWx0LCB0cmllcyB0byBxdWVyeSB0aGUgW2ZvbGQgbm9kZVxucHJvcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkTm9kZVByb3ApIG9mIHN5bnRheCBub2RlcyB0aGF0IGNvdmVyIHRoZSBlbmRcbm9mIHRoZSBsaW5lLlxuKi9cbmZ1bmN0aW9uIGZvbGRhYmxlKHN0YXRlLCBsaW5lU3RhcnQsIGxpbmVFbmQpIHtcbiAgICBmb3IgKGxldCBzZXJ2aWNlIG9mIHN0YXRlLmZhY2V0KGZvbGRTZXJ2aWNlKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc2VydmljZShzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBzeW50YXhGb2xkaW5nKHN0YXRlLCBsaW5lU3RhcnQsIGxpbmVFbmQpO1xufVxuZnVuY3Rpb24gbWFwUmFuZ2UocmFuZ2UsIG1hcHBpbmcpIHtcbiAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUG9zKHJhbmdlLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUG9zKHJhbmdlLnRvLCAtMSk7XG4gICAgcmV0dXJuIGZyb20gPj0gdG8gPyB1bmRlZmluZWQgOiB7IGZyb20sIHRvIH07XG59XG4vKipcblN0YXRlIGVmZmVjdCB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIHRyYW5zYWN0aW9uIHRvIGZvbGQgdGhlXG5naXZlbiByYW5nZS4gKFlvdSBwcm9iYWJseSBvbmx5IG5lZWQgdGhpcyBpbiBleGNlcHRpb25hbFxuY2lyY3Vtc3RhbmNlc1x1MjAxNHVzdWFsbHkgeW91J2xsIGp1c3Qgd2FudCB0byBsZXRcbltgZm9sZENvZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRDb2RlKSBhbmQgdGhlIFtmb2xkXG5ndXR0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZEd1dHRlcikgY3JlYXRlIHRoZSB0cmFuc2FjdGlvbnMuKVxuKi9cbmNvbnN0IGZvbGRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiBtYXBSYW5nZSB9KTtcbi8qKlxuU3RhdGUgZWZmZWN0IHRoYXQgdW5mb2xkcyB0aGUgZ2l2ZW4gcmFuZ2UgKGlmIGl0IHdhcyBmb2xkZWQpLlxuKi9cbmNvbnN0IHVuZm9sZEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6IG1hcFJhbmdlIH0pO1xuZnVuY3Rpb24gc2VsZWN0ZWRMaW5lcyh2aWV3KSB7XG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgZm9yIChsZXQgeyBoZWFkIH0gb2Ygdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGlmIChsaW5lcy5zb21lKGwgPT4gbC5mcm9tIDw9IGhlYWQgJiYgbC50byA+PSBoZWFkKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsaW5lcy5wdXNoKHZpZXcubGluZUJsb2NrQXQoaGVhZCkpO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXM7XG59XG4vKipcblRoZSBzdGF0ZSBmaWVsZCB0aGF0IHN0b3JlcyB0aGUgZm9sZGVkIHJhbmdlcyAoYXMgYSBbZGVjb3JhdGlvblxuc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvblNldCkpLiBDYW4gYmUgcGFzc2VkIHRvXG5bYEVkaXRvclN0YXRlLnRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudG9KU09OKSBhbmRcbltgZnJvbUpTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmZyb21KU09OKSB0byBzZXJpYWxpemUgdGhlIGZvbGRcbnN0YXRlLlxuKi9cbmNvbnN0IGZvbGRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgIH0sXG4gICAgdXBkYXRlKGZvbGRlZCwgdHIpIHtcbiAgICAgICAgZm9sZGVkID0gZm9sZGVkLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZS5pcyhmb2xkRWZmZWN0KSAmJiAhZm9sZEV4aXN0cyhmb2xkZWQsIGUudmFsdWUuZnJvbSwgZS52YWx1ZS50bykpXG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7IGFkZDogW2ZvbGRXaWRnZXQucmFuZ2UoZS52YWx1ZS5mcm9tLCBlLnZhbHVlLnRvKV0gfSk7XG4gICAgICAgICAgICBlbHNlIGlmIChlLmlzKHVuZm9sZEVmZmVjdCkpXG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7IGZpbHRlcjogKGZyb20sIHRvKSA9PiBlLnZhbHVlLmZyb20gIT0gZnJvbSB8fCBlLnZhbHVlLnRvICE9IHRvLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGcm9tOiBlLnZhbHVlLmZyb20sIGZpbHRlclRvOiBlLnZhbHVlLnRvIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIGZvbGRlZCByYW5nZXMgdGhhdCBjb3ZlciB0aGUgc2VsZWN0aW9uIGhlYWRcbiAgICAgICAgaWYgKHRyLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IG9uU2VsZWN0aW9uID0gZmFsc2UsIHsgaGVhZCB9ID0gdHIuc2VsZWN0aW9uLm1haW47XG4gICAgICAgICAgICBmb2xkZWQuYmV0d2VlbihoZWFkLCBoZWFkLCAoYSwgYikgPT4geyBpZiAoYSA8IGhlYWQgJiYgYiA+IGhlYWQpXG4gICAgICAgICAgICAgICAgb25TZWxlY3Rpb24gPSB0cnVlOyB9KTtcbiAgICAgICAgICAgIGlmIChvblNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICBmb2xkZWQgPSBmb2xkZWQudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnJvbTogaGVhZCxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyVG86IGhlYWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogKGEsIGIpID0+IGIgPD0gaGVhZCB8fCBhID49IGhlYWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9sZGVkO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZiksXG4gICAgdG9KU09OKGZvbGRlZCwgc3RhdGUpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb2xkZWQuYmV0d2VlbigwLCBzdGF0ZS5kb2MubGVuZ3RoLCAoZnJvbSwgdG8pID0+IHsgcmFuZ2VzLnB1c2goZnJvbSwgdG8pOyB9KTtcbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9LFxuICAgIGZyb21KU09OKHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoICUgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIGZvciBmb2xkIHN0YXRlXCIpO1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSB2YWx1ZVtpKytdLCB0byA9IHZhbHVlW2krK107XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiBmb3IgZm9sZCBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGZvbGRXaWRnZXQucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQocmFuZ2VzLCB0cnVlKTtcbiAgICB9XG59KTtcbi8qKlxuR2V0IGEgW3JhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldCkgY29udGFpbmluZyB0aGUgZm9sZGVkIHJhbmdlc1xuaW4gdGhlIGdpdmVuIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIGZvbGRlZFJhbmdlcyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSB8fCBSYW5nZVNldC5lbXB0eTtcbn1cbmZ1bmN0aW9uIGZpbmRGb2xkKHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIChfYSA9IHN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmV0d2Vlbihmcm9tLCB0bywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGlmICghZm91bmQgfHwgZm91bmQuZnJvbSA+IGZyb20pXG4gICAgICAgICAgICBmb3VuZCA9IHsgZnJvbSwgdG8gfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBmb2xkRXhpc3RzKGZvbGRlZCwgZnJvbSwgdG8pIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBmb2xkZWQuYmV0d2Vlbihmcm9tLCBmcm9tLCAoYSwgYikgPT4geyBpZiAoYSA9PSBmcm9tICYmIGIgPT0gdG8pXG4gICAgICAgIGZvdW5kID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gbWF5YmVFbmFibGUoc3RhdGUsIG90aGVyKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpID8gb3RoZXIgOiBvdGhlci5jb25jYXQoU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKGNvZGVGb2xkaW5nKCkpKTtcbn1cbi8qKlxuRm9sZCB0aGUgbGluZXMgdGhhdCBhcmUgc2VsZWN0ZWQsIGlmIHBvc3NpYmxlLlxuKi9cbmNvbnN0IGZvbGRDb2RlID0gdmlldyA9PiB7XG4gICAgZm9yIChsZXQgbGluZSBvZiBzZWxlY3RlZExpbmVzKHZpZXcpKSB7XG4gICAgICAgIGxldCByYW5nZSA9IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlKHZpZXcuc3RhdGUsIFtmb2xkRWZmZWN0Lm9mKHJhbmdlKSwgYW5ub3VuY2VGb2xkKHZpZXcsIHJhbmdlKV0pIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuVW5mb2xkIGZvbGRlZCByYW5nZXMgb24gc2VsZWN0ZWQgbGluZXMuXG4qL1xuY29uc3QgdW5mb2xkQ29kZSA9IHZpZXcgPT4ge1xuICAgIGlmICghdmlldy5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBvZiBzZWxlY3RlZExpbmVzKHZpZXcpKSB7XG4gICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGVkKVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZGVkLCBmYWxzZSkpO1xuICAgIH1cbiAgICBpZiAoZWZmZWN0cy5sZW5ndGgpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuICAgIHJldHVybiBlZmZlY3RzLmxlbmd0aCA+IDA7XG59O1xuZnVuY3Rpb24gYW5ub3VuY2VGb2xkKHZpZXcsIHJhbmdlLCBmb2xkID0gdHJ1ZSkge1xuICAgIGxldCBsaW5lRnJvbSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5mcm9tKS5udW1iZXIsIGxpbmVUbyA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50bykubnVtYmVyO1xuICAgIHJldHVybiBFZGl0b3JWaWV3LmFubm91bmNlLm9mKGAke3ZpZXcuc3RhdGUucGhyYXNlKGZvbGQgPyBcIkZvbGRlZCBsaW5lc1wiIDogXCJVbmZvbGRlZCBsaW5lc1wiKX0gJHtsaW5lRnJvbX0gJHt2aWV3LnN0YXRlLnBocmFzZShcInRvXCIpfSAke2xpbmVUb30uYCk7XG59XG4vKipcbkZvbGQgYWxsIHRvcC1sZXZlbCBmb2xkYWJsZSByYW5nZXMuIE5vdGUgdGhhdCwgaW4gbW9zdCBjYXNlcyxcbmZvbGRpbmcgaW5mb3JtYXRpb24gd2lsbCBkZXBlbmQgb24gdGhlIFtzeW50YXhcbnRyZWVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2Uuc3ludGF4VHJlZSksIGFuZCBmb2xkaW5nIGV2ZXJ5dGhpbmcgbWF5IG5vdCB3b3JrXG5yZWxpYWJseSB3aGVuIHRoZSBkb2N1bWVudCBoYXNuJ3QgYmVlbiBmdWxseSBwYXJzZWQgKGVpdGhlclxuYmVjYXVzZSB0aGUgZWRpdG9yIHN0YXRlIHdhcyBvbmx5IGp1c3QgaW5pdGlhbGl6ZWQsIG9yIGJlY2F1c2UgdGhlXG5kb2N1bWVudCBpcyBzbyBiaWcgdGhhdCB0aGUgcGFyc2VyIGRlY2lkZWQgbm90IHRvIHBhcnNlIGl0XG5lbnRpcmVseSkuXG4qL1xuY29uc3QgZm9sZEFsbCA9IHZpZXcgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgc3RhdGUuZG9jLmxlbmd0aDspIHtcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcyksIHJhbmdlID0gZm9sZGFibGUoc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaChmb2xkRWZmZWN0Lm9mKHJhbmdlKSk7XG4gICAgICAgIHBvcyA9IChyYW5nZSA/IHZpZXcubGluZUJsb2NrQXQocmFuZ2UudG8pIDogbGluZSkudG8gKyAxO1xuICAgIH1cbiAgICBpZiAoZWZmZWN0cy5sZW5ndGgpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZSh2aWV3LnN0YXRlLCBlZmZlY3RzKSB9KTtcbiAgICByZXR1cm4gISFlZmZlY3RzLmxlbmd0aDtcbn07XG4vKipcblVuZm9sZCBhbGwgZm9sZGVkIGNvZGUuXG4qL1xuY29uc3QgdW5mb2xkQWxsID0gdmlldyA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5zaXplKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmaWVsZC5iZXR3ZWVuKDAsIHZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgKGZyb20sIHRvKSA9PiB7IGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YoeyBmcm9tLCB0byB9KSk7IH0pO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8vIEZpbmQgdGhlIGZvbGRhYmxlIHJlZ2lvbiBjb250YWluaW5nIHRoZSBnaXZlbiBsaW5lLCBpZiBvbmUgZXhpc3RzXG5mdW5jdGlvbiBmb2xkYWJsZUNvbnRhaW5lcih2aWV3LCBsaW5lQmxvY2spIHtcbiAgICAvLyBMb29rIGJhY2t3YXJkcyB0aHJvdWdoIGxpbmUgYmxvY2tzIHVudGlsIHdlIGZpbmQgYSBmb2xkYWJsZSByZWdpb24gdGhhdFxuICAgIC8vIGludGVyc2VjdHMgd2l0aCB0aGUgbGluZVxuICAgIGZvciAobGV0IGxpbmUgPSBsaW5lQmxvY2s7Oykge1xuICAgICAgICBsZXQgZm9sZGFibGVSZWdpb24gPSBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGFibGVSZWdpb24gJiYgZm9sZGFibGVSZWdpb24udG8gPiBsaW5lQmxvY2suZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBmb2xkYWJsZVJlZ2lvbjtcbiAgICAgICAgaWYgKCFsaW5lLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGluZSA9IHZpZXcubGluZUJsb2NrQXQobGluZS5mcm9tIC0gMSk7XG4gICAgfVxufVxuLyoqXG5Ub2dnbGUgZm9sZGluZyBhdCBjdXJzb3JzLiBVbmZvbGRzIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGZvbGRcbnN0YXJ0aW5nIGluIHRoYXQgbGluZSwgdHJpZXMgdG8gZmluZCBhIGZvbGRhYmxlIHJhbmdlIGFyb3VuZCBpdFxub3RoZXJ3aXNlLlxuKi9cbmNvbnN0IHRvZ2dsZUZvbGQgPSAodmlldykgPT4ge1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBvZiBzZWxlY3RlZExpbmVzKHZpZXcpKSB7XG4gICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGVkKSB7XG4gICAgICAgICAgICBlZmZlY3RzLnB1c2godW5mb2xkRWZmZWN0Lm9mKGZvbGRlZCksIGFubm91bmNlRm9sZCh2aWV3LCBmb2xkZWQsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZm9sZFJhbmdlID0gZm9sZGFibGVDb250YWluZXIodmlldywgbGluZSk7XG4gICAgICAgICAgICBpZiAoZm9sZFJhbmdlKVxuICAgICAgICAgICAgICAgIGVmZmVjdHMucHVzaChmb2xkRWZmZWN0Lm9mKGZvbGRSYW5nZSksIGFubm91bmNlRm9sZCh2aWV3LCBmb2xkUmFuZ2UpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWZmZWN0cy5sZW5ndGggPiAwKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGUodmlldy5zdGF0ZSwgZWZmZWN0cykgfSk7XG4gICAgcmV0dXJuICEhZWZmZWN0cy5sZW5ndGg7XG59O1xuLyoqXG5EZWZhdWx0IGZvbGQtcmVsYXRlZCBrZXkgYmluZGluZ3MuXG5cbiAtIEN0cmwtU2hpZnQtWyAoQ21kLUFsdC1bIG9uIG1hY09TKTogW2Bmb2xkQ29kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZENvZGUpLlxuIC0gQ3RybC1TaGlmdC1dIChDbWQtQWx0LV0gb24gbWFjT1MpOiBbYHVuZm9sZENvZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnVuZm9sZENvZGUpLlxuIC0gQ3RybC1BbHQtWzogW2Bmb2xkQWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkQWxsKS5cbiAtIEN0cmwtQWx0LV06IFtgdW5mb2xkQWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS51bmZvbGRBbGwpLlxuKi9cbmNvbnN0IGZvbGRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1TaGlmdC1bXCIsIG1hYzogXCJDbWQtQWx0LVtcIiwgcnVuOiBmb2xkQ29kZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtU2hpZnQtXVwiLCBtYWM6IFwiQ21kLUFsdC1dXCIsIHJ1bjogdW5mb2xkQ29kZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LVtcIiwgcnVuOiBmb2xkQWxsIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1BbHQtXVwiLCBydW46IHVuZm9sZEFsbCB9XG5dO1xuY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgICBwbGFjZWhvbGRlckRPTTogbnVsbCxcbiAgICBwbGFjZWhvbGRlclRleHQ6IFwiXHUyMDI2XCJcbn07XG5jb25zdCBmb2xkQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHsgcmV0dXJuIGNvbWJpbmVDb25maWcodmFsdWVzLCBkZWZhdWx0Q29uZmlnKTsgfVxufSk7XG4vKipcbkNyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb25maWd1cmVzIGNvZGUgZm9sZGluZy5cbiovXG5mdW5jdGlvbiBjb2RlRm9sZGluZyhjb25maWcpIHtcbiAgICBsZXQgcmVzdWx0ID0gW2ZvbGRTdGF0ZSwgYmFzZVRoZW1lJDFdO1xuICAgIGlmIChjb25maWcpXG4gICAgICAgIHJlc3VsdC5wdXNoKGZvbGRDb25maWcub2YoY29uZmlnKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGZvbGRXaWRnZXQgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjb25mID0gc3RhdGUuZmFjZXQoZm9sZENvbmZpZyk7XG4gICAgICAgICAgICBsZXQgb25jbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdCh2aWV3LnBvc0F0RE9NKGV2ZW50LnRhcmdldCkpO1xuICAgICAgICAgICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICAgICAgICAgIGlmIChmb2xkZWQpXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSB9KTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjb25mLnBsYWNlaG9sZGVyRE9NKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb25mLnBsYWNlaG9sZGVyRE9NKHZpZXcsIG9uY2xpY2spO1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBjb25mLnBsYWNlaG9sZGVyVGV4dDtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBzdGF0ZS5waHJhc2UoXCJmb2xkZWQgY29kZVwiKSk7XG4gICAgICAgICAgICBlbGVtZW50LnRpdGxlID0gc3RhdGUucGhyYXNlKFwidW5mb2xkXCIpO1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBcImNtLWZvbGRQbGFjZWhvbGRlclwiO1xuICAgICAgICAgICAgZWxlbWVudC5vbmNsaWNrID0gb25jbGljaztcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgfSB9KTtcbmNvbnN0IGZvbGRHdXR0ZXJEZWZhdWx0cyA9IHtcbiAgICBvcGVuVGV4dDogXCJcdTIzMDRcIixcbiAgICBjbG9zZWRUZXh0OiBcIlx1MjAzQVwiLFxuICAgIG1hcmtlckRPTTogbnVsbCxcbiAgICBkb21FdmVudEhhbmRsZXJzOiB7fSxcbiAgICBmb2xkaW5nQ2hhbmdlZDogKCkgPT4gZmFsc2Vcbn07XG5jbGFzcyBGb2xkTWFya2VyIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIG9wZW4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMub3BlbiA9IG9wZW47XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLmNvbmZpZyA9PSBvdGhlci5jb25maWcgJiYgdGhpcy5vcGVuID09IG90aGVyLm9wZW47IH1cbiAgICB0b0RPTSh2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXJrZXJET00pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubWFya2VyRE9NKHRoaXMub3Blbik7XG4gICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSB0aGlzLm9wZW4gPyB0aGlzLmNvbmZpZy5vcGVuVGV4dCA6IHRoaXMuY29uZmlnLmNsb3NlZFRleHQ7XG4gICAgICAgIHNwYW4udGl0bGUgPSB2aWV3LnN0YXRlLnBocmFzZSh0aGlzLm9wZW4gPyBcIkZvbGQgbGluZVwiIDogXCJVbmZvbGQgbGluZVwiKTtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgcmVnaXN0ZXJzIGEgZm9sZCBndXR0ZXIsIHdoaWNoIHNob3dzIGFcbmZvbGQgc3RhdHVzIGluZGljYXRvciBiZWZvcmUgZm9sZGFibGUgbGluZXMgKHdoaWNoIGNhbiBiZSBjbGlja2VkXG50byBmb2xkIG9yIHVuZm9sZCB0aGUgbGluZSkuXG4qL1xuZnVuY3Rpb24gZm9sZEd1dHRlcihjb25maWcgPSB7fSkge1xuICAgIGxldCBmdWxsQ29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb2xkR3V0dGVyRGVmYXVsdHMpLCBjb25maWcpO1xuICAgIGxldCBjYW5Gb2xkID0gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgdHJ1ZSksIGNhblVuZm9sZCA9IG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIGZhbHNlKTtcbiAgICBsZXQgbWFya2VycyA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdmlldy52aWV3cG9ydC5mcm9tO1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJzID0gdGhpcy5idWlsZE1hcmtlcnModmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHxcbiAgICAgICAgICAgICAgICB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsYW5ndWFnZSkgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGxhbmd1YWdlKSB8fFxuICAgICAgICAgICAgICAgIHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpICE9IHVwZGF0ZS5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSB8fFxuICAgICAgICAgICAgICAgIHN5bnRheFRyZWUodXBkYXRlLnN0YXJ0U3RhdGUpICE9IHN5bnRheFRyZWUodXBkYXRlLnN0YXRlKSB8fFxuICAgICAgICAgICAgICAgIGZ1bGxDb25maWcuZm9sZGluZ0NoYW5nZWQodXBkYXRlKSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlcnMgPSB0aGlzLmJ1aWxkTWFya2Vycyh1cGRhdGUudmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRNYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgbGluZSBvZiB2aWV3LnZpZXdwb3J0TGluZUJsb2Nrcykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKSA/IGNhblVuZm9sZFxuICAgICAgICAgICAgICAgICAgICA6IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50bykgPyBjYW5Gb2xkIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAobWFyaylcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRlci5hZGQobGluZS5mcm9tLCBsaW5lLmZyb20sIG1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgeyBkb21FdmVudEhhbmRsZXJzIH0gPSBmdWxsQ29uZmlnO1xuICAgIHJldHVybiBbXG4gICAgICAgIG1hcmtlcnMsXG4gICAgICAgIGd1dHRlcih7XG4gICAgICAgICAgICBjbGFzczogXCJjbS1mb2xkR3V0dGVyXCIsXG4gICAgICAgICAgICBtYXJrZXJzKHZpZXcpIHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKG1hcmtlcnMpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFya2VycykgfHwgUmFuZ2VTZXQuZW1wdHk7IH0sXG4gICAgICAgICAgICBpbml0aWFsU3BhY2VyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm9sZE1hcmtlcihmdWxsQ29uZmlnLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9tRXZlbnRIYW5kbGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkb21FdmVudEhhbmRsZXJzKSwgeyBjbGljazogKHZpZXcsIGxpbmUsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21FdmVudEhhbmRsZXJzLmNsaWNrICYmIGRvbUV2ZW50SGFuZGxlcnMuY2xpY2sodmlldywgbGluZSwgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9sZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdW5mb2xkRWZmZWN0Lm9mKGZvbGRlZCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBmb2xkRWZmZWN0Lm9mKHJhbmdlKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IH0pXG4gICAgICAgIH0pLFxuICAgICAgICBjb2RlRm9sZGluZygpXG4gICAgXTtcbn1cbmNvbnN0IGJhc2VUaGVtZSQxID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1mb2xkUGxhY2Vob2xkZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2VlZVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICNkZGRcIixcbiAgICAgICAgY29sb3I6IFwiIzg4OFwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiLjJlbVwiLFxuICAgICAgICBtYXJnaW46IFwiMCAxcHhcIixcbiAgICAgICAgcGFkZGluZzogXCIwIDFweFwiLFxuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgfSxcbiAgICBcIi5jbS1mb2xkR3V0dGVyIHNwYW5cIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjAgMXB4XCIsXG4gICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICB9XG59KTtcblxuLyoqXG5BIGhpZ2hsaWdodCBzdHlsZSBhc3NvY2lhdGVzIENTUyBzdHlsZXMgd2l0aCBoaWdsaWdodGluZ1xuW3RhZ3NdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjaGlnaGxpZ2h0LlRhZykuXG4qL1xuY2xhc3MgSGlnaGxpZ2h0U3R5bGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0YWcgc3R5bGVzIHVzZWQgdG8gY3JlYXRlIHRoaXMgaGlnaGxpZ2h0IHN0eWxlLlxuICAgICovXG4gICAgc3BlY3MsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zcGVjcyA9IHNwZWNzO1xuICAgICAgICBsZXQgbW9kU3BlYztcbiAgICAgICAgZnVuY3Rpb24gZGVmKHNwZWMpIHtcbiAgICAgICAgICAgIGxldCBjbHMgPSBTdHlsZU1vZHVsZS5uZXdOYW1lKCk7XG4gICAgICAgICAgICAobW9kU3BlYyB8fCAobW9kU3BlYyA9IE9iamVjdC5jcmVhdGUobnVsbCkpKVtcIi5cIiArIGNsc10gPSBzcGVjO1xuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGwgPSB0eXBlb2Ygb3B0aW9ucy5hbGwgPT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMuYWxsIDogb3B0aW9ucy5hbGwgPyBkZWYob3B0aW9ucy5hbGwpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzY29wZU9wdCA9IG9wdGlvbnMuc2NvcGU7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZU9wdCBpbnN0YW5jZW9mIExhbmd1YWdlID8gKHR5cGUpID0+IHR5cGUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSBzY29wZU9wdC5kYXRhXG4gICAgICAgICAgICA6IHNjb3BlT3B0ID8gKHR5cGUpID0+IHR5cGUgPT0gc2NvcGVPcHQgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3R5bGUgPSB0YWdIaWdobGlnaHRlcihzcGVjcy5tYXAoc3R5bGUgPT4gKHtcbiAgICAgICAgICAgIHRhZzogc3R5bGUudGFnLFxuICAgICAgICAgICAgY2xhc3M6IHN0eWxlLmNsYXNzIHx8IGRlZihPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwgeyB0YWc6IG51bGwgfSkpXG4gICAgICAgIH0pKSwge1xuICAgICAgICAgICAgYWxsLFxuICAgICAgICB9KS5zdHlsZTtcbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2RTcGVjID8gbmV3IFN0eWxlTW9kdWxlKG1vZFNwZWMpIDogbnVsbDtcbiAgICAgICAgdGhpcy50aGVtZVR5cGUgPSBvcHRpb25zLnRoZW1lVHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgaGlnaGxpZ2h0ZXIgc3R5bGUgdGhhdCBhc3NvY2lhdGVzIHRoZSBnaXZlbiBzdHlsZXMgdG9cbiAgICB0aGUgZ2l2ZW4gdGFncy4gVGhlIHNwZWNzIG11c3QgYmUgb2JqZWN0cyB0aGF0IGhvbGQgYSBzdHlsZSB0YWdcbiAgICBvciBhcnJheSBvZiB0YWdzIGluIHRoZWlyIGB0YWdgIHByb3BlcnR5LCBhbmQgZWl0aGVyIGEgc2luZ2xlXG4gICAgYGNsYXNzYCBwcm9wZXJ0eSBwcm92aWRpbmcgYSBzdGF0aWMgQ1NTIGNsYXNzIChmb3IgaGlnaGxpZ2h0ZXJcbiAgICB0aGF0IHJlbHkgb24gZXh0ZXJuYWwgc3R5bGluZyksIG9yIGFcbiAgICBbYHN0eWxlLW1vZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKS1zdHlsZVxuICAgIHNldCBvZiBDU1MgcHJvcGVydGllcyAod2hpY2ggZGVmaW5lIHRoZSBzdHlsaW5nIGZvciB0aG9zZSB0YWdzKS5cbiAgICBcbiAgICBUaGUgQ1NTIHJ1bGVzIGNyZWF0ZWQgZm9yIGEgaGlnaGxpZ2h0ZXIgd2lsbCBiZSBlbWl0dGVkIGluIHRoZVxuICAgIG9yZGVyIG9mIHRoZSBzcGVjJ3MgcHJvcGVydGllcy4gVGhhdCBtZWFucyB0aGF0IGZvciBlbGVtZW50cyB0aGF0XG4gICAgaGF2ZSBtdWx0aXBsZSB0YWdzIGFzc29jaWF0ZWQgd2l0aCB0aGVtLCBzdHlsZXMgZGVmaW5lZCBmdXJ0aGVyXG4gICAgZG93biBpbiB0aGUgbGlzdCB3aWxsIGhhdmUgYSBoaWdoZXIgQ1NTIHByZWNlZGVuY2UgdGhhbiBzdHlsZXNcbiAgICBkZWZpbmVkIGVhcmxpZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlnaGxpZ2h0U3R5bGUoc3BlY3MsIG9wdGlvbnMgfHwge30pO1xuICAgIH1cbn1cbmNvbnN0IGhpZ2hsaWdodGVyRmFjZXQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBmYWxsYmFja0hpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHsgcmV0dXJuIHZhbHVlcy5sZW5ndGggPyBbdmFsdWVzWzBdXSA6IG51bGw7IH1cbn0pO1xuZnVuY3Rpb24gZ2V0SGlnaGxpZ2h0ZXJzKHN0YXRlKSB7XG4gICAgbGV0IG1haW4gPSBzdGF0ZS5mYWNldChoaWdobGlnaHRlckZhY2V0KTtcbiAgICByZXR1cm4gbWFpbi5sZW5ndGggPyBtYWluIDogc3RhdGUuZmFjZXQoZmFsbGJhY2tIaWdobGlnaHRlcik7XG59XG4vKipcbldyYXAgYSBoaWdobGlnaHRlciBpbiBhbiBlZGl0b3IgZXh0ZW5zaW9uIHRoYXQgdXNlcyBpdCB0byBhcHBseVxuc3ludGF4IGhpZ2hsaWdodGluZyB0byB0aGUgZWRpdG9yIGNvbnRlbnQuXG5cbldoZW4gbXVsdGlwbGUgKG5vbi1mYWxsYmFjaykgc3R5bGVzIGFyZSBwcm92aWRlZCwgdGhlIHN0eWxpbmdcbmFwcGxpZWQgaXMgdGhlIHVuaW9uIG9mIHRoZSBjbGFzc2VzIHRoZXkgZW1pdC5cbiovXG5mdW5jdGlvbiBzeW50YXhIaWdobGlnaHRpbmcoaGlnaGxpZ2h0ZXIsIG9wdGlvbnMpIHtcbiAgICBsZXQgZXh0ID0gW3RyZWVIaWdobGlnaHRlcl0sIHRoZW1lVHlwZTtcbiAgICBpZiAoaGlnaGxpZ2h0ZXIgaW5zdGFuY2VvZiBIaWdobGlnaHRTdHlsZSkge1xuICAgICAgICBpZiAoaGlnaGxpZ2h0ZXIubW9kdWxlKVxuICAgICAgICAgICAgZXh0LnB1c2goRWRpdG9yVmlldy5zdHlsZU1vZHVsZS5vZihoaWdobGlnaHRlci5tb2R1bGUpKTtcbiAgICAgICAgdGhlbWVUeXBlID0gaGlnaGxpZ2h0ZXIudGhlbWVUeXBlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZhbGxiYWNrKVxuICAgICAgICBleHQucHVzaChmYWxsYmFja0hpZ2hsaWdodGVyLm9mKGhpZ2hsaWdodGVyKSk7XG4gICAgZWxzZSBpZiAodGhlbWVUeXBlKVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRlckZhY2V0LmNvbXB1dGVOKFtFZGl0b3JWaWV3LmRhcmtUaGVtZV0sIHN0YXRlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5mYWNldChFZGl0b3JWaWV3LmRhcmtUaGVtZSkgPT0gKHRoZW1lVHlwZSA9PSBcImRhcmtcIikgPyBbaGlnaGxpZ2h0ZXJdIDogW107XG4gICAgICAgIH0pKTtcbiAgICBlbHNlXG4gICAgICAgIGV4dC5wdXNoKGhpZ2hsaWdodGVyRmFjZXQub2YoaGlnaGxpZ2h0ZXIpKTtcbiAgICByZXR1cm4gZXh0O1xufVxuLyoqXG5SZXR1cm5zIHRoZSBDU1MgY2xhc3NlcyAoaWYgYW55KSB0aGF0IHRoZSBoaWdobGlnaHRlcnMgYWN0aXZlIGluXG50aGUgc3RhdGUgd291bGQgYXNzaWduIHRvIHRoZSBnaXZlbiBzdHlsZVxuW3RhZ3NdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjaGlnaGxpZ2h0LlRhZykgYW5kXG4ob3B0aW9uYWwpIGxhbmd1YWdlXG5bc2NvcGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSGlnaGxpZ2h0U3R5bGVeZGVmaW5lXm9wdGlvbnMuc2NvcGUpLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodGluZ0ZvcihzdGF0ZSwgdGFncywgc2NvcGUpIHtcbiAgICBsZXQgaGlnaGxpZ2h0ZXJzID0gZ2V0SGlnaGxpZ2h0ZXJzKHN0YXRlKTtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAoaGlnaGxpZ2h0ZXJzKVxuICAgICAgICBmb3IgKGxldCBoaWdobGlnaHRlciBvZiBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgICAgIGlmICghaGlnaGxpZ2h0ZXIuc2NvcGUgfHwgc2NvcGUgJiYgaGlnaGxpZ2h0ZXIuc2NvcGUoc2NvcGUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNscyA9IGhpZ2hsaWdodGVyLnN0eWxlKHRhZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA/IHJlc3VsdCArIFwiIFwiICsgY2xzIDogY2xzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIFRyZWVIaWdobGlnaHRlciB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLm1hcmtDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudHJlZSA9IHN5bnRheFRyZWUodmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjbyh2aWV3LCBnZXRIaWdobGlnaHRlcnModmlldy5zdGF0ZSkpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCB0cmVlID0gc3ludGF4VHJlZSh1cGRhdGUuc3RhdGUpLCBoaWdobGlnaHRlcnMgPSBnZXRIaWdobGlnaHRlcnModXBkYXRlLnN0YXRlKTtcbiAgICAgICAgbGV0IHN0eWxlQ2hhbmdlID0gaGlnaGxpZ2h0ZXJzICE9IGdldEhpZ2hsaWdodGVycyh1cGRhdGUuc3RhcnRTdGF0ZSk7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA8IHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvICYmICFzdHlsZUNoYW5nZSAmJiB0cmVlLnR5cGUgPT0gdGhpcy50cmVlLnR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRpb25zLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJlZSAhPSB0aGlzLnRyZWUgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fCBzdHlsZUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjbyh1cGRhdGUudmlldywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZERlY28odmlldywgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGlmICghaGlnaGxpZ2h0ZXJzIHx8ICF0aGlzLnRyZWUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodFRyZWUodGhpcy50cmVlLCBoaWdobGlnaHRlcnMsIChmcm9tLCB0bywgc3R5bGUpID0+IHtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChmcm9tLCB0bywgdGhpcy5tYXJrQ2FjaGVbc3R5bGVdIHx8ICh0aGlzLm1hcmtDYWNoZVtzdHlsZV0gPSBEZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogc3R5bGUgfSkpKTtcbiAgICAgICAgICAgIH0sIGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICB9XG59XG5jb25zdCB0cmVlSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoKC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhUcmVlSGlnaGxpZ2h0ZXIsIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KSk7XG4vKipcbkEgZGVmYXVsdCBoaWdobGlnaHQgc3R5bGUgKHdvcmtzIHdlbGwgd2l0aCBsaWdodCB0aGVtZXMpLlxuKi9cbmNvbnN0IGRlZmF1bHRIaWdobGlnaHRTdHlsZSA9IC8qQF9fUFVSRV9fKi9IaWdobGlnaHRTdHlsZS5kZWZpbmUoW1xuICAgIHsgdGFnOiB0YWdzLm1ldGEsXG4gICAgICAgIGNvbG9yOiBcIiM0MDQ3NDBcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxpbmssXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZyxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZW1waGFzaXMsXG4gICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZyxcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJpa2V0aHJvdWdoLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJsaW5lLXRocm91Z2hcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmtleXdvcmQsXG4gICAgICAgIGNvbG9yOiBcIiM3MDhcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5hdG9tLCB0YWdzLmJvb2wsIHRhZ3MudXJsLCB0YWdzLmNvbnRlbnRTZXBhcmF0b3IsIHRhZ3MubGFiZWxOYW1lXSxcbiAgICAgICAgY29sb3I6IFwiIzIxOVwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLmxpdGVyYWwsIHRhZ3MuaW5zZXJ0ZWRdLFxuICAgICAgICBjb2xvcjogXCIjMTY0XCIgfSxcbiAgICB7IHRhZzogW3RhZ3Muc3RyaW5nLCB0YWdzLmRlbGV0ZWRdLFxuICAgICAgICBjb2xvcjogXCIjYTExXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MucmVnZXhwLCB0YWdzLmVzY2FwZSwgLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLnN0cmluZyldLFxuICAgICAgICBjb2xvcjogXCIjZTQwXCIgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksXG4gICAgICAgIGNvbG9yOiBcIiMwMGZcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5sb2NhbCh0YWdzLnZhcmlhYmxlTmFtZSksXG4gICAgICAgIGNvbG9yOiBcIiMzMGFcIiB9LFxuICAgIHsgdGFnOiBbdGFncy50eXBlTmFtZSwgdGFncy5uYW1lc3BhY2VdLFxuICAgICAgICBjb2xvcjogXCIjMDg1XCIgfSxcbiAgICB7IHRhZzogdGFncy5jbGFzc05hbWUsXG4gICAgICAgIGNvbG9yOiBcIiMxNjdcIiB9LFxuICAgIHsgdGFnOiBbLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSksIHRhZ3MubWFjcm9OYW1lXSxcbiAgICAgICAgY29sb3I6IFwiIzI1NlwiIH0sXG4gICAgeyB0YWc6IC8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy5wcm9wZXJ0eU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMDBjXCIgfSxcbiAgICB7IHRhZzogdGFncy5jb21tZW50LFxuICAgICAgICBjb2xvcjogXCIjOTQwXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLFxuICAgICAgICBjb2xvcjogXCIjZjAwXCIgfVxuXSk7XG5cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCImLmNtLWZvY3VzZWQgLmNtLW1hdGNoaW5nQnJhY2tldFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMzI4YzgyNTJcIiB9LFxuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1ub25tYXRjaGluZ0JyYWNrZXRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2JiNTU1NTQ0XCIgfVxufSk7XG5jb25zdCBEZWZhdWx0U2NhbkRpc3QgPSAxMDAwMCwgRGVmYXVsdEJyYWNrZXRzID0gXCIoKVtde31cIjtcbmNvbnN0IGJyYWNrZXRNYXRjaGluZ0NvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBhZnRlckN1cnNvcjogdHJ1ZSxcbiAgICAgICAgICAgIGJyYWNrZXRzOiBEZWZhdWx0QnJhY2tldHMsXG4gICAgICAgICAgICBtYXhTY2FuRGlzdGFuY2U6IERlZmF1bHRTY2FuRGlzdCxcbiAgICAgICAgICAgIHJlbmRlck1hdGNoOiBkZWZhdWx0UmVuZGVyTWF0Y2hcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jb25zdCBtYXRjaGluZ01hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbWF0Y2hpbmdCcmFja2V0XCIgfSksIG5vbm1hdGNoaW5nTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1ub25tYXRjaGluZ0JyYWNrZXRcIiB9KTtcbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJNYXRjaChtYXRjaCkge1xuICAgIGxldCBkZWNvcmF0aW9ucyA9IFtdO1xuICAgIGxldCBtYXJrID0gbWF0Y2gubWF0Y2hlZCA/IG1hdGNoaW5nTWFyayA6IG5vbm1hdGNoaW5nTWFyaztcbiAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcmsucmFuZ2UobWF0Y2guc3RhcnQuZnJvbSwgbWF0Y2guc3RhcnQudG8pKTtcbiAgICBpZiAobWF0Y2guZW5kKVxuICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcmsucmFuZ2UobWF0Y2guZW5kLmZyb20sIG1hdGNoLmVuZC50bykpO1xuICAgIHJldHVybiBkZWNvcmF0aW9ucztcbn1cbmNvbnN0IGJyYWNrZXRNYXRjaGluZ1N0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBEZWNvcmF0aW9uLm5vbmU7IH0sXG4gICAgdXBkYXRlKGRlY28sIHRyKSB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCAmJiAhdHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIGRlY287XG4gICAgICAgIGxldCBkZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgY29uZmlnID0gdHIuc3RhdGUuZmFjZXQoYnJhY2tldE1hdGNoaW5nQ29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgdHIuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQsIC0xLCBjb25maWcpXG4gICAgICAgICAgICAgICAgfHwgKHJhbmdlLmhlYWQgPiAwICYmIG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQgLSAxLCAxLCBjb25maWcpKVxuICAgICAgICAgICAgICAgIHx8IChjb25maWcuYWZ0ZXJDdXJzb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgKG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQsIDEsIGNvbmZpZykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChyYW5nZS5oZWFkIDwgdHIuc3RhdGUuZG9jLmxlbmd0aCAmJiBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkICsgMSwgLTEsIGNvbmZpZykpKSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucy5jb25jYXQoY29uZmlnLnJlbmRlck1hdGNoKG1hdGNoLCB0ci5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvcmF0aW9ucywgdHJ1ZSk7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmKVxufSk7XG5jb25zdCBicmFja2V0TWF0Y2hpbmdVbmlxdWUgPSBbXG4gICAgYnJhY2tldE1hdGNoaW5nU3RhdGUsXG4gICAgYmFzZVRoZW1lXG5dO1xuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBicmFja2V0IG1hdGNoaW5nLiBXaGVuZXZlciB0aGVcbmN1cnNvciBpcyBuZXh0IHRvIGEgYnJhY2tldCwgdGhhdCBicmFja2V0IGFuZCB0aGUgb25lIGl0IG1hdGNoZXNcbmFyZSBoaWdobGlnaHRlZC4gT3IsIHdoZW4gbm8gbWF0Y2hpbmcgYnJhY2tldCBpcyBmb3VuZCwgYW5vdGhlclxuaGlnaGxpZ2h0aW5nIHN0eWxlIGlzIHVzZWQgdG8gaW5kaWNhdGUgdGhpcy5cbiovXG5mdW5jdGlvbiBicmFja2V0TWF0Y2hpbmcoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW2JyYWNrZXRNYXRjaGluZ0NvbmZpZy5vZihjb25maWcpLCBicmFja2V0TWF0Y2hpbmdVbmlxdWVdO1xufVxuLyoqXG5XaGVuIGxhcmdlciBzeW50YXggbm9kZXMsIHN1Y2ggYXMgSFRNTCB0YWdzLCBhcmUgbWFya2VkIGFzXG5vcGVuaW5nL2Nsb3NpbmcsIGl0IGNhbiBiZSBhIGJpdCBtZXNzeSB0byB0cmVhdCB0aGUgd2hvbGUgbm9kZSBhc1xuYSBtYXRjaGFibGUgYnJhY2tldC4gVGhpcyBub2RlIHByb3AgYWxsb3dzIHlvdSB0byBkZWZpbmUsIGZvciBzdWNoXG5hIG5vZGUsIGEgXHUyMDE4aGFuZGxlXHUyMDE5XHUyMDE0dGhlIHBhcnQgb2YgdGhlIG5vZGUgdGhhdCBpcyBoaWdobGlnaHRlZCwgYW5kXG50aGF0IHRoZSBjdXJzb3IgbXVzdCBiZSBvbiB0byBhY3RpdmF0ZSBoaWdobGlnaHRpbmcgaW4gdGhlIGZpcnN0XG5wbGFjZS5cbiovXG5jb25zdCBicmFja2V0TWF0Y2hpbmdIYW5kbGUgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG5mdW5jdGlvbiBtYXRjaGluZ05vZGVzKG5vZGUsIGRpciwgYnJhY2tldHMpIHtcbiAgICBsZXQgYnlQcm9wID0gbm9kZS5wcm9wKGRpciA8IDAgPyBOb2RlUHJvcC5vcGVuZWRCeSA6IE5vZGVQcm9wLmNsb3NlZEJ5KTtcbiAgICBpZiAoYnlQcm9wKVxuICAgICAgICByZXR1cm4gYnlQcm9wO1xuICAgIGlmIChub2RlLm5hbWUubGVuZ3RoID09IDEpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gYnJhY2tldHMuaW5kZXhPZihub2RlLm5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSAmJiBpbmRleCAlIDIgPT0gKGRpciA8IDAgPyAxIDogMCkpXG4gICAgICAgICAgICByZXR1cm4gW2JyYWNrZXRzW2luZGV4ICsgZGlyXV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZEhhbmRsZShub2RlKSB7XG4gICAgbGV0IGhhc0hhbmRsZSA9IG5vZGUudHlwZS5wcm9wKGJyYWNrZXRNYXRjaGluZ0hhbmRsZSk7XG4gICAgcmV0dXJuIGhhc0hhbmRsZSA/IGhhc0hhbmRsZShub2RlLm5vZGUpIDogbm9kZTtcbn1cbi8qKlxuRmluZCB0aGUgbWF0Y2hpbmcgYnJhY2tldCBmb3IgdGhlIHRva2VuIGF0IGBwb3NgLCBzY2FubmluZ1xuZGlyZWN0aW9uIGBkaXJgLiBPbmx5IHRoZSBgYnJhY2tldHNgIGFuZCBgbWF4U2NhbkRpc3RhbmNlYFxucHJvcGVydGllcyBhcmUgdXNlZCBmcm9tIGBjb25maWdgLCBpZiBnaXZlbi4gUmV0dXJucyBudWxsIGlmIG5vXG5icmFja2V0IHdhcyBmb3VuZCBhdCBgcG9zYCwgb3IgYSBtYXRjaCByZXN1bHQgb3RoZXJ3aXNlLlxuKi9cbmZ1bmN0aW9uIG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCBjb25maWcgPSB7fSkge1xuICAgIGxldCBtYXhTY2FuRGlzdGFuY2UgPSBjb25maWcubWF4U2NhbkRpc3RhbmNlIHx8IERlZmF1bHRTY2FuRGlzdCwgYnJhY2tldHMgPSBjb25maWcuYnJhY2tldHMgfHwgRGVmYXVsdEJyYWNrZXRzO1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSksIG5vZGUgPSB0cmVlLnJlc29sdmVJbm5lcihwb3MsIGRpcik7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZTsgY3VyOyBjdXIgPSBjdXIucGFyZW50KSB7XG4gICAgICAgIGxldCBtYXRjaGVzID0gbWF0Y2hpbmdOb2RlcyhjdXIudHlwZSwgZGlyLCBicmFja2V0cyk7XG4gICAgICAgIGlmIChtYXRjaGVzICYmIGN1ci5mcm9tIDwgY3VyLnRvKSB7XG4gICAgICAgICAgICBsZXQgaGFuZGxlID0gZmluZEhhbmRsZShjdXIpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZSAmJiAoZGlyID4gMCA/IHBvcyA+PSBoYW5kbGUuZnJvbSAmJiBwb3MgPCBoYW5kbGUudG8gOiBwb3MgPiBoYW5kbGUuZnJvbSAmJiBwb3MgPD0gaGFuZGxlLnRvKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hNYXJrZWRCcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIGN1ciwgaGFuZGxlLCBtYXRjaGVzLCBicmFja2V0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoUGxhaW5CcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIHRyZWUsIG5vZGUudHlwZSwgbWF4U2NhbkRpc3RhbmNlLCBicmFja2V0cyk7XG59XG5mdW5jdGlvbiBtYXRjaE1hcmtlZEJyYWNrZXRzKF9zdGF0ZSwgX3BvcywgZGlyLCB0b2tlbiwgaGFuZGxlLCBtYXRjaGluZywgYnJhY2tldHMpIHtcbiAgICBsZXQgcGFyZW50ID0gdG9rZW4ucGFyZW50LCBmaXJzdFRva2VuID0geyBmcm9tOiBoYW5kbGUuZnJvbSwgdG86IGhhbmRsZS50byB9O1xuICAgIGxldCBkZXB0aCA9IDAsIGN1cnNvciA9IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5jdXJzb3IoKTtcbiAgICBpZiAoY3Vyc29yICYmIChkaXIgPCAwID8gY3Vyc29yLmNoaWxkQmVmb3JlKHRva2VuLmZyb20pIDogY3Vyc29yLmNoaWxkQWZ0ZXIodG9rZW4udG8pKSlcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGRpciA8IDAgPyBjdXJzb3IudG8gPD0gdG9rZW4uZnJvbSA6IGN1cnNvci5mcm9tID49IHRva2VuLnRvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IDAgJiYgbWF0Y2hpbmcuaW5kZXhPZihjdXJzb3IudHlwZS5uYW1lKSA+IC0xICYmIGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmRIYW5kbGUgPSBmaW5kSGFuZGxlKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBmaXJzdFRva2VuLCBlbmQ6IGVuZEhhbmRsZSA/IHsgZnJvbTogZW5kSGFuZGxlLmZyb20sIHRvOiBlbmRIYW5kbGUudG8gfSA6IHVuZGVmaW5lZCwgbWF0Y2hlZDogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZ05vZGVzKGN1cnNvci50eXBlLCBkaXIsIGJyYWNrZXRzKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZ05vZGVzKGN1cnNvci50eXBlLCAtZGlyLCBicmFja2V0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbmRIYW5kbGUgPSBmaW5kSGFuZGxlKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBmaXJzdFRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZW5kSGFuZGxlICYmIGVuZEhhbmRsZS5mcm9tIDwgZW5kSGFuZGxlLnRvID8geyBmcm9tOiBlbmRIYW5kbGUuZnJvbSwgdG86IGVuZEhhbmRsZS50byB9IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChkaXIgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IGZpcnN0VG9rZW4sIG1hdGNoZWQ6IGZhbHNlIH07XG59XG5mdW5jdGlvbiBtYXRjaFBsYWluQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCB0cmVlLCB0b2tlblR5cGUsIG1heFNjYW5EaXN0YW5jZSwgYnJhY2tldHMpIHtcbiAgICBsZXQgc3RhcnRDaCA9IGRpciA8IDAgPyBzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MpIDogc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyAxKTtcbiAgICBsZXQgYnJhY2tldCA9IGJyYWNrZXRzLmluZGV4T2Yoc3RhcnRDaCk7XG4gICAgaWYgKGJyYWNrZXQgPCAwIHx8IChicmFja2V0ICUgMiA9PSAwKSAhPSAoZGlyID4gMCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBzdGFydFRva2VuID0geyBmcm9tOiBkaXIgPCAwID8gcG9zIC0gMSA6IHBvcywgdG86IGRpciA+IDAgPyBwb3MgKyAxIDogcG9zIH07XG4gICAgbGV0IGl0ZXIgPSBzdGF0ZS5kb2MuaXRlclJhbmdlKHBvcywgZGlyID4gMCA/IHN0YXRlLmRvYy5sZW5ndGggOiAwKSwgZGVwdGggPSAwO1xuICAgIGZvciAobGV0IGRpc3RhbmNlID0gMDsgIShpdGVyLm5leHQoKSkuZG9uZSAmJiBkaXN0YW5jZSA8PSBtYXhTY2FuRGlzdGFuY2U7KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gaXRlci52YWx1ZTtcbiAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICBkaXN0YW5jZSArPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgbGV0IGJhc2VQb3MgPSBwb3MgKyBkaXN0YW5jZSAqIGRpcjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZGlyID4gMCA/IDAgOiB0ZXh0Lmxlbmd0aCAtIDEsIGVuZCA9IGRpciA+IDAgPyB0ZXh0Lmxlbmd0aCA6IC0xOyBwb3MgIT0gZW5kOyBwb3MgKz0gZGlyKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBicmFja2V0cy5pbmRleE9mKHRleHRbcG9zXSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPCAwIHx8IHRyZWUucmVzb2x2ZUlubmVyKGJhc2VQb3MgKyBwb3MsIDEpLnR5cGUgIT0gdG9rZW5UeXBlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKChmb3VuZCAlIDIgPT0gMCkgPT0gKGRpciA+IDApKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlcHRoID09IDEpIHsgLy8gQ2xvc2luZ1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydFRva2VuLCBlbmQ6IHsgZnJvbTogYmFzZVBvcyArIHBvcywgdG86IGJhc2VQb3MgKyBwb3MgKyAxIH0sIG1hdGNoZWQ6IChmb3VuZCA+PiAxKSA9PSAoYnJhY2tldCA+PiAxKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IHRleHQubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gaXRlci5kb25lID8geyBzdGFydDogc3RhcnRUb2tlbiwgbWF0Y2hlZDogZmFsc2UgfSA6IG51bGw7XG59XG5cbi8vIENvdW50cyB0aGUgY29sdW1uIG9mZnNldCBpbiBhIHN0cmluZywgdGFraW5nIHRhYnMgaW50byBhY2NvdW50LlxuLy8gVXNlZCBtb3N0bHkgdG8gZmluZCBpbmRlbnRhdGlvbi5cbmZ1bmN0aW9uIGNvdW50Q29sKHN0cmluZywgZW5kLCB0YWJTaXplLCBzdGFydEluZGV4ID0gMCwgc3RhcnRWYWx1ZSA9IDApIHtcbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gc3RyaW5nLnNlYXJjaCgvW15cXHNcXHUwMGEwXS8pO1xuICAgICAgICBpZiAoZW5kID09IC0xKVxuICAgICAgICAgICAgZW5kID0gc3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgbGV0IG4gPSBzdGFydFZhbHVlO1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkpXG4gICAgICAgICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuKys7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuLyoqXG5FbmNhcHN1bGF0ZXMgYSBzaW5nbGUgbGluZSBvZiBpbnB1dC4gR2l2ZW4gdG8gc3RyZWFtIHN5bnRheCBjb2RlLFxud2hpY2ggdXNlcyBpdCB0byB0b2tlbml6ZSB0aGUgY29udGVudC5cbiovXG5jbGFzcyBTdHJpbmdTdHJlYW0ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHN0cmVhbS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsaW5lLlxuICAgICovXG4gICAgc3RyaW5nLCB0YWJTaXplLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBpbmRlbnQgdW5pdCBzaXplLlxuICAgICovXG4gICAgaW5kZW50VW5pdCwgb3ZlcnJpZGVJbmRlbnQpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMudGFiU2l6ZSA9IHRhYlNpemU7XG4gICAgICAgIHRoaXMuaW5kZW50VW5pdCA9IGluZGVudFVuaXQ7XG4gICAgICAgIHRoaXMub3ZlcnJpZGVJbmRlbnQgPSBvdmVycmlkZUluZGVudDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBsaW5lLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgd2UgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBlb2woKSB7IHJldHVybiB0aGlzLnBvcyA+PSB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHdlIGFyZSBhdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBzb2woKSB7IHJldHVybiB0aGlzLnBvcyA9PSAwOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBuZXh0IGNvZGUgdW5pdCBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbiwgb3IgdW5kZWZpbmVkXG4gICAgaWYgd2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHBlZWsoKSB7IHJldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpIHx8IHVuZGVmaW5lZDsgfVxuICAgIC8qKlxuICAgIFJlYWQgdGhlIG5leHQgY29kZSB1bml0IGFuZCBhZHZhbmNlIGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPCB0aGlzLnN0cmluZy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCB0aGUgbmV4dCBjaGFyYWN0ZXIgYWdhaW5zdCB0aGUgZ2l2ZW4gc3RyaW5nLCByZWd1bGFyXG4gICAgZXhwcmVzc2lvbiwgb3IgcHJlZGljYXRlLiBDb25zdW1lIGFuZCByZXR1cm4gaXQgaWYgaXQgbWF0Y2hlcy5cbiAgICAqL1xuICAgIGVhdChtYXRjaCkge1xuICAgICAgICBsZXQgY2ggPSB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgb2s7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIG9rID0gY2ggPT0gbWF0Y2g7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9rID0gY2ggJiYgKG1hdGNoIGluc3RhbmNlb2YgUmVnRXhwID8gbWF0Y2gudGVzdChjaCkgOiBtYXRjaChjaCkpO1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ29udGludWUgbWF0Y2hpbmcgY2hhcmFjdGVycyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBzdHJpbmcsXG4gICAgcmVndWxhciBleHByZXNzaW9uLCBvciBwcmVkaWNhdGUgZnVuY3Rpb24uIFJldHVybiB0cnVlIGlmIGFueVxuICAgIGNoYXJhY3RlcnMgd2VyZSBjb25zdW1lZC5cbiAgICAqL1xuICAgIGVhdFdoaWxlKG1hdGNoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAodGhpcy5lYXQobWF0Y2gpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnN1bWUgd2hpdGVzcGFjZSBhaGVhZCBvZiBgdGhpcy5wb3NgLiBSZXR1cm4gdHJ1ZSBpZiBhbnkgd2FzXG4gICAgZm91bmQuXG4gICAgKi9cbiAgICBlYXRTcGFjZSgpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHdoaWxlICgvW1xcc1xcdTAwYTBdLy50ZXN0KHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykpKVxuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHNraXBUb0VuZCgpIHsgdGhpcy5wb3MgPSB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIGRpcmVjdGx5IGJlZm9yZSB0aGUgZ2l2ZW4gY2hhcmFjdGVyLCBpZiBmb3VuZCBvbiB0aGVcbiAgICBjdXJyZW50IGxpbmUuXG4gICAgKi9cbiAgICBza2lwVG8oY2gpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihjaCwgdGhpcy5wb3MpO1xuICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBmb3VuZDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYmFjayBgbmAgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIGJhY2tVcChuKSB7IHRoaXMucG9zIC09IG47IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbHVtbiBwb3NpdGlvbiBhdCBgdGhpcy5wb3NgLlxuICAgICovXG4gICAgY29sdW1uKCkge1xuICAgICAgICBpZiAodGhpcy5sYXN0Q29sdW1uUG9zIDwgdGhpcy5zdGFydCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSBjb3VudENvbCh0aGlzLnN0cmluZywgdGhpcy5zdGFydCwgdGhpcy50YWJTaXplLCB0aGlzLmxhc3RDb2x1bW5Qb3MsIHRoaXMubGFzdENvbHVtblZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENvbHVtblZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGNvbHVtbiBvZiB0aGUgY3VycmVudCBsaW5lLlxuICAgICovXG4gICAgaW5kZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMub3ZlcnJpZGVJbmRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvdW50Q29sKHRoaXMuc3RyaW5nLCBudWxsLCB0aGlzLnRhYlNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCB0aGUgaW5wdXQgYWdhaW5zdCB0aGUgZ2l2ZW4gc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICh3aGljaCBzaG91bGQgc3RhcnQgd2l0aCBhIGBeYCkuIFJldHVybiB0cnVlIG9yIHRoZSByZWdleHAgbWF0Y2hcbiAgICBpZiBpdCBtYXRjaGVzLlxuICAgIFxuICAgIFVubGVzcyBgY29uc3VtZWAgaXMgc2V0IHRvIGBmYWxzZWAsIHRoaXMgd2lsbCBtb3ZlIGB0aGlzLnBvc2BcbiAgICBwYXN0IHRoZSBtYXRjaGVkIHRleHQuXG4gICAgXG4gICAgV2hlbiBtYXRjaGluZyBhIHN0cmluZyBgY2FzZUluc2Vuc2l0aXZlYCBjYW4gYmUgc2V0IHRvIHRydWUgdG9cbiAgICBtYWtlIHRoZSBtYXRjaCBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICovXG4gICAgbWF0Y2gocGF0dGVybiwgY29uc3VtZSwgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsZXQgY2FzZWQgPSAoc3RyKSA9PiBjYXNlSW5zZW5zaXRpdmUgPyBzdHIudG9Mb3dlckNhc2UoKSA6IHN0cjtcbiAgICAgICAgICAgIGxldCBzdWJzdHIgPSB0aGlzLnN0cmluZy5zdWJzdHIodGhpcy5wb3MsIHBhdHRlcm4ubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChjYXNlZChzdWJzdHIpID09IGNhc2VkKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN1bWUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMucG9zKS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgY29uc3VtZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY3VycmVudCB0b2tlbi5cbiAgICAqL1xuICAgIGN1cnJlbnQoKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcyk7IH1cbn1cblxuZnVuY3Rpb24gZnVsbFBhcnNlcihzcGVjKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogc3BlYy5uYW1lIHx8IFwiXCIsXG4gICAgICAgIHRva2VuOiBzcGVjLnRva2VuLFxuICAgICAgICBibGFua0xpbmU6IHNwZWMuYmxhbmtMaW5lIHx8ICgoKSA9PiB7IH0pLFxuICAgICAgICBzdGFydFN0YXRlOiBzcGVjLnN0YXJ0U3RhdGUgfHwgKCgpID0+IHRydWUpLFxuICAgICAgICBjb3B5U3RhdGU6IHNwZWMuY29weVN0YXRlIHx8IGRlZmF1bHRDb3B5U3RhdGUsXG4gICAgICAgIGluZGVudDogc3BlYy5pbmRlbnQgfHwgKCgpID0+IG51bGwpLFxuICAgICAgICBsYW5ndWFnZURhdGE6IHNwZWMubGFuZ3VhZ2VEYXRhIHx8IHt9LFxuICAgICAgICB0b2tlblRhYmxlOiBzcGVjLnRva2VuVGFibGUgfHwgbm9Ub2tlbnNcbiAgICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdENvcHlTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIGxldCBuZXdTdGF0ZSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gc3RhdGUpIHtcbiAgICAgICAgbGV0IHZhbCA9IHN0YXRlW3Byb3BdO1xuICAgICAgICBuZXdTdGF0ZVtwcm9wXSA9ICh2YWwgaW5zdGFuY2VvZiBBcnJheSA/IHZhbC5zbGljZSgpIDogdmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xufVxuY29uc3QgSW5kZW50ZWRGcm9tID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG4vKipcbkEgW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSBjbGFzcyBiYXNlZCBvbiBhIENvZGVNaXJyb3JcbjUtc3R5bGUgW3N0cmVhbWluZyBwYXJzZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuU3RyZWFtUGFyc2VyKS5cbiovXG5jbGFzcyBTdHJlYW1MYW5ndWFnZSBleHRlbmRzIExhbmd1YWdlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBkZWZpbmVMYW5ndWFnZUZhY2V0KHBhcnNlci5sYW5ndWFnZURhdGEpO1xuICAgICAgICBsZXQgcCA9IGZ1bGxQYXJzZXIocGFyc2VyKSwgc2VsZjtcbiAgICAgICAgbGV0IGltcGwgPSBuZXcgY2xhc3MgZXh0ZW5kcyBQYXJzZXIge1xuICAgICAgICAgICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZShzZWxmLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzdXBlcihkYXRhLCBpbXBsLCBbaW5kZW50U2VydmljZS5vZigoY3gsIHBvcykgPT4gdGhpcy5nZXRJbmRlbnQoY3gsIHBvcykpXSwgcGFyc2VyLm5hbWUpO1xuICAgICAgICB0aGlzLnRvcE5vZGUgPSBkb2NJRChkYXRhKTtcbiAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RyZWFtUGFyc2VyID0gcDtcbiAgICAgICAgdGhpcy5zdGF0ZUFmdGVyID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy50b2tlblRhYmxlID0gcGFyc2VyLnRva2VuVGFibGUgPyBuZXcgVG9rZW5UYWJsZShwLnRva2VuVGFibGUpIDogZGVmYXVsdFRva2VuVGFibGU7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHN0cmVhbSBsYW5ndWFnZS5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlYykgeyByZXR1cm4gbmV3IFN0cmVhbUxhbmd1YWdlKHNwZWMpOyB9XG4gICAgZ2V0SW5kZW50KGN4LCBwb3MpIHtcbiAgICAgICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKGN4LnN0YXRlKSwgYXQgPSB0cmVlLnJlc29sdmUocG9zKTtcbiAgICAgICAgd2hpbGUgKGF0ICYmIGF0LnR5cGUgIT0gdGhpcy50b3BOb2RlKVxuICAgICAgICAgICAgYXQgPSBhdC5wYXJlbnQ7XG4gICAgICAgIGlmICghYXQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGZyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB7IG92ZXJyaWRlSW5kZW50YXRpb24gfSA9IGN4Lm9wdGlvbnM7XG4gICAgICAgIGlmIChvdmVycmlkZUluZGVudGF0aW9uKSB7XG4gICAgICAgICAgICBmcm9tID0gSW5kZW50ZWRGcm9tLmdldChjeC5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoZnJvbSAhPSBudWxsICYmIGZyb20gPCBwb3MgLSAxZTQpXG4gICAgICAgICAgICAgICAgZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSBmaW5kU3RhdGUodGhpcywgdHJlZSwgMCwgYXQuZnJvbSwgZnJvbSAhPT0gbnVsbCAmJiBmcm9tICE9PSB2b2lkIDAgPyBmcm9tIDogcG9zKSwgc3RhdGVQb3MsIHN0YXRlO1xuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gc3RhcnQuc3RhdGU7XG4gICAgICAgICAgICBzdGF0ZVBvcyA9IHN0YXJ0LnBvcyArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHRoaXMuc3RyZWFtUGFyc2VyLnN0YXJ0U3RhdGUoY3gudW5pdCk7XG4gICAgICAgICAgICBzdGF0ZVBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyAtIHN0YXRlUG9zID4gMTAwMDAgLyogQy5NYXhJbmRlbnRTY2FuRGlzdCAqLylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAoc3RhdGVQb3MgPCBwb3MpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gY3guc3RhdGUuZG9jLmxpbmVBdChzdGF0ZVBvcyksIGVuZCA9IE1hdGgubWluKHBvcywgbGluZS50byk7XG4gICAgICAgICAgICBpZiAobGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50YXRpb24gPSBvdmVycmlkZUluZGVudGF0aW9uID8gb3ZlcnJpZGVJbmRlbnRhdGlvbihsaW5lLmZyb20pIDogLTE7XG4gICAgICAgICAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0obGluZS50ZXh0LCBjeC5zdGF0ZS50YWJTaXplLCBjeC51bml0LCBpbmRlbnRhdGlvbiA8IDAgPyB1bmRlZmluZWQgOiBpbmRlbnRhdGlvbik7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0cmVhbS5wb3MgPCBlbmQgLSBsaW5lLmZyb20pXG4gICAgICAgICAgICAgICAgICAgIHJlYWRUb2tlbih0aGlzLnN0cmVhbVBhcnNlci50b2tlbiwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbVBhcnNlci5ibGFua0xpbmUoc3RhdGUsIGN4LnVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA9PSBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzdGF0ZVBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaW5lID0gY3gubGluZUF0KHBvcyk7XG4gICAgICAgIGlmIChvdmVycmlkZUluZGVudGF0aW9uICYmIGZyb20gPT0gbnVsbClcbiAgICAgICAgICAgIEluZGVudGVkRnJvbS5zZXQoY3guc3RhdGUsIGxpbmUuZnJvbSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbVBhcnNlci5pbmRlbnQoc3RhdGUsIC9eXFxzKiguKikvLmV4ZWMobGluZS50ZXh0KVsxXSwgY3gpO1xuICAgIH1cbiAgICBnZXQgYWxsb3dzTmVzdGluZygpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5mdW5jdGlvbiBmaW5kU3RhdGUobGFuZywgdHJlZSwgb2ZmLCBzdGFydFBvcywgYmVmb3JlKSB7XG4gICAgbGV0IHN0YXRlID0gb2ZmID49IHN0YXJ0UG9zICYmIG9mZiArIHRyZWUubGVuZ3RoIDw9IGJlZm9yZSAmJiB0cmVlLnByb3AobGFuZy5zdGF0ZUFmdGVyKTtcbiAgICBpZiAoc3RhdGUpXG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBsYW5nLnN0cmVhbVBhcnNlci5jb3B5U3RhdGUoc3RhdGUpLCBwb3M6IG9mZiArIHRyZWUubGVuZ3RoIH07XG4gICAgZm9yIChsZXQgaSA9IHRyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGNoaWxkID0gdHJlZS5jaGlsZHJlbltpXSwgcG9zID0gb2ZmICsgdHJlZS5wb3NpdGlvbnNbaV07XG4gICAgICAgIGxldCBmb3VuZCA9IGNoaWxkIGluc3RhbmNlb2YgVHJlZSAmJiBwb3MgPCBiZWZvcmUgJiYgZmluZFN0YXRlKGxhbmcsIGNoaWxkLCBwb3MsIHN0YXJ0UG9zLCBiZWZvcmUpO1xuICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY3V0VHJlZShsYW5nLCB0cmVlLCBmcm9tLCB0bywgaW5zaWRlKSB7XG4gICAgaWYgKGluc2lkZSAmJiBmcm9tIDw9IDAgJiYgdG8gPj0gdHJlZS5sZW5ndGgpXG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgIGlmICghaW5zaWRlICYmIHRyZWUudHlwZSA9PSBsYW5nLnRvcE5vZGUpXG4gICAgICAgIGluc2lkZSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IHRyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IHBvcyA9IHRyZWUucG9zaXRpb25zW2ldLCBjaGlsZCA9IHRyZWUuY2hpbGRyZW5baV0sIGlubmVyO1xuICAgICAgICBpZiAocG9zIDwgdG8gJiYgY2hpbGQgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICBpZiAoIShpbm5lciA9IGN1dFRyZWUobGFuZywgY2hpbGQsIGZyb20gLSBwb3MsIHRvIC0gcG9zLCBpbnNpZGUpKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHJldHVybiAhaW5zaWRlID8gaW5uZXJcbiAgICAgICAgICAgICAgICA6IG5ldyBUcmVlKHRyZWUudHlwZSwgdHJlZS5jaGlsZHJlbi5zbGljZSgwLCBpKS5jb25jYXQoaW5uZXIpLCB0cmVlLnBvc2l0aW9ucy5zbGljZSgwLCBpICsgMSksIHBvcyArIGlubmVyLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kU3RhcnRJbkZyYWdtZW50cyhsYW5nLCBmcmFnbWVudHMsIHN0YXJ0UG9zLCBlZGl0b3JTdGF0ZSkge1xuICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKSB7XG4gICAgICAgIGxldCBmcm9tID0gZi5mcm9tICsgKGYub3BlblN0YXJ0ID8gMjUgOiAwKSwgdG8gPSBmLnRvIC0gKGYub3BlbkVuZCA/IDI1IDogMCk7XG4gICAgICAgIGxldCBmb3VuZCA9IGZyb20gPD0gc3RhcnRQb3MgJiYgdG8gPiBzdGFydFBvcyAmJiBmaW5kU3RhdGUobGFuZywgZi50cmVlLCAwIC0gZi5vZmZzZXQsIHN0YXJ0UG9zLCB0byksIHRyZWU7XG4gICAgICAgIGlmIChmb3VuZCAmJiAodHJlZSA9IGN1dFRyZWUobGFuZywgZi50cmVlLCBzdGFydFBvcyArIGYub2Zmc2V0LCBmb3VuZC5wb3MgKyBmLm9mZnNldCwgZmFsc2UpKSlcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBmb3VuZC5zdGF0ZSwgdHJlZSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0ZTogbGFuZy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShlZGl0b3JTdGF0ZSA/IGdldEluZGVudFVuaXQoZWRpdG9yU3RhdGUpIDogNCksIHRyZWU6IFRyZWUuZW1wdHkgfTtcbn1cbmNsYXNzIFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihsYW5nLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5sYW5nID0gbGFuZztcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtSZXVzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMudG8gPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICBsZXQgY29udGV4dCA9IFBhcnNlQ29udGV4dC5nZXQoKSwgZnJvbSA9IHJhbmdlc1swXS5mcm9tO1xuICAgICAgICBsZXQgeyBzdGF0ZSwgdHJlZSB9ID0gZmluZFN0YXJ0SW5GcmFnbWVudHMobGFuZywgZnJhZ21lbnRzLCBmcm9tLCBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQuc3RhdGUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucGFyc2VkUG9zID0gdGhpcy5jaHVua1N0YXJ0ID0gZnJvbSArIHRyZWUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzLnB1c2godHJlZS5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godHJlZS5wb3NpdGlvbnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0ICYmIHRoaXMucGFyc2VkUG9zIDwgY29udGV4dC52aWV3cG9ydC5mcm9tIC0gMTAwMDAwIC8qIEMuTWF4RGlzdGFuY2VCZWZvcmVWaWV3cG9ydCAqLykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMubGFuZy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShnZXRJbmRlbnRVbml0KGNvbnRleHQuc3RhdGUpKTtcbiAgICAgICAgICAgIGNvbnRleHQuc2tpcFVudGlsSW5WaWV3KHRoaXMucGFyc2VkUG9zLCBjb250ZXh0LnZpZXdwb3J0LmZyb20pO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSBjb250ZXh0LnZpZXdwb3J0LmZyb207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZlUmFuZ2VJbmRleCgpO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBsZXQgY29udGV4dCA9IFBhcnNlQ29udGV4dC5nZXQoKTtcbiAgICAgICAgbGV0IHBhcnNlRW5kID0gdGhpcy5zdG9wcGVkQXQgPT0gbnVsbCA/IHRoaXMudG8gOiBNYXRoLm1pbih0aGlzLnRvLCB0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihwYXJzZUVuZCwgdGhpcy5jaHVua1N0YXJ0ICsgMjA0OCAvKiBDLkNodW5rU2l6ZSAqLyk7XG4gICAgICAgIGlmIChjb250ZXh0KVxuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCBjb250ZXh0LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgd2hpbGUgKHRoaXMucGFyc2VkUG9zIDwgZW5kKVxuICAgICAgICAgICAgdGhpcy5wYXJzZUxpbmUoY29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rU3RhcnQgPCB0aGlzLnBhcnNlZFBvcylcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsoKTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VkUG9zID49IHBhcnNlRW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGlmIChjb250ZXh0ICYmIHRoaXMucGFyc2VkUG9zID49IGNvbnRleHQudmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2tpcFVudGlsSW5WaWV3KHRoaXMucGFyc2VkUG9zLCBwYXJzZUVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICB9XG4gICAgbGluZUFmdGVyKHBvcykge1xuICAgICAgICBsZXQgY2h1bmsgPSB0aGlzLmlucHV0LmNodW5rKHBvcyk7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dC5saW5lQ2h1bmtzKSB7XG4gICAgICAgICAgICBsZXQgZW9sID0gY2h1bmsuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgICAgIGlmIChlb2wgPiAtMSlcbiAgICAgICAgICAgICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIGVvbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2h1bmsgPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgY2h1bmsgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3MgKyBjaHVuay5sZW5ndGggPD0gdGhpcy50byA/IGNodW5rIDogY2h1bmsuc2xpY2UoMCwgdGhpcy50byAtIHBvcyk7XG4gICAgfVxuICAgIG5leHRMaW5lKCkge1xuICAgICAgICBsZXQgZnJvbSA9IHRoaXMucGFyc2VkUG9zLCBsaW5lID0gdGhpcy5saW5lQWZ0ZXIoZnJvbSksIGVuZCA9IGZyb20gKyBsaW5lLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSB0aGlzLnJhbmdlSW5kZXg7Oykge1xuICAgICAgICAgICAgbGV0IHJhbmdlRW5kID0gdGhpcy5yYW5nZXNbaW5kZXhdLnRvO1xuICAgICAgICAgICAgaWYgKHJhbmdlRW5kID49IGVuZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIHJhbmdlRW5kIC0gKGVuZCAtIGxpbmUubGVuZ3RoKSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCByYW5nZVN0YXJ0ID0gdGhpcy5yYW5nZXNbaW5kZXhdLmZyb207XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmxpbmVBZnRlcihyYW5nZVN0YXJ0KTtcbiAgICAgICAgICAgIGxpbmUgKz0gYWZ0ZXI7XG4gICAgICAgICAgICBlbmQgPSByYW5nZVN0YXJ0ICsgYWZ0ZXIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmUsIGVuZCB9O1xuICAgIH1cbiAgICBza2lwR2Fwc1RvKHBvcywgb2Zmc2V0LCBzaWRlKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXhdLnRvLCBvZmZQb3MgPSBwb3MgKyBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoc2lkZSA+IDAgPyBlbmQgPiBvZmZQb3MgOiBlbmQgPj0gb2ZmUG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdLmZyb207XG4gICAgICAgICAgICBvZmZzZXQgKz0gc3RhcnQgLSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgbW92ZVJhbmdlSW5kZXgoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXhdLnRvIDwgdGhpcy5wYXJzZWRQb3MpXG4gICAgICAgICAgICB0aGlzLnJhbmdlSW5kZXgrKztcbiAgICB9XG4gICAgZW1pdFRva2VuKGlkLCBmcm9tLCB0bywgc2l6ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNraXBHYXBzVG8oZnJvbSwgb2Zmc2V0LCAxKTtcbiAgICAgICAgICAgIGZyb20gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IGxlbjAgPSB0aGlzLmNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2tpcEdhcHNUbyh0bywgb2Zmc2V0LCAtMSk7XG4gICAgICAgICAgICB0byArPSBvZmZzZXQ7XG4gICAgICAgICAgICBzaXplICs9IHRoaXMuY2h1bmsubGVuZ3RoIC0gbGVuMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNodW5rLnB1c2goaWQsIGZyb20sIHRvLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgcGFyc2VMaW5lKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHsgbGluZSwgZW5kIH0gPSB0aGlzLm5leHRMaW5lKCksIG9mZnNldCA9IDAsIHsgc3RyZWFtUGFyc2VyIH0gPSB0aGlzLmxhbmc7XG4gICAgICAgIGxldCBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKGxpbmUsIGNvbnRleHQgPyBjb250ZXh0LnN0YXRlLnRhYlNpemUgOiA0LCBjb250ZXh0ID8gZ2V0SW5kZW50VW5pdChjb250ZXh0LnN0YXRlKSA6IDIpO1xuICAgICAgICBpZiAoc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgICBzdHJlYW1QYXJzZXIuYmxhbmtMaW5lKHRoaXMuc3RhdGUsIHN0cmVhbS5pbmRlbnRVbml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuID0gcmVhZFRva2VuKHN0cmVhbVBhcnNlci50b2tlbiwgc3RyZWFtLCB0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuZW1pdFRva2VuKHRoaXMubGFuZy50b2tlblRhYmxlLnJlc29sdmUodG9rZW4pLCB0aGlzLnBhcnNlZFBvcyArIHN0cmVhbS5zdGFydCwgdGhpcy5wYXJzZWRQb3MgKyBzdHJlYW0ucG9zLCA0LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uc3RhcnQgPiAxMDAwMCAvKiBDLk1heExpbmVMZW5ndGggKi8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2VkUG9zID0gZW5kO1xuICAgICAgICB0aGlzLm1vdmVSYW5nZUluZGV4KCk7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlZFBvcyA8IHRoaXMudG8pXG4gICAgICAgICAgICB0aGlzLnBhcnNlZFBvcysrO1xuICAgIH1cbiAgICBmaW5pc2hDaHVuaygpIHtcbiAgICAgICAgbGV0IHRyZWUgPSBUcmVlLmJ1aWxkKHtcbiAgICAgICAgICAgIGJ1ZmZlcjogdGhpcy5jaHVuayxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmNodW5rU3RhcnQsXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMucGFyc2VkUG9zIC0gdGhpcy5jaHVua1N0YXJ0LFxuICAgICAgICAgICAgbm9kZVNldCxcbiAgICAgICAgICAgIHRvcElEOiAwLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiAyMDQ4IC8qIEMuQ2h1bmtTaXplICovLFxuICAgICAgICAgICAgcmV1c2VkOiB0aGlzLmNodW5rUmV1c2VkXG4gICAgICAgIH0pO1xuICAgICAgICB0cmVlID0gbmV3IFRyZWUodHJlZS50eXBlLCB0cmVlLmNoaWxkcmVuLCB0cmVlLnBvc2l0aW9ucywgdHJlZS5sZW5ndGgsIFtbdGhpcy5sYW5nLnN0YXRlQWZ0ZXIsIHRoaXMubGFuZy5zdHJlYW1QYXJzZXIuY29weVN0YXRlKHRoaXMuc3RhdGUpXV0pO1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHRyZWUpO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godGhpcy5jaHVua1N0YXJ0IC0gdGhpcy5yYW5nZXNbMF0uZnJvbSk7XG4gICAgICAgIHRoaXMuY2h1bmsgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1JldXNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gdGhpcy5wYXJzZWRQb3M7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHRoaXMubGFuZy50b3BOb2RlLCB0aGlzLmNodW5rcywgdGhpcy5jaHVua1BvcywgdGhpcy5wYXJzZWRQb3MgLSB0aGlzLnJhbmdlc1swXS5mcm9tKS5iYWxhbmNlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVhZFRva2VuKHRva2VuLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRva2VuKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBpZiAoc3RyZWFtLnBvcyA+IHN0cmVhbS5zdGFydClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBwYXJzZXIgZmFpbGVkIHRvIGFkdmFuY2Ugc3RyZWFtLlwiKTtcbn1cbmNvbnN0IG5vVG9rZW5zID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCB0eXBlQXJyYXkgPSBbTm9kZVR5cGUubm9uZV07XG5jb25zdCBub2RlU2V0ID0gLypAX19QVVJFX18qL25ldyBOb2RlU2V0KHR5cGVBcnJheSk7XG5jb25zdCB3YXJuZWQgPSBbXTtcbmNvbnN0IGRlZmF1bHRUYWJsZSA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuZm9yIChsZXQgW2xlZ2FjeU5hbWUsIG5hbWVdIG9mIFtcbiAgICBbXCJ2YXJpYWJsZVwiLCBcInZhcmlhYmxlTmFtZVwiXSxcbiAgICBbXCJ2YXJpYWJsZS0yXCIsIFwidmFyaWFibGVOYW1lLnNwZWNpYWxcIl0sXG4gICAgW1wic3RyaW5nLTJcIiwgXCJzdHJpbmcuc3BlY2lhbFwiXSxcbiAgICBbXCJkZWZcIiwgXCJ2YXJpYWJsZU5hbWUuZGVmaW5pdGlvblwiXSxcbiAgICBbXCJ0YWdcIiwgXCJ0YWdOYW1lXCJdLFxuICAgIFtcImF0dHJpYnV0ZVwiLCBcImF0dHJpYnV0ZU5hbWVcIl0sXG4gICAgW1widHlwZVwiLCBcInR5cGVOYW1lXCJdLFxuICAgIFtcImJ1aWx0aW5cIiwgXCJ2YXJpYWJsZU5hbWUuc3RhbmRhcmRcIl0sXG4gICAgW1wicXVhbGlmaWVyXCIsIFwibW9kaWZpZXJcIl0sXG4gICAgW1wiZXJyb3JcIiwgXCJpbnZhbGlkXCJdLFxuICAgIFtcImhlYWRlclwiLCBcImhlYWRpbmdcIl0sXG4gICAgW1wicHJvcGVydHlcIiwgXCJwcm9wZXJ0eU5hbWVcIl1cbl0pXG4gICAgZGVmYXVsdFRhYmxlW2xlZ2FjeU5hbWVdID0gLypAX19QVVJFX18qL2NyZWF0ZVRva2VuVHlwZShub1Rva2VucywgbmFtZSk7XG5jbGFzcyBUb2tlblRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihleHRyYSkge1xuICAgICAgICB0aGlzLmV4dHJhID0gZXh0cmE7XG4gICAgICAgIHRoaXMudGFibGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGRlZmF1bHRUYWJsZSk7XG4gICAgfVxuICAgIHJlc29sdmUodGFnKSB7XG4gICAgICAgIHJldHVybiAhdGFnID8gMCA6IHRoaXMudGFibGVbdGFnXSB8fCAodGhpcy50YWJsZVt0YWddID0gY3JlYXRlVG9rZW5UeXBlKHRoaXMuZXh0cmEsIHRhZykpO1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRUb2tlblRhYmxlID0gLypAX19QVVJFX18qL25ldyBUb2tlblRhYmxlKG5vVG9rZW5zKTtcbmZ1bmN0aW9uIHdhcm5Gb3JQYXJ0KHBhcnQsIG1zZykge1xuICAgIGlmICh3YXJuZWQuaW5kZXhPZihwYXJ0KSA+IC0xKVxuICAgICAgICByZXR1cm47XG4gICAgd2FybmVkLnB1c2gocGFydCk7XG4gICAgY29uc29sZS53YXJuKG1zZyk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlblR5cGUoZXh0cmEsIHRhZ1N0cikge1xuICAgIGxldCB0YWcgPSBudWxsO1xuICAgIGZvciAobGV0IHBhcnQgb2YgdGFnU3RyLnNwbGl0KFwiLlwiKSkge1xuICAgICAgICBsZXQgdmFsdWUgPSAoZXh0cmFbcGFydF0gfHwgdGFnc1twYXJ0XSk7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBVbmtub3duIGhpZ2hsaWdodGluZyB0YWcgJHtwYXJ0fWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghdGFnKVxuICAgICAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBNb2RpZmllciAke3BhcnR9IHVzZWQgYXQgc3RhcnQgb2YgdGFnYCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGFnID0gdmFsdWUodGFnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0YWcpXG4gICAgICAgICAgICAgICAgd2FybkZvclBhcnQocGFydCwgYFRhZyAke3BhcnR9IHVzZWQgYXMgbW9kaWZpZXJgKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0YWcgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRhZylcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgbGV0IG5hbWUgPSB0YWdTdHIucmVwbGFjZSgvIC9nLCBcIl9cIiksIHR5cGUgPSBOb2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICBpZDogdHlwZUFycmF5Lmxlbmd0aCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcHJvcHM6IFtzdHlsZVRhZ3MoeyBbbmFtZV06IHRhZyB9KV1cbiAgICB9KTtcbiAgICB0eXBlQXJyYXkucHVzaCh0eXBlKTtcbiAgICByZXR1cm4gdHlwZS5pZDtcbn1cbmZ1bmN0aW9uIGRvY0lEKGRhdGEpIHtcbiAgICBsZXQgdHlwZSA9IE5vZGVUeXBlLmRlZmluZSh7IGlkOiB0eXBlQXJyYXkubGVuZ3RoLCBuYW1lOiBcIkRvY3VtZW50XCIsIHByb3BzOiBbbGFuZ3VhZ2VEYXRhUHJvcC5hZGQoKCkgPT4gZGF0YSldIH0pO1xuICAgIHR5cGVBcnJheS5wdXNoKHR5cGUpO1xuICAgIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgeyBIaWdobGlnaHRTdHlsZSwgSW5kZW50Q29udGV4dCwgTFJMYW5ndWFnZSwgTGFuZ3VhZ2UsIExhbmd1YWdlRGVzY3JpcHRpb24sIExhbmd1YWdlU3VwcG9ydCwgUGFyc2VDb250ZXh0LCBTdHJlYW1MYW5ndWFnZSwgU3RyaW5nU3RyZWFtLCBUcmVlSW5kZW50Q29udGV4dCwgYnJhY2tldE1hdGNoaW5nLCBicmFja2V0TWF0Y2hpbmdIYW5kbGUsIGNvZGVGb2xkaW5nLCBjb250aW51ZWRJbmRlbnQsIGRlZmF1bHRIaWdobGlnaHRTdHlsZSwgZGVmaW5lTGFuZ3VhZ2VGYWNldCwgZGVsaW1pdGVkSW5kZW50LCBlbnN1cmVTeW50YXhUcmVlLCBmbGF0SW5kZW50LCBmb2xkQWxsLCBmb2xkQ29kZSwgZm9sZEVmZmVjdCwgZm9sZEd1dHRlciwgZm9sZEluc2lkZSwgZm9sZEtleW1hcCwgZm9sZE5vZGVQcm9wLCBmb2xkU2VydmljZSwgZm9sZFN0YXRlLCBmb2xkYWJsZSwgZm9sZGVkUmFuZ2VzLCBmb3JjZVBhcnNpbmcsIGdldEluZGVudFVuaXQsIGdldEluZGVudGF0aW9uLCBoaWdobGlnaHRpbmdGb3IsIGluZGVudE5vZGVQcm9wLCBpbmRlbnRPbklucHV0LCBpbmRlbnRSYW5nZSwgaW5kZW50U2VydmljZSwgaW5kZW50U3RyaW5nLCBpbmRlbnRVbml0LCBsYW5ndWFnZSwgbGFuZ3VhZ2VEYXRhUHJvcCwgbWF0Y2hCcmFja2V0cywgc3VibGFuZ3VhZ2VQcm9wLCBzeW50YXhIaWdobGlnaHRpbmcsIHN5bnRheFBhcnNlclJ1bm5pbmcsIHN5bnRheFRyZWUsIHN5bnRheFRyZWVBdmFpbGFibGUsIHRvZ2dsZUZvbGQsIHVuZm9sZEFsbCwgdW5mb2xkQ29kZSwgdW5mb2xkRWZmZWN0IH07XG4iLCAiaW1wb3J0IHsgQW5ub3RhdGlvbiwgRmFjZXQsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQsIEVkaXRvclNlbGVjdGlvbiwgVHJhbnNhY3Rpb24sIENoYW5nZVNldCwgQ2hhbmdlRGVzYywgU3RhdGVFZmZlY3QsIFRleHQsIGZpbmRDbHVzdGVyQnJlYWssIGNvdW50Q29sdW1uLCBDaGFyQ2F0ZWdvcnkgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3LCBEaXJlY3Rpb24gfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IEluZGVudENvbnRleHQsIGdldEluZGVudGF0aW9uLCBpbmRlbnRTdHJpbmcsIG1hdGNoQnJhY2tldHMsIHN5bnRheFRyZWUsIGdldEluZGVudFVuaXQsIGluZGVudFVuaXQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyBOb2RlUHJvcCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gV2lsbCB1c2UgbGluZSBjb21tZW50c1xuaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZmFsbGluZyBiYWNrIHRvIGJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IHRvZ2dsZUNvbW1lbnQgPSB0YXJnZXQgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB0YXJnZXQsIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpLCBjb25maWcgPSBnZXRDb25maWcodGFyZ2V0LnN0YXRlLCBsaW5lLmZyb20pO1xuICAgIHJldHVybiBjb25maWcubGluZSA/IHRvZ2dsZUxpbmVDb21tZW50KHRhcmdldCkgOiBjb25maWcuYmxvY2sgPyB0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUodGFyZ2V0KSA6IGZhbHNlO1xufTtcbmZ1bmN0aW9uIGNvbW1hbmQoZiwgb3B0aW9uKSB7XG4gICAgcmV0dXJuICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHRyID0gZihvcHRpb24sIHN0YXRlKTtcbiAgICAgICAgaWYgKCF0cilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHRyKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBsaW5lIGNvbW1lbnRzLlxuVGhlIGxpbmUgY29tbWVudCBzeW50YXggaXMgdGFrZW4gZnJvbSB0aGVcbltgY29tbWVudFRva2Vuc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuQ29tbWVudFRva2VucykgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KS5cbiovXG5jb25zdCB0b2dnbGVMaW5lQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAwIC8qIENvbW1lbnRPcHRpb24uVG9nZ2xlICovKTtcbi8qKlxuQ29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgbGluZSBjb21tZW50cy5cbiovXG5jb25zdCBsaW5lQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyk7XG4vKipcblVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgbGluZSBjb21tZW50cy5cbiovXG5jb25zdCBsaW5lVW5jb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlTGluZUNvbW1lbnQsIDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8pO1xuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXG5UaGUgYmxvY2sgY29tbWVudCBzeW50YXggaXMgdGFrZW4gZnJvbSB0aGVcbltgY29tbWVudFRva2Vuc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuQ29tbWVudFRva2VucykgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KS5cbiovXG5jb25zdCB0b2dnbGVCbG9ja0NvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDAgLyogQ29tbWVudE9wdGlvbi5Ub2dnbGUgKi8pO1xuLyoqXG5Db21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBibG9jayBjb21tZW50cy5cbiovXG5jb25zdCBibG9ja0NvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovKTtcbi8qKlxuVW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBibG9jayBjb21tZW50cy5cbiovXG5jb25zdCBibG9ja1VuY29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUJsb2NrQ29tbWVudCwgMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyk7XG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBsaW5lcyBhcm91bmQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nXG5ibG9jayBjb21tZW50cy5cbiovXG5jb25zdCB0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUgPSAvKkBfX1BVUkVfXyovY29tbWFuZCgobywgcykgPT4gY2hhbmdlQmxvY2tDb21tZW50KG8sIHMsIHNlbGVjdGVkTGluZVJhbmdlcyhzKSksIDAgLyogQ29tbWVudE9wdGlvbi5Ub2dnbGUgKi8pO1xuZnVuY3Rpb24gZ2V0Q29uZmlnKHN0YXRlLCBwb3MpIHtcbiAgICBsZXQgZGF0YSA9IHN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiY29tbWVudFRva2Vuc1wiLCBwb3MpO1xuICAgIHJldHVybiBkYXRhLmxlbmd0aCA/IGRhdGFbMF0gOiB7fTtcbn1cbmNvbnN0IFNlYXJjaE1hcmdpbiA9IDUwO1xuLyoqXG5EZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiByYW5nZSBpcyBibG9jay1jb21tZW50ZWQgaW4gdGhlIGdpdmVuXG5zdGF0ZS5cbiovXG5mdW5jdGlvbiBmaW5kQmxvY2tDb21tZW50KHN0YXRlLCB7IG9wZW4sIGNsb3NlIH0sIGZyb20sIHRvKSB7XG4gICAgbGV0IHRleHRCZWZvcmUgPSBzdGF0ZS5zbGljZURvYyhmcm9tIC0gU2VhcmNoTWFyZ2luLCBmcm9tKTtcbiAgICBsZXQgdGV4dEFmdGVyID0gc3RhdGUuc2xpY2VEb2ModG8sIHRvICsgU2VhcmNoTWFyZ2luKTtcbiAgICBsZXQgc3BhY2VCZWZvcmUgPSAvXFxzKiQvLmV4ZWModGV4dEJlZm9yZSlbMF0ubGVuZ3RoLCBzcGFjZUFmdGVyID0gL15cXHMqLy5leGVjKHRleHRBZnRlcilbMF0ubGVuZ3RoO1xuICAgIGxldCBiZWZvcmVPZmYgPSB0ZXh0QmVmb3JlLmxlbmd0aCAtIHNwYWNlQmVmb3JlO1xuICAgIGlmICh0ZXh0QmVmb3JlLnNsaWNlKGJlZm9yZU9mZiAtIG9wZW4ubGVuZ3RoLCBiZWZvcmVPZmYpID09IG9wZW4gJiZcbiAgICAgICAgdGV4dEFmdGVyLnNsaWNlKHNwYWNlQWZ0ZXIsIHNwYWNlQWZ0ZXIgKyBjbG9zZS5sZW5ndGgpID09IGNsb3NlKSB7XG4gICAgICAgIHJldHVybiB7IG9wZW46IHsgcG9zOiBmcm9tIC0gc3BhY2VCZWZvcmUsIG1hcmdpbjogc3BhY2VCZWZvcmUgJiYgMSB9LFxuICAgICAgICAgICAgY2xvc2U6IHsgcG9zOiB0byArIHNwYWNlQWZ0ZXIsIG1hcmdpbjogc3BhY2VBZnRlciAmJiAxIH0gfTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0VGV4dCwgZW5kVGV4dDtcbiAgICBpZiAodG8gLSBmcm9tIDw9IDIgKiBTZWFyY2hNYXJnaW4pIHtcbiAgICAgICAgc3RhcnRUZXh0ID0gZW5kVGV4dCA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0YXJ0VGV4dCA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIGZyb20gKyBTZWFyY2hNYXJnaW4pO1xuICAgICAgICBlbmRUZXh0ID0gc3RhdGUuc2xpY2VEb2ModG8gLSBTZWFyY2hNYXJnaW4sIHRvKTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0U3BhY2UgPSAvXlxccyovLmV4ZWMoc3RhcnRUZXh0KVswXS5sZW5ndGgsIGVuZFNwYWNlID0gL1xccyokLy5leGVjKGVuZFRleHQpWzBdLmxlbmd0aDtcbiAgICBsZXQgZW5kT2ZmID0gZW5kVGV4dC5sZW5ndGggLSBlbmRTcGFjZSAtIGNsb3NlLmxlbmd0aDtcbiAgICBpZiAoc3RhcnRUZXh0LnNsaWNlKHN0YXJ0U3BhY2UsIHN0YXJ0U3BhY2UgKyBvcGVuLmxlbmd0aCkgPT0gb3BlbiAmJlxuICAgICAgICBlbmRUZXh0LnNsaWNlKGVuZE9mZiwgZW5kT2ZmICsgY2xvc2UubGVuZ3RoKSA9PSBjbG9zZSkge1xuICAgICAgICByZXR1cm4geyBvcGVuOiB7IHBvczogZnJvbSArIHN0YXJ0U3BhY2UgKyBvcGVuLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtYXJnaW46IC9cXHMvLnRlc3Qoc3RhcnRUZXh0LmNoYXJBdChzdGFydFNwYWNlICsgb3Blbi5sZW5ndGgpKSA/IDEgOiAwIH0sXG4gICAgICAgICAgICBjbG9zZTogeyBwb3M6IHRvIC0gZW5kU3BhY2UgLSBjbG9zZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAvXFxzLy50ZXN0KGVuZFRleHQuY2hhckF0KGVuZE9mZiAtIDEpKSA/IDEgOiAwIH0gfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzZWxlY3RlZExpbmVSYW5nZXMoc3RhdGUpIHtcbiAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgciBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tTGluZSA9IHN0YXRlLmRvYy5saW5lQXQoci5mcm9tKTtcbiAgICAgICAgbGV0IHRvTGluZSA9IHIudG8gPD0gZnJvbUxpbmUudG8gPyBmcm9tTGluZSA6IHN0YXRlLmRvYy5saW5lQXQoci50byk7XG4gICAgICAgIGxldCBsYXN0ID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0ID49IDAgJiYgcmFuZ2VzW2xhc3RdLnRvID4gZnJvbUxpbmUuZnJvbSlcbiAgICAgICAgICAgIHJhbmdlc1tsYXN0XS50byA9IHRvTGluZS50bztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBmcm9tTGluZS5mcm9tLCB0bzogdG9MaW5lLnRvIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuLy8gUGVyZm9ybXMgdG9nZ2xlLCBjb21tZW50IGFuZCB1bmNvbW1lbnQgb2YgYmxvY2sgY29tbWVudHMgaW5cbi8vIGxhbmd1YWdlcyB0aGF0IHN1cHBvcnQgdGhlbS5cbmZ1bmN0aW9uIGNoYW5nZUJsb2NrQ29tbWVudChvcHRpb24sIHN0YXRlLCByYW5nZXMgPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgbGV0IHRva2VucyA9IHJhbmdlcy5tYXAociA9PiBnZXRDb25maWcoc3RhdGUsIHIuZnJvbSkuYmxvY2spO1xuICAgIGlmICghdG9rZW5zLmV2ZXJ5KGMgPT4gYykpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBjb21tZW50cyA9IHJhbmdlcy5tYXAoKHIsIGkpID0+IGZpbmRCbG9ja0NvbW1lbnQoc3RhdGUsIHRva2Vuc1tpXSwgci5mcm9tLCByLnRvKSk7XG4gICAgaWYgKG9wdGlvbiAhPSAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovICYmICFjb21tZW50cy5ldmVyeShjID0+IGMpKSB7XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHN0YXRlLmNoYW5nZXMocmFuZ2VzLm1hcCgocmFuZ2UsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudHNbaV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3sgZnJvbTogcmFuZ2UuZnJvbSwgaW5zZXJ0OiB0b2tlbnNbaV0ub3BlbiArIFwiIFwiIH0sIHsgZnJvbTogcmFuZ2UudG8sIGluc2VydDogXCIgXCIgKyB0b2tlbnNbaV0uY2xvc2UgfV07XG4gICAgICAgICAgICB9KSkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9uICE9IDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovICYmIGNvbW1lbnRzLnNvbWUoYyA9PiBjKSkge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgY29tbWVudDsgaSA8IGNvbW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNvbW1lbnQgPSBjb21tZW50c1tpXSkge1xuICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHRva2Vuc1tpXSwgeyBvcGVuLCBjbG9zZSB9ID0gY29tbWVudDtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBvcGVuLnBvcyAtIHRva2VuLm9wZW4ubGVuZ3RoLCB0bzogb3Blbi5wb3MgKyBvcGVuLm1hcmdpbiB9LCB7IGZyb206IGNsb3NlLnBvcyAtIGNsb3NlLm1hcmdpbiwgdG86IGNsb3NlLnBvcyArIHRva2VuLmNsb3NlLmxlbmd0aCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlcyB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIFBlcmZvcm1zIHRvZ2dsZSwgY29tbWVudCBhbmQgdW5jb21tZW50IG9mIGxpbmUgY29tbWVudHMuXG5mdW5jdGlvbiBjaGFuZ2VMaW5lQ29tbWVudChvcHRpb24sIHN0YXRlLCByYW5nZXMgPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGV0IHByZXZMaW5lID0gLTE7XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHJhbmdlcykge1xuICAgICAgICBsZXQgc3RhcnRJID0gbGluZXMubGVuZ3RoLCBtaW5JbmRlbnQgPSAxZTk7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IGZyb207IHBvcyA8PSB0bzspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA+IHByZXZMaW5lICYmIChmcm9tID09IHRvIHx8IHRvID4gbGluZS5mcm9tKSkge1xuICAgICAgICAgICAgICAgIHByZXZMaW5lID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IGdldENvbmZpZyhzdGF0ZSwgbGluZS5mcm9tKS5saW5lO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGVtcHR5ID0gaW5kZW50ID09IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBjb21tZW50ID0gbGluZS50ZXh0LnNsaWNlKGluZGVudCwgaW5kZW50ICsgdG9rZW4ubGVuZ3RoKSA9PSB0b2tlbiA/IGluZGVudCA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChpbmRlbnQgPCBsaW5lLnRleHQubGVuZ3RoICYmIGluZGVudCA8IG1pbkluZGVudClcbiAgICAgICAgICAgICAgICAgICAgbWluSW5kZW50ID0gaW5kZW50O1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goeyBsaW5lLCBjb21tZW50LCB0b2tlbiwgaW5kZW50LCBlbXB0eSwgc2luZ2xlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW5JbmRlbnQgPCAxZTkpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzW2ldLmluZGVudCA8IGxpbmVzW2ldLmxpbmUudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzW2ldLmluZGVudCA9IG1pbkluZGVudDtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PSBzdGFydEkgKyAxKVxuICAgICAgICAgICAgbGluZXNbc3RhcnRJXS5zaW5nbGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0aW9uICE9IDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8gJiYgbGluZXMuc29tZShsID0+IGwuY29tbWVudCA8IDAgJiYgKCFsLmVtcHR5IHx8IGwuc2luZ2xlKSkpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeyBsaW5lLCB0b2tlbiwgaW5kZW50LCBlbXB0eSwgc2luZ2xlIH0gb2YgbGluZXMpXG4gICAgICAgICAgICBpZiAoc2luZ2xlIHx8ICFlbXB0eSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20gKyBpbmRlbnQsIGluc2VydDogdG9rZW4gKyBcIiBcIiB9KTtcbiAgICAgICAgbGV0IGNoYW5nZVNldCA9IHN0YXRlLmNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IGNoYW5nZVNldCwgc2VsZWN0aW9uOiBzdGF0ZS5zZWxlY3Rpb24ubWFwKGNoYW5nZVNldCwgMSkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9uICE9IDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovICYmIGxpbmVzLnNvbWUobCA9PiBsLmNvbW1lbnQgPj0gMCkpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeyBsaW5lLCBjb21tZW50LCB0b2tlbiB9IG9mIGxpbmVzKVxuICAgICAgICAgICAgaWYgKGNvbW1lbnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gbGluZS5mcm9tICsgY29tbWVudCwgdG8gPSBmcm9tICsgdG9rZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLnRleHRbdG8gLSBsaW5lLmZyb21dID09IFwiIFwiKVxuICAgICAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBmcm9tSGlzdG9yeSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5UcmFuc2FjdGlvbiBhbm5vdGF0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IHRoYXQgdHJhbnNhY3Rpb24gZnJvbVxuYmVpbmcgY29tYmluZWQgd2l0aCBvdGhlciB0cmFuc2FjdGlvbnMgaW4gdGhlIHVuZG8gaGlzdG9yeS4gR2l2ZW5cbmBcImJlZm9yZVwiYCwgaXQnbGwgcHJldmVudCBtZXJnaW5nIHdpdGggcHJldmlvdXMgdHJhbnNhY3Rpb25zLiBXaXRoXG5gXCJhZnRlclwiYCwgc3Vic2VxdWVudCB0cmFuc2FjdGlvbnMgd29uJ3QgYmUgY29tYmluZWQgd2l0aCB0aGlzXG5vbmUuIFdpdGggYFwiZnVsbFwiYCwgdGhlIHRyYW5zYWN0aW9uIGlzIGlzb2xhdGVkIG9uIGJvdGggc2lkZXMuXG4qL1xuY29uc3QgaXNvbGF0ZUhpc3RvcnkgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuVGhpcyBmYWNldCBwcm92aWRlcyBhIHdheSB0byByZWdpc3RlciBmdW5jdGlvbnMgdGhhdCwgZ2l2ZW4gYVxudHJhbnNhY3Rpb24sIHByb3ZpZGUgYSBzZXQgb2YgZWZmZWN0cyB0aGF0IHRoZSBoaXN0b3J5IHNob3VsZFxuc3RvcmUgd2hlbiBpbnZlcnRpbmcgdGhlIHRyYW5zYWN0aW9uLiBUaGlzIGNhbiBiZSB1c2VkIHRvXG5pbnRlZ3JhdGUgc29tZSBraW5kcyBvZiBlZmZlY3RzIGluIHRoZSBoaXN0b3J5LCBzbyB0aGF0IHRoZXkgY2FuXG5iZSB1bmRvbmUgKGFuZCByZWRvbmUgYWdhaW4pLlxuKi9cbmNvbnN0IGludmVydGVkRWZmZWN0cyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGhpc3RvcnlDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgbWluRGVwdGg6IDEwMCxcbiAgICAgICAgICAgIG5ld0dyb3VwRGVsYXk6IDUwMCxcbiAgICAgICAgICAgIGpvaW5Ub0V2ZW50OiAoX3QsIGlzQWRqYWNlbnQpID0+IGlzQWRqYWNlbnQsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1pbkRlcHRoOiBNYXRoLm1heCxcbiAgICAgICAgICAgIG5ld0dyb3VwRGVsYXk6IE1hdGgubWluLFxuICAgICAgICAgICAgam9pblRvRXZlbnQ6IChhLCBiKSA9PiAodHIsIGFkaikgPT4gYSh0ciwgYWRqKSB8fCBiKHRyLCBhZGopXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gY2hhbmdlRW5kKGNoYW5nZXMpIHtcbiAgICBsZXQgZW5kID0gMDtcbiAgICBjaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChfLCB0bykgPT4gZW5kID0gdG8pO1xuICAgIHJldHVybiBlbmQ7XG59XG5jb25zdCBoaXN0b3J5RmllbGRfID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBIaXN0b3J5U3RhdGUuZW1wdHk7XG4gICAgfSxcbiAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB0ci5zdGF0ZS5mYWNldChoaXN0b3J5Q29uZmlnKTtcbiAgICAgICAgbGV0IGZyb21IaXN0ID0gdHIuYW5ub3RhdGlvbihmcm9tSGlzdG9yeSk7XG4gICAgICAgIGlmIChmcm9tSGlzdCkge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHRyLmRvY0NoYW5nZWQgPyBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGNoYW5nZUVuZCh0ci5jaGFuZ2VzKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IEhpc3RFdmVudC5mcm9tVHJhbnNhY3Rpb24odHIsIHNlbGVjdGlvbiksIGZyb20gPSBmcm9tSGlzdC5zaWRlO1xuICAgICAgICAgICAgbGV0IG90aGVyID0gZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IHN0YXRlLnVuZG9uZSA6IHN0YXRlLmRvbmU7XG4gICAgICAgICAgICBpZiAoaXRlbSlcbiAgICAgICAgICAgICAgICBvdGhlciA9IHVwZGF0ZUJyYW5jaChvdGhlciwgb3RoZXIubGVuZ3RoLCBjb25maWcubWluRGVwdGgsIGl0ZW0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG90aGVyID0gYWRkU2VsZWN0aW9uKG90aGVyLCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShmcm9tID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gZnJvbUhpc3QucmVzdCA6IG90aGVyLCBmcm9tID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gb3RoZXIgOiBmcm9tSGlzdC5yZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNvbGF0ZSA9IHRyLmFubm90YXRpb24oaXNvbGF0ZUhpc3RvcnkpO1xuICAgICAgICBpZiAoaXNvbGF0ZSA9PSBcImZ1bGxcIiB8fCBpc29sYXRlID09IFwiYmVmb3JlXCIpXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmlzb2xhdGUoKTtcbiAgICAgICAgaWYgKHRyLmFubm90YXRpb24oVHJhbnNhY3Rpb24uYWRkVG9IaXN0b3J5KSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gIXRyLmNoYW5nZXMuZW1wdHkgPyBzdGF0ZS5hZGRNYXBwaW5nKHRyLmNoYW5nZXMuZGVzYykgOiBzdGF0ZTtcbiAgICAgICAgbGV0IGV2ZW50ID0gSGlzdEV2ZW50LmZyb21UcmFuc2FjdGlvbih0cik7XG4gICAgICAgIGxldCB0aW1lID0gdHIuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi50aW1lKSwgdXNlckV2ZW50ID0gdHIuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi51c2VyRXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQpXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmFkZENoYW5nZXMoZXZlbnQsIHRpbWUsIHVzZXJFdmVudCwgY29uZmlnLCB0cik7XG4gICAgICAgIGVsc2UgaWYgKHRyLnNlbGVjdGlvbilcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuYWRkU2VsZWN0aW9uKHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLCB0aW1lLCB1c2VyRXZlbnQsIGNvbmZpZy5uZXdHcm91cERlbGF5KTtcbiAgICAgICAgaWYgKGlzb2xhdGUgPT0gXCJmdWxsXCIgfHwgaXNvbGF0ZSA9PSBcImFmdGVyXCIpXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmlzb2xhdGUoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgdG9KU09OKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHZhbHVlLmRvbmUubWFwKGUgPT4gZS50b0pTT04oKSksIHVuZG9uZTogdmFsdWUudW5kb25lLm1hcChlID0+IGUudG9KU09OKCkpIH07XG4gICAgfSxcbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGpzb24uZG9uZS5tYXAoSGlzdEV2ZW50LmZyb21KU09OKSwganNvbi51bmRvbmUubWFwKEhpc3RFdmVudC5mcm9tSlNPTikpO1xuICAgIH1cbn0pO1xuLyoqXG5DcmVhdGUgYSBoaXN0b3J5IGV4dGVuc2lvbiB3aXRoIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uLlxuKi9cbmZ1bmN0aW9uIGhpc3RvcnkoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBoaXN0b3J5RmllbGRfLFxuICAgICAgICBoaXN0b3J5Q29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIEVkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAgICAgICAgICBiZWZvcmVpbnB1dChlLCB2aWV3KSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbW1hbmQgPSBlLmlucHV0VHlwZSA9PSBcImhpc3RvcnlVbmRvXCIgPyB1bmRvIDogZS5pbnB1dFR5cGUgPT0gXCJoaXN0b3J5UmVkb1wiID8gcmVkbyA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21tYW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kKHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIF07XG59XG4vKipcblRoZSBzdGF0ZSBmaWVsZCB1c2VkIHRvIHN0b3JlIHRoZSBoaXN0b3J5IGRhdGEuIFNob3VsZCBwcm9iYWJseVxub25seSBiZSB1c2VkIHdoZW4geW91IHdhbnQgdG9cbltzZXJpYWxpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudG9KU09OKSBvclxuW2Rlc2VyaWFsaXplXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmZyb21KU09OKSBzdGF0ZSBvYmplY3RzIGluIGEgd2F5XG50aGF0IHByZXNlcnZlcyBoaXN0b3J5LlxuKi9cbmNvbnN0IGhpc3RvcnlGaWVsZCA9IGhpc3RvcnlGaWVsZF87XG5mdW5jdGlvbiBjbWQoc2lkZSwgc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh7IHN0YXRlLCBkaXNwYXRjaCB9KSB7XG4gICAgICAgIGlmICghc2VsZWN0aW9uICYmIHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgaGlzdG9yeVN0YXRlID0gc3RhdGUuZmllbGQoaGlzdG9yeUZpZWxkXywgZmFsc2UpO1xuICAgICAgICBpZiAoIWhpc3RvcnlTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHRyID0gaGlzdG9yeVN0YXRlLnBvcChzaWRlLCBzdGF0ZSwgc2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKCF0cilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5VbmRvIGEgc2luZ2xlIGdyb3VwIG9mIGhpc3RvcnkgZXZlbnRzLiBSZXR1cm5zIGZhbHNlIGlmIG5vIGdyb3VwXG53YXMgYXZhaWxhYmxlLlxuKi9cbmNvbnN0IHVuZG8gPSAvKkBfX1BVUkVfXyovY21kKDAgLyogQnJhbmNoTmFtZS5Eb25lICovLCBmYWxzZSk7XG4vKipcblJlZG8gYSBncm91cCBvZiBoaXN0b3J5IGV2ZW50cy4gUmV0dXJucyBmYWxzZSBpZiBubyBncm91cCB3YXNcbmF2YWlsYWJsZS5cbiovXG5jb25zdCByZWRvID0gLypAX19QVVJFX18qL2NtZCgxIC8qIEJyYW5jaE5hbWUuVW5kb25lICovLCBmYWxzZSk7XG4vKipcblVuZG8gYSBjaGFuZ2Ugb3Igc2VsZWN0aW9uIGNoYW5nZS5cbiovXG5jb25zdCB1bmRvU2VsZWN0aW9uID0gLypAX19QVVJFX18qL2NtZCgwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLywgdHJ1ZSk7XG4vKipcblJlZG8gYSBjaGFuZ2Ugb3Igc2VsZWN0aW9uIGNoYW5nZS5cbiovXG5jb25zdCByZWRvU2VsZWN0aW9uID0gLypAX19QVVJFX18qL2NtZCgxIC8qIEJyYW5jaE5hbWUuVW5kb25lICovLCB0cnVlKTtcbmZ1bmN0aW9uIGRlcHRoKHNpZGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGxldCBoaXN0U3RhdGUgPSBzdGF0ZS5maWVsZChoaXN0b3J5RmllbGRfLCBmYWxzZSk7XG4gICAgICAgIGlmICghaGlzdFN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBicmFuY2ggPSBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gaGlzdFN0YXRlLmRvbmUgOiBoaXN0U3RhdGUudW5kb25lO1xuICAgICAgICByZXR1cm4gYnJhbmNoLmxlbmd0aCAtIChicmFuY2gubGVuZ3RoICYmICFicmFuY2hbMF0uY2hhbmdlcyA/IDEgOiAwKTtcbiAgICB9O1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHVuZG9hYmxlIGNoYW5nZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gc3RhdGUuXG4qL1xuY29uc3QgdW5kb0RlcHRoID0gLypAX19QVVJFX18qL2RlcHRoKDAgLyogQnJhbmNoTmFtZS5Eb25lICovKTtcbi8qKlxuVGhlIGFtb3VudCBvZiByZWRvYWJsZSBjaGFuZ2UgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHN0YXRlLlxuKi9cbmNvbnN0IHJlZG9EZXB0aCA9IC8qQF9fUFVSRV9fKi9kZXB0aCgxIC8qIEJyYW5jaE5hbWUuVW5kb25lICovKTtcbi8vIEhpc3RvcnkgZXZlbnRzIHN0b3JlIGdyb3VwcyBvZiBjaGFuZ2VzIG9yIGVmZmVjdHMgdGhhdCBuZWVkIHRvIGJlXG4vLyB1bmRvbmUvcmVkb25lIHRvZ2V0aGVyLlxuY2xhc3MgSGlzdEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgY2hhbmdlcyBpbiB0aGlzIGV2ZW50LiBOb3JtYWwgZXZlbnRzIGhvbGQgYXQgbGVhc3Qgb25lXG4gICAgLy8gY2hhbmdlIG9yIGVmZmVjdC4gQnV0IGl0IG1heSBiZSBuZWNlc3NhcnkgdG8gc3RvcmUgc2VsZWN0aW9uXG4gICAgLy8gZXZlbnRzIGJlZm9yZSB0aGUgZmlyc3QgY2hhbmdlLCBpbiB3aGljaCBjYXNlIGEgc3BlY2lhbCB0eXBlIG9mXG4gICAgLy8gaW5zdGFuY2UgaXMgY3JlYXRlZCB3aGljaCBkb2Vzbid0IGhvbGQgYW55IGNoYW5nZXMsIHdpdGhcbiAgICAvLyBjaGFuZ2VzID09IHN0YXJ0U2VsZWN0aW9uID09IHVuZGVmaW5lZFxuICAgIGNoYW5nZXMsIFxuICAgIC8vIFRoZSBlZmZlY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGV2ZW50XG4gICAgZWZmZWN0cywgXG4gICAgLy8gQWNjdW11bGF0ZWQgbWFwcGluZyAoZnJvbSBhZGRUb0hpc3Rvcnk9PWZhbHNlKSB0aGF0IHNob3VsZCBiZVxuICAgIC8vIGFwcGxpZWQgdG8gZXZlbnRzIGJlbG93IHRoaXMgb25lLlxuICAgIG1hcHBlZCwgXG4gICAgLy8gVGhlIHNlbGVjdGlvbiBiZWZvcmUgdGhpcyBldmVudFxuICAgIHN0YXJ0U2VsZWN0aW9uLCBcbiAgICAvLyBTdG9yZXMgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIgdGhpcyBldmVudCwgdG8gYmUgdXNlZCBmb3JcbiAgICAvLyBzZWxlY3Rpb24gdW5kby9yZWRvLlxuICAgIHNlbGVjdGlvbnNBZnRlcikge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xuICAgICAgICB0aGlzLm1hcHBlZCA9IG1hcHBlZDtcbiAgICAgICAgdGhpcy5zdGFydFNlbGVjdGlvbiA9IHN0YXJ0U2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbnNBZnRlciA9IHNlbGVjdGlvbnNBZnRlcjtcbiAgICB9XG4gICAgc2V0U2VsQWZ0ZXIoYWZ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQodGhpcy5jaGFuZ2VzLCB0aGlzLmVmZmVjdHMsIHRoaXMubWFwcGVkLCB0aGlzLnN0YXJ0U2VsZWN0aW9uLCBhZnRlcik7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VzOiAoX2EgPSB0aGlzLmNoYW5nZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0pTT04oKSxcbiAgICAgICAgICAgIG1hcHBlZDogKF9iID0gdGhpcy5tYXBwZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b0pTT04oKSxcbiAgICAgICAgICAgIHN0YXJ0U2VsZWN0aW9uOiAoX2MgPSB0aGlzLnN0YXJ0U2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9KU09OKCksXG4gICAgICAgICAgICBzZWxlY3Rpb25zQWZ0ZXI6IHRoaXMuc2VsZWN0aW9uc0FmdGVyLm1hcChzID0+IHMudG9KU09OKCkpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KGpzb24uY2hhbmdlcyAmJiBDaGFuZ2VTZXQuZnJvbUpTT04oanNvbi5jaGFuZ2VzKSwgW10sIGpzb24ubWFwcGVkICYmIENoYW5nZURlc2MuZnJvbUpTT04oanNvbi5tYXBwZWQpLCBqc29uLnN0YXJ0U2VsZWN0aW9uICYmIEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTihqc29uLnN0YXJ0U2VsZWN0aW9uKSwganNvbi5zZWxlY3Rpb25zQWZ0ZXIubWFwKEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTikpO1xuICAgIH1cbiAgICAvLyBUaGlzIGRvZXMgbm90IGNoZWNrIGBhZGRUb0hpc3RvcnlgIGFuZCBzdWNoLCBpdCBhc3N1bWVzIHRoZVxuICAgIC8vIHRyYW5zYWN0aW9uIG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhbiBpdGVtLiBSZXR1cm5zIG51bGwgd2hlblxuICAgIC8vIHRoZXJlIGFyZSBubyBjaGFuZ2VzIG9yIGVmZmVjdHMgaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgIHN0YXRpYyBmcm9tVHJhbnNhY3Rpb24odHIsIHNlbGVjdGlvbikge1xuICAgICAgICBsZXQgZWZmZWN0cyA9IG5vbmU7XG4gICAgICAgIGZvciAobGV0IGludmVydCBvZiB0ci5zdGFydFN0YXRlLmZhY2V0KGludmVydGVkRWZmZWN0cykpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBpbnZlcnQodHIpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZWZmZWN0cyA9IGVmZmVjdHMuY29uY2F0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlZmZlY3RzLmxlbmd0aCAmJiB0ci5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHRyLmNoYW5nZXMuaW52ZXJ0KHRyLnN0YXJ0U3RhdGUuZG9jKSwgZWZmZWN0cywgdW5kZWZpbmVkLCBzZWxlY3Rpb24gfHwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24sIG5vbmUpO1xuICAgIH1cbiAgICBzdGF0aWMgc2VsZWN0aW9uKHNlbGVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQodW5kZWZpbmVkLCBub25lLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgc2VsZWN0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQnJhbmNoKGJyYW5jaCwgdG8sIG1heExlbiwgbmV3RXZlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSB0byArIDEgPiBtYXhMZW4gKyAyMCA/IHRvIC0gbWF4TGVuIC0gMSA6IDA7XG4gICAgbGV0IG5ld0JyYW5jaCA9IGJyYW5jaC5zbGljZShzdGFydCwgdG8pO1xuICAgIG5ld0JyYW5jaC5wdXNoKG5ld0V2ZW50KTtcbiAgICByZXR1cm4gbmV3QnJhbmNoO1xufVxuZnVuY3Rpb24gaXNBZGphY2VudChhLCBiKSB7XG4gICAgbGV0IHJhbmdlcyA9IFtdLCBpc0FkamFjZW50ID0gZmFsc2U7XG4gICAgYS5pdGVyQ2hhbmdlZFJhbmdlcygoZiwgdCkgPT4gcmFuZ2VzLnB1c2goZiwgdCkpO1xuICAgIGIuaXRlckNoYW5nZWRSYW5nZXMoKF9mLCBfdCwgZiwgdCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1tpKytdLCB0byA9IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgaWYgKHQgPj0gZnJvbSAmJiBmIDw9IHRvKVxuICAgICAgICAgICAgICAgIGlzQWRqYWNlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzQWRqYWNlbnQ7XG59XG5mdW5jdGlvbiBlcVNlbGVjdGlvblNoYXBlKGEsIGIpIHtcbiAgICByZXR1cm4gYS5yYW5nZXMubGVuZ3RoID09IGIucmFuZ2VzLmxlbmd0aCAmJlxuICAgICAgICBhLnJhbmdlcy5maWx0ZXIoKHIsIGkpID0+IHIuZW1wdHkgIT0gYi5yYW5nZXNbaV0uZW1wdHkpLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIGNvbmMoYSwgYikge1xuICAgIHJldHVybiAhYS5sZW5ndGggPyBiIDogIWIubGVuZ3RoID8gYSA6IGEuY29uY2F0KGIpO1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuY29uc3QgTWF4U2VsZWN0aW9uc1BlckV2ZW50ID0gMjAwO1xuZnVuY3Rpb24gYWRkU2VsZWN0aW9uKGJyYW5jaCwgc2VsZWN0aW9uKSB7XG4gICAgaWYgKCFicmFuY2gubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbSGlzdEV2ZW50LnNlbGVjdGlvbihbc2VsZWN0aW9uXSldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGxhc3RFdmVudCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBzZWxzID0gbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5zbGljZShNYXRoLm1heCgwLCBsYXN0RXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIE1heFNlbGVjdGlvbnNQZXJFdmVudCkpO1xuICAgICAgICBpZiAoc2Vscy5sZW5ndGggJiYgc2Vsc1tzZWxzLmxlbmd0aCAtIDFdLmVxKHNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgICAgICBzZWxzLnB1c2goc2VsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUJyYW5jaChicmFuY2gsIGJyYW5jaC5sZW5ndGggLSAxLCAxZTksIGxhc3RFdmVudC5zZXRTZWxBZnRlcihzZWxzKSk7XG4gICAgfVxufVxuLy8gQXNzdW1lcyB0aGUgdG9wIGl0ZW0gaGFzIG9uZSBvciBtb3JlIHNlbGVjdGlvbkFmdGVyIHZhbHVlc1xuZnVuY3Rpb24gcG9wU2VsZWN0aW9uKGJyYW5jaCkge1xuICAgIGxldCBsYXN0ID0gYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXTtcbiAgICBsZXQgbmV3QnJhbmNoID0gYnJhbmNoLnNsaWNlKCk7XG4gICAgbmV3QnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXSA9IGxhc3Quc2V0U2VsQWZ0ZXIobGFzdC5zZWxlY3Rpb25zQWZ0ZXIuc2xpY2UoMCwgbGFzdC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBuZXdCcmFuY2g7XG59XG4vLyBBZGQgYSBtYXBwaW5nIHRvIHRoZSB0b3AgZXZlbnQgaW4gdGhlIGdpdmVuIGJyYW5jaC4gSWYgdGhpcyBtYXBzXG4vLyBhd2F5IGFsbCB0aGUgY2hhbmdlcyBhbmQgZWZmZWN0cyBpbiB0aGF0IGl0ZW0sIGRyb3AgaXQgYW5kXG4vLyBwcm9wYWdhdGUgdGhlIG1hcHBpbmcgdG8gdGhlIG5leHQgaXRlbS5cbmZ1bmN0aW9uIGFkZE1hcHBpbmdUb0JyYW5jaChicmFuY2gsIG1hcHBpbmcpIHtcbiAgICBpZiAoIWJyYW5jaC5sZW5ndGgpXG4gICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgbGV0IGxlbmd0aCA9IGJyYW5jaC5sZW5ndGgsIHNlbGVjdGlvbnMgPSBub25lO1xuICAgIHdoaWxlIChsZW5ndGgpIHtcbiAgICAgICAgbGV0IGV2ZW50ID0gbWFwRXZlbnQoYnJhbmNoW2xlbmd0aCAtIDFdLCBtYXBwaW5nLCBzZWxlY3Rpb25zKTtcbiAgICAgICAgaWYgKGV2ZW50LmNoYW5nZXMgJiYgIWV2ZW50LmNoYW5nZXMuZW1wdHkgfHwgZXZlbnQuZWZmZWN0cy5sZW5ndGgpIHsgLy8gRXZlbnQgc3Vydml2ZWQgbWFwcGluZ1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGJyYW5jaC5zbGljZSgwLCBsZW5ndGgpO1xuICAgICAgICAgICAgcmVzdWx0W2xlbmd0aCAtIDFdID0gZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBEcm9wIHRoaXMgZXZlbnQsIHNpbmNlIHRoZXJlJ3Mgbm8gY2hhbmdlcyBvciBlZmZlY3RzIGxlZnRcbiAgICAgICAgICAgIG1hcHBpbmcgPSBldmVudC5tYXBwZWQ7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIHNlbGVjdGlvbnMgPSBldmVudC5zZWxlY3Rpb25zQWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGlvbnMubGVuZ3RoID8gW0hpc3RFdmVudC5zZWxlY3Rpb24oc2VsZWN0aW9ucyldIDogbm9uZTtcbn1cbmZ1bmN0aW9uIG1hcEV2ZW50KGV2ZW50LCBtYXBwaW5nLCBleHRyYVNlbGVjdGlvbnMpIHtcbiAgICBsZXQgc2VsZWN0aW9ucyA9IGNvbmMoZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCA/IGV2ZW50LnNlbGVjdGlvbnNBZnRlci5tYXAocyA9PiBzLm1hcChtYXBwaW5nKSkgOiBub25lLCBleHRyYVNlbGVjdGlvbnMpO1xuICAgIC8vIENoYW5nZS1sZXNzIGV2ZW50cyBkb24ndCBzdG9yZSBtYXBwaW5ncyAodGhleSBhcmUgYWx3YXlzIHRoZSBsYXN0IGV2ZW50IGluIGEgYnJhbmNoKVxuICAgIGlmICghZXZlbnQuY2hhbmdlcylcbiAgICAgICAgcmV0dXJuIEhpc3RFdmVudC5zZWxlY3Rpb24oc2VsZWN0aW9ucyk7XG4gICAgbGV0IG1hcHBlZENoYW5nZXMgPSBldmVudC5jaGFuZ2VzLm1hcChtYXBwaW5nKSwgYmVmb3JlID0gbWFwcGluZy5tYXBEZXNjKGV2ZW50LmNoYW5nZXMsIHRydWUpO1xuICAgIGxldCBmdWxsTWFwcGluZyA9IGV2ZW50Lm1hcHBlZCA/IGV2ZW50Lm1hcHBlZC5jb21wb3NlRGVzYyhiZWZvcmUpIDogYmVmb3JlO1xuICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KG1hcHBlZENoYW5nZXMsIFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoZXZlbnQuZWZmZWN0cywgbWFwcGluZyksIGZ1bGxNYXBwaW5nLCBldmVudC5zdGFydFNlbGVjdGlvbi5tYXAoYmVmb3JlKSwgc2VsZWN0aW9ucyk7XG59XG5jb25zdCBqb2luYWJsZVVzZXJFdmVudCA9IC9eKGlucHV0XFwudHlwZXxkZWxldGUpKCR8XFwuKS87XG5jbGFzcyBIaXN0b3J5U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGRvbmUsIHVuZG9uZSwgcHJldlRpbWUgPSAwLCBwcmV2VXNlckV2ZW50ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IGRvbmU7XG4gICAgICAgIHRoaXMudW5kb25lID0gdW5kb25lO1xuICAgICAgICB0aGlzLnByZXZUaW1lID0gcHJldlRpbWU7XG4gICAgICAgIHRoaXMucHJldlVzZXJFdmVudCA9IHByZXZVc2VyRXZlbnQ7XG4gICAgfVxuICAgIGlzb2xhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZUaW1lID8gbmV3IEhpc3RvcnlTdGF0ZSh0aGlzLmRvbmUsIHRoaXMudW5kb25lKSA6IHRoaXM7XG4gICAgfVxuICAgIGFkZENoYW5nZXMoZXZlbnQsIHRpbWUsIHVzZXJFdmVudCwgY29uZmlnLCB0cikge1xuICAgICAgICBsZXQgZG9uZSA9IHRoaXMuZG9uZSwgbGFzdEV2ZW50ID0gZG9uZVtkb25lLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdEV2ZW50ICYmIGxhc3RFdmVudC5jaGFuZ2VzICYmICFsYXN0RXZlbnQuY2hhbmdlcy5lbXB0eSAmJiBldmVudC5jaGFuZ2VzICYmXG4gICAgICAgICAgICAoIXVzZXJFdmVudCB8fCBqb2luYWJsZVVzZXJFdmVudC50ZXN0KHVzZXJFdmVudCkpICYmXG4gICAgICAgICAgICAoKCFsYXN0RXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHRpbWUgLSB0aGlzLnByZXZUaW1lIDwgY29uZmlnLm5ld0dyb3VwRGVsYXkgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuam9pblRvRXZlbnQodHIsIGlzQWRqYWNlbnQobGFzdEV2ZW50LmNoYW5nZXMsIGV2ZW50LmNoYW5nZXMpKSkgfHxcbiAgICAgICAgICAgICAgICAvLyBGb3IgY29tcG9zZSAoYnV0IG5vdCBjb21wb3NlLnN0YXJ0KSBldmVudHMsIGFsd2F5cyBqb2luIHdpdGggcHJldmlvdXMgZXZlbnRcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQgPT0gXCJpbnB1dC50eXBlLmNvbXBvc2VcIikpIHtcbiAgICAgICAgICAgIGRvbmUgPSB1cGRhdGVCcmFuY2goZG9uZSwgZG9uZS5sZW5ndGggLSAxLCBjb25maWcubWluRGVwdGgsIG5ldyBIaXN0RXZlbnQoZXZlbnQuY2hhbmdlcy5jb21wb3NlKGxhc3RFdmVudC5jaGFuZ2VzKSwgY29uYyhldmVudC5lZmZlY3RzLCBsYXN0RXZlbnQuZWZmZWN0cyksIGxhc3RFdmVudC5tYXBwZWQsIGxhc3RFdmVudC5zdGFydFNlbGVjdGlvbiwgbm9uZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG9uZSA9IHVwZGF0ZUJyYW5jaChkb25lLCBkb25lLmxlbmd0aCwgY29uZmlnLm1pbkRlcHRoLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoZG9uZSwgbm9uZSwgdGltZSwgdXNlckV2ZW50KTtcbiAgICB9XG4gICAgYWRkU2VsZWN0aW9uKHNlbGVjdGlvbiwgdGltZSwgdXNlckV2ZW50LCBuZXdHcm91cERlbGF5KSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5kb25lLmxlbmd0aCA/IHRoaXMuZG9uZVt0aGlzLmRvbmUubGVuZ3RoIC0gMV0uc2VsZWN0aW9uc0FmdGVyIDogbm9uZTtcbiAgICAgICAgaWYgKGxhc3QubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGltZSAtIHRoaXMucHJldlRpbWUgPCBuZXdHcm91cERlbGF5ICYmXG4gICAgICAgICAgICB1c2VyRXZlbnQgPT0gdGhpcy5wcmV2VXNlckV2ZW50ICYmIHVzZXJFdmVudCAmJiAvXnNlbGVjdCgkfFxcLikvLnRlc3QodXNlckV2ZW50KSAmJlxuICAgICAgICAgICAgZXFTZWxlY3Rpb25TaGFwZShsYXN0W2xhc3QubGVuZ3RoIC0gMV0sIHNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoYWRkU2VsZWN0aW9uKHRoaXMuZG9uZSwgc2VsZWN0aW9uKSwgdGhpcy51bmRvbmUsIHRpbWUsIHVzZXJFdmVudCk7XG4gICAgfVxuICAgIGFkZE1hcHBpbmcobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShhZGRNYXBwaW5nVG9CcmFuY2godGhpcy5kb25lLCBtYXBwaW5nKSwgYWRkTWFwcGluZ1RvQnJhbmNoKHRoaXMudW5kb25lLCBtYXBwaW5nKSwgdGhpcy5wcmV2VGltZSwgdGhpcy5wcmV2VXNlckV2ZW50KTtcbiAgICB9XG4gICAgcG9wKHNpZGUsIHN0YXRlLCBzZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGJyYW5jaCA9IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyB0aGlzLmRvbmUgOiB0aGlzLnVuZG9uZTtcbiAgICAgICAgaWYgKGJyYW5jaC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZXZlbnQgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoc2VsZWN0aW9uICYmIGV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogZXZlbnQuc2VsZWN0aW9uc0FmdGVyW2V2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uczogZnJvbUhpc3Rvcnkub2YoeyBzaWRlLCByZXN0OiBwb3BTZWxlY3Rpb24oYnJhbmNoKSB9KSxcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBcInNlbGVjdC51bmRvXCIgOiBcInNlbGVjdC5yZWRvXCIsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFldmVudC5jaGFuZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXN0ID0gYnJhbmNoLmxlbmd0aCA9PSAxID8gbm9uZSA6IGJyYW5jaC5zbGljZSgwLCBicmFuY2gubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBpZiAoZXZlbnQubWFwcGVkKVxuICAgICAgICAgICAgICAgIHJlc3QgPSBhZGRNYXBwaW5nVG9CcmFuY2gocmVzdCwgZXZlbnQubWFwcGVkKTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgICAgIGNoYW5nZXM6IGV2ZW50LmNoYW5nZXMsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBldmVudC5zdGFydFNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBldmVudC5lZmZlY3RzLFxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiBmcm9tSGlzdG9yeS5vZih7IHNpZGUsIHJlc3QgfSksXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBcInVuZG9cIiA6IFwicmVkb1wiLFxuICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkhpc3RvcnlTdGF0ZS5lbXB0eSA9IC8qQF9fUFVSRV9fKi9uZXcgSGlzdG9yeVN0YXRlKG5vbmUsIG5vbmUpO1xuLyoqXG5EZWZhdWx0IGtleSBiaW5kaW5ncyBmb3IgdGhlIHVuZG8gaGlzdG9yeS5cblxuLSBNb2QtejogW2B1bmRvYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy51bmRvKS5cbi0gTW9kLXkgKE1vZC1TaGlmdC16IG9uIG1hY09TKSArIEN0cmwtU2hpZnQteiBvbiBMaW51eDogW2ByZWRvYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5yZWRvKS5cbi0gTW9kLXU6IFtgdW5kb1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudW5kb1NlbGVjdGlvbikuXG4tIEFsdC11IChNb2QtU2hpZnQtdSBvbiBtYWNPUyk6IFtgcmVkb1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMucmVkb1NlbGVjdGlvbikuXG4qL1xuY29uc3QgaGlzdG9yeUtleW1hcCA9IFtcbiAgICB7IGtleTogXCJNb2QtelwiLCBydW46IHVuZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLXlcIiwgbWFjOiBcIk1vZC1TaGlmdC16XCIsIHJ1bjogcmVkbywgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGxpbnV4OiBcIkN0cmwtU2hpZnQtelwiLCBydW46IHJlZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLXVcIiwgcnVuOiB1bmRvU2VsZWN0aW9uLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFsdC11XCIsIG1hYzogXCJNb2QtU2hpZnQtdVwiLCBydW46IHJlZG9TZWxlY3Rpb24sIHByZXZlbnREZWZhdWx0OiB0cnVlIH1cbl07XG5cbmZ1bmN0aW9uIHVwZGF0ZVNlbChzZWwsIGJ5KSB7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsLnJhbmdlcy5tYXAoYnkpLCBzZWwubWFpbkluZGV4KTtcbn1cbmZ1bmN0aW9uIHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbiwgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJzZWxlY3RcIiB9KTtcbn1cbmZ1bmN0aW9uIG1vdmVTZWwoeyBzdGF0ZSwgZGlzcGF0Y2ggfSwgaG93KSB7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIGhvdyk7XG4gICAgaWYgKHNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IHJhbmdlLnRvIDogcmFuZ2UuZnJvbSk7XG59XG5mdW5jdGlvbiBjdXJzb3JCeUNoYXIodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XG59XG5mdW5jdGlvbiBsdHJBdEN1cnNvcih2aWV3KSB7XG4gICAgcmV0dXJuIHZpZXcudGV4dERpcmVjdGlvbkF0KHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkgPT0gRGlyZWN0aW9uLkxUUjtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIGxlZnQgKHdoaWNoIGlzIGJhY2t3YXJkIGluXG5sZWZ0LXRvLXJpZ2h0IHRleHQsIGZvcndhcmQgaW4gcmlnaHQtdG8tbGVmdCB0ZXh0KS5cbiovXG5jb25zdCBjdXJzb3JDaGFyTGVmdCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JDaGFyUmlnaHQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGZvcndhcmQuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckZvcndhcmQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckJhY2t3YXJkID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gY3Vyc29yQnlHcm91cCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVCeUdyb3VwKHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbGVmdCBhY3Jvc3Mgb25lIGdyb3VwIG9mIHdvcmQgb3Jcbm5vbi13b3JkIChidXQgYWxzbyBub24tc3BhY2UpIGNoYXJhY3RlcnMuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBMZWZ0ID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwUmlnaHQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIGZvcndhcmQuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwQmFja3dhcmQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkge1xuICAgIGxldCBjYXRlZ29yaXplID0gdmlldy5zdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocmFuZ2UuZnJvbSk7XG4gICAgcmV0dXJuIHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCwgc3RhcnQgPT4ge1xuICAgICAgICBsZXQgY2F0ID0gQ2hhckNhdGVnb3J5LlNwYWNlLCBwb3MgPSByYW5nZS5mcm9tO1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlLCBzYXdVcHBlciA9IGZhbHNlLCBzYXdMb3dlciA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RlcCA9IChuZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBwb3MgKz0gZm9yd2FyZCA/IG5leHQubGVuZ3RoIDogLW5leHQubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHQpLCBhaGVhZDtcbiAgICAgICAgICAgIGlmIChjYXQgPT0gQ2hhckNhdGVnb3J5LlNwYWNlKVxuICAgICAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgICAgICBpZiAoY2F0ICE9IG5leHRDYXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuV29yZCkge1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvTG93ZXJDYXNlKCkgPT0gbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvcndhcmQgJiYgc2F3VXBwZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHNhd0xvd2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2F3TG93ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhd1VwcGVyICYmIGZvcndhcmQgJiYgY2F0ZWdvcml6ZShhaGVhZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyAxKSkgPT0gQ2hhckNhdGVnb3J5LldvcmQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFoZWFkLnRvTG93ZXJDYXNlKCkgPT0gYWhlYWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHNhd1VwcGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgc3RlcChzdGFydCk7XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBvciBjYW1lbC1jYXNlIHN1YndvcmQgZm9yd2FyZC5cbiovXG5jb25zdCBjdXJzb3JTdWJ3b3JkRm9yd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBiYWNrd2FyZC5cbiovXG5jb25zdCBjdXJzb3JTdWJ3b3JkQmFja3dhcmQgPSB2aWV3ID0+IGN1cnNvckJ5U3Vid29yZCh2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBpbnRlcmVzdGluZ05vZGUoc3RhdGUsIG5vZGUsIGJyYWNrZXRQcm9wKSB7XG4gICAgaWYgKG5vZGUudHlwZS5wcm9wKGJyYWNrZXRQcm9wKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGxlbiA9IG5vZGUudG8gLSBub2RlLmZyb207XG4gICAgcmV0dXJuIGxlbiAmJiAobGVuID4gMiB8fCAvW15cXHMsLjs6XS8udGVzdChzdGF0ZS5zbGljZURvYyhub2RlLmZyb20sIG5vZGUudG8pKSkgfHwgbm9kZS5maXJzdENoaWxkO1xufVxuZnVuY3Rpb24gbW92ZUJ5U3ludGF4KHN0YXRlLCBzdGFydCwgZm9yd2FyZCkge1xuICAgIGxldCBwb3MgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIoc3RhcnQuaGVhZCk7XG4gICAgbGV0IGJyYWNrZXRQcm9wID0gZm9yd2FyZCA/IE5vZGVQcm9wLmNsb3NlZEJ5IDogTm9kZVByb3Aub3BlbmVkQnk7XG4gICAgLy8gU2NhbiBmb3J3YXJkIHRocm91Z2ggY2hpbGQgbm9kZXMgdG8gc2VlIGlmIHRoZXJlJ3MgYW4gaW50ZXJlc3RpbmdcbiAgICAvLyBub2RlIGFoZWFkLlxuICAgIGZvciAobGV0IGF0ID0gc3RhcnQuaGVhZDs7KSB7XG4gICAgICAgIGxldCBuZXh0ID0gZm9yd2FyZCA/IHBvcy5jaGlsZEFmdGVyKGF0KSA6IHBvcy5jaGlsZEJlZm9yZShhdCk7XG4gICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoaW50ZXJlc3RpbmdOb2RlKHN0YXRlLCBuZXh0LCBicmFja2V0UHJvcCkpXG4gICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhdCA9IGZvcndhcmQgPyBuZXh0LnRvIDogbmV4dC5mcm9tO1xuICAgIH1cbiAgICBsZXQgYnJhY2tldCA9IHBvcy50eXBlLnByb3AoYnJhY2tldFByb3ApLCBtYXRjaCwgbmV3UG9zO1xuICAgIGlmIChicmFja2V0ICYmIChtYXRjaCA9IGZvcndhcmQgPyBtYXRjaEJyYWNrZXRzKHN0YXRlLCBwb3MuZnJvbSwgMSkgOiBtYXRjaEJyYWNrZXRzKHN0YXRlLCBwb3MudG8sIC0xKSkgJiYgbWF0Y2gubWF0Y2hlZClcbiAgICAgICAgbmV3UG9zID0gZm9yd2FyZCA/IG1hdGNoLmVuZC50byA6IG1hdGNoLmVuZC5mcm9tO1xuICAgIGVsc2VcbiAgICAgICAgbmV3UG9zID0gZm9yd2FyZCA/IHBvcy50byA6IHBvcy5mcm9tO1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5ld1BvcywgZm9yd2FyZCA/IC0xIDogMSk7XG59XG4vKipcbk1vdmUgdGhlIGN1cnNvciBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IGN1cnNvclN5bnRheExlZnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgY3Vyc29yIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvclN5bnRheFJpZ2h0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN5bnRheCh2aWV3LnN0YXRlLCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbmZ1bmN0aW9uIGN1cnNvckJ5TGluZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKTtcbiAgICAgICAgbGV0IG1vdmVkID0gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCk7XG4gICAgICAgIHJldHVybiBtb3ZlZC5oZWFkICE9IHJhbmdlLmhlYWQgPyBtb3ZlZCA6IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHJhbmdlLCBmb3J3YXJkKTtcbiAgICB9KTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHVwLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVVcCA9IHZpZXcgPT4gY3Vyc29yQnlMaW5lKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIGRvd24uXG4qL1xuY29uc3QgY3Vyc29yTGluZURvd24gPSB2aWV3ID0+IGN1cnNvckJ5TGluZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIHBhZ2VJbmZvKHZpZXcpIHtcbiAgICBsZXQgc2VsZlNjcm9sbCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudEhlaWdodCA8IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbEhlaWdodCAtIDI7XG4gICAgbGV0IG1hcmdpblRvcCA9IDAsIG1hcmdpbkJvdHRvbSA9IDAsIGhlaWdodDtcbiAgICBpZiAoc2VsZlNjcm9sbCkge1xuICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2Ygdmlldy5zdGF0ZS5mYWNldChFZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMpKSB7XG4gICAgICAgICAgICBsZXQgbWFyZ2lucyA9IHNvdXJjZSh2aWV3KTtcbiAgICAgICAgICAgIGlmIChtYXJnaW5zID09PSBudWxsIHx8IG1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmdpbnMudG9wKVxuICAgICAgICAgICAgICAgIG1hcmdpblRvcCA9IE1hdGgubWF4KG1hcmdpbnMgPT09IG51bGwgfHwgbWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFyZ2lucy50b3AsIG1hcmdpblRvcCk7XG4gICAgICAgICAgICBpZiAobWFyZ2lucyA9PT0gbnVsbCB8fCBtYXJnaW5zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJnaW5zLmJvdHRvbSlcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b20gPSBNYXRoLm1heChtYXJnaW5zID09PSBudWxsIHx8IG1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmdpbnMuYm90dG9tLCBtYXJnaW5Cb3R0b20pO1xuICAgICAgICB9XG4gICAgICAgIGhlaWdodCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudEhlaWdodCAtIG1hcmdpblRvcCAtIG1hcmdpbkJvdHRvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhlaWdodCA9ICh2aWV3LmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdykuaW5uZXJIZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiB7IG1hcmdpblRvcCwgbWFyZ2luQm90dG9tLCBzZWxmU2Nyb2xsLFxuICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KHZpZXcuZGVmYXVsdExpbmVIZWlnaHQsIGhlaWdodCAtIDUpIH07XG59XG5mdW5jdGlvbiBjdXJzb3JCeVBhZ2UodmlldywgZm9yd2FyZCkge1xuICAgIGxldCBwYWdlID0gcGFnZUluZm8odmlldyk7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgcmV0dXJuIHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCwgcGFnZS5oZWlnaHQpXG4gICAgICAgICAgICA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKTtcbiAgICB9KTtcbiAgICBpZiAoc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZWZmZWN0O1xuICAgIGlmIChwYWdlLnNlbGZTY3JvbGwpIHtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gdmlldy5jb29yZHNBdFBvcyhzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgbGV0IHNjcm9sbFJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IHNjcm9sbFJlY3QudG9wICsgcGFnZS5tYXJnaW5Ub3AsIHNjcm9sbEJvdHRvbSA9IHNjcm9sbFJlY3QuYm90dG9tIC0gcGFnZS5tYXJnaW5Cb3R0b207XG4gICAgICAgIGlmIChzdGFydFBvcyAmJiBzdGFydFBvcy50b3AgPiBzY3JvbGxUb3AgJiYgc3RhcnRQb3MuYm90dG9tIDwgc2Nyb2xsQm90dG9tKVxuICAgICAgICAgICAgZWZmZWN0ID0gRWRpdG9yVmlldy5zY3JvbGxJbnRvVmlldyhzZWxlY3Rpb24ubWFpbi5oZWFkLCB7IHk6IFwic3RhcnRcIiwgeU1hcmdpbjogc3RhcnRQb3MudG9wIC0gc2Nyb2xsVG9wIH0pO1xuICAgIH1cbiAgICB2aWV3LmRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSwgeyBlZmZlY3RzOiBlZmZlY3QgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgcGFnZSB1cC5cbiovXG5jb25zdCBjdXJzb3JQYWdlVXAgPSB2aWV3ID0+IGN1cnNvckJ5UGFnZSh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgcGFnZSBkb3duLlxuKi9cbmNvbnN0IGN1cnNvclBhZ2VEb3duID0gdmlldyA9PiBjdXJzb3JCeVBhZ2UodmlldywgdHJ1ZSk7XG5mdW5jdGlvbiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgc3RhcnQsIGZvcndhcmQpIHtcbiAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQoc3RhcnQuaGVhZCksIG1vdmVkID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQpO1xuICAgIGlmIChtb3ZlZC5oZWFkID09IHN0YXJ0LmhlYWQgJiYgbW92ZWQuaGVhZCAhPSAoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20pKVxuICAgICAgICBtb3ZlZCA9IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHN0YXJ0LCBmb3J3YXJkLCBmYWxzZSk7XG4gICAgaWYgKCFmb3J3YXJkICYmIG1vdmVkLmhlYWQgPT0gbGluZS5mcm9tICYmIGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIGxldCBzcGFjZSA9IC9eXFxzKi8uZXhlYyh2aWV3LnN0YXRlLnNsaWNlRG9jKGxpbmUuZnJvbSwgTWF0aC5taW4obGluZS5mcm9tICsgMTAwLCBsaW5lLnRvKSkpWzBdLmxlbmd0aDtcbiAgICAgICAgaWYgKHNwYWNlICYmIHN0YXJ0LmhlYWQgIT0gbGluZS5mcm9tICsgc3BhY2UpXG4gICAgICAgICAgICBtb3ZlZCA9IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobGluZS5mcm9tICsgc3BhY2UpO1xuICAgIH1cbiAgICByZXR1cm4gbW92ZWQ7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbmV4dCBsaW5lIHdyYXAgcG9pbnQsIG9yIHRvIHRoZSBlbmQgb2ZcbnRoZSBsaW5lIGlmIHRoZXJlIGlzbid0IG9uZSBsZWZ0IG9uIHRoaXMgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgdHJ1ZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gcHJldmlvdXMgbGluZSB3cmFwIHBvaW50LCBvciBmYWlsaW5nIHRoYXQgdG9cbnRoZSBzdGFydCBvZiB0aGUgbGluZS4gSWYgdGhlIGxpbmUgaXMgaW5kZW50ZWQsIGFuZCB0aGUgY3Vyc29yXG5pc24ndCBhbHJlYWR5IGF0IHRoZSBlbmQgb2YgdGhlIGluZGVudGF0aW9uLCB0aGlzIHdpbGwgbW92ZSB0byB0aGVcbmVuZCBvZiB0aGUgaW5kZW50YXRpb24gaW5zdGVhZCBvZiB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBmYWxzZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgd3JhcCBwb2ludCB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlMZWZ0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgIWx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgbGluZSB3cmFwIHBvaW50IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlSaWdodCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZVN0YXJ0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS5mcm9tLCAxKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVFbmQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLnRvLCAtMSkpO1xuZnVuY3Rpb24gdG9NYXRjaGluZ0JyYWNrZXQoc3RhdGUsIGRpc3BhdGNoLCBleHRlbmQpIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZSwgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICBsZXQgbWF0Y2hpbmcgPSBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkLCAtMSlcbiAgICAgICAgICAgIHx8IG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQsIDEpXG4gICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA+IDAgJiYgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCAtIDEsIDEpKVxuICAgICAgICAgICAgfHwgKHJhbmdlLmhlYWQgPCBzdGF0ZS5kb2MubGVuZ3RoICYmIG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQgKyAxLCAtMSkpO1xuICAgICAgICBpZiAoIW1hdGNoaW5nIHx8ICFtYXRjaGluZy5lbmQpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgbGV0IGhlYWQgPSBtYXRjaGluZy5zdGFydC5mcm9tID09IHJhbmdlLmhlYWQgPyBtYXRjaGluZy5lbmQudG8gOiBtYXRjaGluZy5lbmQuZnJvbTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCA/IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IsIGhlYWQpIDogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihoZWFkKTtcbiAgICB9KTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBicmFja2V0IG1hdGNoaW5nIHRoZSBvbmUgaXQgaXMgY3VycmVudGx5XG5vbiwgaWYgYW55LlxuKi9cbmNvbnN0IGN1cnNvck1hdGNoaW5nQnJhY2tldCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbi8qKlxuRXh0ZW5kIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGJyYWNrZXQgbWF0Y2hpbmcgdGhlIG9uZSB0aGUgc2VsZWN0aW9uXG5oZWFkIGlzIGN1cnJlbnRseSBvbiwgaWYgYW55LlxuKi9cbmNvbnN0IHNlbGVjdE1hdGNoaW5nQnJhY2tldCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIHRydWUpO1xuZnVuY3Rpb24gZXh0ZW5kU2VsKHZpZXcsIGhvdykge1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwodmlldy5zdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgbGV0IGhlYWQgPSBob3cocmFuZ2UpO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciwgaGVhZC5oZWFkLCBoZWFkLmdvYWxDb2x1bW4sIGhlYWQuYmlkaUxldmVsIHx8IHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdGlvbi5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHNldFNlbCh2aWV3LnN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdEJ5Q2hhcih2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciB0byB0aGUgbGVmdCwgd2hpbGUgbGVhdmluZ1xudGhlIGFuY2hvciBpbiBwbGFjZS5cbiovXG5jb25zdCBzZWxlY3RDaGFyTGVmdCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IHNlbGVjdENoYXJSaWdodCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gc2VsZWN0QnlHcm91cCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVCeUdyb3VwKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBbZ3JvdXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBMZWZ0KSB0b1xudGhlIGxlZnQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBMZWZ0ID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBSaWdodCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwRm9yd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIGJhY2t3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwQmFja3dhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gc2VsZWN0QnlTdWJ3b3JkKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdFN1YndvcmRGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeVN1YndvcmQodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBvciBzdWJ3b3JkIGJhY2t3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdFN1YndvcmRCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlTdWJ3b3JkKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RTeW50YXhMZWZ0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0U3ludGF4UmlnaHQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XG5mdW5jdGlvbiBzZWxlY3RCeUxpbmUodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSB1cC5cbiovXG5jb25zdCBzZWxlY3RMaW5lVXAgPSB2aWV3ID0+IHNlbGVjdEJ5TGluZSh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIGRvd24uXG4qL1xuY29uc3Qgc2VsZWN0TGluZURvd24gPSB2aWV3ID0+IHNlbGVjdEJ5TGluZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIHNlbGVjdEJ5UGFnZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkLCBwYWdlSW5mbyh2aWV3KS5oZWlnaHQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIHBhZ2UgdXAuXG4qL1xuY29uc3Qgc2VsZWN0UGFnZVVwID0gdmlldyA9PiBzZWxlY3RCeVBhZ2UodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgcGFnZSBkb3duLlxuKi9cbmNvbnN0IHNlbGVjdFBhZ2VEb3duID0gdmlldyA9PiBzZWxlY3RCeVBhZ2UodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBuZXh0IGxpbmUgYm91bmRhcnkuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgdHJ1ZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgcHJldmlvdXMgbGluZSBib3VuZGFyeS5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgZmFsc2UpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgYm91bmRhcnkgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5TGVmdCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgIWx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIGJvdW5kYXJ5IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVTdGFydCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS5mcm9tKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUVuZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS50bykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBjdXJzb3JEb2NTdGFydCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogMCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3QgY3Vyc29yRG9jRW5kID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiBzdGF0ZS5kb2MubGVuZ3RoIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0RG9jU3RhcnQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogMCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3REb2NFbmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogc3RhdGUuZG9jLmxlbmd0aCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIGVudGlyZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3RBbGwgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbjogeyBhbmNob3I6IDAsIGhlYWQ6IHN0YXRlLmRvYy5sZW5ndGggfSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkV4cGFuZCB0aGUgc2VsZWN0aW9uIHRvIGNvdmVyIGVudGlyZSBsaW5lcy5cbiovXG5jb25zdCBzZWxlY3RMaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgcmFuZ2VzID0gc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKS5tYXAoKHsgZnJvbSwgdG8gfSkgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIE1hdGgubWluKHRvICsgMSwgc3RhdGUuZG9jLmxlbmd0aCkpKTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzKSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNlbGVjdCB0aGUgbmV4dCBzeW50YWN0aWMgY29uc3RydWN0IHRoYXQgaXMgbGFyZ2VyIHRoYW4gdGhlXG5zZWxlY3Rpb24uIE5vdGUgdGhhdCB0aGlzIHdpbGwgb25seSB3b3JrIGluc29mYXIgYXMgdGhlIGxhbmd1YWdlXG5bcHJvdmlkZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2UpIHlvdSB1c2UgYnVpbGRzIHVwIGEgZnVsbFxuc3ludGF4IHRyZWUuXG4qL1xuY29uc3Qgc2VsZWN0UGFyZW50U3ludGF4ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjb250ZXh0ID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHJhbmdlLmhlYWQsIDEpO1xuICAgICAgICB3aGlsZSAoISgoY29udGV4dC5mcm9tIDwgcmFuZ2UuZnJvbSAmJiBjb250ZXh0LnRvID49IHJhbmdlLnRvKSB8fFxuICAgICAgICAgICAgKGNvbnRleHQudG8gPiByYW5nZS50byAmJiBjb250ZXh0LmZyb20gPD0gcmFuZ2UuZnJvbSkgfHxcbiAgICAgICAgICAgICEoKF9hID0gY29udGV4dC5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnQpKSlcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShjb250ZXh0LnRvLCBjb250ZXh0LmZyb20pO1xuICAgIH0pO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TaW1wbGlmeSB0aGUgY3VycmVudCBzZWxlY3Rpb24uIFdoZW4gbXVsdGlwbGUgcmFuZ2VzIGFyZSBzZWxlY3RlZCxcbnJlZHVjZSBpdCB0byBpdHMgbWFpbiByYW5nZS4gT3RoZXJ3aXNlLCBpZiB0aGUgc2VsZWN0aW9uIGlzXG5ub24tZW1wdHksIGNvbnZlcnQgaXQgdG8gYSBjdXJzb3Igc2VsZWN0aW9uLlxuKi9cbmNvbnN0IHNpbXBsaWZ5U2VsZWN0aW9uID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgY3VyID0gc3RhdGUuc2VsZWN0aW9uLCBzZWxlY3Rpb24gPSBudWxsO1xuICAgIGlmIChjdXIucmFuZ2VzLmxlbmd0aCA+IDEpXG4gICAgICAgIHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW2N1ci5tYWluXSk7XG4gICAgZWxzZSBpZiAoIWN1ci5tYWluLmVtcHR5KVxuICAgICAgICBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGN1ci5tYWluLmhlYWQpXSk7XG4gICAgaWYgKCFzZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGRlbGV0ZUJ5KHRhcmdldCwgYnkpIHtcbiAgICBpZiAodGFyZ2V0LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGV2ZW50ID0gXCJkZWxldGUuc2VsZWN0aW9uXCIsIHsgc3RhdGUgfSA9IHRhcmdldDtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2U7XG4gICAgICAgIGlmIChmcm9tID09IHRvKSB7XG4gICAgICAgICAgICBsZXQgdG93YXJkcyA9IGJ5KGZyb20pO1xuICAgICAgICAgICAgaWYgKHRvd2FyZHMgPCBmcm9tKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBcImRlbGV0ZS5iYWNrd2FyZFwiO1xuICAgICAgICAgICAgICAgIHRvd2FyZHMgPSBza2lwQXRvbWljKHRhcmdldCwgdG93YXJkcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG93YXJkcyA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IFwiZGVsZXRlLmZvcndhcmRcIjtcbiAgICAgICAgICAgICAgICB0b3dhcmRzID0gc2tpcEF0b21pYyh0YXJnZXQsIHRvd2FyZHMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbSA9IE1hdGgubWluKGZyb20sIHRvd2FyZHMpO1xuICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgdG93YXJkcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc2tpcEF0b21pYyh0YXJnZXQsIGZyb20sIGZhbHNlKTtcbiAgICAgICAgICAgIHRvID0gc2tpcEF0b21pYyh0YXJnZXQsIHRvLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbSA9PSB0byA/IHsgcmFuZ2UgfSA6IHsgY2hhbmdlczogeyBmcm9tLCB0byB9LCByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tKSB9O1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0YXJnZXQuZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogZXZlbnQsXG4gICAgICAgIGVmZmVjdHM6IGV2ZW50ID09IFwiZGVsZXRlLnNlbGVjdGlvblwiID8gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihzdGF0ZS5waHJhc2UoXCJTZWxlY3Rpb24gZGVsZXRlZFwiKSkgOiB1bmRlZmluZWRcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBza2lwQXRvbWljKHRhcmdldCwgcG9zLCBmb3J3YXJkKSB7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEVkaXRvclZpZXcpXG4gICAgICAgIGZvciAobGV0IHJhbmdlcyBvZiB0YXJnZXQuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5hdG9taWNSYW5nZXMpLm1hcChmID0+IGYodGFyZ2V0KSkpXG4gICAgICAgICAgICByYW5nZXMuYmV0d2Vlbihwb3MsIHBvcywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCBwb3MgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGZvcndhcmQgPyB0byA6IGZyb207XG4gICAgICAgICAgICB9KTtcbiAgICByZXR1cm4gcG9zO1xufVxuY29uc3QgZGVsZXRlQnlDaGFyID0gKHRhcmdldCwgZm9yd2FyZCkgPT4gZGVsZXRlQnkodGFyZ2V0LCBwb3MgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB0YXJnZXQsIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyksIGJlZm9yZSwgdGFyZ2V0UG9zO1xuICAgIGlmICghZm9yd2FyZCAmJiBwb3MgPiBsaW5lLmZyb20gJiYgcG9zIDwgbGluZS5mcm9tICsgMjAwICYmXG4gICAgICAgICEvW14gXFx0XS8udGVzdChiZWZvcmUgPSBsaW5lLnRleHQuc2xpY2UoMCwgcG9zIC0gbGluZS5mcm9tKSkpIHtcbiAgICAgICAgaWYgKGJlZm9yZVtiZWZvcmUubGVuZ3RoIC0gMV0gPT0gXCJcXHRcIilcbiAgICAgICAgICAgIHJldHVybiBwb3MgLSAxO1xuICAgICAgICBsZXQgY29sID0gY291bnRDb2x1bW4oYmVmb3JlLCBzdGF0ZS50YWJTaXplKSwgZHJvcCA9IGNvbCAlIGdldEluZGVudFVuaXQoc3RhdGUpIHx8IGdldEluZGVudFVuaXQoc3RhdGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRyb3AgJiYgYmVmb3JlW2JlZm9yZS5sZW5ndGggLSAxIC0gaV0gPT0gXCIgXCI7IGkrKylcbiAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICB0YXJnZXRQb3MgPSBwb3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXRQb3MgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmb3J3YXJkLCBmb3J3YXJkKSArIGxpbmUuZnJvbTtcbiAgICAgICAgaWYgKHRhcmdldFBvcyA9PSBwb3MgJiYgbGluZS5udW1iZXIgIT0gKGZvcndhcmQgPyBzdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgIHRhcmdldFBvcyArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0UG9zO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgZm9yIGN1cnNvciBzZWxlY3Rpb25zLCB0aGUgY2hhcmFjdGVyXG5iZWZvcmUgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVDaGFyQmFja3dhcmQgPSB2aWV3ID0+IGRlbGV0ZUJ5Q2hhcih2aWV3LCBmYWxzZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uIG9yIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVDaGFyRm9yd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIHRydWUpO1xuY29uc3QgZGVsZXRlQnlHcm91cCA9ICh0YXJnZXQsIGZvcndhcmQpID0+IGRlbGV0ZUJ5KHRhcmdldCwgc3RhcnQgPT4ge1xuICAgIGxldCBwb3MgPSBzdGFydCwgeyBzdGF0ZSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgIGxldCBjYXRlZ29yaXplID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgZm9yIChsZXQgY2F0ID0gbnVsbDs7KSB7XG4gICAgICAgIGlmIChwb3MgPT0gKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tKSkge1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBzdGFydCAmJiBsaW5lLm51bWJlciAhPSAoZm9yd2FyZCA/IHN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgICAgIHBvcyArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmb3J3YXJkKSArIGxpbmUuZnJvbTtcbiAgICAgICAgbGV0IG5leHRDaGFyID0gbGluZS50ZXh0LnNsaWNlKE1hdGgubWluKHBvcywgbmV4dCkgLSBsaW5lLmZyb20sIE1hdGgubWF4KHBvcywgbmV4dCkgLSBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dENoYXIpO1xuICAgICAgICBpZiAoY2F0ICE9IG51bGwgJiYgbmV4dENhdCAhPSBjYXQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKG5leHRDaGFyICE9IFwiIFwiIHx8IHBvcyAhPSBzdGFydClcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIHBvcyA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgYmFja3dhcmQgdW50aWwgdGhlIGVuZCBvZiB0aGUgbmV4dFxuW2dyb3VwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlQnlHcm91cCksIG9ubHkgc2tpcHBpbmcgZ3JvdXBzIG9mXG53aGl0ZXNwYWNlIHdoZW4gdGhleSBjb25zaXN0IG9mIGEgc2luZ2xlIHNwYWNlLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwQmFja3dhcmQgPSB0YXJnZXQgPT4gZGVsZXRlQnlHcm91cCh0YXJnZXQsIGZhbHNlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgZm9yd2FyZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBuZXh0IGdyb3VwLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwRm9yd2FyZCA9IHRhcmdldCA9PiBkZWxldGVCeUdyb3VwKHRhcmdldCwgdHJ1ZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBlbmQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIGVuZCBvZiB0aGVcbmxpbmUsIGRlbGV0ZSB0aGUgbGluZSBicmVhayBhZnRlciBpdC5cbiovXG5jb25zdCBkZWxldGVUb0xpbmVFbmQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHBvcyA9PiB7XG4gICAgbGV0IGxpbmVFbmQgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcykudG87XG4gICAgcmV0dXJuIHBvcyA8IGxpbmVFbmQgPyBsaW5lRW5kIDogTWF0aC5taW4odmlldy5zdGF0ZS5kb2MubGVuZ3RoLCBwb3MgKyAxKTtcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgc3RhcnQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIHN0YXJ0IG9mIHRoZVxubGluZSwgZGVsZXRlIHRoZSBsaW5lIGJyZWFrIGJlZm9yZSBpdC5cbiovXG5jb25zdCBkZWxldGVUb0xpbmVTdGFydCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcG9zID0+IHtcbiAgICBsZXQgbGluZVN0YXJ0ID0gdmlldy5saW5lQmxvY2tBdChwb3MpLmZyb207XG4gICAgcmV0dXJuIHBvcyA+IGxpbmVTdGFydCA/IGxpbmVTdGFydCA6IE1hdGgubWF4KDAsIHBvcyAtIDEpO1xufSk7XG4vKipcbkRlbGV0ZSBhbGwgd2hpdGVzcGFjZSBkaXJlY3RseSBiZWZvcmUgYSBsaW5lIGVuZCBmcm9tIHRoZVxuZG9jdW1lbnQuXG4qL1xuY29uc3QgZGVsZXRlVHJhaWxpbmdXaGl0ZXNwYWNlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIHByZXYgPSBcIlwiLCBpdGVyID0gc3RhdGUuZG9jLml0ZXIoKTs7KSB7XG4gICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICBpZiAoaXRlci5saW5lQnJlYWsgfHwgaXRlci5kb25lKSB7XG4gICAgICAgICAgICBsZXQgdHJhaWxpbmcgPSBwcmV2LnNlYXJjaCgvXFxzKyQvKTtcbiAgICAgICAgICAgIGlmICh0cmFpbGluZyA+IC0xKVxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IHBvcyAtIChwcmV2Lmxlbmd0aCAtIHRyYWlsaW5nKSwgdG86IHBvcyB9KTtcbiAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwcmV2ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXYgPSBpdGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBpdGVyLnZhbHVlLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGNoYW5nZXMsIHVzZXJFdmVudDogXCJkZWxldGVcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIGVhY2ggc2VsZWN0aW9uIHJhbmdlIHdpdGggYSBsaW5lIGJyZWFrLCBsZWF2aW5nIHRoZSBjdXJzb3Jcbm9uIHRoZSBsaW5lIGJlZm9yZSB0aGUgYnJlYWsuXG4qL1xuY29uc3Qgc3BsaXRMaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiBUZXh0Lm9mKFtcIlwiLCBcIlwiXSkgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20pIH07XG4gICAgfSk7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkZsaXAgdGhlIGNoYXJhY3RlcnMgYmVmb3JlIGFuZCBhZnRlciB0aGUgY3Vyc29yKHMpLlxuKi9cbmNvbnN0IHRyYW5zcG9zZUNoYXJzID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5IHx8IHJhbmdlLmZyb20gPT0gMCB8fCByYW5nZS5mcm9tID09IHN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICBsZXQgcG9zID0gcmFuZ2UuZnJvbSwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IGZyb20gPSBwb3MgPT0gbGluZS5mcm9tID8gcG9zIC0gMSA6IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZhbHNlKSArIGxpbmUuZnJvbTtcbiAgICAgICAgbGV0IHRvID0gcG9zID09IGxpbmUudG8gPyBwb3MgKyAxIDogZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgdHJ1ZSkgKyBsaW5lLmZyb207XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogc3RhdGUuZG9jLnNsaWNlKHBvcywgdG8pLmFwcGVuZChzdGF0ZS5kb2Muc2xpY2UoZnJvbSwgcG9zKSkgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHRvKSB9O1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcIm1vdmUuY2hhcmFjdGVyXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkge1xuICAgIGxldCBibG9ja3MgPSBbXSwgdXB0byA9IC0xO1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSksIGVuZExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLnRvKTtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSAmJiByYW5nZS50byA9PSBlbmRMaW5lLmZyb20pXG4gICAgICAgICAgICBlbmRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50byAtIDEpO1xuICAgICAgICBpZiAodXB0byA+PSBzdGFydExpbmUubnVtYmVyKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGJsb2Nrc1tibG9ja3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBwcmV2LnRvID0gZW5kTGluZS50bztcbiAgICAgICAgICAgIHByZXYucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goeyBmcm9tOiBzdGFydExpbmUuZnJvbSwgdG86IGVuZExpbmUudG8sIHJhbmdlczogW3JhbmdlXSB9KTtcbiAgICAgICAgfVxuICAgICAgICB1cHRvID0gZW5kTGluZS5udW1iZXIgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gYmxvY2tzO1xufVxuZnVuY3Rpb24gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmb3J3YXJkKSB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXSwgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgYmxvY2sgb2Ygc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKSkge1xuICAgICAgICBpZiAoZm9yd2FyZCA/IGJsb2NrLnRvID09IHN0YXRlLmRvYy5sZW5ndGggOiBibG9jay5mcm9tID09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IG5leHRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmb3J3YXJkID8gYmxvY2sudG8gKyAxIDogYmxvY2suZnJvbSAtIDEpO1xuICAgICAgICBsZXQgc2l6ZSA9IG5leHRMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay50bywgdG86IG5leHRMaW5lLnRvIH0sIHsgZnJvbTogYmxvY2suZnJvbSwgaW5zZXJ0OiBuZXh0TGluZS50ZXh0ICsgc3RhdGUubGluZUJyZWFrIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgciBvZiBibG9jay5yYW5nZXMpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIHIuYW5jaG9yICsgc2l6ZSksIE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIHIuaGVhZCArIHNpemUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBuZXh0TGluZS5mcm9tLCB0bzogYmxvY2suZnJvbSB9LCB7IGZyb206IGJsb2NrLnRvLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIG5leHRMaW5lLnRleHQgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCByIG9mIGJsb2NrLnJhbmdlcylcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5hbmNob3IgLSBzaXplLCByLmhlYWQgLSBzaXplKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbkluZGV4KSxcbiAgICAgICAgdXNlckV2ZW50OiBcIm1vdmUubGluZVwiXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3RlZCBsaW5lcyB1cCBvbmUgbGluZS5cbiovXG5jb25zdCBtb3ZlTGluZVVwID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3RlZCBsaW5lcyBkb3duIG9uZSBsaW5lLlxuKi9cbmNvbnN0IG1vdmVMaW5lRG93biA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBtb3ZlTGluZShzdGF0ZSwgZGlzcGF0Y2gsIHRydWUpO1xuZnVuY3Rpb24gY29weUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmb3J3YXJkKSB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBibG9jayBvZiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpKSB7XG4gICAgICAgIGlmIChmb3J3YXJkKVxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogYmxvY2suZnJvbSwgaW5zZXJ0OiBzdGF0ZS5kb2Muc2xpY2UoYmxvY2suZnJvbSwgYmxvY2sudG8pICsgc3RhdGUubGluZUJyZWFrIH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay50bywgaW5zZXJ0OiBzdGF0ZS5saW5lQnJlYWsgKyBzdGF0ZS5kb2Muc2xpY2UoYmxvY2suZnJvbSwgYmxvY2sudG8pIH0pO1xuICAgIH1cbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBjaGFuZ2VzLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0LmNvcHlsaW5lXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5DcmVhdGUgYSBjb3B5IG9mIHRoZSBzZWxlY3RlZCBsaW5lcy4gS2VlcCB0aGUgc2VsZWN0aW9uIGluIHRoZSB0b3AgY29weS5cbiovXG5jb25zdCBjb3B5TGluZVVwID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5DcmVhdGUgYSBjb3B5IG9mIHRoZSBzZWxlY3RlZCBsaW5lcy4gS2VlcCB0aGUgc2VsZWN0aW9uIGluIHRoZSBib3R0b20gY29weS5cbiovXG5jb25zdCBjb3B5TGluZURvd24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gY29weUxpbmUoc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbi8qKlxuRGVsZXRlIHNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IGRlbGV0ZUxpbmUgPSB2aWV3ID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlcyhzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpLm1hcCgoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgZWxzZSBpZiAodG8gPCBzdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgdG8rKztcbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8gfTtcbiAgICB9KSk7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIHRydWUpKS5tYXAoY2hhbmdlcyk7XG4gICAgdmlldy5kaXNwYXRjaCh7IGNoYW5nZXMsIHNlbGVjdGlvbiwgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJkZWxldGUubGluZVwiIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lLlxuKi9cbmNvbnN0IGluc2VydE5ld2xpbmUgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKHN0YXRlLmxpbmVCcmVhayksIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBpc0JldHdlZW5CcmFja2V0cyhzdGF0ZSwgcG9zKSB7XG4gICAgaWYgKC9cXChcXCl8XFxbXFxdfFxce1xcfS8udGVzdChzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MgKyAxKSkpXG4gICAgICAgIHJldHVybiB7IGZyb206IHBvcywgdG86IHBvcyB9O1xuICAgIGxldCBjb250ZXh0ID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcyk7XG4gICAgbGV0IGJlZm9yZSA9IGNvbnRleHQuY2hpbGRCZWZvcmUocG9zKSwgYWZ0ZXIgPSBjb250ZXh0LmNoaWxkQWZ0ZXIocG9zKSwgY2xvc2VkQnk7XG4gICAgaWYgKGJlZm9yZSAmJiBhZnRlciAmJiBiZWZvcmUudG8gPD0gcG9zICYmIGFmdGVyLmZyb20gPj0gcG9zICYmXG4gICAgICAgIChjbG9zZWRCeSA9IGJlZm9yZS50eXBlLnByb3AoTm9kZVByb3AuY2xvc2VkQnkpKSAmJiBjbG9zZWRCeS5pbmRleE9mKGFmdGVyLm5hbWUpID4gLTEgJiZcbiAgICAgICAgc3RhdGUuZG9jLmxpbmVBdChiZWZvcmUudG8pLmZyb20gPT0gc3RhdGUuZG9jLmxpbmVBdChhZnRlci5mcm9tKS5mcm9tKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBiZWZvcmUudG8sIHRvOiBhZnRlci5mcm9tIH07XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcblJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZSBhbmQgaW5kZW50IHRoZSBuZXdseSBjcmVhdGVkXG5saW5lKHMpLiBJZiB0aGUgY3VycmVudCBsaW5lIGNvbnNpc3RzIG9ubHkgb2Ygd2hpdGVzcGFjZSwgdGhpc1xud2lsbCBhbHNvIGRlbGV0ZSB0aGF0IHdoaXRlc3BhY2UuIFdoZW4gdGhlIGN1cnNvciBpcyBiZXR3ZWVuXG5tYXRjaGluZyBicmFja2V0cywgYW4gYWRkaXRpb25hbCBuZXdsaW5lIHdpbGwgYmUgaW5zZXJ0ZWQgYWZ0ZXJcbnRoZSBjdXJzb3IuXG4qL1xuY29uc3QgaW5zZXJ0TmV3bGluZUFuZEluZGVudCA9IC8qQF9fUFVSRV9fKi9uZXdsaW5lQW5kSW5kZW50KGZhbHNlKTtcbi8qKlxuQ3JlYXRlIGEgYmxhbmssIGluZGVudGVkIGxpbmUgYmVsb3cgdGhlIGN1cnJlbnQgbGluZS5cbiovXG5jb25zdCBpbnNlcnRCbGFua0xpbmUgPSAvKkBfX1BVUkVfXyovbmV3bGluZUFuZEluZGVudCh0cnVlKTtcbmZ1bmN0aW9uIG5ld2xpbmVBbmRJbmRlbnQoYXRFb2YpIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlLCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKTtcbiAgICAgICAgICAgIGxldCBleHBsb2RlID0gIWF0RW9mICYmIGZyb20gPT0gdG8gJiYgaXNCZXR3ZWVuQnJhY2tldHMoc3RhdGUsIGZyb20pO1xuICAgICAgICAgICAgaWYgKGF0RW9mKVxuICAgICAgICAgICAgICAgIGZyb20gPSB0byA9ICh0byA8PSBsaW5lLnRvID8gbGluZSA6IHN0YXRlLmRvYy5saW5lQXQodG8pKS50bztcbiAgICAgICAgICAgIGxldCBjeCA9IG5ldyBJbmRlbnRDb250ZXh0KHN0YXRlLCB7IHNpbXVsYXRlQnJlYWs6IGZyb20sIHNpbXVsYXRlRG91YmxlQnJlYWs6ICEhZXhwbG9kZSB9KTtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihjeCwgZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaW5kZW50ID0gL15cXHMqLy5leGVjKHN0YXRlLmRvYy5saW5lQXQoZnJvbSkudGV4dClbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHRvIDwgbGluZS50byAmJiAvXFxzLy50ZXN0KGxpbmUudGV4dFt0byAtIGxpbmUuZnJvbV0pKVxuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICBpZiAoZXhwbG9kZSlcbiAgICAgICAgICAgICAgICAoeyBmcm9tLCB0byB9ID0gZXhwbG9kZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tID4gbGluZS5mcm9tICYmIGZyb20gPCBsaW5lLmZyb20gKyAxMDAgJiYgIS9cXFMvLnRlc3QobGluZS50ZXh0LnNsaWNlKDAsIGZyb20pKSlcbiAgICAgICAgICAgICAgICBmcm9tID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IFtcIlwiLCBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCldO1xuICAgICAgICAgICAgaWYgKGV4cGxvZGUpXG4gICAgICAgICAgICAgICAgaW5zZXJ0LnB1c2goaW5kZW50U3RyaW5nKHN0YXRlLCBjeC5saW5lSW5kZW50KGxpbmUuZnJvbSwgLTEpKSk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb20sIHRvLCBpbnNlcnQ6IFRleHQub2YoaW5zZXJ0KSB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20gKyAxICsgaW5zZXJ0WzFdLmxlbmd0aCkgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgZikge1xuICAgIGxldCBhdExpbmUgPSAtMTtcbiAgICByZXR1cm4gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHJhbmdlLmZyb207IHBvcyA8PSByYW5nZS50bzspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID4gYXRMaW5lICYmIChyYW5nZS5lbXB0eSB8fCByYW5nZS50byA+IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBmKGxpbmUsIGNoYW5nZXMsIHJhbmdlKTtcbiAgICAgICAgICAgICAgICBhdExpbmUgPSBsaW5lLm51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGFuZ2VTZXQgPSBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzLFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShjaGFuZ2VTZXQubWFwUG9zKHJhbmdlLmFuY2hvciwgMSksIGNoYW5nZVNldC5tYXBQb3MocmFuZ2UuaGVhZCwgMSkpIH07XG4gICAgfSk7XG59XG4vKipcbkF1dG8taW5kZW50IHRoZSBzZWxlY3RlZCBsaW5lcy4gVGhpcyB1c2VzIHRoZSBbaW5kZW50YXRpb24gc2VydmljZVxuZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U2VydmljZSkgYXMgc291cmNlIGZvciBhdXRvLWluZGVudFxuaW5mb3JtYXRpb24uXG4qL1xuY29uc3QgaW5kZW50U2VsZWN0aW9uID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdXBkYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBvdmVycmlkZUluZGVudGF0aW9uOiBzdGFydCA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB1cGRhdGVkW3N0YXJ0XTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZCA9PSBudWxsID8gLTEgOiBmb3VuZDtcbiAgICAgICAgfSB9KTtcbiAgICBsZXQgY2hhbmdlcyA9IGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcywgcmFuZ2UpID0+IHtcbiAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKGNvbnRleHQsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGxpbmUudGV4dCkpXG4gICAgICAgICAgICBpbmRlbnQgPSAwO1xuICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGxldCBub3JtID0gaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpO1xuICAgICAgICBpZiAoY3VyICE9IG5vcm0gfHwgcmFuZ2UuZnJvbSA8IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRbbGluZS5mcm9tXSA9IGluZGVudDtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgsIGluc2VydDogbm9ybSB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyB1c2VyRXZlbnQ6IFwiaW5kZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQWRkIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gdG8gYWxsIHNlbGVjdGVkXG5saW5lcy5cbiovXG5jb25zdCBpbmRlbnRNb3JlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgaW5zZXJ0OiBzdGF0ZS5mYWNldChpbmRlbnRVbml0KSB9KTtcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiaW5wdXQuaW5kZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVtb3ZlIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gZnJvbSBhbGxcbnNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IGluZGVudExlc3MgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgKGxpbmUsIGNoYW5nZXMpID0+IHtcbiAgICAgICAgbGV0IHNwYWNlID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGlmICghc3BhY2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb2wgPSBjb3VudENvbHVtbihzcGFjZSwgc3RhdGUudGFiU2l6ZSksIGtlZXAgPSAwO1xuICAgICAgICBsZXQgaW5zZXJ0ID0gaW5kZW50U3RyaW5nKHN0YXRlLCBNYXRoLm1heCgwLCBjb2wgLSBnZXRJbmRlbnRVbml0KHN0YXRlKSkpO1xuICAgICAgICB3aGlsZSAoa2VlcCA8IHNwYWNlLmxlbmd0aCAmJiBrZWVwIDwgaW5zZXJ0Lmxlbmd0aCAmJiBzcGFjZS5jaGFyQ29kZUF0KGtlZXApID09IGluc2VydC5jaGFyQ29kZUF0KGtlZXApKVxuICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20gKyBrZWVwLCB0bzogbGluZS5mcm9tICsgc3BhY2UubGVuZ3RoLCBpbnNlcnQ6IGluc2VydC5zbGljZShrZWVwKSB9KTtcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiZGVsZXRlLmRlZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkluc2VydCBhIHRhYiBjaGFyYWN0ZXIgYXQgdGhlIGN1cnNvciBvciwgaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkLFxudXNlIFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSkgdG8gaW5kZW50IHRoZSBlbnRpcmVcbnNlbGVjdGlvbi5cbiovXG5jb25zdCBpbnNlcnRUYWIgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiAhci5lbXB0eSkpXG4gICAgICAgIHJldHVybiBpbmRlbnRNb3JlKHsgc3RhdGUsIGRpc3BhdGNoIH0pO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKFwiXFx0XCIpLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BcnJheSBvZiBrZXkgYmluZGluZ3MgY29udGFpbmluZyB0aGUgRW1hY3Mtc3R5bGUgYmluZGluZ3MgdGhhdCBhcmVcbmF2YWlsYWJsZSBvbiBtYWNPUyBieSBkZWZhdWx0LlxuXG4gLSBDdHJsLWI6IFtgY3Vyc29yQ2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJMZWZ0KSAoW2BzZWxlY3RDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhckxlZnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWY6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1wOiBbYGN1cnNvckxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVVwKSAoW2BzZWxlY3RMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtbjogW2BjdXJzb3JMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZURvd24pIChbYHNlbGVjdExpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRG93bikgd2l0aCBTaGlmdClcbiAtIEN0cmwtYTogW2BjdXJzb3JMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVTdGFydCkgKFtgc2VsZWN0TGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWU6IFtgY3Vyc29yTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUVuZCkgKFtgc2VsZWN0TGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUVuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtZDogW2BkZWxldGVDaGFyRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckZvcndhcmQpXG4gLSBDdHJsLWg6IFtgZGVsZXRlQ2hhckJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyQmFja3dhcmQpXG4gLSBDdHJsLWs6IFtgZGVsZXRlVG9MaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVFbmQpXG4gLSBDdHJsLUFsdC1oOiBbYGRlbGV0ZUdyb3VwQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwQmFja3dhcmQpXG4gLSBDdHJsLW86IFtgc3BsaXRMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdExpbmUpXG4gLSBDdHJsLXQ6IFtgdHJhbnNwb3NlQ2hhcnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRyYW5zcG9zZUNoYXJzKVxuIC0gQ3RybC12OiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bilcbiAtIEFsdC12OiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKVxuKi9cbmNvbnN0IGVtYWNzU3R5bGVLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1iXCIsIHJ1bjogY3Vyc29yQ2hhckxlZnQsIHNoaWZ0OiBzZWxlY3RDaGFyTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJDdHJsLWZcIiwgcnVuOiBjdXJzb3JDaGFyUmlnaHQsIHNoaWZ0OiBzZWxlY3RDaGFyUmlnaHQgfSxcbiAgICB7IGtleTogXCJDdHJsLXBcIiwgcnVuOiBjdXJzb3JMaW5lVXAsIHNoaWZ0OiBzZWxlY3RMaW5lVXAgfSxcbiAgICB7IGtleTogXCJDdHJsLW5cIiwgcnVuOiBjdXJzb3JMaW5lRG93biwgc2hpZnQ6IHNlbGVjdExpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1hXCIsIHJ1bjogY3Vyc29yTGluZVN0YXJ0LCBzaGlmdDogc2VsZWN0TGluZVN0YXJ0IH0sXG4gICAgeyBrZXk6IFwiQ3RybC1lXCIsIHJ1bjogY3Vyc29yTGluZUVuZCwgc2hpZnQ6IHNlbGVjdExpbmVFbmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWRcIiwgcnVuOiBkZWxldGVDaGFyRm9yd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtaFwiLCBydW46IGRlbGV0ZUNoYXJCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwta1wiLCBydW46IGRlbGV0ZVRvTGluZUVuZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LWhcIiwgcnVuOiBkZWxldGVHcm91cEJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1vXCIsIHJ1bjogc3BsaXRMaW5lIH0sXG4gICAgeyBrZXk6IFwiQ3RybC10XCIsIHJ1bjogdHJhbnNwb3NlQ2hhcnMgfSxcbiAgICB7IGtleTogXCJDdHJsLXZcIiwgcnVuOiBjdXJzb3JQYWdlRG93biB9LFxuXTtcbi8qKlxuQW4gYXJyYXkgb2Yga2V5IGJpbmRpbmdzIGNsb3NlbHkgc3RpY2tpbmcgdG8gcGxhdGZvcm0tc3RhbmRhcmQgb3JcbndpZGVseSB1c2VkIGJpbmRpbmdzLiAoVGhpcyBpbmNsdWRlcyB0aGUgYmluZGluZ3MgZnJvbVxuW2BlbWFjc1N0eWxlS2V5bWFwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5lbWFjc1N0eWxlS2V5bWFwKSwgd2l0aCB0aGVpciBga2V5YFxucHJvcGVydHkgY2hhbmdlZCB0byBgbWFjYC4pXG5cbiAtIEFycm93TGVmdDogW2BjdXJzb3JDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhckxlZnQpIChbYHNlbGVjdENoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyTGVmdCkgd2l0aCBTaGlmdClcbiAtIEFycm93UmlnaHQ6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd0xlZnQgKEFsdC1BcnJvd0xlZnQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBMZWZ0KSAoW2BzZWxlY3RHcm91cExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwTGVmdCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dSaWdodCAoQWx0LUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwUmlnaHQpIChbYHNlbGVjdEdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwUmlnaHQpIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dMZWZ0IChvbiBtYWNPUyk6IFtgY3Vyc29yTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lU3RhcnQpIChbYHNlbGVjdExpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVN0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93UmlnaHQgKG9uIG1hY09TKTogW2BjdXJzb3JMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRW5kKSAoW2BzZWxlY3RMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRW5kKSB3aXRoIFNoaWZ0KVxuIC0gQXJyb3dVcDogW2BjdXJzb3JMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVVcCkgKFtgc2VsZWN0TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lVXApIHdpdGggU2hpZnQpXG4gLSBBcnJvd0Rvd246IFtgY3Vyc29yTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVEb3duKSAoW2BzZWxlY3RMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZURvd24pIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dVcCAob24gbWFjT1MpOiBbYGN1cnNvckRvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NTdGFydCkgKFtgc2VsZWN0RG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY1N0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93RG93biAob24gbWFjT1MpOiBbYGN1cnNvckRvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jRW5kKSAoW2BzZWxlY3REb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY0VuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dVcCAob24gbWFjT1MpOiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKSAoW2BzZWxlY3RQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dEb3duIChvbiBtYWNPUyk6IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKSAoW2BzZWxlY3RQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZURvd24pIHdpdGggU2hpZnQpXG4gLSBQYWdlVXA6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApIChbYHNlbGVjdFBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZVVwKSB3aXRoIFNoaWZ0KVxuIC0gUGFnZURvd246IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKSAoW2BzZWxlY3RQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZURvd24pIHdpdGggU2hpZnQpXG4gLSBIb21lOiBbYGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCkgKFtgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkKSB3aXRoIFNoaWZ0KVxuIC0gRW5kOiBbYGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQpIChbYHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUhvbWUgKENtZC1Ib21lIG9uIG1hY09TKTogW2BjdXJzb3JEb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jU3RhcnQpIChbYHNlbGVjdERvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NTdGFydCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtRW5kIChDbWQtSG9tZSBvbiBtYWNPUyk6IFtgY3Vyc29yRG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NFbmQpIChbYHNlbGVjdERvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jRW5kKSB3aXRoIFNoaWZ0KVxuIC0gRW50ZXI6IFtgaW5zZXJ0TmV3bGluZUFuZEluZGVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5zZXJ0TmV3bGluZUFuZEluZGVudClcbiAtIEN0cmwtYSAoQ21kLWEgb24gbWFjT1MpOiBbYHNlbGVjdEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0QWxsKVxuIC0gQmFja3NwYWNlOiBbYGRlbGV0ZUNoYXJCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckJhY2t3YXJkKVxuIC0gRGVsZXRlOiBbYGRlbGV0ZUNoYXJGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyRm9yd2FyZClcbiAtIEN0cmwtQmFja3NwYWNlIChBbHQtQmFja3NwYWNlIG9uIG1hY09TKTogW2BkZWxldGVHcm91cEJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVHcm91cEJhY2t3YXJkKVxuIC0gQ3RybC1EZWxldGUgKEFsdC1EZWxldGUgb24gbWFjT1MpOiBbYGRlbGV0ZUdyb3VwRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlR3JvdXBGb3J3YXJkKVxuIC0gQ21kLUJhY2tzcGFjZSAobWFjT1MpOiBbYGRlbGV0ZVRvTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVTdGFydCkuXG4gLSBDbWQtRGVsZXRlIChtYWNPUyk6IFtgZGVsZXRlVG9MaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVFbmQpLlxuKi9cbmNvbnN0IHN0YW5kYXJkS2V5bWFwID0gLypAX19QVVJFX18qL1tcbiAgICB7IGtleTogXCJBcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JDaGFyTGVmdCwgc2hpZnQ6IHNlbGVjdENoYXJMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BcnJvd0xlZnRcIiwgbWFjOiBcIkFsdC1BcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JHcm91cExlZnQsIHNoaWZ0OiBzZWxlY3RHcm91cExlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93TGVmdFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUxlZnQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JDaGFyUmlnaHQsIHNoaWZ0OiBzZWxlY3RDaGFyUmlnaHQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFycm93UmlnaHRcIiwgbWFjOiBcIkFsdC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yR3JvdXBSaWdodCwgc2hpZnQ6IHNlbGVjdEdyb3VwUmlnaHQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlSaWdodCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeVJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFycm93VXBcIiwgcnVuOiBjdXJzb3JMaW5lVXAsIHNoaWZ0OiBzZWxlY3RMaW5lVXAsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93VXBcIiwgcnVuOiBjdXJzb3JEb2NTdGFydCwgc2hpZnQ6IHNlbGVjdERvY1N0YXJ0IH0sXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd1VwXCIsIHJ1bjogY3Vyc29yUGFnZVVwLCBzaGlmdDogc2VsZWN0UGFnZVVwIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yTGluZURvd24sIHNoaWZ0OiBzZWxlY3RMaW5lRG93biwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yRG9jRW5kLCBzaGlmdDogc2VsZWN0RG9jRW5kIH0sXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JQYWdlRG93biwgc2hpZnQ6IHNlbGVjdFBhZ2VEb3duIH0sXG4gICAgeyBrZXk6IFwiUGFnZVVwXCIsIHJ1bjogY3Vyc29yUGFnZVVwLCBzaGlmdDogc2VsZWN0UGFnZVVwIH0sXG4gICAgeyBrZXk6IFwiUGFnZURvd25cIiwgcnVuOiBjdXJzb3JQYWdlRG93biwgc2hpZnQ6IHNlbGVjdFBhZ2VEb3duIH0sXG4gICAgeyBrZXk6IFwiSG9tZVwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkLCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUhvbWVcIiwgcnVuOiBjdXJzb3JEb2NTdGFydCwgc2hpZnQ6IHNlbGVjdERvY1N0YXJ0IH0sXG4gICAgeyBrZXk6IFwiRW5kXCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUVuZFwiLCBydW46IGN1cnNvckRvY0VuZCwgc2hpZnQ6IHNlbGVjdERvY0VuZCB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIHJ1bjogaW5zZXJ0TmV3bGluZUFuZEluZGVudCB9LFxuICAgIHsga2V5OiBcIk1vZC1hXCIsIHJ1bjogc2VsZWN0QWxsIH0sXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlQ2hhckJhY2t3YXJkLCBzaGlmdDogZGVsZXRlQ2hhckJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiRGVsZXRlXCIsIHJ1bjogZGVsZXRlQ2hhckZvcndhcmQgfSxcbiAgICB7IGtleTogXCJNb2QtQmFja3NwYWNlXCIsIG1hYzogXCJBbHQtQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlR3JvdXBCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIk1vZC1EZWxldGVcIiwgbWFjOiBcIkFsdC1EZWxldGVcIiwgcnVuOiBkZWxldGVHcm91cEZvcndhcmQgfSxcbiAgICB7IG1hYzogXCJNb2QtQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlVG9MaW5lU3RhcnQgfSxcbiAgICB7IG1hYzogXCJNb2QtRGVsZXRlXCIsIHJ1bjogZGVsZXRlVG9MaW5lRW5kIH1cbl0uY29uY2F0KC8qQF9fUFVSRV9fKi9lbWFjc1N0eWxlS2V5bWFwLm1hcChiID0+ICh7IG1hYzogYi5rZXksIHJ1bjogYi5ydW4sIHNoaWZ0OiBiLnNoaWZ0IH0pKSk7XG4vKipcblRoZSBkZWZhdWx0IGtleW1hcC4gSW5jbHVkZXMgYWxsIGJpbmRpbmdzIGZyb21cbltgc3RhbmRhcmRLZXltYXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnN0YW5kYXJkS2V5bWFwKSBwbHVzIHRoZSBmb2xsb3dpbmc6XG5cbi0gQWx0LUFycm93TGVmdCAoQ3RybC1BcnJvd0xlZnQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclN5bnRheExlZnQpIChbYHNlbGVjdFN5bnRheExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheExlZnQpIHdpdGggU2hpZnQpXG4tIEFsdC1BcnJvd1JpZ2h0IChDdHJsLUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JTeW50YXhSaWdodCkgKFtgc2VsZWN0U3ludGF4UmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheFJpZ2h0KSB3aXRoIFNoaWZ0KVxuLSBBbHQtQXJyb3dVcDogW2Btb3ZlTGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5tb3ZlTGluZVVwKVxuLSBBbHQtQXJyb3dEb3duOiBbYG1vdmVMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMubW92ZUxpbmVEb3duKVxuLSBTaGlmdC1BbHQtQXJyb3dVcDogW2Bjb3B5TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jb3B5TGluZVVwKVxuLSBTaGlmdC1BbHQtQXJyb3dEb3duOiBbYGNvcHlMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY29weUxpbmVEb3duKVxuLSBFc2NhcGU6IFtgc2ltcGxpZnlTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNpbXBsaWZ5U2VsZWN0aW9uKVxuLSBDdHJsLUVudGVyIChDb21kLUVudGVyIG9uIG1hY09TKTogW2BpbnNlcnRCbGFua0xpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluc2VydEJsYW5rTGluZSlcbi0gQWx0LWwgKEN0cmwtbCBvbiBtYWNPUyk6IFtgc2VsZWN0TGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZSlcbi0gQ3RybC1pIChDbWQtaSBvbiBtYWNPUyk6IFtgc2VsZWN0UGFyZW50U3ludGF4YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYXJlbnRTeW50YXgpXG4tIEN0cmwtWyAoQ21kLVsgb24gbWFjT1MpOiBbYGluZGVudExlc3NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudExlc3MpXG4tIEN0cmwtXSAoQ21kLV0gb24gbWFjT1MpOiBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpXG4tIEN0cmwtQWx0LVxcXFwgKENtZC1BbHQtXFxcXCBvbiBtYWNPUyk6IFtgaW5kZW50U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRTZWxlY3Rpb24pXG4tIFNoaWZ0LUN0cmwtayAoU2hpZnQtQ21kLWsgb24gbWFjT1MpOiBbYGRlbGV0ZUxpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUxpbmUpXG4tIFNoaWZ0LUN0cmwtXFxcXCAoU2hpZnQtQ21kLVxcXFwgb24gbWFjT1MpOiBbYGN1cnNvck1hdGNoaW5nQnJhY2tldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTWF0Y2hpbmdCcmFja2V0KVxuLSBDdHJsLS8gKENtZC0vIG9uIG1hY09TKTogW2B0b2dnbGVDb21tZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50b2dnbGVDb21tZW50KS5cbi0gU2hpZnQtQWx0LWE6IFtgdG9nZ2xlQmxvY2tDb21tZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50b2dnbGVCbG9ja0NvbW1lbnQpLlxuKi9cbmNvbnN0IGRlZmF1bHRLZXltYXAgPSAvKkBfX1BVUkVfXyovW1xuICAgIHsga2V5OiBcIkFsdC1BcnJvd0xlZnRcIiwgbWFjOiBcIkN0cmwtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yU3ludGF4TGVmdCwgc2hpZnQ6IHNlbGVjdFN5bnRheExlZnQgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dSaWdodFwiLCBtYWM6IFwiQ3RybC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yU3ludGF4UmlnaHQsIHNoaWZ0OiBzZWxlY3RTeW50YXhSaWdodCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd1VwXCIsIHJ1bjogbW92ZUxpbmVVcCB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LUFsdC1BcnJvd1VwXCIsIHJ1bjogY29weUxpbmVVcCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd0Rvd25cIiwgcnVuOiBtb3ZlTGluZURvd24gfSxcbiAgICB7IGtleTogXCJTaGlmdC1BbHQtQXJyb3dEb3duXCIsIHJ1bjogY29weUxpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogc2ltcGxpZnlTZWxlY3Rpb24gfSxcbiAgICB7IGtleTogXCJNb2QtRW50ZXJcIiwgcnVuOiBpbnNlcnRCbGFua0xpbmUgfSxcbiAgICB7IGtleTogXCJBbHQtbFwiLCBtYWM6IFwiQ3RybC1sXCIsIHJ1bjogc2VsZWN0TGluZSB9LFxuICAgIHsga2V5OiBcIk1vZC1pXCIsIHJ1bjogc2VsZWN0UGFyZW50U3ludGF4LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1bXCIsIHJ1bjogaW5kZW50TGVzcyB9LFxuICAgIHsga2V5OiBcIk1vZC1dXCIsIHJ1bjogaW5kZW50TW9yZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BbHQtXFxcXFwiLCBydW46IGluZGVudFNlbGVjdGlvbiB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LU1vZC1rXCIsIHJ1bjogZGVsZXRlTGluZSB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LU1vZC1cXFxcXCIsIHJ1bjogY3Vyc29yTWF0Y2hpbmdCcmFja2V0IH0sXG4gICAgeyBrZXk6IFwiTW9kLS9cIiwgcnVuOiB0b2dnbGVDb21tZW50IH0sXG4gICAgeyBrZXk6IFwiQWx0LUFcIiwgcnVuOiB0b2dnbGVCbG9ja0NvbW1lbnQgfVxuXS5jb25jYXQoc3RhbmRhcmRLZXltYXApO1xuLyoqXG5BIGJpbmRpbmcgdGhhdCBiaW5kcyBUYWIgdG8gW2BpbmRlbnRNb3JlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRNb3JlKSBhbmRcblNoaWZ0LVRhYiB0byBbYGluZGVudExlc3NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudExlc3MpLlxuUGxlYXNlIHNlZSB0aGUgW1RhYiBleGFtcGxlXSguLi8uLi9leGFtcGxlcy90YWIvKSBiZWZvcmUgdXNpbmdcbnRoaXMuXG4qL1xuY29uc3QgaW5kZW50V2l0aFRhYiA9IHsga2V5OiBcIlRhYlwiLCBydW46IGluZGVudE1vcmUsIHNoaWZ0OiBpbmRlbnRMZXNzIH07XG5cbmV4cG9ydCB7IGJsb2NrQ29tbWVudCwgYmxvY2tVbmNvbW1lbnQsIGNvcHlMaW5lRG93biwgY29weUxpbmVVcCwgY3Vyc29yQ2hhckJhY2t3YXJkLCBjdXJzb3JDaGFyRm9yd2FyZCwgY3Vyc29yQ2hhckxlZnQsIGN1cnNvckNoYXJSaWdodCwgY3Vyc29yRG9jRW5kLCBjdXJzb3JEb2NTdGFydCwgY3Vyc29yR3JvdXBCYWNrd2FyZCwgY3Vyc29yR3JvdXBGb3J3YXJkLCBjdXJzb3JHcm91cExlZnQsIGN1cnNvckdyb3VwUmlnaHQsIGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkLCBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkLCBjdXJzb3JMaW5lQm91bmRhcnlMZWZ0LCBjdXJzb3JMaW5lQm91bmRhcnlSaWdodCwgY3Vyc29yTGluZURvd24sIGN1cnNvckxpbmVFbmQsIGN1cnNvckxpbmVTdGFydCwgY3Vyc29yTGluZVVwLCBjdXJzb3JNYXRjaGluZ0JyYWNrZXQsIGN1cnNvclBhZ2VEb3duLCBjdXJzb3JQYWdlVXAsIGN1cnNvclN1YndvcmRCYWNrd2FyZCwgY3Vyc29yU3Vid29yZEZvcndhcmQsIGN1cnNvclN5bnRheExlZnQsIGN1cnNvclN5bnRheFJpZ2h0LCBkZWZhdWx0S2V5bWFwLCBkZWxldGVDaGFyQmFja3dhcmQsIGRlbGV0ZUNoYXJGb3J3YXJkLCBkZWxldGVHcm91cEJhY2t3YXJkLCBkZWxldGVHcm91cEZvcndhcmQsIGRlbGV0ZUxpbmUsIGRlbGV0ZVRvTGluZUVuZCwgZGVsZXRlVG9MaW5lU3RhcnQsIGRlbGV0ZVRyYWlsaW5nV2hpdGVzcGFjZSwgZW1hY3NTdHlsZUtleW1hcCwgaGlzdG9yeSwgaGlzdG9yeUZpZWxkLCBoaXN0b3J5S2V5bWFwLCBpbmRlbnRMZXNzLCBpbmRlbnRNb3JlLCBpbmRlbnRTZWxlY3Rpb24sIGluZGVudFdpdGhUYWIsIGluc2VydEJsYW5rTGluZSwgaW5zZXJ0TmV3bGluZSwgaW5zZXJ0TmV3bGluZUFuZEluZGVudCwgaW5zZXJ0VGFiLCBpbnZlcnRlZEVmZmVjdHMsIGlzb2xhdGVIaXN0b3J5LCBsaW5lQ29tbWVudCwgbGluZVVuY29tbWVudCwgbW92ZUxpbmVEb3duLCBtb3ZlTGluZVVwLCByZWRvLCByZWRvRGVwdGgsIHJlZG9TZWxlY3Rpb24sIHNlbGVjdEFsbCwgc2VsZWN0Q2hhckJhY2t3YXJkLCBzZWxlY3RDaGFyRm9yd2FyZCwgc2VsZWN0Q2hhckxlZnQsIHNlbGVjdENoYXJSaWdodCwgc2VsZWN0RG9jRW5kLCBzZWxlY3REb2NTdGFydCwgc2VsZWN0R3JvdXBCYWNrd2FyZCwgc2VsZWN0R3JvdXBGb3J3YXJkLCBzZWxlY3RHcm91cExlZnQsIHNlbGVjdEdyb3VwUmlnaHQsIHNlbGVjdExpbmUsIHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkLCBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkLCBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0LCBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCwgc2VsZWN0TGluZURvd24sIHNlbGVjdExpbmVFbmQsIHNlbGVjdExpbmVTdGFydCwgc2VsZWN0TGluZVVwLCBzZWxlY3RNYXRjaGluZ0JyYWNrZXQsIHNlbGVjdFBhZ2VEb3duLCBzZWxlY3RQYWdlVXAsIHNlbGVjdFBhcmVudFN5bnRheCwgc2VsZWN0U3Vid29yZEJhY2t3YXJkLCBzZWxlY3RTdWJ3b3JkRm9yd2FyZCwgc2VsZWN0U3ludGF4TGVmdCwgc2VsZWN0U3ludGF4UmlnaHQsIHNpbXBsaWZ5U2VsZWN0aW9uLCBzcGxpdExpbmUsIHN0YW5kYXJkS2V5bWFwLCB0b2dnbGVCbG9ja0NvbW1lbnQsIHRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSwgdG9nZ2xlQ29tbWVudCwgdG9nZ2xlTGluZUNvbW1lbnQsIHRyYW5zcG9zZUNoYXJzLCB1bmRvLCB1bmRvRGVwdGgsIHVuZG9TZWxlY3Rpb24gfTtcbiIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVsdCgpIHtcbiAgdmFyIGVsdCA9IGFyZ3VtZW50c1swXVxuICBpZiAodHlwZW9mIGVsdCA9PSBcInN0cmluZ1wiKSBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsdClcbiAgdmFyIGkgPSAxLCBuZXh0ID0gYXJndW1lbnRzWzFdXG4gIGlmIChuZXh0ICYmIHR5cGVvZiBuZXh0ID09IFwib2JqZWN0XCIgJiYgbmV4dC5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBuZXh0KSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHQsIG5hbWUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBuZXh0W25hbWVdXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIGVsdC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSBlbHRbbmFtZV0gPSB2YWx1ZVxuICAgIH1cbiAgICBpKytcbiAgfVxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYWRkKGVsdCwgYXJndW1lbnRzW2ldKVxuICByZXR1cm4gZWx0XG59XG5cbmZ1bmN0aW9uIGFkZChlbHQsIGNoaWxkKSB7XG4gIGlmICh0eXBlb2YgY2hpbGQgPT0gXCJzdHJpbmdcIikge1xuICAgIGVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZCkpXG4gIH0gZWxzZSBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICB9IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlICE9IG51bGwpIHtcbiAgICBlbHQuYXBwZW5kQ2hpbGQoY2hpbGQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkLmxlbmd0aDsgaSsrKSBhZGQoZWx0LCBjaGlsZFtpXSlcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVuc3VwcG9ydGVkIGNoaWxkIG5vZGU6IFwiICsgY2hpbGQpXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBzaG93UGFuZWwsIEVkaXRvclZpZXcsIGdldFBhbmVsLCBEZWNvcmF0aW9uLCBWaWV3UGx1Z2luLCBydW5TY29wZUhhbmRsZXJzIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBjb2RlUG9pbnRBdCwgZnJvbUNvZGVQb2ludCwgY29kZVBvaW50U2l6ZSwgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEVkaXRvclNlbGVjdGlvbiwgRmFjZXQsIGNvbWJpbmVDb25maWcsIENoYXJDYXRlZ29yeSwgUmFuZ2VTZXRCdWlsZGVyLCBQcmVjLCBFZGl0b3JTdGF0ZSwgZmluZENsdXN0ZXJCcmVhayB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCBlbHQgZnJvbSAnY3JlbHQnO1xuXG5jb25zdCBiYXNpY05vcm1hbGl6ZSA9IHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZSA9PSBcImZ1bmN0aW9uXCJcbiAgICA/IHggPT4geC5ub3JtYWxpemUoXCJORktEXCIpIDogeCA9PiB4O1xuLyoqXG5BIHNlYXJjaCBjdXJzb3IgcHJvdmlkZXMgYW4gaXRlcmF0b3Igb3ZlciB0ZXh0IG1hdGNoZXMgaW4gYVxuZG9jdW1lbnQuXG4qL1xuY2xhc3MgU2VhcmNoQ3Vyc29yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0ZXh0IGN1cnNvci4gVGhlIHF1ZXJ5IGlzIHRoZSBzZWFyY2ggc3RyaW5nLCBgZnJvbWAgdG9cbiAgICBgdG9gIHByb3ZpZGVzIHRoZSByZWdpb24gdG8gc2VhcmNoLlxuICAgIFxuICAgIFdoZW4gYG5vcm1hbGl6ZWAgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgY2FsbGVkLCBvbiBib3RoIHRoZSBxdWVyeVxuICAgIHN0cmluZyBhbmQgdGhlIGNvbnRlbnQgaXQgaXMgbWF0Y2hlZCBhZ2FpbnN0LCBiZWZvcmUgY29tcGFyaW5nLlxuICAgIFlvdSBjYW4sIGZvciBleGFtcGxlLCBjcmVhdGUgYSBjYXNlLWluc2Vuc2l0aXZlIHNlYXJjaCBieVxuICAgIHBhc3NpbmcgYHMgPT4gcy50b0xvd2VyQ2FzZSgpYC5cbiAgICBcbiAgICBUZXh0IGlzIGFsd2F5cyBub3JtYWxpemVkIHdpdGhcbiAgICBbYC5ub3JtYWxpemUoXCJORktEXCIpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL25vcm1hbGl6ZSlcbiAgICAod2hlbiBzdXBwb3J0ZWQpLlxuICAgICovXG4gICAgY29uc3RydWN0b3IodGV4dCwgcXVlcnksIGZyb20gPSAwLCB0byA9IHRleHQubGVuZ3RoLCBub3JtYWxpemUsIHRlc3QpIHtcbiAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBjdXJyZW50IG1hdGNoIChvbmx5IGhvbGRzIGEgbWVhbmluZ2Z1bCB2YWx1ZSBhZnRlclxuICAgICAgICBbYG5leHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IubmV4dCkgaGFzIGJlZW4gY2FsbGVkIGFuZCB3aGVuXG4gICAgICAgIGBkb25lYCBpcyBmYWxzZSkuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb206IDAsIHRvOiAwIH07XG4gICAgICAgIC8qKlxuICAgICAgICBXaGV0aGVyIHRoZSBlbmQgb2YgdGhlIGl0ZXJhdGVkIHJlZ2lvbiBoYXMgYmVlbiByZWFjaGVkLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gW107XG4gICAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICAgICAgdGhpcy5idWZmZXJQb3MgPSAwO1xuICAgICAgICB0aGlzLml0ZXIgPSB0ZXh0Lml0ZXJSYW5nZShmcm9tLCB0byk7XG4gICAgICAgIHRoaXMuYnVmZmVyU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZSA/IHggPT4gbm9ybWFsaXplKGJhc2ljTm9ybWFsaXplKHgpKSA6IGJhc2ljTm9ybWFsaXplO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5ub3JtYWxpemUocXVlcnkpO1xuICAgIH1cbiAgICBwZWVrKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXJQb3MgPT0gdGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclN0YXJ0ICs9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuaXRlci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJQb3MgPSAwO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLml0ZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludEF0KHRoaXMuYnVmZmVyLCB0aGlzLmJ1ZmZlclBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgZm9yIHRoZSBuZXh0IG1hdGNoLiBVcGRhdGVzIHRoZSBpdGVyYXRvcidzXG4gICAgW2B2YWx1ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvci52YWx1ZSkgYW5kXG4gICAgW2Bkb25lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLmRvbmUpIHByb3BlcnRpZXMuIFNob3VsZCBiZSBjYWxsZWRcbiAgICBhdCBsZWFzdCBvbmNlIGJlZm9yZSB1c2luZyB0aGUgY3Vyc29yLlxuICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2hlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLm1hdGNoZXMucG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRPdmVybGFwcGluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgYG5leHRgIG1ldGhvZCB3aWxsIGlnbm9yZSBtYXRjaGVzIHRoYXQgcGFydGlhbGx5IG92ZXJsYXAgYVxuICAgIHByZXZpb3VzIG1hdGNoLiBUaGlzIG1ldGhvZCBiZWhhdmVzIGxpa2UgYG5leHRgLCBidXQgaW5jbHVkZXNcbiAgICBzdWNoIG1hdGNoZXMuXG4gICAgKi9cbiAgICBuZXh0T3ZlcmxhcHBpbmcoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5wZWVrKCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0ciA9IGZyb21Db2RlUG9pbnQobmV4dCksIHN0YXJ0ID0gdGhpcy5idWZmZXJTdGFydCArIHRoaXMuYnVmZmVyUG9zO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJQb3MgKz0gY29kZVBvaW50U2l6ZShuZXh0KTtcbiAgICAgICAgICAgIGxldCBub3JtID0gdGhpcy5ub3JtYWxpemUoc3RyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBzdGFydDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjb2RlID0gbm9ybS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMubWF0Y2goY29kZSwgcG9zKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gbm9ybS5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAocG9zID09IHN0YXJ0ICYmIGkgPCBzdHIubGVuZ3RoICYmIHN0ci5jaGFyQ29kZUF0KGkpID09IGNvZGUpXG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1hdGNoKGNvZGUsIHBvcykge1xuICAgICAgICBsZXQgbWF0Y2ggPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWF0Y2hlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5tYXRjaGVzW2ldLCBrZWVwID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeS5jaGFyQ29kZUF0KGluZGV4KSA9PSBjb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucXVlcnkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHsgZnJvbTogdGhpcy5tYXRjaGVzW2kgKyAxXSwgdG86IHBvcyArIDEgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlc1tpXSsrO1xuICAgICAgICAgICAgICAgICAgICBrZWVwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtlZXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5xdWVyeS5jaGFyQ29kZUF0KDApID09IGNvZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5Lmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIG1hdGNoID0geyBmcm9tOiBwb3MsIHRvOiBwb3MgKyAxIH07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnB1c2goMSwgcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2ggJiYgdGhpcy50ZXN0ICYmICF0aGlzLnRlc3QobWF0Y2guZnJvbSwgbWF0Y2gudG8sIHRoaXMuYnVmZmVyLCB0aGlzLmJ1ZmZlclBvcykpXG4gICAgICAgICAgICBtYXRjaCA9IG51bGw7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG59XG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKVxuICAgIFNlYXJjaEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbmNvbnN0IGVtcHR5ID0geyBmcm9tOiAtMSwgdG86IC0xLCBtYXRjaDogLypAX19QVVJFX18qLy8uKi8uZXhlYyhcIlwiKSB9O1xuY29uc3QgYmFzZUZsYWdzID0gXCJnbVwiICsgKC94Ly51bmljb2RlID09IG51bGwgPyBcIlwiIDogXCJ1XCIpO1xuLyoqXG5UaGlzIGNsYXNzIGlzIHNpbWlsYXIgdG8gW2BTZWFyY2hDdXJzb3JgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IpXG5idXQgc2VhcmNoZXMgZm9yIGEgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4gaW5zdGVhZCBvZiBhIHBsYWluXG5zdHJpbmcuXG4qL1xuY2xhc3MgUmVnRXhwQ3Vyc29yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBjdXJzb3IgdGhhdCB3aWxsIHNlYXJjaCB0aGUgZ2l2ZW4gcmFuZ2UgaW4gdGhlIGdpdmVuXG4gICAgZG9jdW1lbnQuIGBxdWVyeWAgc2hvdWxkIGJlIHRoZSByYXcgcGF0dGVybiAoYXMgeW91J2QgcGFzcyBpdCB0b1xuICAgIGBuZXcgUmVnRXhwYCkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgb3B0aW9ucywgZnJvbSA9IDAsIHRvID0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgU2V0IHRvIGB0cnVlYCB3aGVuIHRoZSBjdXJzb3IgaGFzIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgc2VhcmNoXG4gICAgICAgIHJhbmdlLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIFdpbGwgY29udGFpbiBhbiBvYmplY3Qgd2l0aCB0aGUgZXh0ZW50IG9mIHRoZSBtYXRjaCBhbmQgdGhlXG4gICAgICAgIG1hdGNoIG9iamVjdCB3aGVuIFtgbmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlJlZ0V4cEN1cnNvci5uZXh0KVxuICAgICAgICBzdWNlc3NmdWxseSBmaW5kcyBhIG1hdGNoLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gZW1wdHk7XG4gICAgICAgIGlmICgvXFxcXFtzV0Rucl18XFxufFxccnxcXFtcXF4vLnRlc3QocXVlcnkpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNdWx0aWxpbmVSZWdFeHBDdXJzb3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20sIHRvKTtcbiAgICAgICAgdGhpcy5yZSA9IG5ldyBSZWdFeHAocXVlcnksIGJhc2VGbGFncyArICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlnbm9yZUNhc2UpID8gXCJpXCIgOiBcIlwiKSk7XG4gICAgICAgIHRoaXMudGVzdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50ZXN0O1xuICAgICAgICB0aGlzLml0ZXIgPSB0ZXh0Lml0ZXIoKTtcbiAgICAgICAgbGV0IHN0YXJ0TGluZSA9IHRleHQubGluZUF0KGZyb20pO1xuICAgICAgICB0aGlzLmN1ckxpbmVTdGFydCA9IHN0YXJ0TGluZS5mcm9tO1xuICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRleHQsIGZyb20pO1xuICAgICAgICB0aGlzLmdldExpbmUodGhpcy5jdXJMaW5lU3RhcnQpO1xuICAgIH1cbiAgICBnZXRMaW5lKHNraXApIHtcbiAgICAgICAgdGhpcy5pdGVyLm5leHQoc2tpcCk7XG4gICAgICAgIGlmICh0aGlzLml0ZXIubGluZUJyZWFrKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5pdGVyLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCA+IHRoaXMudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5jdXJMaW5lLnNsaWNlKDAsIHRoaXMudG8gLSB0aGlzLmN1ckxpbmVTdGFydCk7XG4gICAgICAgICAgICB0aGlzLml0ZXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRMaW5lKCkge1xuICAgICAgICB0aGlzLmN1ckxpbmVTdGFydCA9IHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIGlmICh0aGlzLmN1ckxpbmVTdGFydCA+IHRoaXMudG8pXG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbWF0Y2gsIGlmIHRoZXJlIGlzIG9uZS5cbiAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmN1ckxpbmVTdGFydDs7KSB7XG4gICAgICAgICAgICB0aGlzLnJlLmxhc3RJbmRleCA9IG9mZjtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMubWF0Y2hQb3MgPD0gdGhpcy50byAmJiB0aGlzLnJlLmV4ZWModGhpcy5jdXJMaW5lKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy5jdXJMaW5lU3RhcnQgKyBtYXRjaC5pbmRleCwgdG8gPSBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGhpcy50ZXh0LCB0byArIChmcm9tID09IHRvID8gMSA6IDApKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSB0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoKGZyb20gPCB0byB8fCBmcm9tID4gdGhpcy52YWx1ZS50bykgJiYgKCF0aGlzLnRlc3QgfHwgdGhpcy50ZXN0KGZyb20sIHRvLCBtYXRjaCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb20sIHRvLCBtYXRjaCB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2ZmID0gdGhpcy5tYXRjaFBvcyAtIHRoaXMuY3VyTGluZVN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoIDwgdGhpcy50bykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICBvZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGZsYXR0ZW5lZCA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuLy8gUmV1c2FibGUgKHBhcnRpYWxseSkgZmxhdHRlbmVkIGRvY3VtZW50IHN0cmluZ3NcbmNsYXNzIEZsYXR0ZW5lZERvYyB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdGV4dCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgc3RhdGljIGdldChkb2MsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSBmbGF0dGVuZWQuZ2V0KGRvYyk7XG4gICAgICAgIGlmICghY2FjaGVkIHx8IGNhY2hlZC5mcm9tID49IHRvIHx8IGNhY2hlZC50byA8PSBmcm9tKSB7XG4gICAgICAgICAgICBsZXQgZmxhdCA9IG5ldyBGbGF0dGVuZWREb2MoZnJvbSwgZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvKSk7XG4gICAgICAgICAgICBmbGF0dGVuZWQuc2V0KGRvYywgZmxhdCk7XG4gICAgICAgICAgICByZXR1cm4gZmxhdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGVkLmZyb20gPT0gZnJvbSAmJiBjYWNoZWQudG8gPT0gdG8pXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tOiBjYWNoZWRGcm9tIH0gPSBjYWNoZWQ7XG4gICAgICAgIGlmIChjYWNoZWRGcm9tID4gZnJvbSkge1xuICAgICAgICAgICAgdGV4dCA9IGRvYy5zbGljZVN0cmluZyhmcm9tLCBjYWNoZWRGcm9tKSArIHRleHQ7XG4gICAgICAgICAgICBjYWNoZWRGcm9tID0gZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGVkLnRvIDwgdG8pXG4gICAgICAgICAgICB0ZXh0ICs9IGRvYy5zbGljZVN0cmluZyhjYWNoZWQudG8sIHRvKTtcbiAgICAgICAgZmxhdHRlbmVkLnNldChkb2MsIG5ldyBGbGF0dGVuZWREb2MoY2FjaGVkRnJvbSwgdGV4dCkpO1xuICAgICAgICByZXR1cm4gbmV3IEZsYXR0ZW5lZERvYyhmcm9tLCB0ZXh0LnNsaWNlKGZyb20gLSBjYWNoZWRGcm9tLCB0byAtIGNhY2hlZEZyb20pKTtcbiAgICB9XG59XG5jbGFzcyBNdWx0aWxpbmVSZWdFeHBDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gZW1wdHk7XG4gICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGV4dCwgZnJvbSk7XG4gICAgICAgIHRoaXMucmUgPSBuZXcgUmVnRXhwKHF1ZXJ5LCBiYXNlRmxhZ3MgKyAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZ25vcmVDYXNlKSA/IFwiaVwiIDogXCJcIikpO1xuICAgICAgICB0aGlzLnRlc3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGVzdDtcbiAgICAgICAgdGhpcy5mbGF0ID0gRmxhdHRlbmVkRG9jLmdldCh0ZXh0LCBmcm9tLCB0aGlzLmNodW5rRW5kKGZyb20gKyA1MDAwIC8qIENodW5rLkJhc2UgKi8pKTtcbiAgICB9XG4gICAgY2h1bmtFbmQocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3MgPj0gdGhpcy50byA/IHRoaXMudG8gOiB0aGlzLnRleHQubGluZUF0KHBvcykudG87XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBvZmYgPSB0aGlzLnJlLmxhc3RJbmRleCA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmZsYXQuZnJvbTtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucmUuZXhlYyh0aGlzLmZsYXQudGV4dCk7XG4gICAgICAgICAgICAvLyBTa2lwIGVtcHR5IG1hdGNoZXMgZGlyZWN0bHkgYWZ0ZXIgdGhlIGxhc3QgbWF0Y2hcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiAhbWF0Y2hbMF0gJiYgbWF0Y2guaW5kZXggPT0gb2ZmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZS5sYXN0SW5kZXggPSBvZmYgKyAxO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gdGhpcy5yZS5leGVjKHRoaXMuZmxhdC50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy5mbGF0LmZyb20gKyBtYXRjaC5pbmRleCwgdG8gPSBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIElmIGEgbWF0Y2ggZ29lcyBhbG1vc3QgdG8gdGhlIGVuZCBvZiBhIG5vbmNvbXBsZXRlIGNodW5rLCB0cnlcbiAgICAgICAgICAgICAgICAvLyBhZ2Fpbiwgc2luY2UgaXQnbGwgbGlrZWx5IGJlIGFibGUgdG8gbWF0Y2ggbW9yZVxuICAgICAgICAgICAgICAgIGlmICgodGhpcy5mbGF0LnRvID49IHRoaXMudG8gfHwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggPD0gdGhpcy5mbGF0LnRleHQubGVuZ3RoIC0gMTApICYmXG4gICAgICAgICAgICAgICAgICAgICghdGhpcy50ZXN0IHx8IHRoaXMudGVzdChmcm9tLCB0bywgbWF0Y2gpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tLCB0bywgbWF0Y2ggfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0aGlzLnRleHQsIHRvICsgKGZyb20gPT0gdG8gPyAxIDogMCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5mbGF0LnRvID09IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR3JvdyB0aGUgZmxhdHRlbmVkIGRvY1xuICAgICAgICAgICAgdGhpcy5mbGF0ID0gRmxhdHRlbmVkRG9jLmdldCh0aGlzLnRleHQsIHRoaXMuZmxhdC5mcm9tLCB0aGlzLmNodW5rRW5kKHRoaXMuZmxhdC5mcm9tICsgdGhpcy5mbGF0LnRleHQubGVuZ3RoICogMikpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFJlZ0V4cEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IE11bHRpbGluZVJlZ0V4cEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9XG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG59XG5mdW5jdGlvbiB2YWxpZFJlZ0V4cChzb3VyY2UpIHtcbiAgICB0cnkge1xuICAgICAgICBuZXcgUmVnRXhwKHNvdXJjZSwgYmFzZUZsYWdzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9DaGFyRW5kKHRleHQsIHBvcykge1xuICAgIGlmIChwb3MgPj0gdGV4dC5sZW5ndGgpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgbGV0IGxpbmUgPSB0ZXh0LmxpbmVBdChwb3MpLCBuZXh0O1xuICAgIHdoaWxlIChwb3MgPCBsaW5lLnRvICYmIChuZXh0ID0gbGluZS50ZXh0LmNoYXJDb2RlQXQocG9zIC0gbGluZS5mcm9tKSkgPj0gMHhEQzAwICYmIG5leHQgPCAweEUwMDApXG4gICAgICAgIHBvcysrO1xuICAgIHJldHVybiBwb3M7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmVEaWFsb2codmlldykge1xuICAgIGxldCBpbnB1dCA9IGVsdChcImlucHV0XCIsIHsgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsIG5hbWU6IFwibGluZVwiIH0pO1xuICAgIGxldCBkb20gPSBlbHQoXCJmb3JtXCIsIHtcbiAgICAgICAgY2xhc3M6IFwiY20tZ290b0xpbmVcIixcbiAgICAgICAgb25rZXlkb3duOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDI3KSB7IC8vIEVzY2FwZVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGRpYWxvZ0VmZmVjdC5vZihmYWxzZSkgfSk7XG4gICAgICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykgeyAvLyBFbnRlclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25zdWJtaXQ6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGdvKCk7XG4gICAgICAgIH1cbiAgICB9LCBlbHQoXCJsYWJlbFwiLCB2aWV3LnN0YXRlLnBocmFzZShcIkdvIHRvIGxpbmVcIiksIFwiOiBcIiwgaW5wdXQpLCBcIiBcIiwgZWx0KFwiYnV0dG9uXCIsIHsgY2xhc3M6IFwiY20tYnV0dG9uXCIsIHR5cGU6IFwic3VibWl0XCIgfSwgdmlldy5zdGF0ZS5waHJhc2UoXCJnb1wiKSkpO1xuICAgIGZ1bmN0aW9uIGdvKCkge1xuICAgICAgICBsZXQgbWF0Y2ggPSAvXihbKy1dKT8oXFxkKyk/KDpcXGQrKT8oJSk/JC8uZXhlYyhpbnB1dC52YWx1ZSk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBzdGFydExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBsZXQgWywgc2lnbiwgbG4sIGNsLCBwZXJjZW50XSA9IG1hdGNoO1xuICAgICAgICBsZXQgY29sID0gY2wgPyArY2wuc2xpY2UoMSkgOiAwO1xuICAgICAgICBsZXQgbGluZSA9IGxuID8gK2xuIDogc3RhcnRMaW5lLm51bWJlcjtcbiAgICAgICAgaWYgKGxuICYmIHBlcmNlbnQpIHtcbiAgICAgICAgICAgIGxldCBwYyA9IGxpbmUgLyAxMDA7XG4gICAgICAgICAgICBpZiAoc2lnbilcbiAgICAgICAgICAgICAgICBwYyA9IHBjICogKHNpZ24gPT0gXCItXCIgPyAtMSA6IDEpICsgKHN0YXJ0TGluZS5udW1iZXIgLyBzdGF0ZS5kb2MubGluZXMpO1xuICAgICAgICAgICAgbGluZSA9IE1hdGgucm91bmQoc3RhdGUuZG9jLmxpbmVzICogcGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxuICYmIHNpZ24pIHtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lICogKHNpZ24gPT0gXCItXCIgPyAtMSA6IDEpICsgc3RhcnRMaW5lLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZG9jTGluZSA9IHN0YXRlLmRvYy5saW5lKE1hdGgubWF4KDEsIE1hdGgubWluKHN0YXRlLmRvYy5saW5lcywgbGluZSkpKTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBlZmZlY3RzOiBkaWFsb2dFZmZlY3Qub2YoZmFsc2UpLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGRvY0xpbmUuZnJvbSArIE1hdGgubWF4KDAsIE1hdGgubWluKGNvbCwgZG9jTGluZS5sZW5ndGgpKSksXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIH1cbiAgICByZXR1cm4geyBkb20gfTtcbn1cbmNvbnN0IGRpYWxvZ0VmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGRpYWxvZ0ZpZWxkID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgaWYgKGUuaXMoZGlhbG9nRWZmZWN0KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGUudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gc2hvd1BhbmVsLmZyb20oZiwgdmFsID0+IHZhbCA/IGNyZWF0ZUxpbmVEaWFsb2cgOiBudWxsKVxufSk7XG4vKipcbkNvbW1hbmQgdGhhdCBzaG93cyBhIGRpYWxvZyBhc2tpbmcgdGhlIHVzZXIgZm9yIGEgbGluZSBudW1iZXIsIGFuZFxud2hlbiBhIHZhbGlkIHBvc2l0aW9uIGlzIHByb3ZpZGVkLCBtb3ZlcyB0aGUgY3Vyc29yIHRvIHRoYXQgbGluZS5cblxuU3VwcG9ydHMgbGluZSBudW1iZXJzLCByZWxhdGl2ZSBsaW5lIG9mZnNldHMgcHJlZml4ZWQgd2l0aCBgK2Agb3JcbmAtYCwgZG9jdW1lbnQgcGVyY2VudGFnZXMgc3VmZml4ZWQgd2l0aCBgJWAsIGFuZCBhbiBvcHRpb25hbFxuY29sdW1uIHBvc2l0aW9uIGJ5IGFkZGluZyBgOmAgYW5kIGEgc2Vjb25kIG51bWJlciBhZnRlciB0aGUgbGluZVxubnVtYmVyLlxuXG5UaGUgZGlhbG9nIGNhbiBiZSBzdHlsZWQgd2l0aCB0aGUgYHBhbmVsLmdvdG9MaW5lYCB0aGVtZVxuc2VsZWN0b3IuXG4qL1xuY29uc3QgZ290b0xpbmUgPSB2aWV3ID0+IHtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVMaW5lRGlhbG9nKTtcbiAgICBpZiAoIXBhbmVsKSB7XG4gICAgICAgIGxldCBlZmZlY3RzID0gW2RpYWxvZ0VmZmVjdC5vZih0cnVlKV07XG4gICAgICAgIGlmICh2aWV3LnN0YXRlLmZpZWxkKGRpYWxvZ0ZpZWxkLCBmYWxzZSkgPT0gbnVsbClcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaChTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoW2RpYWxvZ0ZpZWxkLCBiYXNlVGhlbWUkMV0pKTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHMgfSk7XG4gICAgICAgIHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlTGluZURpYWxvZyk7XG4gICAgfVxuICAgIGlmIChwYW5lbClcbiAgICAgICAgcGFuZWwuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKS5mb2N1cygpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGJhc2VUaGVtZSQxID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1wYW5lbC5jbS1nb3RvTGluZVwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMnB4IDZweCA0cHhcIixcbiAgICAgICAgXCImIGxhYmVsXCI6IHsgZm9udFNpemU6IFwiODAlXCIgfVxuICAgIH1cbn0pO1xuXG5jb25zdCBkZWZhdWx0SGlnaGxpZ2h0T3B0aW9ucyA9IHtcbiAgICBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yOiBmYWxzZSxcbiAgICBtaW5TZWxlY3Rpb25MZW5ndGg6IDEsXG4gICAgbWF4TWF0Y2hlczogMTAwLFxuICAgIHdob2xlV29yZHM6IGZhbHNlXG59O1xuY29uc3QgaGlnaGxpZ2h0Q29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKG9wdGlvbnMsIGRlZmF1bHRIaWdobGlnaHRPcHRpb25zLCB7XG4gICAgICAgICAgICBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yOiAoYSwgYikgPT4gYSB8fCBiLFxuICAgICAgICAgICAgbWluU2VsZWN0aW9uTGVuZ3RoOiBNYXRoLm1pbixcbiAgICAgICAgICAgIG1heE1hdGNoZXM6IE1hdGgubWluXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5UaGlzIGV4dGVuc2lvbiBoaWdobGlnaHRzIHRleHQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rpb24uIEl0IHVzZXNcbnRoZSBgXCJjbS1zZWxlY3Rpb25NYXRjaFwiYCBjbGFzcyBmb3IgdGhlIGhpZ2hsaWdodGluZy4gV2hlblxuYGhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3JgIGlzIGVuYWJsZWQsIHRoZSB3b3JkIGF0IHRoZSBjdXJzb3Jcbml0c2VsZiB3aWxsIGJlIGhpZ2hsaWdodGVkIHdpdGggYFwiY20tc2VsZWN0aW9uTWF0Y2gtbWFpblwiYC5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzKG9wdGlvbnMpIHtcbiAgICBsZXQgZXh0ID0gW2RlZmF1bHRUaGVtZSwgbWF0Y2hIaWdobGlnaHRlcl07XG4gICAgaWYgKG9wdGlvbnMpXG4gICAgICAgIGV4dC5wdXNoKGhpZ2hsaWdodENvbmZpZy5vZihvcHRpb25zKSk7XG4gICAgcmV0dXJuIGV4dDtcbn1cbmNvbnN0IG1hdGNoRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWxlY3Rpb25NYXRjaFwiIH0pO1xuY29uc3QgbWFpbk1hdGNoRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWxlY3Rpb25NYXRjaCBjbS1zZWxlY3Rpb25NYXRjaC1tYWluXCIgfSk7XG4vLyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXJzIGRpcmVjdGx5IG91dHNpZGUgdGhlIGdpdmVuIHBvc2l0aW9ucyBhcmUgbm9uLXdvcmQgY2hhcmFjdGVyc1xuZnVuY3Rpb24gaW5zaWRlV29yZEJvdW5kYXJpZXMoY2hlY2ssIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiAoZnJvbSA9PSAwIHx8IGNoZWNrKHN0YXRlLnNsaWNlRG9jKGZyb20gLSAxLCBmcm9tKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpICYmXG4gICAgICAgICh0byA9PSBzdGF0ZS5kb2MubGVuZ3RoIHx8IGNoZWNrKHN0YXRlLnNsaWNlRG9jKHRvLCB0byArIDEpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCk7XG59XG4vLyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXJzIGRpcmVjdGx5IGF0IHRoZSBnaXZlbiBwb3NpdGlvbnMgYXJlIHdvcmQgY2hhcmFjdGVyc1xuZnVuY3Rpb24gaW5zaWRlV29yZChjaGVjaywgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGNoZWNrKHN0YXRlLnNsaWNlRG9jKGZyb20sIGZyb20gKyAxKSkgPT0gQ2hhckNhdGVnb3J5LldvcmRcbiAgICAgICAgJiYgY2hlY2soc3RhdGUuc2xpY2VEb2ModG8gLSAxLCB0bykpID09IENoYXJDYXRlZ29yeS5Xb3JkO1xufVxuY29uc3QgbWF0Y2hIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHZpZXcpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHVwZGF0ZS52aWV3KTtcbiAgICB9XG4gICAgZ2V0RGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBjb25mID0gdmlldy5zdGF0ZS5mYWNldChoaWdobGlnaHRDb25maWcpO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc2VsLnJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IHJhbmdlID0gc2VsLm1haW4sIHF1ZXJ5LCBjaGVjayA9IG51bGw7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgaWYgKCFjb25mLmhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgaWYgKCF3b3JkKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBjaGVjayA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihyYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gc3RhdGUuc2xpY2VEb2Mod29yZC5mcm9tLCB3b3JkLnRvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSByYW5nZS50byAtIHJhbmdlLmZyb207XG4gICAgICAgICAgICBpZiAobGVuIDwgY29uZi5taW5TZWxlY3Rpb25MZW5ndGggfHwgbGVuID4gMjAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBpZiAoY29uZi53aG9sZVdvcmRzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50byk7IC8vIFRPRE86IGFsbG93IGFuZCBpbmNsdWRlIGxlYWRpbmcvdHJhaWxpbmcgc3BhY2U/XG4gICAgICAgICAgICAgICAgY2hlY2sgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICAgICAgaWYgKCEoaW5zaWRlV29yZEJvdW5kYXJpZXMoY2hlY2ssIHN0YXRlLCByYW5nZS5mcm9tLCByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgJiYgaW5zaWRlV29yZChjaGVjaywgc3RhdGUsIHJhbmdlLmZyb20sIHJhbmdlLnRvKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVjbyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgcGFydC5mcm9tLCBwYXJ0LnRvKTtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrIHx8IGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSAmJiBmcm9tIDw9IHJhbmdlLmZyb20gJiYgdG8gPj0gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWFpbk1hdGNoRGVjby5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmcm9tID49IHJhbmdlLnRvIHx8IHRvIDw9IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWF0Y2hEZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWNvLmxlbmd0aCA+IGNvbmYubWF4TWF0Y2hlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5jb25zdCBkZWZhdWx0VGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXNlbGVjdGlvbk1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM5OWZmNzc4MFwiIH0sXG4gICAgXCIuY20tc2VhcmNoTWF0Y2ggLmNtLXNlbGVjdGlvbk1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCIgfVxufSk7XG4vLyBTZWxlY3QgdGhlIHdvcmRzIGFyb3VuZCB0aGUgY3Vyc29ycy5cbmNvbnN0IHNlbGVjdFdvcmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgbGV0IG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsZWN0aW9uLnJhbmdlcy5tYXAocmFuZ2UgPT4gc3RhdGUud29yZEF0KHJhbmdlLmhlYWQpIHx8IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCkpLCBzZWxlY3Rpb24ubWFpbkluZGV4KTtcbiAgICBpZiAobmV3U2VsLmVxKHNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IG5ld1NlbCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLy8gRmluZCBuZXh0IG9jY3VycmVuY2Ugb2YgcXVlcnkgcmVsYXRpdmUgdG8gbGFzdCBjdXJzb3IuIFdyYXAgYXJvdW5kXG4vLyB0aGUgZG9jdW1lbnQgaWYgdGhlcmUgYXJlIG5vIG1vcmUgbWF0Y2hlcy5cbmZ1bmN0aW9uIGZpbmROZXh0T2NjdXJyZW5jZShzdGF0ZSwgcXVlcnkpIHtcbiAgICBsZXQgeyBtYWluLCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChtYWluLmhlYWQpLCBmdWxsV29yZCA9IHdvcmQgJiYgd29yZC5mcm9tID09IG1haW4uZnJvbSAmJiB3b3JkLnRvID09IG1haW4udG87XG4gICAgZm9yIChsZXQgY3ljbGVkID0gZmFsc2UsIGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50byk7Oykge1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChjeWNsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIDAsIE1hdGgubWF4KDAsIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0uZnJvbSAtIDEpKTtcbiAgICAgICAgICAgIGN5Y2xlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3ljbGVkICYmIHJhbmdlcy5zb21lKHIgPT4gci5mcm9tID09IGN1cnNvci52YWx1ZS5mcm9tKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChmdWxsV29yZCkge1xuICAgICAgICAgICAgICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KGN1cnNvci52YWx1ZS5mcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoIXdvcmQgfHwgd29yZC5mcm9tICE9IGN1cnNvci52YWx1ZS5mcm9tIHx8IHdvcmQudG8gIT0gY3Vyc29yLnZhbHVlLnRvKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJzb3IudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcblNlbGVjdCBuZXh0IG9jY3VycmVuY2Ugb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBFeHBhbmQgc2VsZWN0aW9uXG50byB0aGUgc3Vycm91bmRpbmcgd29yZCB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkuXG4qL1xuY29uc3Qgc2VsZWN0TmV4dE9jY3VycmVuY2UgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCB7IHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChyYW5nZXMuc29tZShzZWwgPT4gc2VsLmZyb20gPT09IHNlbC50bykpXG4gICAgICAgIHJldHVybiBzZWxlY3RXb3JkKHsgc3RhdGUsIGRpc3BhdGNoIH0pO1xuICAgIGxldCBzZWFyY2hlZFRleHQgPSBzdGF0ZS5zbGljZURvYyhyYW5nZXNbMF0uZnJvbSwgcmFuZ2VzWzBdLnRvKTtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gc3RhdGUuc2xpY2VEb2Moci5mcm9tLCByLnRvKSAhPSBzZWFyY2hlZFRleHQpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHJhbmdlID0gZmluZE5leHRPY2N1cnJlbmNlKHN0YXRlLCBzZWFyY2hlZFRleHQpO1xuICAgIGlmICghcmFuZ2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICBzZWxlY3Rpb246IHN0YXRlLnNlbGVjdGlvbi5hZGRSYW5nZShFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuZnJvbSwgcmFuZ2UudG8pLCBmYWxzZSksXG4gICAgICAgIGVmZmVjdHM6IEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcocmFuZ2UudG8pXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3Qgc2VhcmNoQ29uZmlnRmFjZXQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgdG9wOiBmYWxzZSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbGl0ZXJhbDogZmFsc2UsXG4gICAgICAgICAgICB3aG9sZVdvcmQ6IGZhbHNlLFxuICAgICAgICAgICAgY3JlYXRlUGFuZWw6IHZpZXcgPT4gbmV3IFNlYXJjaFBhbmVsKHZpZXcpXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5BZGQgc2VhcmNoIHN0YXRlIHRvIHRoZSBlZGl0b3IgY29uZmlndXJhdGlvbiwgYW5kIG9wdGlvbmFsbHlcbmNvbmZpZ3VyZSB0aGUgc2VhcmNoIGV4dGVuc2lvbi5cbihbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbCkgd2lsbCBhdXRvbWF0aWNhbGx5XG5lbmFibGUgdGhpcyBpZiBpdCBpc24ndCBhbHJlYWR5IG9uKS5cbiovXG5mdW5jdGlvbiBzZWFyY2goY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZyA/IFtzZWFyY2hDb25maWdGYWNldC5vZihjb25maWcpLCBzZWFyY2hFeHRlbnNpb25zXSA6IHNlYXJjaEV4dGVuc2lvbnM7XG59XG4vKipcbkEgc2VhcmNoIHF1ZXJ5LiBQYXJ0IG9mIHRoZSBlZGl0b3IncyBzZWFyY2ggc3RhdGUuXG4qL1xuY2xhc3MgU2VhcmNoUXVlcnkge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHF1ZXJ5IG9iamVjdC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IGNvbmZpZy5zZWFyY2g7XG4gICAgICAgIHRoaXMuY2FzZVNlbnNpdGl2ZSA9ICEhY29uZmlnLmNhc2VTZW5zaXRpdmU7XG4gICAgICAgIHRoaXMubGl0ZXJhbCA9ICEhY29uZmlnLmxpdGVyYWw7XG4gICAgICAgIHRoaXMucmVnZXhwID0gISFjb25maWcucmVnZXhwO1xuICAgICAgICB0aGlzLnJlcGxhY2UgPSBjb25maWcucmVwbGFjZSB8fCBcIlwiO1xuICAgICAgICB0aGlzLnZhbGlkID0gISF0aGlzLnNlYXJjaCAmJiAoIXRoaXMucmVnZXhwIHx8IHZhbGlkUmVnRXhwKHRoaXMuc2VhcmNoKSk7XG4gICAgICAgIHRoaXMudW5xdW90ZWQgPSB0aGlzLnVucXVvdGUodGhpcy5zZWFyY2gpO1xuICAgICAgICB0aGlzLndob2xlV29yZCA9ICEhY29uZmlnLndob2xlV29yZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB1bnF1b3RlKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGl0ZXJhbCA/IHRleHQgOlxuICAgICAgICAgICAgdGV4dC5yZXBsYWNlKC9cXFxcKFtucnRcXFxcXSkvZywgKF8sIGNoKSA9PiBjaCA9PSBcIm5cIiA/IFwiXFxuXCIgOiBjaCA9PSBcInJcIiA/IFwiXFxyXCIgOiBjaCA9PSBcInRcIiA/IFwiXFx0XCIgOiBcIlxcXFxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBxdWVyeSB0byBhbm90aGVyIHF1ZXJ5LlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoID09IG90aGVyLnNlYXJjaCAmJiB0aGlzLnJlcGxhY2UgPT0gb3RoZXIucmVwbGFjZSAmJlxuICAgICAgICAgICAgdGhpcy5jYXNlU2Vuc2l0aXZlID09IG90aGVyLmNhc2VTZW5zaXRpdmUgJiYgdGhpcy5yZWdleHAgPT0gb3RoZXIucmVnZXhwICYmXG4gICAgICAgICAgICB0aGlzLndob2xlV29yZCA9PSBvdGhlci53aG9sZVdvcmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHAgPyBuZXcgUmVnRXhwUXVlcnkodGhpcykgOiBuZXcgU3RyaW5nUXVlcnkodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIHNlYXJjaCBjdXJzb3IgZm9yIHRoaXMgcXVlcnksIHNlYXJjaGluZyB0aHJvdWdoIHRoZSBnaXZlblxuICAgIHJhbmdlIGluIHRoZSBnaXZlbiBzdGF0ZS5cbiAgICAqL1xuICAgIGdldEN1cnNvcihzdGF0ZSwgZnJvbSA9IDAsIHRvKSB7XG4gICAgICAgIGxldCBzdCA9IHN0YXRlLmRvYyA/IHN0YXRlIDogRWRpdG9yU3RhdGUuY3JlYXRlKHsgZG9jOiBzdGF0ZSB9KTtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IHN0LmRvYy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cCA/IHJlZ2V4cEN1cnNvcih0aGlzLCBzdCwgZnJvbSwgdG8pIDogc3RyaW5nQ3Vyc29yKHRoaXMsIHN0LCBmcm9tLCB0byk7XG4gICAgfVxufVxuY2xhc3MgUXVlcnlUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyaW5nQ3Vyc29yKHNwZWMsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgc3BlYy51bnF1b3RlZCwgZnJvbSwgdG8sIHNwZWMuY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IHggPT4geC50b0xvd2VyQ2FzZSgpLCBzcGVjLndob2xlV29yZCA/IHN0cmluZ1dvcmRUZXN0KHN0YXRlLmRvYywgc3RhdGUuY2hhckNhdGVnb3JpemVyKHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpKSA6IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBzdHJpbmdXb3JkVGVzdChkb2MsIGNhdGVnb3JpemVyKSB7XG4gICAgcmV0dXJuIChmcm9tLCB0bywgYnVmLCBidWZQb3MpID0+IHtcbiAgICAgICAgaWYgKGJ1ZlBvcyA+IGZyb20gfHwgYnVmUG9zICsgYnVmLmxlbmd0aCA8IHRvKSB7XG4gICAgICAgICAgICBidWZQb3MgPSBNYXRoLm1heCgwLCBmcm9tIC0gMik7XG4gICAgICAgICAgICBidWYgPSBkb2Muc2xpY2VTdHJpbmcoYnVmUG9zLCBNYXRoLm1pbihkb2MubGVuZ3RoLCB0byArIDIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNhdGVnb3JpemVyKGNoYXJCZWZvcmUoYnVmLCBmcm9tIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcbiAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJBZnRlcihidWYsIGZyb20gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkgJiZcbiAgICAgICAgICAgIChjYXRlZ29yaXplcihjaGFyQWZ0ZXIoYnVmLCB0byAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShidWYsIHRvIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xuICAgIH07XG59XG5jbGFzcyBTdHJpbmdRdWVyeSBleHRlbmRzIFF1ZXJ5VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcihzcGVjKTtcbiAgICB9XG4gICAgbmV4dE1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKS5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKVxuICAgICAgICAgICAgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIGN1ckZyb20pLm5leHRPdmVybGFwcGluZygpO1xuICAgICAgICByZXR1cm4gY3Vyc29yLmRvbmUgPyBudWxsIDogY3Vyc29yLnZhbHVlO1xuICAgIH1cbiAgICAvLyBTZWFyY2hpbmcgaW4gcmV2ZXJzZSBpcywgcmF0aGVyIHRoYW4gaW1wbGVtZW50aW5nIGludmVydGVkIHNlYXJjaFxuICAgIC8vIGN1cnNvciwgZG9uZSBieSBzY2FubmluZyBjaHVuayBhZnRlciBjaHVuayBmb3J3YXJkLlxuICAgIHByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRvOzspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGZyb20sIHBvcyAtIDEwMDAwIC8qIEZpbmRQcmV2LkNodW5rU2l6ZSAqLyAtIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBzdGFydCwgcG9zKSwgcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dE92ZXJsYXBwaW5nKCkuZG9uZSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHBvcyAtPSAxMDAwMCAvKiBGaW5kUHJldi5DaHVua1NpemUgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJldk1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCAwLCBjdXJGcm9tKSB8fFxuICAgICAgICAgICAgdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgfVxuICAgIGdldFJlcGxhY2VtZW50KF9yZXN1bHQpIHsgcmV0dXJuIHRoaXMuc3BlYy51bnF1b3RlKHRoaXMuc3BlYy5yZXBsYWNlKTsgfVxuICAgIG1hdGNoQWxsKHN0YXRlLCBsaW1pdCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIHN0YXRlLmRvYy5sZW5ndGgpLCByYW5nZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID49IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cbiAgICBoaWdobGlnaHQoc3RhdGUsIGZyb20sIHRvLCBhZGQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBNYXRoLm1heCgwLCBmcm9tIC0gdGhpcy5zcGVjLnVucXVvdGVkLmxlbmd0aCksIE1hdGgubWluKHRvICsgdGhpcy5zcGVjLnVucXVvdGVkLmxlbmd0aCwgc3RhdGUuZG9jLmxlbmd0aCkpO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgIGFkZChjdXJzb3IudmFsdWUuZnJvbSwgY3Vyc29yLnZhbHVlLnRvKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWdleHBDdXJzb3Ioc3BlYywgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHBDdXJzb3Ioc3RhdGUuZG9jLCBzcGVjLnNlYXJjaCwge1xuICAgICAgICBpZ25vcmVDYXNlOiAhc3BlYy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgICB0ZXN0OiBzcGVjLndob2xlV29yZCA/IHJlZ2V4cFdvcmRUZXN0KHN0YXRlLmNoYXJDYXRlZ29yaXplcihzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKSkgOiB1bmRlZmluZWRcbiAgICB9LCBmcm9tLCB0byk7XG59XG5mdW5jdGlvbiBjaGFyQmVmb3JlKHN0ciwgaW5kZXgpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKGZpbmRDbHVzdGVyQnJlYWsoc3RyLCBpbmRleCwgZmFsc2UpLCBpbmRleCk7XG59XG5mdW5jdGlvbiBjaGFyQWZ0ZXIoc3RyLCBpbmRleCkge1xuICAgIHJldHVybiBzdHIuc2xpY2UoaW5kZXgsIGZpbmRDbHVzdGVyQnJlYWsoc3RyLCBpbmRleCkpO1xufVxuZnVuY3Rpb24gcmVnZXhwV29yZFRlc3QoY2F0ZWdvcml6ZXIpIHtcbiAgICByZXR1cm4gKF9mcm9tLCBfdG8sIG1hdGNoKSA9PiAhbWF0Y2hbMF0ubGVuZ3RoIHx8XG4gICAgICAgIChjYXRlZ29yaXplcihjaGFyQmVmb3JlKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICBjYXRlZ29yaXplcihjaGFyQWZ0ZXIobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpICYmXG4gICAgICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckFmdGVyKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCk7XG59XG5jbGFzcyBSZWdFeHBRdWVyeSBleHRlbmRzIFF1ZXJ5VHlwZSB7XG4gICAgbmV4dE1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKS5uZXh0KCk7XG4gICAgICAgIGlmIChjdXJzb3IuZG9uZSlcbiAgICAgICAgICAgIGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBjdXJGcm9tKS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBjdXJzb3IuZG9uZSA/IG51bGwgOiBjdXJzb3IudmFsdWU7XG4gICAgfVxuICAgIHByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAobGV0IHNpemUgPSAxOzsgc2l6ZSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChmcm9tLCB0byAtIHNpemUgKiAxMDAwMCAvKiBGaW5kUHJldi5DaHVua1NpemUgKi8pO1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBzdGFydCwgdG8pLCByYW5nZSA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZSAmJiAoc3RhcnQgPT0gZnJvbSB8fCByYW5nZS5mcm9tID4gc3RhcnQgKyAxMCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJldk1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCAwLCBjdXJGcm9tKSB8fFxuICAgICAgICAgICAgdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgfVxuICAgIGdldFJlcGxhY2VtZW50KHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjLnVucXVvdGUodGhpcy5zcGVjLnJlcGxhY2UucmVwbGFjZSgvXFwkKFskJlxcZCtdKS9nLCAobSwgaSkgPT4gaSA9PSBcIiRcIiA/IFwiJFwiXG4gICAgICAgICAgICA6IGkgPT0gXCImXCIgPyByZXN1bHQubWF0Y2hbMF1cbiAgICAgICAgICAgICAgICA6IGkgIT0gXCIwXCIgJiYgK2kgPCByZXN1bHQubWF0Y2gubGVuZ3RoID8gcmVzdWx0Lm1hdGNoW2ldXG4gICAgICAgICAgICAgICAgICAgIDogbSkpO1xuICAgIH1cbiAgICBtYXRjaEFsbChzdGF0ZSwgbGltaXQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKSwgcmFuZ2VzID0gW107XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+PSBsaW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHN0YXRlLCBmcm9tLCB0bywgYWRkKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgTWF0aC5tYXgoMCwgZnJvbSAtIDI1MCAvKiBSZWdFeHAuSGlnaGxpZ2h0TWFyZ2luICovKSwgTWF0aC5taW4odG8gKyAyNTAgLyogUmVnRXhwLkhpZ2hsaWdodE1hcmdpbiAqLywgc3RhdGUuZG9jLmxlbmd0aCkpO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgIGFkZChjdXJzb3IudmFsdWUuZnJvbSwgY3Vyc29yLnZhbHVlLnRvKTtcbiAgICB9XG59XG4vKipcbkEgc3RhdGUgZWZmZWN0IHRoYXQgdXBkYXRlcyB0aGUgY3VycmVudCBzZWFyY2ggcXVlcnkuIE5vdGUgdGhhdFxudGhpcyBvbmx5IGhhcyBhbiBlZmZlY3QgaWYgdGhlIHNlYXJjaCBzdGF0ZSBoYXMgYmVlbiBpbml0aWFsaXplZFxuKGJ5IGluY2x1ZGluZyBbYHNlYXJjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLnNlYXJjaCkgaW4geW91ciBjb25maWd1cmF0aW9uIG9yXG5ieSBydW5uaW5nIFtgb3BlblNlYXJjaFBhbmVsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2gub3BlblNlYXJjaFBhbmVsKSBhdCBsZWFzdFxub25jZSkuXG4qL1xuY29uc3Qgc2V0U2VhcmNoUXVlcnkgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCB0b2dnbGVQYW5lbCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHNlYXJjaFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWFyY2hTdGF0ZShkZWZhdWx0UXVlcnkoc3RhdGUpLmNyZWF0ZSgpLCBudWxsKTtcbiAgICB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0U2VhcmNoUXVlcnkpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IFNlYXJjaFN0YXRlKGVmZmVjdC52YWx1ZS5jcmVhdGUoKSwgdmFsdWUucGFuZWwpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHRvZ2dsZVBhbmVsKSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBTZWFyY2hTdGF0ZSh2YWx1ZS5xdWVyeSwgZWZmZWN0LnZhbHVlID8gY3JlYXRlU2VhcmNoUGFuZWwgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IHNob3dQYW5lbC5mcm9tKGYsIHZhbCA9PiB2YWwucGFuZWwpXG59KTtcbi8qKlxuR2V0IHRoZSBjdXJyZW50IHNlYXJjaCBxdWVyeSBmcm9tIGFuIGVkaXRvciBzdGF0ZS5cbiovXG5mdW5jdGlvbiBnZXRTZWFyY2hRdWVyeShzdGF0ZSkge1xuICAgIGxldCBjdXJTdGF0ZSA9IHN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGN1clN0YXRlID8gY3VyU3RhdGUucXVlcnkuc3BlYyA6IGRlZmF1bHRRdWVyeShzdGF0ZSk7XG59XG4vKipcblF1ZXJ5IHdoZXRoZXIgdGhlIHNlYXJjaCBwYW5lbCBpcyBvcGVuIGluIHRoZSBnaXZlbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gc2VhcmNoUGFuZWxPcGVuKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhbmVsKSAhPSBudWxsO1xufVxuY2xhc3MgU2VhcmNoU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBwYW5lbCkge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcbiAgICB9XG59XG5jb25zdCBtYXRjaE1hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VhcmNoTWF0Y2hcIiB9KSwgc2VsZWN0ZWRNYXRjaE1hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VhcmNoTWF0Y2ggY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIiB9KTtcbmNvbnN0IHNlYXJjaEhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmhpZ2hsaWdodCh2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlICE9IHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKSB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5oaWdobGlnaHQoc3RhdGUpO1xuICAgIH1cbiAgICBoaWdobGlnaHQoeyBxdWVyeSwgcGFuZWwgfSkge1xuICAgICAgICBpZiAoIXBhbmVsIHx8ICFxdWVyeS5zcGVjLnZhbGlkKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCByYW5nZXMgPSB2aWV3LnZpc2libGVSYW5nZXMsIGwgPSByYW5nZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBsIC0gMSAmJiB0byA+IHJhbmdlc1tpICsgMV0uZnJvbSAtIDIgKiAyNTAgLyogUmVnRXhwLkhpZ2hsaWdodE1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICB0byA9IHJhbmdlc1srK2ldLnRvO1xuICAgICAgICAgICAgcXVlcnkuaGlnaGxpZ2h0KHZpZXcuc3RhdGUsIGZyb20sIHRvLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsZWN0ZWQgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuc29tZShyID0+IHIuZnJvbSA9PSBmcm9tICYmIHIudG8gPT0gdG8pO1xuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGZyb20sIHRvLCBzZWxlY3RlZCA/IHNlbGVjdGVkTWF0Y2hNYXJrIDogbWF0Y2hNYXJrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgIH1cbn0sIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KTtcbmZ1bmN0aW9uIHNlYXJjaENvbW1hbmQoZikge1xuICAgIHJldHVybiB2aWV3ID0+IHtcbiAgICAgICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gc3RhdGUgJiYgc3RhdGUucXVlcnkuc3BlYy52YWxpZCA/IGYodmlldywgc3RhdGUpIDogb3BlblNlYXJjaFBhbmVsKHZpZXcpO1xuICAgIH07XG59XG4vKipcbk9wZW4gdGhlIHNlYXJjaCBwYW5lbCBpZiBpdCBpc24ndCBhbHJlYWR5IG9wZW4sIGFuZCBtb3ZlIHRoZVxuc2VsZWN0aW9uIHRvIHRoZSBmaXJzdCBtYXRjaCBhZnRlciB0aGUgY3VycmVudCBtYWluIHNlbGVjdGlvbi5cbldpbGwgd3JhcCBhcm91bmQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudCB3aGVuIGl0IHJlYWNoZXMgdGhlXG5lbmQuXG4qL1xuY29uc3QgZmluZE5leHQgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgdG8gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IG5leHQgPSBxdWVyeS5uZXh0TWF0Y2godmlldy5zdGF0ZSwgdG8sIHRvKTtcbiAgICBpZiAoIW5leHQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgc2VsZWN0aW9uOiB7IGFuY2hvcjogbmV4dC5mcm9tLCBoZWFkOiBuZXh0LnRvIH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICBlZmZlY3RzOiBhbm5vdW5jZU1hdGNoKHZpZXcsIG5leHQpLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaFwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBwcmV2aW91cyBpbnN0YW5jZSBvZiB0aGUgc2VhcmNoIHF1ZXJ5LFxuYmVmb3JlIHRoZSBjdXJyZW50IG1haW4gc2VsZWN0aW9uLiBXaWxsIHdyYXAgcGFzdCB0aGUgc3RhcnRcbm9mIHRoZSBkb2N1bWVudCB0byBzdGFydCBzZWFyY2hpbmcgYXQgdGhlIGVuZCBhZ2Fpbi5cbiovXG5jb25zdCBmaW5kUHJldmlvdXMgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHsgZnJvbSB9ID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IHJhbmdlID0gcXVlcnkucHJldk1hdGNoKHN0YXRlLCBmcm9tLCBmcm9tKTtcbiAgICBpZiAoIXJhbmdlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IHJhbmdlLmZyb20sIGhlYWQ6IHJhbmdlLnRvIH0sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICBlZmZlY3RzOiBhbm5vdW5jZU1hdGNoKHZpZXcsIHJhbmdlKSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2hcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblNlbGVjdCBhbGwgaW5zdGFuY2VzIG9mIHRoZSBzZWFyY2ggcXVlcnkuXG4qL1xuY29uc3Qgc2VsZWN0TWF0Y2hlcyA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgcmFuZ2VzID0gcXVlcnkubWF0Y2hBbGwodmlldy5zdGF0ZSwgMTAwMCk7XG4gICAgaWYgKCFyYW5nZXMgfHwgIXJhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcy5tYXAociA9PiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5mcm9tLCByLnRvKSkpLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaC5tYXRjaGVzXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5TZWxlY3QgYWxsIGluc3RhbmNlcyBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRleHQuXG4qL1xuY29uc3Qgc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcyA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoc2VsLnJhbmdlcy5sZW5ndGggPiAxIHx8IHNlbC5tYWluLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbC5tYWluO1xuICAgIGxldCByYW5nZXMgPSBbXSwgbWFpbiA9IDA7XG4gICAgZm9yIChsZXQgY3VyID0gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSk7ICFjdXIubmV4dCgpLmRvbmU7KSB7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID4gMTAwMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGN1ci52YWx1ZS5mcm9tID09IGZyb20pXG4gICAgICAgICAgICBtYWluID0gcmFuZ2VzLmxlbmd0aDtcbiAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGN1ci52YWx1ZS5mcm9tLCBjdXIudmFsdWUudG8pKTtcbiAgICB9XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgbWFpbiksXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoLm1hdGNoZXNcIlxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlcGxhY2UgdGhlIGN1cnJlbnQgbWF0Y2ggb2YgdGhlIHNlYXJjaCBxdWVyeS5cbiovXG5jb25zdCByZXBsYWNlTmV4dCA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgeyBmcm9tLCB0byB9ID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IG5leHQgPSBxdWVyeS5uZXh0TWF0Y2goc3RhdGUsIGZyb20sIGZyb20pO1xuICAgIGlmICghbmV4dClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW10sIHNlbGVjdGlvbiwgcmVwbGFjZW1lbnQ7XG4gICAgbGV0IGFubm91bmNlID0gW107XG4gICAgaWYgKG5leHQuZnJvbSA9PSBmcm9tICYmIG5leHQudG8gPT0gdG8pIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBzdGF0ZS50b1RleHQocXVlcnkuZ2V0UmVwbGFjZW1lbnQobmV4dCkpO1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBuZXh0LmZyb20sIHRvOiBuZXh0LnRvLCBpbnNlcnQ6IHJlcGxhY2VtZW50IH0pO1xuICAgICAgICBuZXh0ID0gcXVlcnkubmV4dE1hdGNoKHN0YXRlLCBuZXh0LmZyb20sIG5leHQudG8pO1xuICAgICAgICBhbm5vdW5jZS5wdXNoKEVkaXRvclZpZXcuYW5ub3VuY2Uub2Yoc3RhdGUucGhyYXNlKFwicmVwbGFjZWQgbWF0Y2ggb24gbGluZSAkXCIsIHN0YXRlLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyKSArIFwiLlwiKSk7XG4gICAgfVxuICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGxldCBvZmYgPSBjaGFuZ2VzLmxlbmd0aCA9PSAwIHx8IGNoYW5nZXNbMF0uZnJvbSA+PSBuZXh0LnRvID8gMCA6IG5leHQudG8gLSBuZXh0LmZyb20gLSByZXBsYWNlbWVudC5sZW5ndGg7XG4gICAgICAgIHNlbGVjdGlvbiA9IHsgYW5jaG9yOiBuZXh0LmZyb20gLSBvZmYsIGhlYWQ6IG5leHQudG8gLSBvZmYgfTtcbiAgICAgICAgYW5ub3VuY2UucHVzaChhbm5vdW5jZU1hdGNoKHZpZXcsIG5leHQpKTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsIHNlbGVjdGlvbixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6ICEhc2VsZWN0aW9uLFxuICAgICAgICBlZmZlY3RzOiBhbm5vdW5jZSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnJlcGxhY2VcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblJlcGxhY2UgYWxsIGluc3RhbmNlcyBvZiB0aGUgc2VhcmNoIHF1ZXJ5IHdpdGggdGhlIGdpdmVuXG5yZXBsYWNlbWVudC5cbiovXG5jb25zdCByZXBsYWNlQWxsID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBxdWVyeS5tYXRjaEFsbCh2aWV3LnN0YXRlLCAxZTkpLm1hcChtYXRjaCA9PiB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBtYXRjaDtcbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIGluc2VydDogcXVlcnkuZ2V0UmVwbGFjZW1lbnQobWF0Y2gpIH07XG4gICAgfSk7XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhbm5vdW5jZVRleHQgPSB2aWV3LnN0YXRlLnBocmFzZShcInJlcGxhY2VkICQgbWF0Y2hlc1wiLCBjaGFuZ2VzLmxlbmd0aCkgKyBcIi5cIjtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgZWZmZWN0czogRWRpdG9yVmlldy5hbm5vdW5jZS5vZihhbm5vdW5jZVRleHQpLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQucmVwbGFjZS5hbGxcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hQYW5lbCh2aWV3KSB7XG4gICAgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpLmNyZWF0ZVBhbmVsKHZpZXcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFF1ZXJ5KHN0YXRlLCBmYWxsYmFjaykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IHNlbFRleHQgPSBzZWwuZW1wdHkgfHwgc2VsLnRvID4gc2VsLmZyb20gKyAxMDAgPyBcIlwiIDogc3RhdGUuc2xpY2VEb2Moc2VsLmZyb20sIHNlbC50byk7XG4gICAgaWYgKGZhbGxiYWNrICYmICFzZWxUZXh0KVxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgbGV0IGNvbmZpZyA9IHN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KTtcbiAgICByZXR1cm4gbmV3IFNlYXJjaFF1ZXJ5KHtcbiAgICAgICAgc2VhcmNoOiAoKF9hID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLmxpdGVyYWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbmZpZy5saXRlcmFsKSA/IHNlbFRleHQgOiBzZWxUZXh0LnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLFxuICAgICAgICBjYXNlU2Vuc2l0aXZlOiAoX2IgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2suY2FzZVNlbnNpdGl2ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29uZmlnLmNhc2VTZW5zaXRpdmUsXG4gICAgICAgIGxpdGVyYWw6IChfYyA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5saXRlcmFsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjb25maWcubGl0ZXJhbCxcbiAgICAgICAgd2hvbGVXb3JkOiAoX2QgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2sud2hvbGVXb3JkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBjb25maWcud2hvbGVXb3JkXG4gICAgfSk7XG59XG4vKipcbk1ha2Ugc3VyZSB0aGUgc2VhcmNoIHBhbmVsIGlzIG9wZW4gYW5kIGZvY3VzZWQuXG4qL1xuY29uc3Qgb3BlblNlYXJjaFBhbmVsID0gdmlldyA9PiB7XG4gICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5wYW5lbCkge1xuICAgICAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVTZWFyY2hQYW5lbCk7XG4gICAgICAgIGlmICghcGFuZWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzZWFyY2hJbnB1dCA9IHBhbmVsLmRvbS5xdWVyeVNlbGVjdG9yKFwiW21haW4tZmllbGRdXCIpO1xuICAgICAgICBpZiAoc2VhcmNoSW5wdXQgJiYgc2VhcmNoSW5wdXQgIT0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IGRlZmF1bHRRdWVyeSh2aWV3LnN0YXRlLCBzdGF0ZS5xdWVyeS5zcGVjKTtcbiAgICAgICAgICAgIGlmIChxdWVyeS52YWxpZClcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VhcmNoUXVlcnkub2YocXVlcnkpIH0pO1xuICAgICAgICAgICAgc2VhcmNoSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIHNlYXJjaElucHV0LnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogW1xuICAgICAgICAgICAgICAgIHRvZ2dsZVBhbmVsLm9mKHRydWUpLFxuICAgICAgICAgICAgICAgIHN0YXRlID8gc2V0U2VhcmNoUXVlcnkub2YoZGVmYXVsdFF1ZXJ5KHZpZXcuc3RhdGUsIHN0YXRlLnF1ZXJ5LnNwZWMpKSA6IFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihzZWFyY2hFeHRlbnNpb25zKVxuICAgICAgICAgICAgXSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DbG9zZSB0aGUgc2VhcmNoIHBhbmVsLlxuKi9cbmNvbnN0IGNsb3NlU2VhcmNoUGFuZWwgPSB2aWV3ID0+IHtcbiAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUucGFuZWwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVTZWFyY2hQYW5lbCk7XG4gICAgaWYgKHBhbmVsICYmIHBhbmVsLmRvbS5jb250YWlucyh2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCkpXG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdG9nZ2xlUGFuZWwub2YoZmFsc2UpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRGVmYXVsdCBzZWFyY2gtcmVsYXRlZCBrZXkgYmluZGluZ3MuXG5cbiAtIE1vZC1mOiBbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbClcbiAtIEYzLCBNb2QtZzogW2BmaW5kTmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmROZXh0KVxuIC0gU2hpZnQtRjMsIFNoaWZ0LU1vZC1nOiBbYGZpbmRQcmV2aW91c2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmRQcmV2aW91cylcbiAtIEFsdC1nOiBbYGdvdG9MaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guZ290b0xpbmUpXG4gLSBNb2QtZDogW2BzZWxlY3ROZXh0T2NjdXJyZW5jZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLnNlbGVjdE5leHRPY2N1cnJlbmNlKVxuKi9cbmNvbnN0IHNlYXJjaEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJNb2QtZlwiLCBydW46IG9wZW5TZWFyY2hQYW5lbCwgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiIH0sXG4gICAgeyBrZXk6IFwiRjNcIiwgcnVuOiBmaW5kTmV4dCwgc2hpZnQ6IGZpbmRQcmV2aW91cywgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1nXCIsIHJ1bjogZmluZE5leHQsIHNoaWZ0OiBmaW5kUHJldmlvdXMsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbG9zZVNlYXJjaFBhbmVsLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIgfSxcbiAgICB7IGtleTogXCJNb2QtU2hpZnQtbFwiLCBydW46IHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMgfSxcbiAgICB7IGtleTogXCJBbHQtZ1wiLCBydW46IGdvdG9MaW5lIH0sXG4gICAgeyBrZXk6IFwiTW9kLWRcIiwgcnVuOiBzZWxlY3ROZXh0T2NjdXJyZW5jZSwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbl07XG5jbGFzcyBTZWFyY2hQYW5lbCB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnF1ZXJ5ID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkucXVlcnkuc3BlYztcbiAgICAgICAgdGhpcy5jb21taXQgPSB0aGlzLmNvbW1pdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlYXJjaEZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHF1ZXJ5LnNlYXJjaCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBwaHJhc2UodmlldywgXCJGaW5kXCIpLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcIkZpbmRcIiksXG4gICAgICAgICAgICBjbGFzczogXCJjbS10ZXh0ZmllbGRcIixcbiAgICAgICAgICAgIG5hbWU6IFwic2VhcmNoXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgXCJtYWluLWZpZWxkXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0LFxuICAgICAgICAgICAgb25rZXl1cDogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVwbGFjZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHF1ZXJ5LnJlcGxhY2UsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogcGhyYXNlKHZpZXcsIFwiUmVwbGFjZVwiKSxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwaHJhc2UodmlldywgXCJSZXBsYWNlXCIpLFxuICAgICAgICAgICAgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsXG4gICAgICAgICAgICBuYW1lOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXQsXG4gICAgICAgICAgICBvbmtleXVwOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYXNlRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICBuYW1lOiBcImNhc2VcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBjaGVja2VkOiBxdWVyeS5jYXNlU2Vuc2l0aXZlLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICBuYW1lOiBcInJlXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkucmVnZXhwLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndvcmRGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgIG5hbWU6IFwid29yZFwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIGNoZWNrZWQ6IHF1ZXJ5Lndob2xlV29yZCxcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gYnV0dG9uKG5hbWUsIG9uY2xpY2ssIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbHQoXCJidXR0b25cIiwgeyBjbGFzczogXCJjbS1idXR0b25cIiwgbmFtZSwgb25jbGljaywgdHlwZTogXCJidXR0b25cIiB9LCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbSA9IGVsdChcImRpdlwiLCB7IG9ua2V5ZG93bjogKGUpID0+IHRoaXMua2V5ZG93bihlKSwgY2xhc3M6IFwiY20tc2VhcmNoXCIgfSwgW1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hGaWVsZCxcbiAgICAgICAgICAgIGJ1dHRvbihcIm5leHRcIiwgKCkgPT4gZmluZE5leHQodmlldyksIFtwaHJhc2UodmlldywgXCJuZXh0XCIpXSksXG4gICAgICAgICAgICBidXR0b24oXCJwcmV2XCIsICgpID0+IGZpbmRQcmV2aW91cyh2aWV3KSwgW3BocmFzZSh2aWV3LCBcInByZXZpb3VzXCIpXSksXG4gICAgICAgICAgICBidXR0b24oXCJzZWxlY3RcIiwgKCkgPT4gc2VsZWN0TWF0Y2hlcyh2aWV3KSwgW3BocmFzZSh2aWV3LCBcImFsbFwiKV0pLFxuICAgICAgICAgICAgZWx0KFwibGFiZWxcIiwgbnVsbCwgW3RoaXMuY2FzZUZpZWxkLCBwaHJhc2UodmlldywgXCJtYXRjaCBjYXNlXCIpXSksXG4gICAgICAgICAgICBlbHQoXCJsYWJlbFwiLCBudWxsLCBbdGhpcy5yZUZpZWxkLCBwaHJhc2UodmlldywgXCJyZWdleHBcIildKSxcbiAgICAgICAgICAgIGVsdChcImxhYmVsXCIsIG51bGwsIFt0aGlzLndvcmRGaWVsZCwgcGhyYXNlKHZpZXcsIFwiYnkgd29yZFwiKV0pLFxuICAgICAgICAgICAgLi4udmlldy5zdGF0ZS5yZWFkT25seSA/IFtdIDogW1xuICAgICAgICAgICAgICAgIGVsdChcImJyXCIpLFxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUZpZWxkLFxuICAgICAgICAgICAgICAgIGJ1dHRvbihcInJlcGxhY2VcIiwgKCkgPT4gcmVwbGFjZU5leHQodmlldyksIFtwaHJhc2UodmlldywgXCJyZXBsYWNlXCIpXSksXG4gICAgICAgICAgICAgICAgYnV0dG9uKFwicmVwbGFjZUFsbFwiLCAoKSA9PiByZXBsYWNlQWxsKHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwicmVwbGFjZSBhbGxcIildKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGVsdChcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJjbG9zZVwiLFxuICAgICAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IGNsb3NlU2VhcmNoUGFuZWwodmlldyksXG4gICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcImNsb3NlXCIpLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCJcbiAgICAgICAgICAgIH0sIFtcIlx1MDBEN1wiXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gbmV3IFNlYXJjaFF1ZXJ5KHtcbiAgICAgICAgICAgIHNlYXJjaDogdGhpcy5zZWFyY2hGaWVsZC52YWx1ZSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IHRoaXMuY2FzZUZpZWxkLmNoZWNrZWQsXG4gICAgICAgICAgICByZWdleHA6IHRoaXMucmVGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgd2hvbGVXb3JkOiB0aGlzLndvcmRGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgcmVwbGFjZTogdGhpcy5yZXBsYWNlRmllbGQudmFsdWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXF1ZXJ5LmVxKHRoaXMucXVlcnkpKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRTZWFyY2hRdWVyeS5vZihxdWVyeSkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAga2V5ZG93bihlKSB7XG4gICAgICAgIGlmIChydW5TY29wZUhhbmRsZXJzKHRoaXMudmlldywgZSwgXCJzZWFyY2gtcGFuZWxcIikpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5zZWFyY2hGaWVsZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgKGUuc2hpZnRLZXkgPyBmaW5kUHJldmlvdXMgOiBmaW5kTmV4dCkodGhpcy52aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5yZXBsYWNlRmllbGQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJlcGxhY2VOZXh0KHRoaXMudmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSAmJiAhZWZmZWN0LnZhbHVlLmVxKHRoaXMucXVlcnkpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFF1ZXJ5KGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHNldFF1ZXJ5KHF1ZXJ5KSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZC52YWx1ZSA9IHF1ZXJ5LnNlYXJjaDtcbiAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQudmFsdWUgPSBxdWVyeS5yZXBsYWNlO1xuICAgICAgICB0aGlzLmNhc2VGaWVsZC5jaGVja2VkID0gcXVlcnkuY2FzZVNlbnNpdGl2ZTtcbiAgICAgICAgdGhpcy5yZUZpZWxkLmNoZWNrZWQgPSBxdWVyeS5yZWdleHA7XG4gICAgICAgIHRoaXMud29yZEZpZWxkLmNoZWNrZWQgPSBxdWVyeS53aG9sZVdvcmQ7XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICB0aGlzLnNlYXJjaEZpZWxkLnNlbGVjdCgpO1xuICAgIH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gODA7IH1cbiAgICBnZXQgdG9wKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS50b3A7IH1cbn1cbmZ1bmN0aW9uIHBocmFzZSh2aWV3LCBwaHJhc2UpIHsgcmV0dXJuIHZpZXcuc3RhdGUucGhyYXNlKHBocmFzZSk7IH1cbmNvbnN0IEFubm91bmNlTWFyZ2luID0gMzA7XG5jb25zdCBCcmVhayA9IC9bXFxzXFwuLDo7PyFdLztcbmZ1bmN0aW9uIGFubm91bmNlTWF0Y2godmlldywgeyBmcm9tLCB0byB9KSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIGxpbmVFbmQgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pLnRvO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGxpbmUuZnJvbSwgZnJvbSAtIEFubm91bmNlTWFyZ2luKSwgZW5kID0gTWF0aC5taW4obGluZUVuZCwgdG8gKyBBbm5vdW5jZU1hcmdpbik7XG4gICAgbGV0IHRleHQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKHN0YXJ0LCBlbmQpO1xuICAgIGlmIChzdGFydCAhPSBsaW5lLmZyb20pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBbm5vdW5jZU1hcmdpbjsgaSsrKVxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSArIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQgIT0gbGluZUVuZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID4gdGV4dC5sZW5ndGggLSBBbm5vdW5jZU1hcmdpbjsgaS0tKVxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSAtIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JWaWV3LmFubm91bmNlLm9mKGAke3ZpZXcuc3RhdGUucGhyYXNlKFwiY3VycmVudCBtYXRjaFwiKX0uICR7dGV4dH0gJHt2aWV3LnN0YXRlLnBocmFzZShcIm9uIGxpbmVcIil9ICR7bGluZS5udW1iZXJ9LmApO1xufVxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1wYW5lbC5jbS1zZWFyY2hcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjJweCA2cHggNHB4XCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJiBbbmFtZT1jbG9zZV1cIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogXCIwXCIsXG4gICAgICAgICAgICByaWdodDogXCI0cHhcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgZm9udDogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBpbnB1dCwgJiBidXR0b24sICYgbGFiZWxcIjoge1xuICAgICAgICAgICAgbWFyZ2luOiBcIi4yZW0gLjZlbSAuMmVtIDBcIlxuICAgICAgICB9LFxuICAgICAgICBcIiYgaW5wdXRbdHlwZT1jaGVja2JveF1cIjoge1xuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IFwiLjJlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBsYWJlbFwiOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogXCI4MCVcIixcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlYXJjaE1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZmMDA1NFwiIH0sXG4gICAgXCImZGFyayAuY20tc2VhcmNoTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwZmZmZjhhXCIgfSxcbiAgICBcIiZsaWdodCAuY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmNmEwMDU0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmYwMGZmOGFcIiB9XG59KTtcbmNvbnN0IHNlYXJjaEV4dGVuc2lvbnMgPSBbXG4gICAgc2VhcmNoU3RhdGUsXG4gICAgLypAX19QVVJFX18qL1ByZWMubG93ZXN0KHNlYXJjaEhpZ2hsaWdodGVyKSxcbiAgICBiYXNlVGhlbWVcbl07XG5cbmV4cG9ydCB7IFJlZ0V4cEN1cnNvciwgU2VhcmNoQ3Vyc29yLCBTZWFyY2hRdWVyeSwgY2xvc2VTZWFyY2hQYW5lbCwgZmluZE5leHQsIGZpbmRQcmV2aW91cywgZ2V0U2VhcmNoUXVlcnksIGdvdG9MaW5lLCBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzLCBvcGVuU2VhcmNoUGFuZWwsIHJlcGxhY2VBbGwsIHJlcGxhY2VOZXh0LCBzZWFyY2gsIHNlYXJjaEtleW1hcCwgc2VhcmNoUGFuZWxPcGVuLCBzZWxlY3RNYXRjaGVzLCBzZWxlY3ROZXh0T2NjdXJyZW5jZSwgc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcywgc2V0U2VhcmNoUXVlcnkgfTtcbiIsICJpbXBvcnQgeyBBbm5vdGF0aW9uLCBFZGl0b3JTZWxlY3Rpb24sIGNvZGVQb2ludEF0LCBjb2RlUG9pbnRTaXplLCBmcm9tQ29kZVBvaW50LCBGYWNldCwgY29tYmluZUNvbmZpZywgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIFByZWMsIFRleHQsIE1hcE1vZGUsIFJhbmdlVmFsdWUsIFJhbmdlU2V0LCBDaGFyQ2F0ZWdvcnkgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBsb2dFeGNlcHRpb24sIERpcmVjdGlvbiwgc2hvd1Rvb2x0aXAsIEVkaXRvclZpZXcsIFZpZXdQbHVnaW4sIGdldFRvb2x0aXAsIERlY29yYXRpb24sIFdpZGdldFR5cGUsIGtleW1hcCB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgc3ludGF4VHJlZSwgaW5kZW50VW5pdCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcblxuLyoqXG5BbiBpbnN0YW5jZSBvZiB0aGlzIGlzIHBhc3NlZCB0byBjb21wbGV0aW9uIHNvdXJjZSBmdW5jdGlvbnMuXG4qL1xuY2xhc3MgQ29tcGxldGlvbkNvbnRleHQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBjb21wbGV0aW9uIGNvbnRleHQuIChNb3N0bHkgdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgY29tcGxldGlvbiBzb3VyY2VzXHUyMDE0aW4gdGhlIGVkaXRvciwgdGhlIGV4dGVuc2lvbiB3aWxsIGNyZWF0ZVxuICAgIHRoZXNlIGZvciB5b3UuKVxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciBzdGF0ZSB0aGF0IHRoZSBjb21wbGV0aW9uIGhhcHBlbnMgaW4uXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBjb21wbGV0aW9uIGlzIGhhcHBlbmluZy5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgY29tcGxldGlvbiB3YXMgYWN0aXZhdGVkIGV4cGxpY2l0bHksIG9yXG4gICAgaW1wbGljaXRseSBieSB0eXBpbmcuIFRoZSB1c3VhbCB3YXkgdG8gcmVzcG9uZCB0byB0aGlzIGlzIHRvXG4gICAgb25seSByZXR1cm4gY29tcGxldGlvbnMgd2hlbiBlaXRoZXIgdGhlcmUgaXMgcGFydCBvZiBhXG4gICAgY29tcGxldGFibGUgZW50aXR5IGJlZm9yZSB0aGUgY3Vyc29yLCBvciBgZXhwbGljaXRgIGlzIHRydWUuXG4gICAgKi9cbiAgICBleHBsaWNpdCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmV4cGxpY2l0ID0gZXhwbGljaXQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hYm9ydExpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGV4dGVudCwgY29udGVudCwgYW5kIChpZiB0aGVyZSBpcyBhIHRva2VuKSB0eXBlIG9mIHRoZVxuICAgIHRva2VuIGJlZm9yZSBgdGhpcy5wb3NgLlxuICAgICovXG4gICAgdG9rZW5CZWZvcmUodHlwZXMpIHtcbiAgICAgICAgbGV0IHRva2VuID0gc3ludGF4VHJlZSh0aGlzLnN0YXRlKS5yZXNvbHZlSW5uZXIodGhpcy5wb3MsIC0xKTtcbiAgICAgICAgd2hpbGUgKHRva2VuICYmIHR5cGVzLmluZGV4T2YodG9rZW4ubmFtZSkgPCAwKVxuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5wYXJlbnQ7XG4gICAgICAgIHJldHVybiB0b2tlbiA/IHsgZnJvbTogdG9rZW4uZnJvbSwgdG86IHRoaXMucG9zLFxuICAgICAgICAgICAgdGV4dDogdGhpcy5zdGF0ZS5zbGljZURvYyh0b2tlbi5mcm9tLCB0aGlzLnBvcyksXG4gICAgICAgICAgICB0eXBlOiB0b2tlbi50eXBlIH0gOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG1hdGNoIG9mIHRoZSBnaXZlbiBleHByZXNzaW9uIGRpcmVjdGx5IGJlZm9yZSB0aGVcbiAgICBjdXJzb3IuXG4gICAgKi9cbiAgICBtYXRjaEJlZm9yZShleHByKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHRoaXMucG9zKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgobGluZS5mcm9tLCB0aGlzLnBvcyAtIDI1MCk7XG4gICAgICAgIGxldCBzdHIgPSBsaW5lLnRleHQuc2xpY2Uoc3RhcnQgLSBsaW5lLmZyb20sIHRoaXMucG9zIC0gbGluZS5mcm9tKTtcbiAgICAgICAgbGV0IGZvdW5kID0gc3RyLnNlYXJjaChlbnN1cmVBbmNob3IoZXhwciwgZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kIDwgMCA/IG51bGwgOiB7IGZyb206IHN0YXJ0ICsgZm91bmQsIHRvOiB0aGlzLnBvcywgdGV4dDogc3RyLnNsaWNlKGZvdW5kKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBZaWVsZHMgdHJ1ZSB3aGVuIHRoZSBxdWVyeSBoYXMgYmVlbiBhYm9ydGVkLiBDYW4gYmUgdXNlZnVsIGluXG4gICAgYXN5bmNocm9ub3VzIHF1ZXJpZXMgdG8gYXZvaWQgZG9pbmcgd29yayB0aGF0IHdpbGwgYmUgaWdub3JlZC5cbiAgICAqL1xuICAgIGdldCBhYm9ydGVkKCkgeyByZXR1cm4gdGhpcy5hYm9ydExpc3RlbmVycyA9PSBudWxsOyB9XG4gICAgLyoqXG4gICAgQWxsb3dzIHlvdSB0byByZWdpc3RlciBhYm9ydCBoYW5kbGVycywgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2hlblxuICAgIHRoZSBxdWVyeSBpc1xuICAgIFthYm9ydGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5Db21wbGV0aW9uQ29udGV4dC5hYm9ydGVkKS5cbiAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJhYm9ydFwiICYmIHRoaXMuYWJvcnRMaXN0ZW5lcnMpXG4gICAgICAgICAgICB0aGlzLmFib3J0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvU2V0KGNoYXJzKSB7XG4gICAgbGV0IGZsYXQgPSBPYmplY3Qua2V5cyhjaGFycykuam9pbihcIlwiKTtcbiAgICBsZXQgd29yZHMgPSAvXFx3Ly50ZXN0KGZsYXQpO1xuICAgIGlmICh3b3JkcylcbiAgICAgICAgZmxhdCA9IGZsYXQucmVwbGFjZSgvXFx3L2csIFwiXCIpO1xuICAgIHJldHVybiBgWyR7d29yZHMgPyBcIlxcXFx3XCIgOiBcIlwifSR7ZmxhdC5yZXBsYWNlKC9bXlxcd1xcc10vZywgXCJcXFxcJCZcIil9XWA7XG59XG5mdW5jdGlvbiBwcmVmaXhNYXRjaChvcHRpb25zKSB7XG4gICAgbGV0IGZpcnN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcmVzdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgeyBsYWJlbCB9IG9mIG9wdGlvbnMpIHtcbiAgICAgICAgZmlyc3RbbGFiZWxbMF1dID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYWJlbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3RbbGFiZWxbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHNvdXJjZSA9IHRvU2V0KGZpcnN0KSArIHRvU2V0KHJlc3QpICsgXCIqJFwiO1xuICAgIHJldHVybiBbbmV3IFJlZ0V4cChcIl5cIiArIHNvdXJjZSksIG5ldyBSZWdFeHAoc291cmNlKV07XG59XG4vKipcbkdpdmVuIGEgYSBmaXhlZCBhcnJheSBvZiBvcHRpb25zLCByZXR1cm4gYW4gYXV0b2NvbXBsZXRlciB0aGF0XG5jb21wbGV0ZXMgdGhlbS5cbiovXG5mdW5jdGlvbiBjb21wbGV0ZUZyb21MaXN0KGxpc3QpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGxpc3QubWFwKG8gPT4gdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiA/IHsgbGFiZWw6IG8gfSA6IG8pO1xuICAgIGxldCBbdmFsaWRGb3IsIG1hdGNoXSA9IG9wdGlvbnMuZXZlcnkobyA9PiAvXlxcdyskLy50ZXN0KG8ubGFiZWwpKSA/IFsvXFx3KiQvLCAvXFx3KyQvXSA6IHByZWZpeE1hdGNoKG9wdGlvbnMpO1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgdG9rZW4gPSBjb250ZXh0Lm1hdGNoQmVmb3JlKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuIHRva2VuIHx8IGNvbnRleHQuZXhwbGljaXQgPyB7IGZyb206IHRva2VuID8gdG9rZW4uZnJvbSA6IGNvbnRleHQucG9zLCBvcHRpb25zLCB2YWxpZEZvciB9IDogbnVsbDtcbiAgICB9O1xufVxuLyoqXG5XcmFwIHRoZSBnaXZlbiBjb21wbGV0aW9uIHNvdXJjZSBzbyB0aGF0IGl0IHdpbGwgb25seSBmaXJlIHdoZW4gdGhlXG5jdXJzb3IgaXMgaW4gYSBzeW50YXggbm9kZSB3aXRoIG9uZSBvZiB0aGUgZ2l2ZW4gbmFtZXMuXG4qL1xuZnVuY3Rpb24gaWZJbihub2Rlcywgc291cmNlKSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKG5vZGVzLmluZGV4T2YocG9zLm5hbWUpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZShjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChwb3MudHlwZS5pc1RvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxuLyoqXG5XcmFwIHRoZSBnaXZlbiBjb21wbGV0aW9uIHNvdXJjZSBzbyB0aGF0IGl0IHdpbGwgbm90IGZpcmUgd2hlbiB0aGVcbmN1cnNvciBpcyBpbiBhIHN5bnRheCBub2RlIHdpdGggb25lIG9mIHRoZSBnaXZlbiBuYW1lcy5cbiovXG5mdW5jdGlvbiBpZk5vdEluKG5vZGVzLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaW5kZXhPZihwb3MubmFtZSkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwb3MudHlwZS5pc1RvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlKGNvbnRleHQpO1xuICAgIH07XG59XG5jbGFzcyBPcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBsZXRpb24sIHNvdXJjZSwgbWF0Y2gpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0aW9uID0gY29tcGxldGlvbjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaDtcbiAgICB9XG59XG5mdW5jdGlvbiBjdXIoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQ7IH1cbi8vIE1ha2Ugc3VyZSB0aGUgZ2l2ZW4gcmVnZXhwIGhhcyBhICQgYXQgaXRzIGVuZCBhbmQsIGlmIGBzdGFydGAgaXNcbi8vIHRydWUsIGEgXiBhdCBpdHMgc3RhcnQuXG5mdW5jdGlvbiBlbnN1cmVBbmNob3IoZXhwciwgc3RhcnQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgc291cmNlIH0gPSBleHByO1xuICAgIGxldCBhZGRTdGFydCA9IHN0YXJ0ICYmIHNvdXJjZVswXSAhPSBcIl5cIiwgYWRkRW5kID0gc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSAhPSBcIiRcIjtcbiAgICBpZiAoIWFkZFN0YXJ0ICYmICFhZGRFbmQpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGAke2FkZFN0YXJ0ID8gXCJeXCIgOiBcIlwifSg/OiR7c291cmNlfSkke2FkZEVuZCA/IFwiJFwiIDogXCJcIn1gLCAoX2EgPSBleHByLmZsYWdzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoZXhwci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSk7XG59XG4vKipcblRoaXMgYW5ub3RhdGlvbiBpcyBhZGRlZCB0byB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgcHJvZHVjZWQgYnlcbnBpY2tpbmcgYSBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IHBpY2tlZENvbXBsZXRpb24gPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRyYW5zYWN0aW9uIHNwZWMgd2hpY2ggaW5zZXJ0cyBhXG5jb21wbGV0aW9uJ3MgdGV4dCBpbiB0aGUgbWFpbiBzZWxlY3Rpb24gcmFuZ2UsIGFuZCBhbnkgb3RoZXJcbnNlbGVjdGlvbiByYW5nZSB0aGF0IGhhcyB0aGUgc2FtZSB0ZXh0IGluIGZyb250IG9mIGl0LlxuKi9cbmZ1bmN0aW9uIGluc2VydENvbXBsZXRpb25UZXh0KHN0YXRlLCB0ZXh0LCBmcm9tLCB0bykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UgPT0gc3RhdGUuc2VsZWN0aW9uLm1haW4pXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogZnJvbSwgdG86IHRvLCBpbnNlcnQ6IHRleHQgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tICsgdGV4dC5sZW5ndGgpXG4gICAgICAgICAgICB9O1xuICAgICAgICBsZXQgbGVuID0gdG8gLSBmcm9tO1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5IHx8XG4gICAgICAgICAgICBsZW4gJiYgc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSAtIGxlbiwgcmFuZ2UuZnJvbSkgIT0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSAtIGxlbiwgdG86IHJhbmdlLmZyb20sIGluc2VydDogdGV4dCB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSAtIGxlbiArIHRleHQubGVuZ3RoKVxuICAgICAgICB9O1xuICAgIH0pKSwgeyB1c2VyRXZlbnQ6IFwiaW5wdXQuY29tcGxldGVcIiB9KTtcbn1cbmZ1bmN0aW9uIGFwcGx5Q29tcGxldGlvbih2aWV3LCBvcHRpb24pIHtcbiAgICBjb25zdCBhcHBseSA9IG9wdGlvbi5jb21wbGV0aW9uLmFwcGx5IHx8IG9wdGlvbi5jb21wbGV0aW9uLmxhYmVsO1xuICAgIGxldCByZXN1bHQgPSBvcHRpb24uc291cmNlO1xuICAgIGlmICh0eXBlb2YgYXBwbHkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgdmlldy5kaXNwYXRjaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluc2VydENvbXBsZXRpb25UZXh0KHZpZXcuc3RhdGUsIGFwcGx5LCByZXN1bHQuZnJvbSwgcmVzdWx0LnRvKSksIHsgYW5ub3RhdGlvbnM6IHBpY2tlZENvbXBsZXRpb24ub2Yob3B0aW9uLmNvbXBsZXRpb24pIH0pKTtcbiAgICBlbHNlXG4gICAgICAgIGFwcGx5KHZpZXcsIG9wdGlvbi5jb21wbGV0aW9uLCByZXN1bHQuZnJvbSwgcmVzdWx0LnRvKTtcbn1cbmNvbnN0IFNvdXJjZUNhY2hlID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBhc1NvdXJjZShzb3VyY2UpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlKSlcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICBsZXQga25vd24gPSBTb3VyY2VDYWNoZS5nZXQoc291cmNlKTtcbiAgICBpZiAoIWtub3duKVxuICAgICAgICBTb3VyY2VDYWNoZS5zZXQoc291cmNlLCBrbm93biA9IGNvbXBsZXRlRnJvbUxpc3Qoc291cmNlKSk7XG4gICAgcmV0dXJuIGtub3duO1xufVxuXG4vLyBBIHBhdHRlcm4gbWF0Y2hlciBmb3IgZnV6enkgY29tcGxldGlvbiBtYXRjaGluZy4gQ3JlYXRlIGFuIGluc3RhbmNlXG4vLyBvbmNlIGZvciBhIHBhdHRlcm4sIGFuZCB0aGVuIHVzZSB0aGF0IHRvIG1hdGNoIGFueSBudW1iZXIgb2Zcbi8vIGNvbXBsZXRpb25zLlxuY2xhc3MgRnV6enlNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMuY2hhcnMgPSBbXTtcbiAgICAgICAgdGhpcy5mb2xkZWQgPSBbXTtcbiAgICAgICAgLy8gQnVmZmVycyByZXVzZWQgYnkgY2FsbHMgdG8gYG1hdGNoYCB0byB0cmFjayBtYXRjaGVkIGNoYXJhY3RlclxuICAgICAgICAvLyBwb3NpdGlvbnMuXG4gICAgICAgIHRoaXMuYW55ID0gW107XG4gICAgICAgIHRoaXMucHJlY2lzZSA9IFtdO1xuICAgICAgICB0aGlzLmJ5V29yZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IHBhdHRlcm4ubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGNoYXIgPSBjb2RlUG9pbnRBdChwYXR0ZXJuLCBwKSwgc2l6ZSA9IGNvZGVQb2ludFNpemUoY2hhcik7XG4gICAgICAgICAgICB0aGlzLmNoYXJzLnB1c2goY2hhcik7XG4gICAgICAgICAgICBsZXQgcGFydCA9IHBhdHRlcm4uc2xpY2UocCwgcCArIHNpemUpLCB1cHBlciA9IHBhcnQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuZm9sZGVkLnB1c2goY29kZVBvaW50QXQodXBwZXIgPT0gcGFydCA/IHBhcnQudG9Mb3dlckNhc2UoKSA6IHVwcGVyLCAwKSk7XG4gICAgICAgICAgICBwICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hc3RyYWwgPSBwYXR0ZXJuLmxlbmd0aCAhPSB0aGlzLmNoYXJzLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gTWF0Y2hlcyBhIGdpdmVuIHdvcmQgKGNvbXBsZXRpb24pIGFnYWluc3QgdGhlIHBhdHRlcm4gKGlucHV0KS5cbiAgICAvLyBXaWxsIHJldHVybiBudWxsIGZvciBubyBtYXRjaCwgYW5kIG90aGVyd2lzZSBhbiBhcnJheSB0aGF0IHN0YXJ0c1xuICAgIC8vIHdpdGggdGhlIG1hdGNoIHNjb3JlLCBmb2xsb3dlZCBieSBhbnkgbnVtYmVyIG9mIGBmcm9tLCB0b2AgcGFpcnNcbiAgICAvLyBpbmRpY2F0aW5nIHRoZSBtYXRjaGVkIHBhcnRzIG9mIGB3b3JkYC5cbiAgICAvL1xuICAgIC8vIFRoZSBzY29yZSBpcyBhIG51bWJlciB0aGF0IGlzIG1vcmUgbmVnYXRpdmUgdGhlIHdvcnNlIHRoZSBtYXRjaFxuICAgIC8vIGlzLiBTZWUgYFBlbmFsdHlgIGFib3ZlLlxuICAgIG1hdGNoKHdvcmQpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0dGVybi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBbMF07XG4gICAgICAgIGlmICh3b3JkLmxlbmd0aCA8IHRoaXMucGF0dGVybi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgY2hhcnMsIGZvbGRlZCwgYW55LCBwcmVjaXNlLCBieVdvcmQgfSA9IHRoaXM7XG4gICAgICAgIC8vIEZvciBzaW5nbGUtY2hhcmFjdGVyIHF1ZXJpZXMsIG9ubHkgbWF0Y2ggd2hlbiB0aGV5IG9jY3VyIHJpZ2h0XG4gICAgICAgIC8vIGF0IHRoZSBzdGFydFxuICAgICAgICBpZiAoY2hhcnMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGNvZGVQb2ludEF0KHdvcmQsIDApLCBmaXJzdFNpemUgPSBjb2RlUG9pbnRTaXplKGZpcnN0KTtcbiAgICAgICAgICAgIGxldCBzY29yZSA9IGZpcnN0U2l6ZSA9PSB3b3JkLmxlbmd0aCA/IDAgOiAtMTAwIC8qIFBlbmFsdHkuTm90RnVsbCAqLztcbiAgICAgICAgICAgIGlmIChmaXJzdCA9PSBjaGFyc1swXSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3QgPT0gZm9sZGVkWzBdKVxuICAgICAgICAgICAgICAgIHNjb3JlICs9IC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBbc2NvcmUsIDAsIGZpcnN0U2l6ZV07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpcmVjdCA9IHdvcmQuaW5kZXhPZih0aGlzLnBhdHRlcm4pO1xuICAgICAgICBpZiAoZGlyZWN0ID09IDApXG4gICAgICAgICAgICByZXR1cm4gW3dvcmQubGVuZ3RoID09IHRoaXMucGF0dGVybi5sZW5ndGggPyAwIDogLTEwMCAvKiBQZW5hbHR5Lk5vdEZ1bGwgKi8sIDAsIHRoaXMucGF0dGVybi5sZW5ndGhdO1xuICAgICAgICBsZXQgbGVuID0gY2hhcnMubGVuZ3RoLCBhbnlUbyA9IDA7XG4gICAgICAgIGlmIChkaXJlY3QgPCAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgZSA9IE1hdGgubWluKHdvcmQubGVuZ3RoLCAyMDApOyBpIDwgZSAmJiBhbnlUbyA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNvZGVQb2ludEF0KHdvcmQsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IGNoYXJzW2FueVRvXSB8fCBuZXh0ID09IGZvbGRlZFthbnlUb10pXG4gICAgICAgICAgICAgICAgICAgIGFueVthbnlUbysrXSA9IGk7XG4gICAgICAgICAgICAgICAgaSArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gbWF0Y2gsIGV4aXQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChhbnlUbyA8IGxlbilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHRyYWNrcyB0aGUgZXh0ZW50IG9mIHRoZSBwcmVjaXNlIChub24tZm9sZGVkLCBub3RcbiAgICAgICAgLy8gbmVjZXNzYXJpbHkgYWRqYWNlbnQpIG1hdGNoXG4gICAgICAgIGxldCBwcmVjaXNlVG8gPSAwO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciB0aGVyZSBpcyBhIG1hdGNoIHRoYXQgaGl0cyBvbmx5IGNoYXJhY3RlcnMgdGhhdFxuICAgICAgICAvLyBhcHBlYXIgdG8gYmUgc3RhcnRpbmcgd29yZHMuIGBieVdvcmRGb2xkZWRgIGlzIHNldCB0byB0cnVlIHdoZW5cbiAgICAgICAgLy8gYSBjYXNlIGZvbGRlZCBjaGFyYWN0ZXIgaXMgZW5jb3VudGVyZWQgaW4gc3VjaCBhIG1hdGNoXG4gICAgICAgIGxldCBieVdvcmRUbyA9IDAsIGJ5V29yZEZvbGRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBmb3VuZCBhIHBhcnRpYWwgYWRqYWNlbnQgbWF0Y2gsIHRoZXNlIHRyYWNrIGl0cyBzdGF0ZVxuICAgICAgICBsZXQgYWRqYWNlbnRUbyA9IDAsIGFkamFjZW50U3RhcnQgPSAtMSwgYWRqYWNlbnRFbmQgPSAtMTtcbiAgICAgICAgbGV0IGhhc0xvd2VyID0gL1thLXpdLy50ZXN0KHdvcmQpLCB3b3JkQWRqYWNlbnQgPSB0cnVlO1xuICAgICAgICAvLyBHbyBvdmVyIHRoZSBvcHRpb24ncyB0ZXh0LCBzY2FubmluZyBmb3IgdGhlIHZhcmlvdXMga2luZHMgb2YgbWF0Y2hlc1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgZSA9IE1hdGgubWluKHdvcmQubGVuZ3RoLCAyMDApLCBwcmV2VHlwZSA9IDAgLyogVHAuTm9uV29yZCAqLzsgaSA8IGUgJiYgYnlXb3JkVG8gPCBsZW47KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGNvZGVQb2ludEF0KHdvcmQsIGkpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlY2lzZVRvIDwgbGVuICYmIG5leHQgPT0gY2hhcnNbcHJlY2lzZVRvXSlcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzZVtwcmVjaXNlVG8rK10gPSBpO1xuICAgICAgICAgICAgICAgIGlmIChhZGphY2VudFRvIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IGNoYXJzW2FkamFjZW50VG9dIHx8IG5leHQgPT0gZm9sZGVkW2FkamFjZW50VG9dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50U3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRFbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50VG8rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50VG8gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoLCB0eXBlID0gbmV4dCA8IDB4ZmZcbiAgICAgICAgICAgICAgICA/IChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcgfHwgbmV4dCA+PSA5NyAmJiBuZXh0IDw9IDEyMiA/IDIgLyogVHAuTG93ZXIgKi8gOiBuZXh0ID49IDY1ICYmIG5leHQgPD0gOTAgPyAxIC8qIFRwLlVwcGVyICovIDogMCAvKiBUcC5Ob25Xb3JkICovKVxuICAgICAgICAgICAgICAgIDogKChjaCA9IGZyb21Db2RlUG9pbnQobmV4dCkpICE9IGNoLnRvTG93ZXJDYXNlKCkgPyAxIC8qIFRwLlVwcGVyICovIDogY2ggIT0gY2gudG9VcHBlckNhc2UoKSA/IDIgLyogVHAuTG93ZXIgKi8gOiAwIC8qIFRwLk5vbldvcmQgKi8pO1xuICAgICAgICAgICAgaWYgKCFpIHx8IHR5cGUgPT0gMSAvKiBUcC5VcHBlciAqLyAmJiBoYXNMb3dlciB8fCBwcmV2VHlwZSA9PSAwIC8qIFRwLk5vbldvcmQgKi8gJiYgdHlwZSAhPSAwIC8qIFRwLk5vbldvcmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnNbYnlXb3JkVG9dID09IG5leHQgfHwgKGZvbGRlZFtieVdvcmRUb10gPT0gbmV4dCAmJiAoYnlXb3JkRm9sZGVkID0gdHJ1ZSkpKVxuICAgICAgICAgICAgICAgICAgICBieVdvcmRbYnlXb3JkVG8rK10gPSBpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJ5V29yZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHdvcmRBZGphY2VudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgaSArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieVdvcmRUbyA9PSBsZW4gJiYgYnlXb3JkWzBdID09IDAgJiYgd29yZEFkamFjZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0KC0xMDAgLyogUGVuYWx0eS5CeVdvcmQgKi8gKyAoYnlXb3JkRm9sZGVkID8gLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovIDogMCksIGJ5V29yZCwgd29yZCk7XG4gICAgICAgIGlmIChhZGphY2VudFRvID09IGxlbiAmJiBhZGphY2VudFN0YXJ0ID09IDApXG4gICAgICAgICAgICByZXR1cm4gWy0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyAtIHdvcmQubGVuZ3RoICsgKGFkamFjZW50RW5kID09IHdvcmQubGVuZ3RoID8gMCA6IC0xMDAgLyogUGVuYWx0eS5Ob3RGdWxsICovKSwgMCwgYWRqYWNlbnRFbmRdO1xuICAgICAgICBpZiAoZGlyZWN0ID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gWy03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyAtIHdvcmQubGVuZ3RoLCBkaXJlY3QsIGRpcmVjdCArIHRoaXMucGF0dGVybi5sZW5ndGhdO1xuICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSBsZW4pXG4gICAgICAgICAgICByZXR1cm4gWy0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyArIC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyAtIHdvcmQubGVuZ3RoLCBhZGphY2VudFN0YXJ0LCBhZGphY2VudEVuZF07XG4gICAgICAgIGlmIChieVdvcmRUbyA9PSBsZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQoLTEwMCAvKiBQZW5hbHR5LkJ5V29yZCAqLyArIChieVdvcmRGb2xkZWQgPyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gOiAwKSArIC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyArXG4gICAgICAgICAgICAgICAgKHdvcmRBZGphY2VudCA/IDAgOiAtMTEwMCAvKiBQZW5hbHR5LkdhcCAqLyksIGJ5V29yZCwgd29yZCk7XG4gICAgICAgIHJldHVybiBjaGFycy5sZW5ndGggPT0gMiA/IG51bGwgOiB0aGlzLnJlc3VsdCgoYW55WzBdID8gLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovIDogMCkgKyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gKyAtMTEwMCAvKiBQZW5hbHR5LkdhcCAqLywgYW55LCB3b3JkKTtcbiAgICB9XG4gICAgcmVzdWx0KHNjb3JlLCBwb3NpdGlvbnMsIHdvcmQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtzY29yZSAtIHdvcmQubGVuZ3RoXSwgaSA9IDE7XG4gICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCB0byA9IHBvcyArICh0aGlzLmFzdHJhbCA/IGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQod29yZCwgcG9zKSkgOiAxKTtcbiAgICAgICAgICAgIGlmIChpID4gMSAmJiByZXN1bHRbaSAtIDFdID09IHBvcylcbiAgICAgICAgICAgICAgICByZXN1bHRbaSAtIDFdID0gdG87XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IHBvcztcbiAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG5jb25zdCBjb21wbGV0aW9uQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIGFjdGl2YXRlT25UeXBpbmc6IHRydWUsXG4gICAgICAgICAgICBzZWxlY3RPbk9wZW46IHRydWUsXG4gICAgICAgICAgICBvdmVycmlkZTogbnVsbCxcbiAgICAgICAgICAgIGNsb3NlT25CbHVyOiB0cnVlLFxuICAgICAgICAgICAgbWF4UmVuZGVyZWRPcHRpb25zOiAxMDAsXG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiB0cnVlLFxuICAgICAgICAgICAgdG9vbHRpcENsYXNzOiAoKSA9PiBcIlwiLFxuICAgICAgICAgICAgb3B0aW9uQ2xhc3M6ICgpID0+IFwiXCIsXG4gICAgICAgICAgICBhYm92ZUN1cnNvcjogZmFsc2UsXG4gICAgICAgICAgICBpY29uczogdHJ1ZSxcbiAgICAgICAgICAgIGFkZFRvT3B0aW9uczogW10sXG4gICAgICAgICAgICBjb21wYXJlQ29tcGxldGlvbnM6IChhLCBiKSA9PiBhLmxhYmVsLmxvY2FsZUNvbXBhcmUoYi5sYWJlbCksXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkRlbGF5OiA3NVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiAoYSwgYikgPT4gYSAmJiBiLFxuICAgICAgICAgICAgY2xvc2VPbkJsdXI6IChhLCBiKSA9PiBhICYmIGIsXG4gICAgICAgICAgICBpY29uczogKGEsIGIpID0+IGEgJiYgYixcbiAgICAgICAgICAgIHRvb2x0aXBDbGFzczogKGEsIGIpID0+IGMgPT4gam9pbkNsYXNzKGEoYyksIGIoYykpLFxuICAgICAgICAgICAgb3B0aW9uQ2xhc3M6IChhLCBiKSA9PiBjID0+IGpvaW5DbGFzcyhhKGMpLCBiKGMpKSxcbiAgICAgICAgICAgIGFkZFRvT3B0aW9uczogKGEsIGIpID0+IGEuY29uY2F0KGIpXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gam9pbkNsYXNzKGEsIGIpIHtcbiAgICByZXR1cm4gYSA/IGIgPyBhICsgXCIgXCIgKyBiIDogYSA6IGI7XG59XG5cbmZ1bmN0aW9uIG9wdGlvbkNvbnRlbnQoY29uZmlnKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBjb25maWcuYWRkVG9PcHRpb25zLnNsaWNlKCk7XG4gICAgaWYgKGNvbmZpZy5pY29ucylcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgIHJlbmRlcihjb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25JY29uXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0aW9uLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZCguLi5jb21wbGV0aW9uLnR5cGUuc3BsaXQoL1xccysvZykubWFwKGNscyA9PiBcImNtLWNvbXBsZXRpb25JY29uLVwiICsgY2xzKSk7XG4gICAgICAgICAgICAgICAgaWNvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGljb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IDIwXG4gICAgICAgIH0pO1xuICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgIHJlbmRlcihjb21wbGV0aW9uLCBfcywgbWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBsYWJlbEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgbGFiZWxFbHQuY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uTGFiZWxcIjtcbiAgICAgICAgICAgIGxldCB7IGxhYmVsIH0gPSBjb21wbGV0aW9uLCBvZmYgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBtYXRjaC5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBtYXRjaFtqKytdLCB0byA9IG1hdGNoW2orK107XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiBvZmYpXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKG9mZiwgZnJvbSkpKTtcbiAgICAgICAgICAgICAgICBsZXQgc3BhbiA9IGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKTtcbiAgICAgICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKGZyb20sIHRvKSkpO1xuICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjtcbiAgICAgICAgICAgICAgICBvZmYgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmYgPCBsYWJlbC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2Uob2ZmKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsRWx0O1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogNTBcbiAgICB9LCB7XG4gICAgICAgIHJlbmRlcihjb21wbGV0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRpb24uZGV0YWlsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IGRldGFpbEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgZGV0YWlsRWx0LmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkRldGFpbFwiO1xuICAgICAgICAgICAgZGV0YWlsRWx0LnRleHRDb250ZW50ID0gY29tcGxldGlvbi5kZXRhaWw7XG4gICAgICAgICAgICByZXR1cm4gZGV0YWlsRWx0O1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogODBcbiAgICB9KTtcbiAgICByZXR1cm4gY29udGVudC5zb3J0KChhLCBiKSA9PiBhLnBvc2l0aW9uIC0gYi5wb3NpdGlvbikubWFwKGEgPT4gYS5yZW5kZXIpO1xufVxuZnVuY3Rpb24gcmFuZ2VBcm91bmRTZWxlY3RlZCh0b3RhbCwgc2VsZWN0ZWQsIG1heCkge1xuICAgIGlmICh0b3RhbCA8PSBtYXgpXG4gICAgICAgIHJldHVybiB7IGZyb206IDAsIHRvOiB0b3RhbCB9O1xuICAgIGlmIChzZWxlY3RlZCA8IDApXG4gICAgICAgIHNlbGVjdGVkID0gMDtcbiAgICBpZiAoc2VsZWN0ZWQgPD0gKHRvdGFsID4+IDEpKSB7XG4gICAgICAgIGxldCBvZmYgPSBNYXRoLmZsb29yKHNlbGVjdGVkIC8gbWF4KTtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogb2ZmICogbWF4LCB0bzogKG9mZiArIDEpICogbWF4IH07XG4gICAgfVxuICAgIGxldCBvZmYgPSBNYXRoLmZsb29yKCh0b3RhbCAtIHNlbGVjdGVkKSAvIG1heCk7XG4gICAgcmV0dXJuIHsgZnJvbTogdG90YWwgLSAob2ZmICsgMSkgKiBtYXgsIHRvOiB0b3RhbCAtIG9mZiAqIG1heCB9O1xufVxuY2xhc3MgQ29tcGxldGlvblRvb2x0aXAge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHN0YXRlRmllbGQpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5zdGF0ZUZpZWxkID0gc3RhdGVGaWVsZDtcbiAgICAgICAgdGhpcy5pbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5wbGFjZUluZm8gPSB7XG4gICAgICAgICAgICByZWFkOiAoKSA9PiB0aGlzLm1lYXN1cmVJbmZvKCksXG4gICAgICAgICAgICB3cml0ZTogKHBvcykgPT4gdGhpcy5wb3NpdGlvbkluZm8ocG9zKSxcbiAgICAgICAgICAgIGtleTogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNwYWNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2xhc3MgPSBcIlwiO1xuICAgICAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzdGF0ZUZpZWxkKTtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgc2VsZWN0ZWQgfSA9IGNTdGF0ZS5vcGVuO1xuICAgICAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgdGhpcy5vcHRpb25Db250ZW50ID0gb3B0aW9uQ29udGVudChjb25maWcpO1xuICAgICAgICB0aGlzLm9wdGlvbkNsYXNzID0gY29uZmlnLm9wdGlvbkNsYXNzO1xuICAgICAgICB0aGlzLnRvb2x0aXBDbGFzcyA9IGNvbmZpZy50b29sdGlwQ2xhc3M7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wdGlvbnMubGVuZ3RoLCBzZWxlY3RlZCwgY29uZmlnLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZVwiO1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBDbGFzcyh2aWV3LnN0YXRlKTtcbiAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgZG9tID0gZS50YXJnZXQsIG1hdGNoOyBkb20gJiYgZG9tICE9IHRoaXMuZG9tOyBkb20gPSBkb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJMSVwiICYmIChtYXRjaCA9IC8tKFxcZCspJC8uZXhlYyhkb20uaWQpKSAmJiArbWF0Y2hbMV0gPCBvcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uc1srbWF0Y2hbMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5saXN0ID0gdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVMaXN0Qm94KG9wdGlvbnMsIGNTdGF0ZS5pZCwgdGhpcy5yYW5nZSkpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmZvKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mbyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtb3VudCgpIHsgdGhpcy51cGRhdGVTZWwoKTsgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGxldCBjU3RhdGUgPSB1cGRhdGUuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKTtcbiAgICAgICAgbGV0IHByZXZTdGF0ZSA9IHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCk7XG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcENsYXNzKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmIChjU3RhdGUgIT0gcHJldlN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbCgpO1xuICAgICAgICAgICAgaWYgKCgoX2EgPSBjU3RhdGUub3BlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2FibGVkKSAhPSAoKF9iID0gcHJldlN0YXRlLm9wZW4pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNhYmxlZCkpXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkXCIsICEhKChfYyA9IGNTdGF0ZS5vcGVuKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGlzYWJsZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVUb29sdGlwQ2xhc3Moc3RhdGUpIHtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMudG9vbHRpcENsYXNzKHN0YXRlKTtcbiAgICAgICAgaWYgKGNscyAhPSB0aGlzLmN1cnJlbnRDbGFzcykge1xuICAgICAgICAgICAgZm9yIChsZXQgYyBvZiB0aGlzLmN1cnJlbnRDbGFzcy5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNscy5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoYyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDbGFzcyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBwb3NpdGlvbmVkKHNwYWNlKSB7XG4gICAgICAgIHRoaXMuc3BhY2UgPSBzcGFjZTtcbiAgICAgICAgaWYgKHRoaXMuaW5mbylcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mbyk7XG4gICAgfVxuICAgIHVwZGF0ZVNlbCgpIHtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQpLCBvcGVuID0gY1N0YXRlLm9wZW47XG4gICAgICAgIGlmIChvcGVuLnNlbGVjdGVkID4gLTEgJiYgb3Blbi5zZWxlY3RlZCA8IHRoaXMucmFuZ2UuZnJvbSB8fCBvcGVuLnNlbGVjdGVkID49IHRoaXMucmFuZ2UudG8pIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wZW4ub3B0aW9ucy5sZW5ndGgsIG9wZW4uc2VsZWN0ZWQsIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5tYXhSZW5kZXJlZE9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5saXN0LnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5saXN0ID0gdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVMaXN0Qm94KG9wZW4ub3B0aW9ucywgY1N0YXRlLmlkLCB0aGlzLnJhbmdlKSk7XG4gICAgICAgICAgICB0aGlzLmxpc3QuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5mbylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVNlbGVjdGVkT3B0aW9uKG9wZW4uc2VsZWN0ZWQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmZvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mbyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgeyBjb21wbGV0aW9uIH0gPSBvcGVuLm9wdGlvbnNbb3Blbi5zZWxlY3RlZF07XG4gICAgICAgICAgICBsZXQgeyBpbmZvIH0gPSBjb21wbGV0aW9uO1xuICAgICAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBpbmZvUmVzdWx0ID0gdHlwZW9mIGluZm8gPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoaW5mbykgOiBpbmZvKGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgaWYgKCFpbmZvUmVzdWx0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICgndGhlbicgaW4gaW5mb1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgIGluZm9SZXN1bHQudGhlbihub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCwgZmFsc2UpID09IGNTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5mb1BhbmUobm9kZSk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZSA9PiBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlLCBcImNvbXBsZXRpb24gaW5mb1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEluZm9QYW5lKGluZm9SZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEluZm9QYW5lKGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IGRvbSA9IHRoaXMuaW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRvbS5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAgY20tY29tcGxldGlvbkluZm9cIjtcbiAgICAgICAgZG9tLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm8pO1xuICAgIH1cbiAgICB1cGRhdGVTZWxlY3RlZE9wdGlvbihzZWxlY3RlZCkge1xuICAgICAgICBsZXQgc2V0ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgb3B0ID0gdGhpcy5saXN0LmZpcnN0Q2hpbGQsIGkgPSB0aGlzLnJhbmdlLmZyb207IG9wdDsgb3B0ID0gb3B0Lm5leHRTaWJsaW5nLCBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHQuaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHQuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IG9wdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpXG4gICAgICAgICAgICAgICAgICAgIG9wdC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXQpXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldyh0aGlzLmxpc3QsIHNldCk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIG1lYXN1cmVJbmZvKCkge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5kb20ucXVlcnlTZWxlY3RvcihcIlthcmlhLXNlbGVjdGVkXVwiKTtcbiAgICAgICAgaWYgKCFzZWwgfHwgIXRoaXMuaW5mbylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbGlzdFJlY3QgPSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGluZm9SZWN0ID0gdGhpcy5pbmZvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc2VsUmVjdCA9IHNlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNwYWNlID0gdGhpcy5zcGFjZTtcbiAgICAgICAgaWYgKCFzcGFjZSkge1xuICAgICAgICAgICAgbGV0IHdpbiA9IHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgICAgICAgICAgc3BhY2UgPSB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IHdpbi5pbm5lcldpZHRoLCBib3R0b206IHdpbi5pbm5lckhlaWdodCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxSZWN0LnRvcCA+IE1hdGgubWluKHNwYWNlLmJvdHRvbSwgbGlzdFJlY3QuYm90dG9tKSAtIDEwIHx8XG4gICAgICAgICAgICBzZWxSZWN0LmJvdHRvbSA8IE1hdGgubWF4KHNwYWNlLnRvcCwgbGlzdFJlY3QudG9wKSArIDEwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBydGwgPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uUlRMLCBsZWZ0ID0gcnRsLCBuYXJyb3cgPSBmYWxzZSwgbWF4V2lkdGg7XG4gICAgICAgIGxldCB0b3AgPSBcIlwiLCBib3R0b20gPSBcIlwiO1xuICAgICAgICBsZXQgc3BhY2VMZWZ0ID0gbGlzdFJlY3QubGVmdCAtIHNwYWNlLmxlZnQsIHNwYWNlUmlnaHQgPSBzcGFjZS5yaWdodCAtIGxpc3RSZWN0LnJpZ2h0O1xuICAgICAgICBpZiAobGVmdCAmJiBzcGFjZUxlZnQgPCBNYXRoLm1pbihpbmZvUmVjdC53aWR0aCwgc3BhY2VSaWdodCkpXG4gICAgICAgICAgICBsZWZ0ID0gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKCFsZWZ0ICYmIHNwYWNlUmlnaHQgPCBNYXRoLm1pbihpbmZvUmVjdC53aWR0aCwgc3BhY2VMZWZ0KSlcbiAgICAgICAgICAgIGxlZnQgPSB0cnVlO1xuICAgICAgICBpZiAoaW5mb1JlY3Qud2lkdGggPD0gKGxlZnQgPyBzcGFjZUxlZnQgOiBzcGFjZVJpZ2h0KSkge1xuICAgICAgICAgICAgdG9wID0gKE1hdGgubWF4KHNwYWNlLnRvcCwgTWF0aC5taW4oc2VsUmVjdC50b3AsIHNwYWNlLmJvdHRvbSAtIGluZm9SZWN0LmhlaWdodCkpIC0gbGlzdFJlY3QudG9wKSArIFwicHhcIjtcbiAgICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5taW4oNDAwIC8qIEluZm8uV2lkdGggKi8sIGxlZnQgPyBzcGFjZUxlZnQgOiBzcGFjZVJpZ2h0KSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hcnJvdyA9IHRydWU7XG4gICAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKDQwMCAvKiBJbmZvLldpZHRoICovLCAocnRsID8gbGlzdFJlY3QucmlnaHQgOiBzcGFjZS5yaWdodCAtIGxpc3RSZWN0LmxlZnQpIC0gMzAgLyogSW5mby5NYXJnaW4gKi8pICsgXCJweFwiO1xuICAgICAgICAgICAgbGV0IHNwYWNlQmVsb3cgPSBzcGFjZS5ib3R0b20gLSBsaXN0UmVjdC5ib3R0b207XG4gICAgICAgICAgICBpZiAoc3BhY2VCZWxvdyA+PSBpbmZvUmVjdC5oZWlnaHQgfHwgc3BhY2VCZWxvdyA+IGxpc3RSZWN0LnRvcCkgLy8gQmVsb3cgdGhlIGNvbXBsZXRpb25cbiAgICAgICAgICAgICAgICB0b3AgPSAoc2VsUmVjdC5ib3R0b20gLSBsaXN0UmVjdC50b3ApICsgXCJweFwiO1xuICAgICAgICAgICAgZWxzZSAvLyBBYm92ZSBpdFxuICAgICAgICAgICAgICAgIGJvdHRvbSA9IChsaXN0UmVjdC5ib3R0b20gLSBzZWxSZWN0LnRvcCkgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcCwgYm90dG9tLCBtYXhXaWR0aCxcbiAgICAgICAgICAgIGNsYXNzOiBuYXJyb3cgPyAocnRsID8gXCJsZWZ0LW5hcnJvd1wiIDogXCJyaWdodC1uYXJyb3dcIikgOiBsZWZ0ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHBvc2l0aW9uSW5mbyhwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5mbykge1xuICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5zdHlsZS50b3AgPSBwb3MudG9wO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5zdHlsZS5ib3R0b20gPSBwb3MuYm90dG9tO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5zdHlsZS5tYXhXaWR0aCA9IHBvcy5tYXhXaWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwIGNtLWNvbXBsZXRpb25JbmZvIGNtLWNvbXBsZXRpb25JbmZvLVwiICsgcG9zLmNsYXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLnN0eWxlLnRvcCA9IFwiLTFlNnB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlTGlzdEJveChvcHRpb25zLCBpZCwgcmFuZ2UpIHtcbiAgICAgICAgY29uc3QgdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG4gICAgICAgIHVsLmlkID0gaWQ7XG4gICAgICAgIHVsLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJsaXN0Ym94XCIpO1xuICAgICAgICB1bC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdWwuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLnZpZXcuc3RhdGUucGhyYXNlKFwiQ29tcGxldGlvbnNcIikpO1xuICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2UuZnJvbTsgaSA8IHJhbmdlLnRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBsZXRpb24sIG1hdGNoIH0gPSBvcHRpb25zW2ldO1xuICAgICAgICAgICAgY29uc3QgbGkgPSB1bC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIikpO1xuICAgICAgICAgICAgbGkuaWQgPSBpZCArIFwiLVwiICsgaTtcbiAgICAgICAgICAgIGxpLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJvcHRpb25cIik7XG4gICAgICAgICAgICBsZXQgY2xzID0gdGhpcy5vcHRpb25DbGFzcyhjb21wbGV0aW9uKTtcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgbGkuY2xhc3NOYW1lID0gY2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgc291cmNlIG9mIHRoaXMub3B0aW9uQ29udGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gc291cmNlKGNvbXBsZXRpb24sIHRoaXMudmlldy5zdGF0ZSwgbWF0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlKVxuICAgICAgICAgICAgICAgICAgICBsaS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmFuZ2UuZnJvbSlcbiAgICAgICAgICAgIHVsLmNsYXNzTGlzdC5hZGQoXCJjbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVUb3BcIik7XG4gICAgICAgIGlmIChyYW5nZS50byA8IG9wdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdWwuY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZUJvdHRvbVwiKTtcbiAgICAgICAgcmV0dXJuIHVsO1xuICAgIH1cbn1cbi8vIFdlIGFsbG9jYXRlIGEgbmV3IGZ1bmN0aW9uIGluc3RhbmNlIGV2ZXJ5IHRpbWUgdGhlIGNvbXBsZXRpb25cbi8vIGNoYW5nZXMgdG8gZm9yY2UgcmVkcmF3aW5nL3JlcG9zaXRpb25pbmcgb2YgdGhlIHRvb2x0aXBcbmZ1bmN0aW9uIGNvbXBsZXRpb25Ub29sdGlwKHN0YXRlRmllbGQpIHtcbiAgICByZXR1cm4gKHZpZXcpID0+IG5ldyBDb21wbGV0aW9uVG9vbHRpcCh2aWV3LCBzdGF0ZUZpZWxkKTtcbn1cbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGNvbnRhaW5lciwgZWxlbWVudCkge1xuICAgIGxldCBwYXJlbnQgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHNlbGYgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChzZWxmLnRvcCA8IHBhcmVudC50b3ApXG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgLT0gcGFyZW50LnRvcCAtIHNlbGYudG9wO1xuICAgIGVsc2UgaWYgKHNlbGYuYm90dG9tID4gcGFyZW50LmJvdHRvbSlcbiAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCArPSBzZWxmLmJvdHRvbSAtIHBhcmVudC5ib3R0b207XG59XG5cbi8vIFVzZWQgdG8gcGljayBhIHByZWZlcnJlZCBvcHRpb24gd2hlbiB0d28gb3B0aW9ucyB3aXRoIHRoZSBzYW1lXG4vLyBsYWJlbCBvY2N1ciBpbiB0aGUgcmVzdWx0LlxuZnVuY3Rpb24gc2NvcmUob3B0aW9uKSB7XG4gICAgcmV0dXJuIChvcHRpb24uYm9vc3QgfHwgMCkgKiAxMDAgKyAob3B0aW9uLmFwcGx5ID8gMTAgOiAwKSArIChvcHRpb24uaW5mbyA/IDUgOiAwKSArXG4gICAgICAgIChvcHRpb24udHlwZSA/IDEgOiAwKTtcbn1cbmZ1bmN0aW9uIHNvcnRPcHRpb25zKGFjdGl2ZSwgc3RhdGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IFtdLCBpID0gMDtcbiAgICBmb3IgKGxldCBhIG9mIGFjdGl2ZSlcbiAgICAgICAgaWYgKGEuaGFzUmVzdWx0KCkpIHtcbiAgICAgICAgICAgIGlmIChhLnJlc3VsdC5maWx0ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGdldE1hdGNoID0gYS5yZXN1bHQuZ2V0TWF0Y2g7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb3B0aW9uIG9mIGEucmVzdWx0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gWzFlOSAtIGkrK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRNYXRjaClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG4gb2YgZ2V0TWF0Y2gob3B0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5wdXNoKG4pO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2gobmV3IE9wdGlvbihvcHRpb24sIGEsIG1hdGNoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoZXIgPSBuZXcgRnV6enlNYXRjaGVyKHN0YXRlLnNsaWNlRG9jKGEuZnJvbSwgYS50bykpLCBtYXRjaDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvcHRpb24gb2YgYS5yZXN1bHQub3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID0gbWF0Y2hlci5tYXRjaChvcHRpb24ubGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uLmJvb3N0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0gKz0gb3B0aW9uLmJvb3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKG5ldyBPcHRpb24ob3B0aW9uLCBhLCBtYXRjaCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gW10sIHByZXYgPSBudWxsO1xuICAgIGxldCBjb21wYXJlID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuY29tcGFyZUNvbXBsZXRpb25zO1xuICAgIGZvciAobGV0IG9wdCBvZiBvcHRpb25zLnNvcnQoKGEsIGIpID0+IChiLm1hdGNoWzBdIC0gYS5tYXRjaFswXSkgfHwgY29tcGFyZShhLmNvbXBsZXRpb24sIGIuY29tcGxldGlvbikpKSB7XG4gICAgICAgIGlmICghcHJldiB8fCBwcmV2LmxhYmVsICE9IG9wdC5jb21wbGV0aW9uLmxhYmVsIHx8IHByZXYuZGV0YWlsICE9IG9wdC5jb21wbGV0aW9uLmRldGFpbCB8fFxuICAgICAgICAgICAgKHByZXYudHlwZSAhPSBudWxsICYmIG9wdC5jb21wbGV0aW9uLnR5cGUgIT0gbnVsbCAmJiBwcmV2LnR5cGUgIT0gb3B0LmNvbXBsZXRpb24udHlwZSkgfHxcbiAgICAgICAgICAgIHByZXYuYXBwbHkgIT0gb3B0LmNvbXBsZXRpb24uYXBwbHkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChvcHQpO1xuICAgICAgICBlbHNlIGlmIChzY29yZShvcHQuY29tcGxldGlvbikgPiBzY29yZShwcmV2KSlcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBvcHQ7XG4gICAgICAgIHByZXYgPSBvcHQuY29tcGxldGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIENvbXBsZXRpb25EaWFsb2cge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGF0dHJzLCB0b29sdGlwLCB0aW1lc3RhbXAsIHNlbGVjdGVkLCBkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMudG9vbHRpcCA9IHRvb2x0aXA7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gICAgc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIGlkKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZCA9PSB0aGlzLnNlbGVjdGVkIHx8IHNlbGVjdGVkID49IHRoaXMub3B0aW9ucy5sZW5ndGggPyB0aGlzXG4gICAgICAgICAgICA6IG5ldyBDb21wbGV0aW9uRGlhbG9nKHRoaXMub3B0aW9ucywgbWFrZUF0dHJzKGlkLCBzZWxlY3RlZCksIHRoaXMudG9vbHRpcCwgdGhpcy50aW1lc3RhbXAsIHNlbGVjdGVkLCB0aGlzLmRpc2FibGVkKTtcbiAgICB9XG4gICAgc3RhdGljIGJ1aWxkKGFjdGl2ZSwgc3RhdGUsIGlkLCBwcmV2LCBjb25mKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0gc29ydE9wdGlvbnMoYWN0aXZlLCBzdGF0ZSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2ICYmIGFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pID9cbiAgICAgICAgICAgICAgICBuZXcgQ29tcGxldGlvbkRpYWxvZyhwcmV2Lm9wdGlvbnMsIHByZXYuYXR0cnMsIHByZXYudG9vbHRpcCwgcHJldi50aW1lc3RhbXAsIHByZXYuc2VsZWN0ZWQsIHRydWUpIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VsZWN0ZWQgPSBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5zZWxlY3RPbk9wZW4gPyAwIDogLTE7XG4gICAgICAgIGlmIChwcmV2ICYmIHByZXYuc2VsZWN0ZWQgIT0gc2VsZWN0ZWQgJiYgcHJldi5zZWxlY3RlZCAhPSAtMSkge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkVmFsdWUgPSBwcmV2Lm9wdGlvbnNbcHJldi5zZWxlY3RlZF0uY29tcGxldGlvbjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc1tpXS5jb21wbGV0aW9uID09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV0aW9uRGlhbG9nKG9wdGlvbnMsIG1ha2VBdHRycyhpZCwgc2VsZWN0ZWQpLCB7XG4gICAgICAgICAgICBwb3M6IGFjdGl2ZS5yZWR1Y2UoKGEsIGIpID0+IGIuaGFzUmVzdWx0KCkgPyBNYXRoLm1pbihhLCBiLmZyb20pIDogYSwgMWU4KSxcbiAgICAgICAgICAgIGNyZWF0ZTogY29tcGxldGlvblRvb2x0aXAoY29tcGxldGlvblN0YXRlKSxcbiAgICAgICAgICAgIGFib3ZlOiBjb25mLmFib3ZlQ3Vyc29yLFxuICAgICAgICB9LCBwcmV2ID8gcHJldi50aW1lc3RhbXAgOiBEYXRlLm5vdygpLCBzZWxlY3RlZCwgZmFsc2UpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25EaWFsb2codGhpcy5vcHRpb25zLCB0aGlzLmF0dHJzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMudG9vbHRpcCksIHsgcG9zOiBjaGFuZ2VzLm1hcFBvcyh0aGlzLnRvb2x0aXAucG9zKSB9KSwgdGhpcy50aW1lc3RhbXAsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuZGlzYWJsZWQpO1xuICAgIH1cbn1cbmNsYXNzIENvbXBsZXRpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoYWN0aXZlLCBpZCwgb3Blbikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgIH1cbiAgICBzdGF0aWMgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvblN0YXRlKG5vbmUsIFwiY20tYWMtXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyZTYpLnRvU3RyaW5nKDM2KSwgbnVsbCk7XG4gICAgfVxuICAgIHVwZGF0ZSh0cikge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdHIsIGNvbmYgPSBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgbGV0IHNvdXJjZXMgPSBjb25mLm92ZXJyaWRlIHx8XG4gICAgICAgICAgICBzdGF0ZS5sYW5ndWFnZURhdGFBdChcImF1dG9jb21wbGV0ZVwiLCBjdXIoc3RhdGUpKS5tYXAoYXNTb3VyY2UpO1xuICAgICAgICBsZXQgYWN0aXZlID0gc291cmNlcy5tYXAoc291cmNlID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuYWN0aXZlLmZpbmQocyA9PiBzLnNvdXJjZSA9PSBzb3VyY2UpIHx8XG4gICAgICAgICAgICAgICAgbmV3IEFjdGl2ZVNvdXJjZShzb3VyY2UsIHRoaXMuYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlICE9IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pID8gMSAvKiBTdGF0ZS5QZW5kaW5nICovIDogMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoID09IHRoaXMuYWN0aXZlLmxlbmd0aCAmJiBhY3RpdmUuZXZlcnkoKGEsIGkpID0+IGEgPT0gdGhpcy5hY3RpdmVbaV0pKVxuICAgICAgICAgICAgYWN0aXZlID0gdGhpcy5hY3RpdmU7XG4gICAgICAgIGxldCBvcGVuID0gdGhpcy5vcGVuO1xuICAgICAgICBpZiAob3BlbiAmJiB0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgb3BlbiA9IG9wZW4ubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBpZiAodHIuc2VsZWN0aW9uIHx8IGFjdGl2ZS5zb21lKGEgPT4gYS5oYXNSZXN1bHQoKSAmJiB0ci5jaGFuZ2VzLnRvdWNoZXNSYW5nZShhLmZyb20sIGEudG8pKSB8fFxuICAgICAgICAgICAgIXNhbWVSZXN1bHRzKGFjdGl2ZSwgdGhpcy5hY3RpdmUpKVxuICAgICAgICAgICAgb3BlbiA9IENvbXBsZXRpb25EaWFsb2cuYnVpbGQoYWN0aXZlLCBzdGF0ZSwgdGhpcy5pZCwgb3BlbiwgY29uZik7XG4gICAgICAgIGVsc2UgaWYgKG9wZW4gJiYgb3Blbi5kaXNhYmxlZCAmJiAhYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLykpXG4gICAgICAgICAgICBvcGVuID0gbnVsbDtcbiAgICAgICAgaWYgKCFvcGVuICYmIGFjdGl2ZS5ldmVyeShhID0+IGEuc3RhdGUgIT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSAmJiBhY3RpdmUuc29tZShhID0+IGEuaGFzUmVzdWx0KCkpKVxuICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLm1hcChhID0+IGEuaGFzUmVzdWx0KCkgPyBuZXcgQWN0aXZlU291cmNlKGEuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA6IGEpO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0U2VsZWN0ZWRFZmZlY3QpKVxuICAgICAgICAgICAgICAgIG9wZW4gPSBvcGVuICYmIG9wZW4uc2V0U2VsZWN0ZWQoZWZmZWN0LnZhbHVlLCB0aGlzLmlkKTtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZSA9PSB0aGlzLmFjdGl2ZSAmJiBvcGVuID09IHRoaXMub3BlbiA/IHRoaXMgOiBuZXcgQ29tcGxldGlvblN0YXRlKGFjdGl2ZSwgdGhpcy5pZCwgb3Blbik7XG4gICAgfVxuICAgIGdldCB0b29sdGlwKCkgeyByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5vcGVuLnRvb2x0aXAgOiBudWxsOyB9XG4gICAgZ2V0IGF0dHJzKCkgeyByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5vcGVuLmF0dHJzIDogYmFzZUF0dHJzOyB9XG59XG5mdW5jdGlvbiBzYW1lUmVzdWx0cyhhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChsZXQgaUEgPSAwLCBpQiA9IDA7Oykge1xuICAgICAgICB3aGlsZSAoaUEgPCBhLmxlbmd0aCAmJiAhYVtpQV0uaGFzUmVzdWx0KVxuICAgICAgICAgICAgaUErKztcbiAgICAgICAgd2hpbGUgKGlCIDwgYi5sZW5ndGggJiYgIWJbaUJdLmhhc1Jlc3VsdClcbiAgICAgICAgICAgIGlCKys7XG4gICAgICAgIGxldCBlbmRBID0gaUEgPT0gYS5sZW5ndGgsIGVuZEIgPSBpQiA9PSBiLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZEEgfHwgZW5kQilcbiAgICAgICAgICAgIHJldHVybiBlbmRBID09IGVuZEI7XG4gICAgICAgIGlmIChhW2lBKytdLnJlc3VsdCAhPSBiW2lCKytdLnJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBiYXNlQXR0cnMgPSB7XG4gICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBcImxpc3RcIlxufTtcbmZ1bmN0aW9uIG1ha2VBdHRycyhpZCwgc2VsZWN0ZWQpIHtcbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IFwibGlzdFwiLFxuICAgICAgICBcImFyaWEtaGFzcG9wdXBcIjogXCJsaXN0Ym94XCIsXG4gICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBpZFxuICAgIH07XG4gICAgaWYgKHNlbGVjdGVkID4gLTEpXG4gICAgICAgIHJlc3VsdFtcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiXSA9IGlkICsgXCItXCIgKyBzZWxlY3RlZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuZnVuY3Rpb24gZ2V0VXNlckV2ZW50KHRyKSB7XG4gICAgcmV0dXJuIHRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKSA/IFwiaW5wdXRcIiA6IHRyLmlzVXNlckV2ZW50KFwiZGVsZXRlLmJhY2t3YXJkXCIpID8gXCJkZWxldGVcIiA6IG51bGw7XG59XG5jbGFzcyBBY3RpdmVTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgc3RhdGUsIGV4cGxpY2l0UG9zID0gLTEpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5leHBsaWNpdFBvcyA9IGV4cGxpY2l0UG9zO1xuICAgIH1cbiAgICBoYXNSZXN1bHQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHVwZGF0ZSh0ciwgY29uZikge1xuICAgICAgICBsZXQgZXZlbnQgPSBnZXRVc2VyRXZlbnQodHIpLCB2YWx1ZSA9IHRoaXM7XG4gICAgICAgIGlmIChldmVudClcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuaGFuZGxlVXNlckV2ZW50KHRyLCBldmVudCwgY29uZik7XG4gICAgICAgIGVsc2UgaWYgKHRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmhhbmRsZUNoYW5nZSh0cik7XG4gICAgICAgIGVsc2UgaWYgKHRyLnNlbGVjdGlvbiAmJiB2YWx1ZS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHN0YXJ0Q29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovLCBlZmZlY3QudmFsdWUgPyBjdXIodHIuc3RhdGUpIDogLTEpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKGNsb3NlQ29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoc2V0QWN0aXZlRWZmZWN0KSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2YgZWZmZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlLnNvdXJjZSA9PSB2YWx1ZS5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFjdGl2ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGhhbmRsZVVzZXJFdmVudCh0ciwgdHlwZSwgY29uZikge1xuICAgICAgICByZXR1cm4gdHlwZSA9PSBcImRlbGV0ZVwiIHx8ICFjb25mLmFjdGl2YXRlT25UeXBpbmcgPyB0aGlzLm1hcCh0ci5jaGFuZ2VzKSA6IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDEgLyogU3RhdGUuUGVuZGluZyAqLyk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZSh0cikge1xuICAgICAgICByZXR1cm4gdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UoY3VyKHRyLnN0YXJ0U3RhdGUpKSA/IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pIDogdGhpcy5tYXAodHIuY2hhbmdlcyk7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmVtcHR5IHx8IHRoaXMuZXhwbGljaXRQb3MgPCAwID8gdGhpcyA6IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIHRoaXMuc3RhdGUsIGNoYW5nZXMubWFwUG9zKHRoaXMuZXhwbGljaXRQb3MpKTtcbiAgICB9XG59XG5jbGFzcyBBY3RpdmVSZXN1bHQgZXh0ZW5kcyBBY3RpdmVTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZXhwbGljaXRQb3MsIHJlc3VsdCwgZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIoc291cmNlLCAyIC8qIFN0YXRlLlJlc3VsdCAqLywgZXhwbGljaXRQb3MpO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBoYXNSZXN1bHQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaGFuZGxlVXNlckV2ZW50KHRyLCB0eXBlLCBjb25mKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGZyb20gPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmZyb20pLCB0byA9IHRyLmNoYW5nZXMubWFwUG9zKHRoaXMudG8sIDEpO1xuICAgICAgICBsZXQgcG9zID0gY3VyKHRyLnN0YXRlKTtcbiAgICAgICAgaWYgKCh0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IHBvcyA8PSBmcm9tIDogcG9zIDwgdGhpcy5mcm9tKSB8fFxuICAgICAgICAgICAgcG9zID4gdG8gfHxcbiAgICAgICAgICAgIHR5cGUgPT0gXCJkZWxldGVcIiAmJiBjdXIodHIuc3RhcnRTdGF0ZSkgPT0gdGhpcy5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIHR5cGUgPT0gXCJpbnB1dFwiICYmIGNvbmYuYWN0aXZhdGVPblR5cGluZyA/IDEgLyogU3RhdGUuUGVuZGluZyAqLyA6IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICBsZXQgZXhwbGljaXRQb3MgPSB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IC0xIDogdHIuY2hhbmdlcy5tYXBQb3ModGhpcy5leHBsaWNpdFBvcyksIHVwZGF0ZWQ7XG4gICAgICAgIGlmIChjaGVja1ZhbGlkKHRoaXMucmVzdWx0LnZhbGlkRm9yLCB0ci5zdGF0ZSwgZnJvbSwgdG8pKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVSZXN1bHQodGhpcy5zb3VyY2UsIGV4cGxpY2l0UG9zLCB0aGlzLnJlc3VsdCwgZnJvbSwgdG8pO1xuICAgICAgICBpZiAodGhpcy5yZXN1bHQudXBkYXRlICYmXG4gICAgICAgICAgICAodXBkYXRlZCA9IHRoaXMucmVzdWx0LnVwZGF0ZSh0aGlzLnJlc3VsdCwgZnJvbSwgdG8sIG5ldyBDb21wbGV0aW9uQ29udGV4dCh0ci5zdGF0ZSwgcG9zLCBleHBsaWNpdFBvcyA+PSAwKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVSZXN1bHQodGhpcy5zb3VyY2UsIGV4cGxpY2l0UG9zLCB1cGRhdGVkLCB1cGRhdGVkLmZyb20sIChfYSA9IHVwZGF0ZWQudG8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN1cih0ci5zdGF0ZSkpO1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovLCBleHBsaWNpdFBvcyk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZSh0cikge1xuICAgICAgICByZXR1cm4gdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKSA/IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pIDogdGhpcy5tYXAodHIuY2hhbmdlcyk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBtYXBwaW5nLmVtcHR5ID8gdGhpcyA6XG4gICAgICAgICAgICBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IC0xIDogbWFwcGluZy5tYXBQb3ModGhpcy5leHBsaWNpdFBvcyksIHRoaXMucmVzdWx0LCBtYXBwaW5nLm1hcFBvcyh0aGlzLmZyb20pLCBtYXBwaW5nLm1hcFBvcyh0aGlzLnRvLCAxKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tWYWxpZCh2YWxpZEZvciwgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgaWYgKCF2YWxpZEZvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0ZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xuICAgIHJldHVybiB0eXBlb2YgdmFsaWRGb3IgPT0gXCJmdW5jdGlvblwiID8gdmFsaWRGb3IodGV4dCwgZnJvbSwgdG8sIHN0YXRlKSA6IGVuc3VyZUFuY2hvcih2YWxpZEZvciwgdHJ1ZSkudGVzdCh0ZXh0KTtcbn1cbmNvbnN0IHN0YXJ0Q29tcGxldGlvbkVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGNsb3NlQ29tcGxldGlvbkVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHNldEFjdGl2ZUVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcChzb3VyY2VzLCBtYXBwaW5nKSB7IHJldHVybiBzb3VyY2VzLm1hcChzID0+IHMubWFwKG1hcHBpbmcpKTsgfVxufSk7XG5jb25zdCBzZXRTZWxlY3RlZEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGNvbXBsZXRpb25TdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gQ29tcGxldGlvblN0YXRlLnN0YXJ0KCk7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikgeyByZXR1cm4gdmFsdWUudXBkYXRlKHRyKTsgfSxcbiAgICBwcm92aWRlOiBmID0+IFtcbiAgICAgICAgc2hvd1Rvb2x0aXAuZnJvbShmLCB2YWwgPT4gdmFsLnRvb2x0aXApLFxuICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLmZyb20oZiwgc3RhdGUgPT4gc3RhdGUuYXR0cnMpXG4gICAgXVxufSk7XG5cbi8qKlxuUmV0dXJucyBhIGNvbW1hbmQgdGhhdCBtb3ZlcyB0aGUgY29tcGxldGlvbiBzZWxlY3Rpb24gZm9yd2FyZCBvclxuYmFja3dhcmQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiovXG5mdW5jdGlvbiBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbihmb3J3YXJkLCBieSA9IFwib3B0aW9uXCIpIHtcbiAgICByZXR1cm4gKHZpZXcpID0+IHtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICghY1N0YXRlIHx8ICFjU3RhdGUub3BlbiB8fCBjU3RhdGUub3Blbi5kaXNhYmxlZCB8fFxuICAgICAgICAgICAgRGF0ZS5ub3coKSAtIGNTdGF0ZS5vcGVuLnRpbWVzdGFtcCA8IHZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuaW50ZXJhY3Rpb25EZWxheSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0ZXAgPSAxLCB0b29sdGlwO1xuICAgICAgICBpZiAoYnkgPT0gXCJwYWdlXCIgJiYgKHRvb2x0aXAgPSBnZXRUb29sdGlwKHZpZXcsIGNTdGF0ZS5vcGVuLnRvb2x0aXApKSlcbiAgICAgICAgICAgIHN0ZXAgPSBNYXRoLm1heCgyLCBNYXRoLmZsb29yKHRvb2x0aXAuZG9tLm9mZnNldEhlaWdodCAvXG4gICAgICAgICAgICAgICAgdG9vbHRpcC5kb20ucXVlcnlTZWxlY3RvcihcImxpXCIpLm9mZnNldEhlaWdodCkgLSAxKTtcbiAgICAgICAgbGV0IHsgbGVuZ3RoIH0gPSBjU3RhdGUub3Blbi5vcHRpb25zO1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSBjU3RhdGUub3Blbi5zZWxlY3RlZCA+IC0xID8gY1N0YXRlLm9wZW4uc2VsZWN0ZWQgKyBzdGVwICogKGZvcndhcmQgPyAxIDogLTEpIDogZm9yd2FyZCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgICBpZiAoc2VsZWN0ZWQgPCAwKVxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBieSA9PSBcInBhZ2VcIiA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgICBlbHNlIGlmIChzZWxlY3RlZCA+PSBsZW5ndGgpXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGJ5ID09IFwicGFnZVwiID8gbGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRTZWxlY3RlZEVmZmVjdC5vZihzZWxlY3RlZCkgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkFjY2VwdCB0aGUgY3VycmVudCBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IGFjY2VwdENvbXBsZXRpb24gPSAodmlldykgPT4ge1xuICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5IHx8ICFjU3RhdGUgfHwgIWNTdGF0ZS5vcGVuIHx8IGNTdGF0ZS5vcGVuLnNlbGVjdGVkIDwgMCB8fFxuICAgICAgICBEYXRlLm5vdygpIC0gY1N0YXRlLm9wZW4udGltZXN0YW1wIDwgdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5pbnRlcmFjdGlvbkRlbGF5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFjU3RhdGUub3Blbi5kaXNhYmxlZClcbiAgICAgICAgYXBwbHlDb21wbGV0aW9uKHZpZXcsIGNTdGF0ZS5vcGVuLm9wdGlvbnNbY1N0YXRlLm9wZW4uc2VsZWN0ZWRdKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkV4cGxpY2l0bHkgc3RhcnQgYXV0b2NvbXBsZXRpb24uXG4qL1xuY29uc3Qgc3RhcnRDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcbiAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWNTdGF0ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzdGFydENvbXBsZXRpb25FZmZlY3Qub2YodHJ1ZSkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DbG9zZSB0aGUgY3VycmVudGx5IGFjdGl2ZSBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IGNsb3NlQ29tcGxldGlvbiA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFjU3RhdGUgfHwgIWNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmNsYXNzIFJ1bm5pbmdRdWVyeSB7XG4gICAgY29uc3RydWN0b3IoYWN0aXZlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnVwZGF0ZXMgPSBbXTtcbiAgICAgICAgLy8gTm90ZSB0aGF0ICd1bmRlZmluZWQnIG1lYW5zICdub3QgZG9uZSB5ZXQnLCB3aGVyZWFzICdudWxsJyBtZWFuc1xuICAgICAgICAvLyAncXVlcnkgcmV0dXJuZWQgbnVsbCcuXG4gICAgICAgIHRoaXMuZG9uZSA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5jb25zdCBEZWJvdW5jZVRpbWUgPSA1MCwgTWF4VXBkYXRlQ291bnQgPSA1MCwgTWluQWJvcnRUaW1lID0gMTAwMDtcbmNvbnN0IGNvbXBsZXRpb25QbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IC0xO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBbXTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IC0xO1xuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDAgLyogQ29tcG9zaXRpb25TdGF0ZS5Ob25lICovO1xuICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2Ygdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpLmFjdGl2ZSlcbiAgICAgICAgICAgIGlmIChhY3RpdmUuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRRdWVyeShhY3RpdmUpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjU3RhdGUgPSB1cGRhdGUuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKTtcbiAgICAgICAgaWYgKCF1cGRhdGUuc2VsZWN0aW9uU2V0ICYmICF1cGRhdGUuZG9jQ2hhbmdlZCAmJiB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpID09IGNTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGRvZXNSZXNldCA9IHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHRyLnNlbGVjdGlvbiB8fCB0ci5kb2NDaGFuZ2VkKSAmJiAhZ2V0VXNlckV2ZW50KHRyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnJ1bm5pbmdbaV07XG4gICAgICAgICAgICBpZiAoZG9lc1Jlc2V0IHx8XG4gICAgICAgICAgICAgICAgcXVlcnkudXBkYXRlcy5sZW5ndGggKyB1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aCA+IE1heFVwZGF0ZUNvdW50ICYmIERhdGUubm93KCkgLSBxdWVyeS50aW1lID4gTWluQWJvcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBxdWVyeS5jb250ZXh0LmFib3J0TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHF1ZXJ5LmNvbnRleHQuYWJvcnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucnVubmluZy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXJ5LnVwZGF0ZXMucHVzaCguLi51cGRhdGUudHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWJvdW5jZVVwZGF0ZSA+IC0xKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVib3VuY2VVcGRhdGUpO1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8gJiYgIXRoaXMucnVubmluZy5zb21lKHEgPT4gcS5hY3RpdmUuc291cmNlID09IGEuc291cmNlKSlcbiAgICAgICAgICAgID8gc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXJ0VXBkYXRlKCksIERlYm91bmNlVGltZSkgOiAtMTtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nICE9IDAgLyogQ29tcG9zaXRpb25TdGF0ZS5Ob25lICovKVxuICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgdXBkYXRlLnRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChnZXRVc2VyRXZlbnQodHIpID09IFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAyIC8qIENvbXBvc2l0aW9uU3RhdGUuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbXBvc2luZyA9PSAyIC8qIENvbXBvc2l0aW9uU3RhdGUuQ2hhbmdlZCAqLyAmJiB0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMyAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWRBbmRNb3ZlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuZGVib3VuY2VVcGRhdGUgPSAtMTtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgY1N0YXRlID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKTtcbiAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIGNTdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovICYmICF0aGlzLnJ1bm5pbmcuc29tZShyID0+IHIuYWN0aXZlLnNvdXJjZSA9PSBhY3RpdmUuc291cmNlKSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoYWN0aXZlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFF1ZXJ5KGFjdGl2ZSkge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBwb3MgPSBjdXIoc3RhdGUpO1xuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBDb21wbGV0aW9uQ29udGV4dChzdGF0ZSwgcG9zLCBhY3RpdmUuZXhwbGljaXRQb3MgPT0gcG9zKTtcbiAgICAgICAgbGV0IHBlbmRpbmcgPSBuZXcgUnVubmluZ1F1ZXJ5KGFjdGl2ZSwgY29udGV4dCk7XG4gICAgICAgIHRoaXMucnVubmluZy5wdXNoKHBlbmRpbmcpO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoYWN0aXZlLnNvdXJjZShjb250ZXh0KSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKCFwZW5kaW5nLmNvbnRleHQuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHBlbmRpbmcuZG9uZSA9IHJlc3VsdCB8fCBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVBY2NlcHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcbiAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY2hlZHVsZUFjY2VwdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZy5ldmVyeShxID0+IHEuZG9uZSAhPT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0KCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGVib3VuY2VBY2NlcHQgPCAwKVxuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hY2NlcHQoKSwgRGVib3VuY2VUaW1lKTtcbiAgICB9XG4gICAgLy8gRm9yIGVhY2ggZmluaXNoZWQgcXVlcnkgaW4gdGhpcy5ydW5uaW5nLCB0cnkgdG8gY3JlYXRlIGEgcmVzdWx0XG4gICAgLy8gb3IsIGlmIGFwcHJvcHJpYXRlLCByZXN0YXJ0IHRoZSBxdWVyeS5cbiAgICBhY2NlcHQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VBY2NlcHQgPiAtMSlcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlQWNjZXB0KTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IC0xO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IFtdO1xuICAgICAgICBsZXQgY29uZiA9IHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJ1bm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMucnVubmluZ1tpXTtcbiAgICAgICAgICAgIGlmIChxdWVyeS5kb25lID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICBpZiAocXVlcnkuZG9uZSkge1xuICAgICAgICAgICAgICAgIGxldCBhY3RpdmUgPSBuZXcgQWN0aXZlUmVzdWx0KHF1ZXJ5LmFjdGl2ZS5zb3VyY2UsIHF1ZXJ5LmFjdGl2ZS5leHBsaWNpdFBvcywgcXVlcnkuZG9uZSwgcXVlcnkuZG9uZS5mcm9tLCAoX2EgPSBxdWVyeS5kb25lLnRvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdXIocXVlcnkudXBkYXRlcy5sZW5ndGggPyBxdWVyeS51cGRhdGVzWzBdLnN0YXJ0U3RhdGUgOiB0aGlzLnZpZXcuc3RhdGUpKTtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYXkgdGhlIHRyYW5zYWN0aW9ucyB0aGF0IGhhcHBlbmVkIHNpbmNlIHRoZSBzdGFydCBvZlxuICAgICAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0IGFuZCBzZWUgaWYgdGhhdCBwcmVzZXJ2ZXMgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHF1ZXJ5LnVwZGF0ZXMpXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGFjdGl2ZS51cGRhdGUodHIsIGNvbmYpO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmUuaGFzUmVzdWx0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5wdXNoKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSkuYWN0aXZlLmZpbmQoYSA9PiBhLnNvdXJjZSA9PSBxdWVyeS5hY3RpdmUuc291cmNlKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5LmRvbmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IGZhaWxlZC4gU2hvdWxkIGNsZWFyIHRoZSBwZW5kaW5nIHN0YXR1cyBpZiBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBoYXNuJ3QgYmVlbiByZS1zZXQgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gbmV3IEFjdGl2ZVNvdXJjZShxdWVyeS5hY3RpdmUuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgcXVlcnkudXBkYXRlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGFjdGl2ZS51cGRhdGUodHIsIGNvbmYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlLnN0YXRlICE9IDEgLyogU3RhdGUuUGVuZGluZyAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQucHVzaChhY3RpdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXJlZCBieSBzdWJzZXF1ZW50IHRyYW5zYWN0aW9ucy4gUmVzdGFydC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFF1ZXJ5KGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlZC5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRBY3RpdmVFZmZlY3Qub2YodXBkYXRlZCkgfSk7XG4gICAgfVxufSwge1xuICAgIGV2ZW50SGFuZGxlcnM6IHtcbiAgICAgICAgYmx1cigpIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS50b29sdGlwICYmIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5jbG9zZU9uQmx1cilcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBvc2l0aW9uc3RhcnQoKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDEgLyogQ29tcG9zaXRpb25TdGF0ZS5TdGFydGVkICovO1xuICAgICAgICB9LFxuICAgICAgICBjb21wb3NpdGlvbmVuZCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvc2luZyA9PSAzIC8qIENvbXBvc2l0aW9uU3RhdGUuQ2hhbmdlZEFuZE1vdmVkICovKSB7XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIGZpcmVzIGNvbXBvc2l0aW9uZW5kIGV2ZW50cyBzeW5jaHJvbm91c2x5LCBwb3NzaWJseVxuICAgICAgICAgICAgICAgIC8vIGZyb20gaW5zaWRlIGFuIHVwZGF0ZSwgc28gZGlzcGF0Y2ggYXN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmVlbnRyYW5jeVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc3RhcnRDb21wbGV0aW9uRWZmZWN0Lm9mKGZhbHNlKSB9KSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAwIC8qIENvbXBvc2l0aW9uU3RhdGUuTm9uZSAqLztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXRvb2x0aXAuY20tdG9vbHRpcC1hdXRvY29tcGxldGVcIjoge1xuICAgICAgICBcIiYgPiB1bFwiOiB7XG4gICAgICAgICAgICBmb250RmFtaWx5OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlbiBhdXRvXCIsXG4gICAgICAgICAgICBtYXhXaWR0aF9mYWxsYmFjazogXCI3MDBweFwiLFxuICAgICAgICAgICAgbWF4V2lkdGg6IFwibWluKDcwMHB4LCA5NXZ3KVwiLFxuICAgICAgICAgICAgbWluV2lkdGg6IFwiMjUwcHhcIixcbiAgICAgICAgICAgIG1heEhlaWdodDogXCIxMGVtXCIsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICAgICAgbGlzdFN0eWxlOiBcIm5vbmVcIixcbiAgICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBcIiYgPiBsaVwiOiB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dYOiBcImhpZGRlblwiLFxuICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogXCJlbGxpcHNpc1wiLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogXCIxcHggM3B4XCIsXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodDogMS4yXG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMxN2NcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZCB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzc3N1wiLFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMzNDdcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNDQ0XCIsXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVUb3A6YmVmb3JlLCAuY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlQm90dG9tOmFmdGVyXCI6IHtcbiAgICAgICAgY29udGVudDogJ1wiXHUwMEI3XHUwMEI3XHUwMEI3XCInLFxuICAgICAgICBvcGFjaXR5OiAwLjUsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwLmNtLWNvbXBsZXRpb25JbmZvXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgcGFkZGluZzogXCIzcHggOXB4XCIsXG4gICAgICAgIHdpZHRoOiBcIm1heC1jb250ZW50XCIsXG4gICAgICAgIG1heFdpZHRoOiBgJHs0MDAgLyogSW5mby5XaWR0aCAqL31weGAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLWxlZnRcIjogeyByaWdodDogXCIxMDAlXCIgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1yaWdodFwiOiB7IGxlZnQ6IFwiMTAwJVwiIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tbGVmdC1uYXJyb3dcIjogeyByaWdodDogYCR7MzAgLyogSW5mby5NYXJnaW4gKi99cHhgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tcmlnaHQtbmFycm93XCI6IHsgbGVmdDogYCR7MzAgLyogSW5mby5NYXJnaW4gKi99cHhgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMDAwMDAwMjJcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZmZmZmMjJcIiB9LFxuICAgIFwiLmNtLXNuaXBwZXRGaWVsZFBvc2l0aW9uXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiBcIjEuMTVlbVwiLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICBtYXJnaW46IFwiMCAtMC43cHggLS43ZW1cIixcbiAgICAgICAgYm9yZGVyTGVmdDogXCIxLjRweCBkb3R0ZWQgIzg4OFwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjoge1xuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkRldGFpbFwiOiB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiMC41ZW1cIixcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvblwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjkwJVwiLFxuICAgICAgICB3aWR0aDogXCIuOGVtXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiBcIi42ZW1cIixcbiAgICAgICAgb3BhY2l0eTogXCIwLjZcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImNvbnRlbnQtYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWZ1bmN0aW9uLCAuY20tY29tcGxldGlvbkljb24tbWV0aG9kXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInXHUwMTkyJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWNsYXNzXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInXHUyNUNCJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWludGVyZmFjZVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ1x1MjVDQydcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi12YXJpYWJsZVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ1x1RDgzNVx1REM2NSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1jb25zdGFudFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ1x1RDgzNVx1REMzNidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi10eXBlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInXHVEODM1XHVEQzYxJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWVudW1cIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidcdTIyMkEnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tcHJvcGVydHlcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidcdTI1QTEnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24ta2V5d29yZFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ1x1RDgzRFx1REQxMVxcdUZFMEUnXCIgfSAvLyBEaXNhYmxlIGVtb2ppIHJlbmRlcmluZ1xuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tbmFtZXNwYWNlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInXHUyNUEyJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXRleHRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidhYmMnXCIsIGZvbnRTaXplOiBcIjUwJVwiLCB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiIH1cbiAgICB9XG59KTtcblxuY2xhc3MgRmllbGRQb3Mge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBsaW5lLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG5jbGFzcyBGaWVsZFJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3ModGhpcy5mcm9tLCAtMSwgTWFwTW9kZS5UcmFja0RlbCk7XG4gICAgICAgIGxldCB0byA9IGNoYW5nZXMubWFwUG9zKHRoaXMudG8sIDEsIE1hcE1vZGUuVHJhY2tEZWwpO1xuICAgICAgICByZXR1cm4gZnJvbSA9PSBudWxsIHx8IHRvID09IG51bGwgPyBudWxsIDogbmV3IEZpZWxkUmFuZ2UodGhpcy5maWVsZCwgZnJvbSwgdG8pO1xuICAgIH1cbn1cbmNsYXNzIFNuaXBwZXQge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVzLCBmaWVsZFBvc2l0aW9ucykge1xuICAgICAgICB0aGlzLmxpbmVzID0gbGluZXM7XG4gICAgICAgIHRoaXMuZmllbGRQb3NpdGlvbnMgPSBmaWVsZFBvc2l0aW9ucztcbiAgICB9XG4gICAgaW5zdGFudGlhdGUoc3RhdGUsIHBvcykge1xuICAgICAgICBsZXQgdGV4dCA9IFtdLCBsaW5lU3RhcnQgPSBbcG9zXTtcbiAgICAgICAgbGV0IGxpbmVPYmogPSBzdGF0ZS5kb2MubGluZUF0KHBvcyksIGJhc2VJbmRlbnQgPSAvXlxccyovLmV4ZWMobGluZU9iai50ZXh0KVswXTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLmxpbmVzKSB7XG4gICAgICAgICAgICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50ID0gYmFzZUluZGVudCwgdGFicyA9IC9eXFx0Ki8uZXhlYyhsaW5lKVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJzOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSBzdGF0ZS5mYWNldChpbmRlbnRVbml0KTtcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQucHVzaChwb3MgKyBpbmRlbnQubGVuZ3RoIC0gdGFicyk7XG4gICAgICAgICAgICAgICAgbGluZSA9IGluZGVudCArIGxpbmUuc2xpY2UodGFicyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0LnB1c2gobGluZSk7XG4gICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLmZpZWxkUG9zaXRpb25zLm1hcChwb3MgPT4gbmV3IEZpZWxkUmFuZ2UocG9zLmZpZWxkLCBsaW5lU3RhcnRbcG9zLmxpbmVdICsgcG9zLmZyb20sIGxpbmVTdGFydFtwb3MubGluZV0gKyBwb3MudG8pKTtcbiAgICAgICAgcmV0dXJuIHsgdGV4dCwgcmFuZ2VzIH07XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh0ZW1wbGF0ZSkge1xuICAgICAgICBsZXQgZmllbGRzID0gW107XG4gICAgICAgIGxldCBsaW5lcyA9IFtdLCBwb3NpdGlvbnMgPSBbXSwgbTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0ZW1wbGF0ZS5zcGxpdCgvXFxyXFxuP3xcXG4vKSkge1xuICAgICAgICAgICAgd2hpbGUgKG0gPSAvWyMkXVxceyg/OihcXGQrKSg/OjooW159XSopKT98KFtefV0qKSlcXH0vLmV4ZWMobGluZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VxID0gbVsxXSA/ICttWzFdIDogbnVsbCwgbmFtZSA9IG1bMl0gfHwgbVszXSB8fCBcIlwiLCBmb3VuZCA9IC0xO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXEgIT0gbnVsbCA/IGZpZWxkc1tpXS5zZXEgPT0gc2VxIDogbmFtZSA/IGZpZWxkc1tpXS5uYW1lID09IG5hbWUgOiBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgZmllbGRzLmxlbmd0aCAmJiAoc2VxID09IG51bGwgfHwgKGZpZWxkc1tpXS5zZXEgIT0gbnVsbCAmJiBmaWVsZHNbaV0uc2VxIDwgc2VxKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5zcGxpY2UoaSwgMCwgeyBzZXEsIG5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIHBvc2l0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MuZmllbGQgPj0gZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmZpZWxkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKG5ldyBGaWVsZFBvcyhmb3VuZCwgbGluZXMubGVuZ3RoLCBtLmluZGV4LCBtLmluZGV4ICsgbmFtZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCBtLmluZGV4KSArIG5hbWUgKyBsaW5lLnNsaWNlKG0uaW5kZXggKyBtWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBlc2M7IGVzYyA9IC9cXFxcKFt7fV0pLy5leGVjKGxpbmUpOykge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIGVzYy5pbmRleCkgKyBlc2NbMV0gKyBsaW5lLnNsaWNlKGVzYy5pbmRleCArIGVzY1swXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MubGluZSA9PSBsaW5lcy5sZW5ndGggJiYgcG9zLmZyb20gPiBlc2MuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy5mcm9tLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MudG8tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNuaXBwZXQobGluZXMsIHBvc2l0aW9ucyk7XG4gICAgfVxufVxubGV0IGZpZWxkTWFya2VyID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ud2lkZ2V0KHsgd2lkZ2V0OiAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgICAgIHRvRE9NKCkge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zbmlwcGV0RmllbGRQb3NpdGlvblwiO1xuICAgICAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgICAgIH1cbiAgICAgICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIH0gfSk7XG5sZXQgZmllbGRSYW5nZSA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zbmlwcGV0RmllbGRcIiB9KTtcbmNsYXNzIEFjdGl2ZVNuaXBwZXQge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlcywgYWN0aXZlKSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5kZWNvID0gRGVjb3JhdGlvbi5zZXQocmFuZ2VzLm1hcChyID0+IChyLmZyb20gPT0gci50byA/IGZpZWxkTWFya2VyIDogZmllbGRSYW5nZSkucmFuZ2Uoci5mcm9tLCByLnRvKSkpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSByLm1hcChjaGFuZ2VzKTtcbiAgICAgICAgICAgIGlmICghbWFwcGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gobWFwcGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNuaXBwZXQocmFuZ2VzLCB0aGlzLmFjdGl2ZSk7XG4gICAgfVxuICAgIHNlbGVjdGlvbkluc2lkZUZpZWxkKHNlbCkge1xuICAgICAgICByZXR1cm4gc2VsLnJhbmdlcy5ldmVyeShyYW5nZSA9PiB0aGlzLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA9PSB0aGlzLmFjdGl2ZSAmJiByLmZyb20gPD0gcmFuZ2UuZnJvbSAmJiByLnRvID49IHJhbmdlLnRvKSk7XG4gICAgfVxufVxuY29uc3Qgc2V0QWN0aXZlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XG4gICAgbWFwKHZhbHVlLCBjaGFuZ2VzKSB7IHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5tYXAoY2hhbmdlcyk7IH1cbn0pO1xuY29uc3QgbW92ZVRvRmllbGQgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBzbmlwcGV0U3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRBY3RpdmUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKG1vdmVUb0ZpZWxkKSAmJiB2YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNuaXBwZXQodmFsdWUucmFuZ2VzLCBlZmZlY3QudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0ci5zZWxlY3Rpb24gJiYgIXZhbHVlLnNlbGVjdGlvbkluc2lkZUZpZWxkKHRyLnNlbGVjdGlvbikpXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYsIHZhbCA9PiB2YWwgPyB2YWwuZGVjbyA6IERlY29yYXRpb24ubm9uZSlcbn0pO1xuZnVuY3Rpb24gZmllbGRTZWxlY3Rpb24ocmFuZ2VzLCBmaWVsZCkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcy5maWx0ZXIociA9PiByLmZpZWxkID09IGZpZWxkKS5tYXAociA9PiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5mcm9tLCByLnRvKSkpO1xufVxuLyoqXG5Db252ZXJ0IGEgc25pcHBldCB0ZW1wbGF0ZSB0byBhIGZ1bmN0aW9uIHRoYXQgY2FuXG5bYXBwbHldKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb24uYXBwbHkpIGl0LiBTbmlwcGV0cyBhcmUgd3JpdHRlblxudXNpbmcgc3ludGF4IGxpa2UgdGhpczpcblxuICAgIFwiZm9yIChsZXQgJHtpbmRleH0gPSAwOyAke2luZGV4fSA8ICR7ZW5kfTsgJHtpbmRleH0rKykge1xcblxcdCR7fVxcbn1cIlxuXG5FYWNoIGAke31gIHBsYWNlaG9sZGVyICh5b3UgbWF5IGFsc28gdXNlIGAje31gKSBpbmRpY2F0ZXMgYSBmaWVsZFxudGhhdCB0aGUgdXNlciBjYW4gZmlsbCBpbi4gSXRzIG5hbWUsIGlmIGFueSwgd2lsbCBiZSB0aGUgZGVmYXVsdFxuY29udGVudCBmb3IgdGhlIGZpZWxkLlxuXG5XaGVuIHRoZSBzbmlwcGV0IGlzIGFjdGl2YXRlZCBieSBjYWxsaW5nIHRoZSByZXR1cm5lZCBmdW5jdGlvbixcbnRoZSBjb2RlIGlzIGluc2VydGVkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gTmV3bGluZXMgaW4gdGhlXG50ZW1wbGF0ZSBhcmUgaW5kZW50ZWQgYnkgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBzdGFydCBsaW5lLCBwbHVzXG5vbmUgW2luZGVudCB1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIHBlciB0YWIgY2hhcmFjdGVyIGFmdGVyXG50aGUgbmV3bGluZS5cblxuT24gYWN0aXZhdGlvbiwgKGFsbCBpbnN0YW5jZXMgb2YpIHRoZSBmaXJzdCBmaWVsZCBhcmUgc2VsZWN0ZWQuXG5UaGUgdXNlciBjYW4gbW92ZSBiZXR3ZWVuIGZpZWxkcyB3aXRoIFRhYiBhbmQgU2hpZnQtVGFiIGFzIGxvbmcgYXNcbnRoZSBmaWVsZHMgYXJlIGFjdGl2ZS4gTW92aW5nIHRvIHRoZSBsYXN0IGZpZWxkIG9yIG1vdmluZyB0aGVcbmN1cnNvciBvdXQgb2YgdGhlIGN1cnJlbnQgZmllbGQgZGVhY3RpdmF0ZXMgdGhlIGZpZWxkcy5cblxuVGhlIG9yZGVyIG9mIGZpZWxkcyBkZWZhdWx0cyB0byB0ZXh0dWFsIG9yZGVyLCBidXQgeW91IGNhbiBhZGRcbm51bWJlcnMgdG8gcGxhY2Vob2xkZXJzIChgJHsxfWAgb3IgYCR7MTpkZWZhdWx0VGV4dH1gKSB0byBwcm92aWRlXG5hIGN1c3RvbSBvcmRlci5cblxuVG8gaW5jbHVkZSBhIGxpdGVyYWwgYHtgIG9yIGB9YCBpbiB5b3VyIHRlbXBsYXRlLCBwdXQgYSBiYWNrc2xhc2hcbmluIGZyb250IG9mIGl0LiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBhbmQgdGhlIGJyYWNlIHdpbGwgbm90IGJlXG5pbnRlcnByZXRlZCBhcyBpbmRpY2F0aW5nIGEgcGxhY2Vob2xkZXIuXG4qL1xuZnVuY3Rpb24gc25pcHBldCh0ZW1wbGF0ZSkge1xuICAgIGxldCBzbmlwcGV0ID0gU25pcHBldC5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIChlZGl0b3IsIGNvbXBsZXRpb24sIGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGxldCB7IHRleHQsIHJhbmdlcyB9ID0gc25pcHBldC5pbnN0YW50aWF0ZShlZGl0b3Iuc3RhdGUsIGZyb20pO1xuICAgICAgICBsZXQgc3BlYyA9IHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogVGV4dC5vZih0ZXh0KSB9LFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgICAgICBhbm5vdGF0aW9uczogcGlja2VkQ29tcGxldGlvbi5vZihjb21wbGV0aW9uKVxuICAgICAgICB9O1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHNwZWMuc2VsZWN0aW9uID0gZmllbGRTZWxlY3Rpb24ocmFuZ2VzLCAwKTtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsZXQgYWN0aXZlID0gbmV3IEFjdGl2ZVNuaXBwZXQocmFuZ2VzLCAwKTtcbiAgICAgICAgICAgIGxldCBlZmZlY3RzID0gc3BlYy5lZmZlY3RzID0gW3NldEFjdGl2ZS5vZihhY3RpdmUpXTtcbiAgICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBlZmZlY3RzLnB1c2goU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKFtzbmlwcGV0U3RhdGUsIGFkZFNuaXBwZXRLZXltYXAsIHNuaXBwZXRQb2ludGVySGFuZGxlciwgYmFzZVRoZW1lXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaChlZGl0b3Iuc3RhdGUudXBkYXRlKHNwZWMpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbW92ZUZpZWxkKGRpcikge1xuICAgIHJldHVybiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICghYWN0aXZlIHx8IGRpciA8IDAgJiYgYWN0aXZlLmFjdGl2ZSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgbmV4dCA9IGFjdGl2ZS5hY3RpdmUgKyBkaXIsIGxhc3QgPSBkaXIgPiAwICYmICFhY3RpdmUucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID09IG5leHQgKyBkaXIpO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiBmaWVsZFNlbGVjdGlvbihhY3RpdmUucmFuZ2VzLCBuZXh0KSxcbiAgICAgICAgICAgIGVmZmVjdHM6IHNldEFjdGl2ZS5vZihsYXN0ID8gbnVsbCA6IG5ldyBBY3RpdmVTbmlwcGV0KGFjdGl2ZS5yYW5nZXMsIG5leHQpKVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkEgY29tbWFuZCB0aGF0IGNsZWFycyB0aGUgYWN0aXZlIHNuaXBwZXQsIGlmIGFueS5cbiovXG5jb25zdCBjbGVhclNuaXBwZXQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGVmZmVjdHM6IHNldEFjdGl2ZS5vZihudWxsKSB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRvIHRoZSBuZXh0IHNuaXBwZXQgZmllbGQsIGlmIGF2YWlsYWJsZS5cbiovXG5jb25zdCBuZXh0U25pcHBldEZpZWxkID0gLypAX19QVVJFX18qL21vdmVGaWVsZCgxKTtcbi8qKlxuTW92ZSB0byB0aGUgcHJldmlvdXMgc25pcHBldCBmaWVsZCwgaWYgYXZhaWxhYmxlLlxuKi9cbmNvbnN0IHByZXZTbmlwcGV0RmllbGQgPSAvKkBfX1BVUkVfXyovbW92ZUZpZWxkKC0xKTtcbmNvbnN0IGRlZmF1bHRTbmlwcGV0S2V5bWFwID0gW1xuICAgIHsga2V5OiBcIlRhYlwiLCBydW46IG5leHRTbmlwcGV0RmllbGQsIHNoaWZ0OiBwcmV2U25pcHBldEZpZWxkIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xlYXJTbmlwcGV0IH1cbl07XG4vKipcbkEgZmFjZXQgdGhhdCBjYW4gYmUgdXNlZCB0byBjb25maWd1cmUgdGhlIGtleSBiaW5kaW5ncyB1c2VkIGJ5XG5zbmlwcGV0cy4gVGhlIGRlZmF1bHQgYmluZHMgVGFiIHRvXG5bYG5leHRTbmlwcGV0RmllbGRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5uZXh0U25pcHBldEZpZWxkKSwgU2hpZnQtVGFiIHRvXG5bYHByZXZTbmlwcGV0RmllbGRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5wcmV2U25pcHBldEZpZWxkKSwgYW5kIEVzY2FwZVxudG8gW2BjbGVhclNuaXBwZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5jbGVhclNuaXBwZXQpLlxuKi9cbmNvbnN0IHNuaXBwZXRLZXltYXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKG1hcHMpIHsgcmV0dXJuIG1hcHMubGVuZ3RoID8gbWFwc1swXSA6IGRlZmF1bHRTbmlwcGV0S2V5bWFwOyB9XG59KTtcbmNvbnN0IGFkZFNuaXBwZXRLZXltYXAgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9rZXltYXAuY29tcHV0ZShbc25pcHBldEtleW1hcF0sIHN0YXRlID0+IHN0YXRlLmZhY2V0KHNuaXBwZXRLZXltYXApKSk7XG4vKipcbkNyZWF0ZSBhIGNvbXBsZXRpb24gZnJvbSBhIHNuaXBwZXQuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlXG5wcm9wZXJ0aWVzIGZyb20gYGNvbXBsZXRpb25gLCBwbHVzIGFuIGBhcHBseWAgZnVuY3Rpb24gdGhhdFxuYXBwbGllcyB0aGUgc25pcHBldC5cbiovXG5mdW5jdGlvbiBzbmlwcGV0Q29tcGxldGlvbih0ZW1wbGF0ZSwgY29tcGxldGlvbikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbXBsZXRpb24pLCB7IGFwcGx5OiBzbmlwcGV0KHRlbXBsYXRlKSB9KTtcbn1cbmNvbnN0IHNuaXBwZXRQb2ludGVySGFuZGxlciA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgIG1vdXNlZG93bihldmVudCwgdmlldykge1xuICAgICAgICBsZXQgYWN0aXZlID0gdmlldy5zdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKSwgcG9zO1xuICAgICAgICBpZiAoIWFjdGl2ZSB8fCAocG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSkpID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBtYXRjaCA9IGFjdGl2ZS5yYW5nZXMuZmluZChyID0+IHIuZnJvbSA8PSBwb3MgJiYgci50byA+PSBwb3MpO1xuICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmZpZWxkID09IGFjdGl2ZS5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiBmaWVsZFNlbGVjdGlvbihhY3RpdmUucmFuZ2VzLCBtYXRjaC5maWVsZCksXG4gICAgICAgICAgICBlZmZlY3RzOiBzZXRBY3RpdmUub2YoYWN0aXZlLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA+IG1hdGNoLmZpZWxkKSA/IG5ldyBBY3RpdmVTbmlwcGV0KGFjdGl2ZS5yYW5nZXMsIG1hdGNoLmZpZWxkKSA6IG51bGwpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gd29yZFJFKHdvcmRDaGFycykge1xuICAgIGxldCBlc2NhcGVkID0gd29yZENoYXJzLnJlcGxhY2UoL1tcXFxcWy4rKj8oKXt8XiRdL2csIFwiXFxcXCQmXCIpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBbXFxcXHB7QWxwaGFiZXRpY31cXFxccHtOdW1iZXJ9XyR7ZXNjYXBlZH1dK2AsIFwidWdcIik7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgW1xcdyR7ZXNjYXBlZH1dYCwgXCJnXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcFJFKHJlLCBmKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoZihyZS5zb3VyY2UpLCByZS51bmljb2RlID8gXCJ1XCIgOiBcIlwiKTtcbn1cbmNvbnN0IHdvcmRDYWNoZXMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIHdvcmRDYWNoZSh3b3JkQ2hhcnMpIHtcbiAgICByZXR1cm4gd29yZENhY2hlc1t3b3JkQ2hhcnNdIHx8ICh3b3JkQ2FjaGVzW3dvcmRDaGFyc10gPSBuZXcgV2Vha01hcCk7XG59XG5mdW5jdGlvbiBzdG9yZVdvcmRzKGRvYywgd29yZFJFLCByZXN1bHQsIHNlZW4sIGlnbm9yZUF0KSB7XG4gICAgZm9yIChsZXQgbGluZXMgPSBkb2MuaXRlckxpbmVzKCksIHBvcyA9IDA7ICFsaW5lcy5uZXh0KCkuZG9uZTspIHtcbiAgICAgICAgbGV0IHsgdmFsdWUgfSA9IGxpbmVzLCBtO1xuICAgICAgICB3b3JkUkUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKG0gPSB3b3JkUkUuZXhlYyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghc2VlblttWzBdXSAmJiBwb3MgKyBtLmluZGV4ICE9IGlnbm9yZUF0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyB0eXBlOiBcInRleHRcIiwgbGFiZWw6IG1bMF0gfSk7XG4gICAgICAgICAgICAgICAgc2VlblttWzBdXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPj0gMjAwMCAvKiBDLk1heExpc3QgKi8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gdmFsdWUubGVuZ3RoICsgMTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0V29yZHMoZG9jLCBjYWNoZSwgd29yZFJFLCB0bywgaWdub3JlQXQpIHtcbiAgICBsZXQgYmlnID0gZG9jLmxlbmd0aCA+PSAxMDAwIC8qIEMuTWluQ2FjaGVMZW4gKi87XG4gICAgbGV0IGNhY2hlZCA9IGJpZyAmJiBjYWNoZS5nZXQoZG9jKTtcbiAgICBpZiAoY2FjaGVkKVxuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIGxldCByZXN1bHQgPSBbXSwgc2VlbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGRvYy5jaGlsZHJlbikge1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgZG9jLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2gubGVuZ3RoID49IDEwMDAgLyogQy5NaW5DYWNoZUxlbiAqLykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgb2YgY29sbGVjdFdvcmRzKGNoLCBjYWNoZSwgd29yZFJFLCB0byAtIHBvcywgaWdub3JlQXQgLSBwb3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VlbltjLmxhYmVsXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VlbltjLmxhYmVsXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0b3JlV29yZHMoY2gsIHdvcmRSRSwgcmVzdWx0LCBzZWVuLCBpZ25vcmVBdCAtIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gY2gubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RvcmVXb3Jkcyhkb2MsIHdvcmRSRSwgcmVzdWx0LCBzZWVuLCBpZ25vcmVBdCk7XG4gICAgfVxuICAgIGlmIChiaWcgJiYgcmVzdWx0Lmxlbmd0aCA8IDIwMDAgLyogQy5NYXhMaXN0ICovKVxuICAgICAgICBjYWNoZS5zZXQoZG9jLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkEgY29tcGxldGlvbiBzb3VyY2UgdGhhdCB3aWxsIHNjYW4gdGhlIGRvY3VtZW50IGZvciB3b3JkcyAodXNpbmcgYVxuW2NoYXJhY3RlciBjYXRlZ29yaXplcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpKSwgYW5kXG5yZXR1cm4gdGhvc2UgYXMgY29tcGxldGlvbnMuXG4qL1xuY29uc3QgY29tcGxldGVBbnlXb3JkID0gY29udGV4dCA9PiB7XG4gICAgbGV0IHdvcmRDaGFycyA9IGNvbnRleHQuc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJ3b3JkQ2hhcnNcIiwgY29udGV4dC5wb3MpLmpvaW4oXCJcIik7XG4gICAgbGV0IHJlID0gd29yZFJFKHdvcmRDaGFycyk7XG4gICAgbGV0IHRva2VuID0gY29udGV4dC5tYXRjaEJlZm9yZShtYXBSRShyZSwgcyA9PiBzICsgXCIkXCIpKTtcbiAgICBpZiAoIXRva2VuICYmICFjb250ZXh0LmV4cGxpY2l0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZnJvbSA9IHRva2VuID8gdG9rZW4uZnJvbSA6IGNvbnRleHQucG9zO1xuICAgIGxldCBvcHRpb25zID0gY29sbGVjdFdvcmRzKGNvbnRleHQuc3RhdGUuZG9jLCB3b3JkQ2FjaGUod29yZENoYXJzKSwgcmUsIDUwMDAwIC8qIEMuUmFuZ2UgKi8sIGZyb20pO1xuICAgIHJldHVybiB7IGZyb20sIG9wdGlvbnMsIHZhbGlkRm9yOiBtYXBSRShyZSwgcyA9PiBcIl5cIiArIHMpIH07XG59O1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgICBicmFja2V0czogW1wiKFwiLCBcIltcIiwgXCJ7XCIsIFwiJ1wiLCAnXCInXSxcbiAgICBiZWZvcmU6IFwiKV19Ojs+XCIsXG4gICAgc3RyaW5nUHJlZml4ZXM6IFtdXG59O1xuY29uc3QgY2xvc2VCcmFja2V0RWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XG4gICAgbWFwKHZhbHVlLCBtYXBwaW5nKSB7XG4gICAgICAgIGxldCBtYXBwZWQgPSBtYXBwaW5nLm1hcFBvcyh2YWx1ZSwgLTEsIE1hcE1vZGUuVHJhY2tBZnRlcik7XG4gICAgICAgIHJldHVybiBtYXBwZWQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG1hcHBlZDtcbiAgICB9XG59KTtcbmNvbnN0IHNraXBCcmFja2V0RWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XG4gICAgbWFwKHZhbHVlLCBtYXBwaW5nKSB7IHJldHVybiBtYXBwaW5nLm1hcFBvcyh2YWx1ZSk7IH1cbn0pO1xuY29uc3QgY2xvc2VkQnJhY2tldCA9IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbn07XG5jbG9zZWRCcmFja2V0LnN0YXJ0U2lkZSA9IDE7XG5jbG9zZWRCcmFja2V0LmVuZFNpZGUgPSAtMTtcbmNvbnN0IGJyYWNrZXRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gUmFuZ2VTZXQuZW1wdHk7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBpZiAodHIuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgbGluZVN0YXJ0ID0gdHIuc3RhdGUuZG9jLmxpbmVBdCh0ci5zZWxlY3Rpb24ubWFpbi5oZWFkKS5mcm9tO1xuICAgICAgICAgICAgbGV0IHByZXZMaW5lU3RhcnQgPSB0ci5zdGFydFN0YXRlLmRvYy5saW5lQXQodHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKS5mcm9tO1xuICAgICAgICAgICAgaWYgKGxpbmVTdGFydCAhPSB0ci5jaGFuZ2VzLm1hcFBvcyhwcmV2TGluZVN0YXJ0LCAtMSkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBSYW5nZVNldC5lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoY2xvc2VCcmFja2V0RWZmZWN0KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZSh7IGFkZDogW2Nsb3NlZEJyYWNrZXQucmFuZ2UoZWZmZWN0LnZhbHVlLCBlZmZlY3QudmFsdWUgKyAxKV0gfSk7XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoc2tpcEJyYWNrZXRFZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudXBkYXRlKHsgZmlsdGVyOiBmcm9tID0+IGZyb20gIT0gZWZmZWN0LnZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59KTtcbi8qKlxuRXh0ZW5zaW9uIHRvIGVuYWJsZSBicmFja2V0LWNsb3NpbmcgYmVoYXZpb3IuIFdoZW4gYSBjbG9zZWFibGVcbmJyYWNrZXQgaXMgdHlwZWQsIGl0cyBjbG9zaW5nIGJyYWNrZXQgaXMgaW1tZWRpYXRlbHkgaW5zZXJ0ZWRcbmFmdGVyIHRoZSBjdXJzb3IuIFdoZW4gY2xvc2luZyBhIGJyYWNrZXQgZGlyZWN0bHkgaW4gZnJvbnQgb2YgYVxuY2xvc2luZyBicmFja2V0IGluc2VydGVkIGJ5IHRoZSBleHRlbnNpb24sIHRoZSBjdXJzb3IgbW92ZXMgb3ZlclxudGhhdCBicmFja2V0LlxuKi9cbmZ1bmN0aW9uIGNsb3NlQnJhY2tldHMoKSB7XG4gICAgcmV0dXJuIFtpbnB1dEhhbmRsZXIsIGJyYWNrZXRTdGF0ZV07XG59XG5jb25zdCBkZWZpbmVkQ2xvc2luZyA9IFwiKClbXXt9PD5cIjtcbmZ1bmN0aW9uIGNsb3NpbmcoY2gpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZmluZWRDbG9zaW5nLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICBpZiAoZGVmaW5lZENsb3NpbmcuY2hhckNvZGVBdChpKSA9PSBjaClcbiAgICAgICAgICAgIHJldHVybiBkZWZpbmVkQ2xvc2luZy5jaGFyQXQoaSArIDEpO1xuICAgIHJldHVybiBmcm9tQ29kZVBvaW50KGNoIDwgMTI4ID8gY2ggOiBjaCArIDEpO1xufVxuZnVuY3Rpb24gY29uZmlnKHN0YXRlLCBwb3MpIHtcbiAgICByZXR1cm4gc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJjbG9zZUJyYWNrZXRzXCIsIHBvcylbMF0gfHwgZGVmYXVsdHM7XG59XG5jb25zdCBhbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcIm9iamVjdFwiICYmIC8qQF9fUFVSRV9fKi8vQW5kcm9pZFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IGlucHV0SGFuZGxlciA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmlucHV0SGFuZGxlci5vZigodmlldywgZnJvbSwgdG8sIGluc2VydCkgPT4ge1xuICAgIGlmICgoYW5kcm9pZCA/IHZpZXcuY29tcG9zaW5nIDogdmlldy5jb21wb3NpdGlvblN0YXJ0ZWQpIHx8IHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBpZiAoaW5zZXJ0Lmxlbmd0aCA+IDIgfHwgaW5zZXJ0Lmxlbmd0aCA9PSAyICYmIGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQoaW5zZXJ0LCAwKSkgPT0gMSB8fFxuICAgICAgICBmcm9tICE9IHNlbC5mcm9tIHx8IHRvICE9IHNlbC50bylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0ciA9IGluc2VydEJyYWNrZXQodmlldy5zdGF0ZSwgaW5zZXJ0KTtcbiAgICBpZiAoIXRyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuQ29tbWFuZCB0aGF0IGltcGxlbWVudHMgZGVsZXRpbmcgYSBwYWlyIG9mIG1hdGNoaW5nIGJyYWNrZXRzIHdoZW5cbnRoZSBjdXJzb3IgaXMgYmV0d2VlbiB0aGVtLlxuKi9cbmNvbnN0IGRlbGV0ZUJyYWNrZXRQYWlyID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY29uZiA9IGNvbmZpZyhzdGF0ZSwgc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgbGV0IHRva2VucyA9IGNvbmYuYnJhY2tldHMgfHwgZGVmYXVsdHMuYnJhY2tldHM7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHByZXZDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT0gYmVmb3JlICYmIG5leHRDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCkgPT0gY2xvc2luZyhjb2RlUG9pbnRBdCh0b2tlbiwgMCkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmhlYWQgLSB0b2tlbi5sZW5ndGgsIHRvOiByYW5nZS5oZWFkICsgdG9rZW4ubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkIC0gdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBkb250ID0gcmFuZ2UgfTtcbiAgICB9KTtcbiAgICBpZiAoIWRvbnQpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiZGVsZXRlLmJhY2t3YXJkXCIgfSkpO1xuICAgIHJldHVybiAhZG9udDtcbn07XG4vKipcbkNsb3NlLWJyYWNrZXRzIHJlbGF0ZWQga2V5IGJpbmRpbmdzLiBCaW5kcyBCYWNrc3BhY2UgdG9cbltgZGVsZXRlQnJhY2tldFBhaXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5kZWxldGVCcmFja2V0UGFpcikuXG4qL1xuY29uc3QgY2xvc2VCcmFja2V0c0tleW1hcCA9IFtcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVCcmFja2V0UGFpciB9XG5dO1xuLyoqXG5JbXBsZW1lbnRzIHRoZSBleHRlbnNpb24ncyBiZWhhdmlvciBvbiB0ZXh0IGluc2VydGlvbi4gSWYgdGhlXG5naXZlbiBzdHJpbmcgY291bnRzIGFzIGEgYnJhY2tldCBpbiB0aGUgbGFuZ3VhZ2UgYXJvdW5kIHRoZVxuc2VsZWN0aW9uLCBhbmQgcmVwbGFjaW5nIHRoZSBzZWxlY3Rpb24gd2l0aCBpdCByZXF1aXJlcyBjdXN0b21cbmJlaGF2aW9yIChpbnNlcnRpbmcgYSBjbG9zaW5nIHZlcnNpb24gb3Igc2tpcHBpbmcgcGFzdCBhXG5wcmV2aW91c2x5LWNsb3NlZCBicmFja2V0KSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHJhbnNhY3Rpb25cbnJlcHJlc2VudGluZyB0aGF0IGN1c3RvbSBiZWhhdmlvci4gKFlvdSBvbmx5IG5lZWQgdGhpcyBpZiB5b3Ugd2FudFxudG8gcHJvZ3JhbW1hdGljYWxseSBpbnNlcnQgYnJhY2tldHNcdTIwMTR0aGVcbltgY2xvc2VCcmFja2V0c2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsb3NlQnJhY2tldHMpIGV4dGVuc2lvbiB3aWxsXG50YWtlIGNhcmUgb2YgcnVubmluZyB0aGlzIGZvciB1c2VyIGlucHV0LilcbiovXG5mdW5jdGlvbiBpbnNlcnRCcmFja2V0KHN0YXRlLCBicmFja2V0KSB7XG4gICAgbGV0IGNvbmYgPSBjb25maWcoc3RhdGUsIHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgIGxldCB0b2tlbnMgPSBjb25mLmJyYWNrZXRzIHx8IGRlZmF1bHRzLmJyYWNrZXRzO1xuICAgIGZvciAobGV0IHRvayBvZiB0b2tlbnMpIHtcbiAgICAgICAgbGV0IGNsb3NlZCA9IGNsb3NpbmcoY29kZVBvaW50QXQodG9rLCAwKSk7XG4gICAgICAgIGlmIChicmFja2V0ID09IHRvaylcbiAgICAgICAgICAgIHJldHVybiBjbG9zZWQgPT0gdG9rID8gaGFuZGxlU2FtZShzdGF0ZSwgdG9rLCB0b2tlbnMuaW5kZXhPZih0b2sgKyB0b2sgKyB0b2spID4gLTEsIGNvbmYpXG4gICAgICAgICAgICAgICAgOiBoYW5kbGVPcGVuKHN0YXRlLCB0b2ssIGNsb3NlZCwgY29uZi5iZWZvcmUgfHwgZGVmYXVsdHMuYmVmb3JlKTtcbiAgICAgICAgaWYgKGJyYWNrZXQgPT0gY2xvc2VkICYmIGNsb3NlZEJyYWNrZXRBdChzdGF0ZSwgc3RhdGUuc2VsZWN0aW9uLm1haW4uZnJvbSkpXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2xvc2Uoc3RhdGUsIHRvaywgY2xvc2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjbG9zZWRCcmFja2V0QXQoc3RhdGUsIHBvcykge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIHN0YXRlLmZpZWxkKGJyYWNrZXRTdGF0ZSkuYmV0d2VlbigwLCBzdGF0ZS5kb2MubGVuZ3RoLCBmcm9tID0+IHtcbiAgICAgICAgaWYgKGZyb20gPT0gcG9zKVxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIG5leHRDaGFyKGRvYywgcG9zKSB7XG4gICAgbGV0IG5leHQgPSBkb2Muc2xpY2VTdHJpbmcocG9zLCBwb3MgKyAyKTtcbiAgICByZXR1cm4gbmV4dC5zbGljZSgwLCBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KG5leHQsIDApKSk7XG59XG5mdW5jdGlvbiBwcmV2Q2hhcihkb2MsIHBvcykge1xuICAgIGxldCBwcmV2ID0gZG9jLnNsaWNlU3RyaW5nKHBvcyAtIDIsIHBvcyk7XG4gICAgcmV0dXJuIGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQocHJldiwgMCkpID09IHByZXYubGVuZ3RoID8gcHJldiA6IHByZXYuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiBoYW5kbGVPcGVuKHN0YXRlLCBvcGVuLCBjbG9zZSwgY2xvc2VCZWZvcmUpIHtcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IFt7IGluc2VydDogb3BlbiwgZnJvbTogcmFuZ2UuZnJvbSB9LCB7IGluc2VydDogY2xvc2UsIGZyb206IHJhbmdlLnRvIH1dLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihyYW5nZS50byArIG9wZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciArIG9wZW4ubGVuZ3RoLCByYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpIH07XG4gICAgICAgIGxldCBuZXh0ID0gbmV4dENoYXIoc3RhdGUuZG9jLCByYW5nZS5oZWFkKTtcbiAgICAgICAgaWYgKCFuZXh0IHx8IC9cXHMvLnRlc3QobmV4dCkgfHwgY2xvc2VCZWZvcmUuaW5kZXhPZihuZXh0KSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IG9wZW4gKyBjbG9zZSwgZnJvbTogcmFuZ2UuaGVhZCB9LFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihyYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgKyBvcGVuLmxlbmd0aCkgfTtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IGRvbnQgPSByYW5nZSB9O1xuICAgIH0pO1xuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVDbG9zZShzdGF0ZSwgX29wZW4sIGNsb3NlKSB7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBtb3ZlZCA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubWFwKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5ICYmIG5leHRDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCkgPT0gY2xvc2UpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkICsgY2xvc2UubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRvbnQgPSByYW5nZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZS51cGRhdGUoe1xuICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUobW92ZWQsIHN0YXRlLnNlbGVjdGlvbi5tYWluSW5kZXgpLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgZWZmZWN0czogc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5tYXAoKHsgZnJvbSB9KSA9PiBza2lwQnJhY2tldEVmZmVjdC5vZihmcm9tKSlcbiAgICB9KTtcbn1cbi8vIEhhbmRsZXMgY2FzZXMgd2hlcmUgdGhlIG9wZW4gYW5kIGNsb3NlIHRva2VuIGFyZSB0aGUgc2FtZSwgYW5kXG4vLyBwb3NzaWJseSB0cmlwbGUgcXVvdGVzIChhcyBpbiBgXCJcIlwiYWJjXCJcIlwiYC1zdHlsZSBxdW90aW5nKS5cbmZ1bmN0aW9uIGhhbmRsZVNhbWUoc3RhdGUsIHRva2VuLCBhbGxvd1RyaXBsZSwgY29uZmlnKSB7XG4gICAgbGV0IHN0cmluZ1ByZWZpeGVzID0gY29uZmlnLnN0cmluZ1ByZWZpeGVzIHx8IGRlZmF1bHRzLnN0cmluZ1ByZWZpeGVzO1xuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogW3sgaW5zZXJ0OiB0b2tlbiwgZnJvbTogcmFuZ2UuZnJvbSB9LCB7IGluc2VydDogdG9rZW4sIGZyb206IHJhbmdlLnRvIH1dLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihyYW5nZS50byArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IgKyB0b2tlbi5sZW5ndGgsIHJhbmdlLmhlYWQgKyB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgIGxldCBwb3MgPSByYW5nZS5oZWFkLCBuZXh0ID0gbmV4dENoYXIoc3RhdGUuZG9jLCBwb3MpLCBzdGFydDtcbiAgICAgICAgaWYgKG5leHQgPT0gdG9rZW4pIHtcbiAgICAgICAgICAgIGlmIChub2RlU3RhcnQoc3RhdGUsIHBvcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiwgZnJvbTogcG9zIH0sXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbG9zZWRCcmFja2V0QXQoc3RhdGUsIHBvcykpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNUcmlwbGUgPSBhbGxvd1RyaXBsZSAmJiBzdGF0ZS5zbGljZURvYyhwb3MsIHBvcyArIHRva2VuLmxlbmd0aCAqIDMpID09IHRva2VuICsgdG9rZW4gKyB0b2tlbjtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyB0b2tlbi5sZW5ndGggKiAoaXNUcmlwbGUgPyAzIDogMSkpLFxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBza2lwQnJhY2tldEVmZmVjdC5vZihwb3MpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWxsb3dUcmlwbGUgJiYgc3RhdGUuc2xpY2VEb2MocG9zIC0gMiAqIHRva2VuLmxlbmd0aCwgcG9zKSA9PSB0b2tlbiArIHRva2VuICYmXG4gICAgICAgICAgICAoc3RhcnQgPSBjYW5TdGFydFN0cmluZ0F0KHN0YXRlLCBwb3MgLSAyICogdG9rZW4ubGVuZ3RoLCBzdHJpbmdQcmVmaXhlcykpID4gLTEgJiZcbiAgICAgICAgICAgIG5vZGVTdGFydChzdGF0ZSwgc3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiArIHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKShuZXh0KSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkge1xuICAgICAgICAgICAgaWYgKGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUsIHBvcywgc3RyaW5nUHJlZml4ZXMpID4gLTEgJiYgIXByb2JhYmx5SW5TdHJpbmcoc3RhdGUsIHBvcywgdG9rZW4sIHN0cmluZ1ByZWZpeGVzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiwgZnJvbTogcG9zIH0sXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IGRvbnQgPSByYW5nZSB9O1xuICAgIH0pO1xuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gICAgfSk7XG59XG5mdW5jdGlvbiBub2RlU3RhcnQoc3RhdGUsIHBvcykge1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcyArIDEpO1xuICAgIHJldHVybiB0cmVlLnBhcmVudCAmJiB0cmVlLmZyb20gPT0gcG9zO1xufVxuZnVuY3Rpb24gcHJvYmFibHlJblN0cmluZyhzdGF0ZSwgcG9zLCBxdW90ZVRva2VuLCBwcmVmaXhlcykge1xuICAgIGxldCBub2RlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcywgLTEpO1xuICAgIGxldCBtYXhQcmVmaXggPSBwcmVmaXhlcy5yZWR1Y2UoKG0sIHApID0+IE1hdGgubWF4KG0sIHAubGVuZ3RoKSwgMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhdGUuc2xpY2VEb2Mobm9kZS5mcm9tLCBNYXRoLm1pbihub2RlLnRvLCBub2RlLmZyb20gKyBxdW90ZVRva2VuLmxlbmd0aCArIG1heFByZWZpeCkpO1xuICAgICAgICBsZXQgcXVvdGVQb3MgPSBzdGFydC5pbmRleE9mKHF1b3RlVG9rZW4pO1xuICAgICAgICBpZiAoIXF1b3RlUG9zIHx8IHF1b3RlUG9zID4gLTEgJiYgcHJlZml4ZXMuaW5kZXhPZihzdGFydC5zbGljZSgwLCBxdW90ZVBvcykpID4gLTEpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChmaXJzdCAmJiBmaXJzdC5mcm9tID09IG5vZGUuZnJvbSAmJiBmaXJzdC50byAtIGZpcnN0LmZyb20gPiBxdW90ZVRva2VuLmxlbmd0aCArIHF1b3RlUG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNsaWNlRG9jKGZpcnN0LnRvIC0gcXVvdGVUb2tlbi5sZW5ndGgsIGZpcnN0LnRvKSA9PSBxdW90ZVRva2VuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmaXJzdC5maXJzdENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUudG8gPT0gcG9zICYmIG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjYW5TdGFydFN0cmluZ0F0KHN0YXRlLCBwb3MsIHByZWZpeGVzKSB7XG4gICAgbGV0IGNoYXJDYXQgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBpZiAoY2hhckNhdChzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBmb3IgKGxldCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gcG9zIC0gcHJlZml4Lmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YXRlLnNsaWNlRG9jKHN0YXJ0LCBwb3MpID09IHByZWZpeCAmJiBjaGFyQ2F0KHN0YXRlLnNsaWNlRG9jKHN0YXJ0IC0gMSwgc3RhcnQpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBhdXRvY29tcGxldGlvbi5cbiovXG5mdW5jdGlvbiBhdXRvY29tcGxldGlvbihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGNvbXBsZXRpb25TdGF0ZSxcbiAgICAgICAgY29tcGxldGlvbkNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBjb21wbGV0aW9uUGx1Z2luLFxuICAgICAgICBjb21wbGV0aW9uS2V5bWFwRXh0LFxuICAgICAgICBiYXNlVGhlbWVcbiAgICBdO1xufVxuLyoqXG5CYXNpYyBrZXliaW5kaW5ncyBmb3IgYXV0b2NvbXBsZXRpb24uXG5cbiAtIEN0cmwtU3BhY2U6IFtgc3RhcnRDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuc3RhcnRDb21wbGV0aW9uKVxuIC0gRXNjYXBlOiBbYGNsb3NlQ29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsb3NlQ29tcGxldGlvbilcbiAtIEFycm93RG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSlgXG4gLSBBcnJvd1VwOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYChmYWxzZSlgXG4gLSBQYWdlRG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSwgXCJwYWdlXCIpYFxuIC0gUGFnZURvd246IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKHRydWUsIFwicGFnZVwiKWBcbiAtIEVudGVyOiBbYGFjY2VwdENvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5hY2NlcHRDb21wbGV0aW9uKVxuKi9cbmNvbnN0IGNvbXBsZXRpb25LZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1TcGFjZVwiLCBydW46IHN0YXJ0Q29tcGxldGlvbiB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IGNsb3NlQ29tcGxldGlvbiB9LFxuICAgIHsga2V5OiBcIkFycm93RG93blwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbih0cnVlKSB9LFxuICAgIHsga2V5OiBcIkFycm93VXBcIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZmFsc2UpIH0sXG4gICAgeyBrZXk6IFwiUGFnZURvd25cIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24odHJ1ZSwgXCJwYWdlXCIpIH0sXG4gICAgeyBrZXk6IFwiUGFnZVVwXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKGZhbHNlLCBcInBhZ2VcIikgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBydW46IGFjY2VwdENvbXBsZXRpb24gfVxuXTtcbmNvbnN0IGNvbXBsZXRpb25LZXltYXBFeHQgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9rZXltYXAuY29tcHV0ZU4oW2NvbXBsZXRpb25Db25maWddLCBzdGF0ZSA9PiBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5kZWZhdWx0S2V5bWFwID8gW2NvbXBsZXRpb25LZXltYXBdIDogW10pKTtcbi8qKlxuR2V0IHRoZSBjdXJyZW50IGNvbXBsZXRpb24gc3RhdHVzLiBXaGVuIGNvbXBsZXRpb25zIGFyZSBhdmFpbGFibGUsXG50aGlzIHdpbGwgcmV0dXJuIGBcImFjdGl2ZVwiYC4gV2hlbiBjb21wbGV0aW9ucyBhcmUgcGVuZGluZyAoaW4gdGhlXG5wcm9jZXNzIG9mIGJlaW5nIHF1ZXJpZWQpLCB0aGlzIHJldHVybnMgYFwicGVuZGluZ1wiYC4gT3RoZXJ3aXNlLCBpdFxucmV0dXJucyBgbnVsbGAuXG4qL1xuZnVuY3Rpb24gY29tcGxldGlvblN0YXR1cyhzdGF0ZSkge1xuICAgIGxldCBjU3RhdGUgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gY1N0YXRlICYmIGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSA/IFwicGVuZGluZ1wiXG4gICAgICAgIDogY1N0YXRlICYmIGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykgPyBcImFjdGl2ZVwiIDogbnVsbDtcbn1cbmNvbnN0IGNvbXBsZXRpb25BcnJheUNhY2hlID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwO1xuLyoqXG5SZXR1cm5zIHRoZSBhdmFpbGFibGUgY29tcGxldGlvbnMgYXMgYW4gYXJyYXkuXG4qL1xuZnVuY3Rpb24gY3VycmVudENvbXBsZXRpb25zKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIGlmICghb3BlbiB8fCBvcGVuLmRpc2FibGVkKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGNvbXBsZXRpb25zID0gY29tcGxldGlvbkFycmF5Q2FjaGUuZ2V0KG9wZW4ub3B0aW9ucyk7XG4gICAgaWYgKCFjb21wbGV0aW9ucylcbiAgICAgICAgY29tcGxldGlvbkFycmF5Q2FjaGUuc2V0KG9wZW4ub3B0aW9ucywgY29tcGxldGlvbnMgPSBvcGVuLm9wdGlvbnMubWFwKG8gPT4gby5jb21wbGV0aW9uKSk7XG4gICAgcmV0dXJuIGNvbXBsZXRpb25zO1xufVxuLyoqXG5SZXR1cm4gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb21wbGV0aW9uLCBpZiBhbnkuXG4qL1xuZnVuY3Rpb24gc2VsZWN0ZWRDb21wbGV0aW9uKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIHJldHVybiBvcGVuICYmICFvcGVuLmRpc2FibGVkICYmIG9wZW4uc2VsZWN0ZWQgPj0gMCA/IG9wZW4ub3B0aW9uc1tvcGVuLnNlbGVjdGVkXS5jb21wbGV0aW9uIDogbnVsbDtcbn1cbi8qKlxuUmV0dXJucyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHBvc2l0aW9uIGluIHRoZSBhY3RpdmUgY29tcGxldGlvblxubGlzdCwgb3IgbnVsbCBpZiBubyBjb21wbGV0aW9ucyBhcmUgYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIHNlbGVjdGVkQ29tcGxldGlvbkluZGV4KHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIHJldHVybiBvcGVuICYmICFvcGVuLmRpc2FibGVkICYmIG9wZW4uc2VsZWN0ZWQgPj0gMCA/IG9wZW4uc2VsZWN0ZWQgOiBudWxsO1xufVxuLyoqXG5DcmVhdGUgYW4gZWZmZWN0IHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdHJhbnNhY3Rpb24gdG8gY2hhbmdlXG50aGUgY3VycmVudGx5IHNlbGVjdGVkIGNvbXBsZXRpb24uXG4qL1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWRDb21wbGV0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHNldFNlbGVjdGVkRWZmZWN0Lm9mKGluZGV4KTtcbn1cblxuZXhwb3J0IHsgQ29tcGxldGlvbkNvbnRleHQsIGFjY2VwdENvbXBsZXRpb24sIGF1dG9jb21wbGV0aW9uLCBjbGVhclNuaXBwZXQsIGNsb3NlQnJhY2tldHMsIGNsb3NlQnJhY2tldHNLZXltYXAsIGNsb3NlQ29tcGxldGlvbiwgY29tcGxldGVBbnlXb3JkLCBjb21wbGV0ZUZyb21MaXN0LCBjb21wbGV0aW9uS2V5bWFwLCBjb21wbGV0aW9uU3RhdHVzLCBjdXJyZW50Q29tcGxldGlvbnMsIGRlbGV0ZUJyYWNrZXRQYWlyLCBpZkluLCBpZk5vdEluLCBpbnNlcnRCcmFja2V0LCBpbnNlcnRDb21wbGV0aW9uVGV4dCwgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24sIG5leHRTbmlwcGV0RmllbGQsIHBpY2tlZENvbXBsZXRpb24sIHByZXZTbmlwcGV0RmllbGQsIHNlbGVjdGVkQ29tcGxldGlvbiwgc2VsZWN0ZWRDb21wbGV0aW9uSW5kZXgsIHNldFNlbGVjdGVkQ29tcGxldGlvbiwgc25pcHBldCwgc25pcHBldENvbXBsZXRpb24sIHNuaXBwZXRLZXltYXAsIHN0YXJ0Q29tcGxldGlvbiB9O1xuIiwgImltcG9ydCB7IERlY29yYXRpb24sIHNob3dQYW5lbCwgRWRpdG9yVmlldywgVmlld1BsdWdpbiwgbG9nRXhjZXB0aW9uLCBndXR0ZXIsIHNob3dUb29sdGlwLCBnZXRQYW5lbCwgV2lkZ2V0VHlwZSwgaG92ZXJUb29sdGlwLCBHdXR0ZXJNYXJrZXIgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBGYWNldCwgY29tYmluZUNvbmZpZywgUmFuZ2VTZXQgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgZWx0IGZyb20gJ2NyZWx0JztcblxuY2xhc3MgU2VsZWN0ZWREaWFnbm9zdGljIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgZGlhZ25vc3RpYykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpYyA9IGRpYWdub3N0aWM7XG4gICAgfVxufVxuY2xhc3MgTGludFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihkaWFnbm9zdGljcywgcGFuZWwsIHNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljcztcbiAgICAgICAgdGhpcy5wYW5lbCA9IHBhbmVsO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgfVxuICAgIHN0YXRpYyBpbml0KGRpYWdub3N0aWNzLCBwYW5lbCwgc3RhdGUpIHtcbiAgICAgICAgLy8gRmlsdGVyIHRoZSBsaXN0IG9mIGRpYWdub3N0aWNzIGZvciB3aGljaCB0byBjcmVhdGUgbWFya2Vyc1xuICAgICAgICBsZXQgbWFya2VkRGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljcztcbiAgICAgICAgbGV0IGRpYWdub3N0aWNGaWx0ZXIgPSBzdGF0ZS5mYWNldChsaW50Q29uZmlnKS5tYXJrZXJGaWx0ZXI7XG4gICAgICAgIGlmIChkaWFnbm9zdGljRmlsdGVyKVxuICAgICAgICAgICAgbWFya2VkRGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljRmlsdGVyKG1hcmtlZERpYWdub3N0aWNzKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IERlY29yYXRpb24uc2V0KG1hcmtlZERpYWdub3N0aWNzLm1hcCgoZCkgPT4ge1xuICAgICAgICAgICAgLy8gRm9yIHplcm8tbGVuZ3RoIHJhbmdlcyBvciByYW5nZXMgY292ZXJpbmcgb25seSBhIGxpbmUgYnJlYWssIGNyZWF0ZSBhIHdpZGdldFxuICAgICAgICAgICAgcmV0dXJuIGQuZnJvbSA9PSBkLnRvIHx8IChkLmZyb20gPT0gZC50byAtIDEgJiYgc3RhdGUuZG9jLmxpbmVBdChkLmZyb20pLnRvID09IGQuZnJvbSlcbiAgICAgICAgICAgICAgICA/IERlY29yYXRpb24ud2lkZ2V0KHtcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0OiBuZXcgRGlhZ25vc3RpY1dpZGdldChkKSxcbiAgICAgICAgICAgICAgICAgICAgZGlhZ25vc3RpYzogZFxuICAgICAgICAgICAgICAgIH0pLnJhbmdlKGQuZnJvbSlcbiAgICAgICAgICAgICAgICA6IERlY29yYXRpb24ubWFyayh7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHsgY2xhc3M6IFwiY20tbGludFJhbmdlIGNtLWxpbnRSYW5nZS1cIiArIGQuc2V2ZXJpdHkgfSxcbiAgICAgICAgICAgICAgICAgICAgZGlhZ25vc3RpYzogZFxuICAgICAgICAgICAgICAgIH0pLnJhbmdlKGQuZnJvbSwgZC50byk7XG4gICAgICAgIH0pLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW50U3RhdGUocmFuZ2VzLCBwYW5lbCwgZmluZERpYWdub3N0aWMocmFuZ2VzKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZERpYWdub3N0aWMoZGlhZ25vc3RpY3MsIGRpYWdub3N0aWMgPSBudWxsLCBhZnRlciA9IDApIHtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIGRpYWdub3N0aWNzLmJldHdlZW4oYWZ0ZXIsIDFlOSwgKGZyb20sIHRvLCB7IHNwZWMgfSkgPT4ge1xuICAgICAgICBpZiAoZGlhZ25vc3RpYyAmJiBzcGVjLmRpYWdub3N0aWMgIT0gZGlhZ25vc3RpYylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm91bmQgPSBuZXcgU2VsZWN0ZWREaWFnbm9zdGljKGZyb20sIHRvLCBzcGVjLmRpYWdub3N0aWMpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gaGlkZVRvb2x0aXAodHIsIHRvb2x0aXApIHtcbiAgICByZXR1cm4gISEodHIuZWZmZWN0cy5zb21lKGUgPT4gZS5pcyhzZXREaWFnbm9zdGljc0VmZmVjdCkpIHx8IHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKHRvb2x0aXAucG9zKSk7XG59XG5mdW5jdGlvbiBtYXliZUVuYWJsZUxpbnQoc3RhdGUsIGVmZmVjdHMpIHtcbiAgICByZXR1cm4gc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSkgPyBlZmZlY3RzIDogZWZmZWN0cy5jb25jYXQoU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKFtcbiAgICAgICAgbGludFN0YXRlLFxuICAgICAgICBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmNvbXB1dGUoW2xpbnRTdGF0ZV0sIHN0YXRlID0+IHtcbiAgICAgICAgICAgIGxldCB7IHNlbGVjdGVkLCBwYW5lbCB9ID0gc3RhdGUuZmllbGQobGludFN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiAhc2VsZWN0ZWQgfHwgIXBhbmVsIHx8IHNlbGVjdGVkLmZyb20gPT0gc2VsZWN0ZWQudG8gPyBEZWNvcmF0aW9uLm5vbmUgOiBEZWNvcmF0aW9uLnNldChbXG4gICAgICAgICAgICAgICAgYWN0aXZlTWFyay5yYW5nZShzZWxlY3RlZC5mcm9tLCBzZWxlY3RlZC50bylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9KSxcbiAgICAgICAgaG92ZXJUb29sdGlwKGxpbnRUb29sdGlwLCB7IGhpZGVPbjogaGlkZVRvb2x0aXAgfSksXG4gICAgICAgIGJhc2VUaGVtZVxuICAgIF0pKTtcbn1cbi8qKlxuUmV0dXJucyBhIHRyYW5zYWN0aW9uIHNwZWMgd2hpY2ggdXBkYXRlcyB0aGUgY3VycmVudCBzZXQgb2ZcbmRpYWdub3N0aWNzLCBhbmQgZW5hYmxlcyB0aGUgbGludCBleHRlbnNpb24gaWYgaWYgd2Fzbid0IGFscmVhZHlcbmFjdGl2ZS5cbiovXG5mdW5jdGlvbiBzZXREaWFnbm9zdGljcyhzdGF0ZSwgZGlhZ25vc3RpY3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlZmZlY3RzOiBtYXliZUVuYWJsZUxpbnQoc3RhdGUsIFtzZXREaWFnbm9zdGljc0VmZmVjdC5vZihkaWFnbm9zdGljcyldKVxuICAgIH07XG59XG4vKipcblRoZSBzdGF0ZSBlZmZlY3QgdGhhdCB1cGRhdGVzIHRoZSBzZXQgb2YgYWN0aXZlIGRpYWdub3N0aWNzLiBDYW5cbmJlIHVzZWZ1bCB3aGVuIHdyaXRpbmcgYW4gZXh0ZW5zaW9uIHRoYXQgbmVlZHMgdG8gdHJhY2sgdGhlc2UuXG4qL1xuY29uc3Qgc2V0RGlhZ25vc3RpY3NFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCB0b2dnbGVQYW5lbCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IG1vdmVQYW5lbFNlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGxpbnRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IExpbnRTdGF0ZShEZWNvcmF0aW9uLm5vbmUsIG51bGwsIG51bGwpO1xuICAgIH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBpZiAodHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHZhbHVlLmRpYWdub3N0aWNzLm1hcCh0ci5jaGFuZ2VzKSwgc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbFBvcyA9IHRyLmNoYW5nZXMubWFwUG9zKHZhbHVlLnNlbGVjdGVkLmZyb20sIDEpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gZmluZERpYWdub3N0aWMobWFwcGVkLCB2YWx1ZS5zZWxlY3RlZC5kaWFnbm9zdGljLCBzZWxQb3MpIHx8IGZpbmREaWFnbm9zdGljKG1hcHBlZCwgbnVsbCwgc2VsUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gbmV3IExpbnRTdGF0ZShtYXBwZWQsIHZhbHVlLnBhbmVsLCBzZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0RGlhZ25vc3RpY3NFZmZlY3QpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMaW50U3RhdGUuaW5pdChlZmZlY3QudmFsdWUsIHZhbHVlLnBhbmVsLCB0ci5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXModG9nZ2xlUGFuZWwpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgTGludFN0YXRlKHZhbHVlLmRpYWdub3N0aWNzLCBlZmZlY3QudmFsdWUgPyBMaW50UGFuZWwub3BlbiA6IG51bGwsIHZhbHVlLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhtb3ZlUGFuZWxTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgTGludFN0YXRlKHZhbHVlLmRpYWdub3N0aWNzLCB2YWx1ZS5wYW5lbCwgZWZmZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IFtzaG93UGFuZWwuZnJvbShmLCB2YWwgPT4gdmFsLnBhbmVsKSxcbiAgICAgICAgRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYsIHMgPT4gcy5kaWFnbm9zdGljcyldXG59KTtcbi8qKlxuUmV0dXJucyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBsaW50IGRpYWdub3N0aWNzIGluIHRoZSBnaXZlbiBzdGF0ZS5cbiovXG5mdW5jdGlvbiBkaWFnbm9zdGljQ291bnQoc3RhdGUpIHtcbiAgICBsZXQgbGludCA9IHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBsaW50ID8gbGludC5kaWFnbm9zdGljcy5zaXplIDogMDtcbn1cbmNvbnN0IGFjdGl2ZU1hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbGludFJhbmdlIGNtLWxpbnRSYW5nZS1hY3RpdmVcIiB9KTtcbmZ1bmN0aW9uIGxpbnRUb29sdGlwKHZpZXcsIHBvcywgc2lkZSkge1xuICAgIGxldCB7IGRpYWdub3N0aWNzIH0gPSB2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSk7XG4gICAgbGV0IGZvdW5kID0gW10sIHN0YWNrU3RhcnQgPSAyZTgsIHN0YWNrRW5kID0gMDtcbiAgICBkaWFnbm9zdGljcy5iZXR3ZWVuKHBvcyAtIChzaWRlIDwgMCA/IDEgOiAwKSwgcG9zICsgKHNpZGUgPiAwID8gMSA6IDApLCAoZnJvbSwgdG8sIHsgc3BlYyB9KSA9PiB7XG4gICAgICAgIGlmIChwb3MgPj0gZnJvbSAmJiBwb3MgPD0gdG8gJiZcbiAgICAgICAgICAgIChmcm9tID09IHRvIHx8ICgocG9zID4gZnJvbSB8fCBzaWRlID4gMCkgJiYgKHBvcyA8IHRvIHx8IHNpZGUgPCAwKSkpKSB7XG4gICAgICAgICAgICBmb3VuZC5wdXNoKHNwZWMuZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICBzdGFja1N0YXJ0ID0gTWF0aC5taW4oZnJvbSwgc3RhY2tTdGFydCk7XG4gICAgICAgICAgICBzdGFja0VuZCA9IE1hdGgubWF4KHRvLCBzdGFja0VuZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgZGlhZ25vc3RpY0ZpbHRlciA9IHZpZXcuc3RhdGUuZmFjZXQobGludENvbmZpZykudG9vbHRpcEZpbHRlcjtcbiAgICBpZiAoZGlhZ25vc3RpY0ZpbHRlcilcbiAgICAgICAgZm91bmQgPSBkaWFnbm9zdGljRmlsdGVyKGZvdW5kKTtcbiAgICBpZiAoIWZvdW5kLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zOiBzdGFja1N0YXJ0LFxuICAgICAgICBlbmQ6IHN0YWNrRW5kLFxuICAgICAgICBhYm92ZTogdmlldy5zdGF0ZS5kb2MubGluZUF0KHN0YWNrU3RhcnQpLnRvIDwgc3RhY2tFbmQsXG4gICAgICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbTogZGlhZ25vc3RpY3NUb29sdGlwKHZpZXcsIGZvdW5kKSB9O1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRpYWdub3N0aWNzVG9vbHRpcCh2aWV3LCBkaWFnbm9zdGljcykge1xuICAgIHJldHVybiBlbHQoXCJ1bFwiLCB7IGNsYXNzOiBcImNtLXRvb2x0aXAtbGludFwiIH0sIGRpYWdub3N0aWNzLm1hcChkID0+IHJlbmRlckRpYWdub3N0aWModmlldywgZCwgZmFsc2UpKSk7XG59XG4vKipcbkNvbW1hbmQgdG8gb3BlbiBhbmQgZm9jdXMgdGhlIGxpbnQgcGFuZWwuXG4qL1xuY29uc3Qgb3BlbkxpbnRQYW5lbCA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5wYW5lbClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlTGludCh2aWV3LnN0YXRlLCBbdG9nZ2xlUGFuZWwub2YodHJ1ZSldKSB9KTtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBMaW50UGFuZWwub3Blbik7XG4gICAgaWYgKHBhbmVsKVxuICAgICAgICBwYW5lbC5kb20ucXVlcnlTZWxlY3RvcihcIi5jbS1wYW5lbC1saW50IHVsXCIpLmZvY3VzKCk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Db21tYW5kIHRvIGNsb3NlIHRoZSBsaW50IHBhbmVsLCB3aGVuIG9wZW4uXG4qL1xuY29uc3QgY2xvc2VMaW50UGFuZWwgPSAodmlldykgPT4ge1xuICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFmaWVsZCB8fCAhZmllbGQucGFuZWwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdG9nZ2xlUGFuZWwub2YoZmFsc2UpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBuZXh0IGRpYWdub3N0aWMuXG4qL1xuY29uc3QgbmV4dERpYWdub3N0aWMgPSAodmlldykgPT4ge1xuICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFmaWVsZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLCBuZXh0ID0gZmllbGQuZGlhZ25vc3RpY3MuaXRlcihzZWwudG8gKyAxKTtcbiAgICBpZiAoIW5leHQudmFsdWUpIHtcbiAgICAgICAgbmV4dCA9IGZpZWxkLmRpYWdub3N0aWNzLml0ZXIoMCk7XG4gICAgICAgIGlmICghbmV4dC52YWx1ZSB8fCBuZXh0LmZyb20gPT0gc2VsLmZyb20gJiYgbmV4dC50byA9PSBzZWwudG8pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goeyBzZWxlY3Rpb246IHsgYW5jaG9yOiBuZXh0LmZyb20sIGhlYWQ6IG5leHQudG8gfSwgc2Nyb2xsSW50b1ZpZXc6IHRydWUgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BIHNldCBvZiBkZWZhdWx0IGtleSBiaW5kaW5ncyBmb3IgdGhlIGxpbnQgZnVuY3Rpb25hbGl0eS5cblxuLSBDdHJsLVNoaWZ0LW0gKENtZC1TaGlmdC1tIG9uIG1hY09TKTogW2BvcGVuTGludFBhbmVsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50Lm9wZW5MaW50UGFuZWwpXG4tIEY4OiBbYG5leHREaWFnbm9zdGljYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50Lm5leHREaWFnbm9zdGljKVxuKi9cbmNvbnN0IGxpbnRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLVNoaWZ0LW1cIiwgcnVuOiBvcGVuTGludFBhbmVsLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkY4XCIsIHJ1bjogbmV4dERpYWdub3N0aWMgfVxuXTtcbmNvbnN0IGxpbnRQbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMuc2V0ID0gdHJ1ZTtcbiAgICAgICAgbGV0IHsgZGVsYXkgfSA9IHZpZXcuc3RhdGUuZmFjZXQobGludENvbmZpZyk7XG4gICAgICAgIHRoaXMubGludFRpbWUgPSBEYXRlLm5vdygpICsgZGVsYXk7XG4gICAgICAgIHRoaXMucnVuID0gdGhpcy5ydW4uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLnJ1biwgZGVsYXkpO1xuICAgIH1cbiAgICBydW4oKSB7XG4gICAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93IDwgdGhpcy5saW50VGltZSAtIDEwKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMucnVuLCB0aGlzLmxpbnRUaW1lIC0gbm93KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCB7IHNvdXJjZXMgfSA9IHN0YXRlLmZhY2V0KGxpbnRDb25maWcpO1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwoc291cmNlcy5tYXAoc291cmNlID0+IFByb21pc2UucmVzb2x2ZShzb3VyY2UodGhpcy52aWV3KSkpKS50aGVuKGFubm90YXRpb25zID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgYWxsID0gYW5ub3RhdGlvbnMucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5kb2MgPT0gc3RhdGUuZG9jKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goc2V0RGlhZ25vc3RpY3ModGhpcy52aWV3LnN0YXRlLCBhbGwpKTtcbiAgICAgICAgICAgIH0sIGVycm9yID0+IHsgbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZXJyb3IpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB1cGRhdGUuc3RhdGUuZmFjZXQobGludENvbmZpZyk7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCBjb25maWcgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGludENvbmZpZykgfHxcbiAgICAgICAgICAgIGNvbmZpZy5uZWVkc1JlZnJlc2ggJiYgY29uZmlnLm5lZWRzUmVmcmVzaCh1cGRhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKSArIGNvbmZpZy5kZWxheTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLnJ1biwgY29uZmlnLmRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JjZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgfVxufSk7XG5jb25zdCBsaW50Q29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHNvdXJjZXM6IGlucHV0Lm1hcChpID0+IGkuc291cmNlKSB9LCBjb21iaW5lQ29uZmlnKGlucHV0Lm1hcChpID0+IGkuY29uZmlnKSwge1xuICAgICAgICAgICAgZGVsYXk6IDc1MCxcbiAgICAgICAgICAgIG1hcmtlckZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgIHRvb2x0aXBGaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICBuZWVkc1JlZnJlc2g6IG51bGxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmVlZHNSZWZyZXNoOiAoYSwgYikgPT4gIWEgPyBiIDogIWIgPyBhIDogdSA9PiBhKHUpIHx8IGIodSlcbiAgICAgICAgfSkpO1xuICAgIH0sXG4gICAgZW5hYmxlczogbGludFBsdWdpblxufSk7XG4vKipcbkdpdmVuIGEgZGlhZ25vc3RpYyBzb3VyY2UsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBleHRlbnNpb24gdGhhdFxuZW5hYmxlcyBsaW50aW5nIHdpdGggdGhhdCBzb3VyY2UuIEl0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZVxuZWRpdG9yIGlzIGlkbGUgKGFmdGVyIGl0cyBjb250ZW50IGNoYW5nZWQpLlxuKi9cbmZ1bmN0aW9uIGxpbnRlcihzb3VyY2UsIGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIGxpbnRDb25maWcub2YoeyBzb3VyY2UsIGNvbmZpZyB9KTtcbn1cbi8qKlxuRm9yY2VzIGFueSBsaW50ZXJzIFtjb25maWd1cmVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQubGludGVyKSB0byBydW4gd2hlbiB0aGVcbmVkaXRvciBpcyBpZGxlIHRvIHJ1biByaWdodCBhd2F5LlxuKi9cbmZ1bmN0aW9uIGZvcmNlTGludGluZyh2aWV3KSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKGxpbnRQbHVnaW4pO1xuICAgIGlmIChwbHVnaW4pXG4gICAgICAgIHBsdWdpbi5mb3JjZSgpO1xufVxuZnVuY3Rpb24gYXNzaWduS2V5cyhhY3Rpb25zKSB7XG4gICAgbGV0IGFzc2lnbmVkID0gW107XG4gICAgaWYgKGFjdGlvbnMpXG4gICAgICAgIGFjdGlvbnM6IGZvciAobGV0IHsgbmFtZSB9IG9mIGFjdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IG5hbWVbaV07XG4gICAgICAgICAgICAgICAgaWYgKC9bYS16QS1aXS8udGVzdChjaCkgJiYgIWFzc2lnbmVkLnNvbWUoYyA9PiBjLnRvTG93ZXJDYXNlKCkgPT0gY2gudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduZWQucHVzaChjaCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGFjdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzaWduZWQucHVzaChcIlwiKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBhc3NpZ25lZDtcbn1cbmZ1bmN0aW9uIHJlbmRlckRpYWdub3N0aWModmlldywgZGlhZ25vc3RpYywgaW5QYW5lbCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQga2V5cyA9IGluUGFuZWwgPyBhc3NpZ25LZXlzKGRpYWdub3N0aWMuYWN0aW9ucykgOiBbXTtcbiAgICByZXR1cm4gZWx0KFwibGlcIiwgeyBjbGFzczogXCJjbS1kaWFnbm9zdGljIGNtLWRpYWdub3N0aWMtXCIgKyBkaWFnbm9zdGljLnNldmVyaXR5IH0sIGVsdChcInNwYW5cIiwgeyBjbGFzczogXCJjbS1kaWFnbm9zdGljVGV4dFwiIH0sIGRpYWdub3N0aWMucmVuZGVyTWVzc2FnZSA/IGRpYWdub3N0aWMucmVuZGVyTWVzc2FnZSgpIDogZGlhZ25vc3RpYy5tZXNzYWdlKSwgKF9hID0gZGlhZ25vc3RpYy5hY3Rpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChhY3Rpb24sIGkpID0+IHtcbiAgICAgICAgbGV0IGZpcmVkID0gZmFsc2UsIGNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChmaXJlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBmaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmaW5kRGlhZ25vc3RpYyh2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSkuZGlhZ25vc3RpY3MsIGRpYWdub3N0aWMpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgIGFjdGlvbi5hcHBseSh2aWV3LCBmb3VuZC5mcm9tLCBmb3VuZC50byk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCB7IG5hbWUgfSA9IGFjdGlvbiwga2V5SW5kZXggPSBrZXlzW2ldID8gbmFtZS5pbmRleE9mKGtleXNbaV0pIDogLTE7XG4gICAgICAgIGxldCBuYW1lRWx0ID0ga2V5SW5kZXggPCAwID8gbmFtZSA6IFtuYW1lLnNsaWNlKDAsIGtleUluZGV4KSxcbiAgICAgICAgICAgIGVsdChcInVcIiwgbmFtZS5zbGljZShrZXlJbmRleCwga2V5SW5kZXggKyAxKSksXG4gICAgICAgICAgICBuYW1lLnNsaWNlKGtleUluZGV4ICsgMSldO1xuICAgICAgICByZXR1cm4gZWx0KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBjbGFzczogXCJjbS1kaWFnbm9zdGljQWN0aW9uXCIsXG4gICAgICAgICAgICBvbmNsaWNrOiBjbGljayxcbiAgICAgICAgICAgIG9ubW91c2Vkb3duOiBjbGljayxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBgIEFjdGlvbjogJHtuYW1lfSR7a2V5SW5kZXggPCAwID8gXCJcIiA6IGAgKGFjY2VzcyBrZXkgXCIke2tleXNbaV19KVwiYH0uYFxuICAgICAgICB9LCBuYW1lRWx0KTtcbiAgICB9KSwgZGlhZ25vc3RpYy5zb3VyY2UgJiYgZWx0KFwiZGl2XCIsIHsgY2xhc3M6IFwiY20tZGlhZ25vc3RpY1NvdXJjZVwiIH0sIGRpYWdub3N0aWMuc291cmNlKSk7XG59XG5jbGFzcyBEaWFnbm9zdGljV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoZGlhZ25vc3RpYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRpYWdub3N0aWMgPSBkaWFnbm9zdGljO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuZGlhZ25vc3RpYyA9PSB0aGlzLmRpYWdub3N0aWM7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgcmV0dXJuIGVsdChcInNwYW5cIiwgeyBjbGFzczogXCJjbS1saW50UG9pbnQgY20tbGludFBvaW50LVwiICsgdGhpcy5kaWFnbm9zdGljLnNldmVyaXR5IH0pO1xuICAgIH1cbn1cbmNsYXNzIFBhbmVsSXRlbSB7XG4gICAgY29uc3RydWN0b3IodmlldywgZGlhZ25vc3RpYykge1xuICAgICAgICB0aGlzLmRpYWdub3N0aWMgPSBkaWFnbm9zdGljO1xuICAgICAgICB0aGlzLmlkID0gXCJpdGVtX1wiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICB0aGlzLmRvbSA9IHJlbmRlckRpYWdub3N0aWModmlldywgZGlhZ25vc3RpYywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZG9tLmlkID0gdGhpcy5pZDtcbiAgICAgICAgdGhpcy5kb20uc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKTtcbiAgICB9XG59XG5jbGFzcyBMaW50UGFuZWwge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICBsZXQgb25rZXlkb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNykgeyAvLyBFc2NhcGVcbiAgICAgICAgICAgICAgICBjbG9zZUxpbnRQYW5lbCh0aGlzLnZpZXcpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzOCB8fCBldmVudC5rZXlDb2RlID09IDMzKSB7IC8vIEFycm93VXAsIFBhZ2VVcFxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigodGhpcy5zZWxlY3RlZEluZGV4IC0gMSArIHRoaXMuaXRlbXMubGVuZ3RoKSAlIHRoaXMuaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gNDAgfHwgZXZlbnQua2V5Q29kZSA9PSAzNCkgeyAvLyBBcnJvd0Rvd24sIFBhZ2VEb3duXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKCh0aGlzLnNlbGVjdGVkSW5kZXggKyAxKSAlIHRoaXMuaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzYpIHsgLy8gSG9tZVxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzUpIHsgLy8gRW5kXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKHRoaXMuaXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDEzKSB7IC8vIEVudGVyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID49IDY1ICYmIGV2ZW50LmtleUNvZGUgPD0gOTAgJiYgdGhpcy5zZWxlY3RlZEluZGV4ID49IDApIHsgLy8gQS1aXG4gICAgICAgICAgICAgICAgbGV0IHsgZGlhZ25vc3RpYyB9ID0gdGhpcy5pdGVtc1t0aGlzLnNlbGVjdGVkSW5kZXhdLCBrZXlzID0gYXNzaWduS2V5cyhkaWFnbm9zdGljLmFjdGlvbnMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleXNbaV0udG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApID09IGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZpbmREaWFnbm9zdGljKHRoaXMudmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpLmRpYWdub3N0aWNzLCBkaWFnbm9zdGljKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljLmFjdGlvbnNbaV0uYXBwbHkodmlldywgZm91bmQuZnJvbSwgZm91bmQudG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgb25jbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbaV0uZG9tLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbihpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0ID0gZWx0KFwidWxcIiwge1xuICAgICAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgICAgICByb2xlOiBcImxpc3Rib3hcIixcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLnZpZXcuc3RhdGUucGhyYXNlKFwiRGlhZ25vc3RpY3NcIiksXG4gICAgICAgICAgICBvbmtleWRvd24sXG4gICAgICAgICAgICBvbmNsaWNrXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRvbSA9IGVsdChcImRpdlwiLCB7IGNsYXNzOiBcImNtLXBhbmVsLWxpbnRcIiB9LCB0aGlzLmxpc3QsIGVsdChcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgbmFtZTogXCJjbG9zZVwiLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMudmlldy5zdGF0ZS5waHJhc2UoXCJjbG9zZVwiKSxcbiAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IGNsb3NlTGludFBhbmVsKHRoaXMudmlldylcbiAgICAgICAgfSwgXCJcdTAwRDdcIikpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWRJbmRleCgpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSkuc2VsZWN0ZWQ7XG4gICAgICAgIGlmICghc2VsZWN0ZWQpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2ldLmRpYWdub3N0aWMgPT0gc2VsZWN0ZWQuZGlhZ25vc3RpYylcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCB7IGRpYWdub3N0aWNzLCBzZWxlY3RlZCB9ID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSk7XG4gICAgICAgIGxldCBpID0gMCwgbmVlZHNTeW5jID0gZmFsc2UsIG5ld1NlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgICAgIGRpYWdub3N0aWNzLmJldHdlZW4oMCwgdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGgsIChfc3RhcnQsIF9lbmQsIHsgc3BlYyB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSAtMSwgaXRlbTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtc1tqXS5kaWFnbm9zdGljID09IHNwZWMuZGlhZ25vc3RpYykge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGo7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZCA8IDApIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gbmV3IFBhbmVsSXRlbSh0aGlzLnZpZXcsIHNwZWMuZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSwgMCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzLml0ZW1zW2ZvdW5kXTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIGZvdW5kIC0gaSk7XG4gICAgICAgICAgICAgICAgICAgIG5lZWRzU3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkICYmIGl0ZW0uZGlhZ25vc3RpYyA9PSBzZWxlY3RlZC5kaWFnbm9zdGljKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLmRvbS5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RlZEl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uZG9tLmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLml0ZW1zLmxlbmd0aCAmJiAhKHRoaXMuaXRlbXMubGVuZ3RoID09IDEgJiYgdGhpcy5pdGVtc1swXS5kaWFnbm9zdGljLmZyb20gPCAwKSkge1xuICAgICAgICAgICAgbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChuZXcgUGFuZWxJdGVtKHRoaXMudmlldywge1xuICAgICAgICAgICAgICAgIGZyb206IC0xLCB0bzogLTEsXG4gICAgICAgICAgICAgICAgc2V2ZXJpdHk6IFwiaW5mb1wiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMudmlldy5zdGF0ZS5waHJhc2UoXCJObyBkaWFnbm9zdGljc1wiKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3U2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3Quc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIG5ld1NlbGVjdGVkSXRlbS5pZCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoe1xuICAgICAgICAgICAgICAgIGtleTogdGhpcyxcbiAgICAgICAgICAgICAgICByZWFkOiAoKSA9PiAoeyBzZWw6IG5ld1NlbGVjdGVkSXRlbS5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHBhbmVsOiB0aGlzLmxpc3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfSksXG4gICAgICAgICAgICAgICAgd3JpdGU6ICh7IHNlbCwgcGFuZWwgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsLnRvcCA8IHBhbmVsLnRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdC5zY3JvbGxUb3AgLT0gcGFuZWwudG9wIC0gc2VsLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsLmJvdHRvbSA+IHBhbmVsLmJvdHRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdC5zY3JvbGxUb3AgKz0gc2VsLmJvdHRvbSAtIHBhbmVsLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3QucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc1N5bmMpXG4gICAgICAgICAgICB0aGlzLnN5bmMoKTtcbiAgICB9XG4gICAgc3luYygpIHtcbiAgICAgICAgbGV0IGRvbVBvcyA9IHRoaXMubGlzdC5maXJzdENoaWxkO1xuICAgICAgICBmdW5jdGlvbiBybSgpIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gZG9tUG9zO1xuICAgICAgICAgICAgZG9tUG9zID0gcHJldi5uZXh0U2libGluZztcbiAgICAgICAgICAgIHByZXYucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmxpc3QpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tUG9zICE9IGl0ZW0uZG9tKVxuICAgICAgICAgICAgICAgICAgICBybSgpO1xuICAgICAgICAgICAgICAgIGRvbVBvcyA9IGl0ZW0uZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0Lmluc2VydEJlZm9yZShpdGVtLmRvbSwgZG9tUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZG9tUG9zKVxuICAgICAgICAgICAgcm0oKTtcbiAgICB9XG4gICAgbW92ZVNlbGVjdGlvbihzZWxlY3RlZEluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZmllbGQgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGZpbmREaWFnbm9zdGljKGZpZWxkLmRpYWdub3N0aWNzLCB0aGlzLml0ZW1zW3NlbGVjdGVkSW5kZXhdLmRpYWdub3N0aWMpO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IHNlbGVjdGlvbi5mcm9tLCBoZWFkOiBzZWxlY3Rpb24udG8gfSxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICAgICAgZWZmZWN0czogbW92ZVBhbmVsU2VsZWN0aW9uLm9mKHNlbGVjdGlvbilcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBvcGVuKHZpZXcpIHsgcmV0dXJuIG5ldyBMaW50UGFuZWwodmlldyk7IH1cbn1cbmZ1bmN0aW9uIHN2Zyhjb250ZW50LCBhdHRycyA9IGB2aWV3Qm94PVwiMCAwIDQwIDQwXCJgKSB7XG4gICAgcmV0dXJuIGB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbCw8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAke2F0dHJzfT4ke2VuY29kZVVSSUNvbXBvbmVudChjb250ZW50KX08L3N2Zz4nKWA7XG59XG5mdW5jdGlvbiB1bmRlcmxpbmUoY29sb3IpIHtcbiAgICByZXR1cm4gc3ZnKGA8cGF0aCBkPVwibTAgMi41IGwyIC0xLjUgbDEgMCBsMiAxLjUgbDEgMFwiIHN0cm9rZT1cIiR7Y29sb3J9XCIgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIuN1wiLz5gLCBgd2lkdGg9XCI2XCIgaGVpZ2h0PVwiM1wiYCk7XG59XG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLWRpYWdub3N0aWNcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjNweCA2cHggM3B4IDhweFwiLFxuICAgICAgICBtYXJnaW5MZWZ0OiBcIi0xcHhcIixcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcInByZS13cmFwXCJcbiAgICB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWMtZXJyb3JcIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCAjZDExXCIgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljLXdhcm5pbmdcIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCBvcmFuZ2VcIiB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWMtaW5mb1wiOiB7IGJvcmRlckxlZnQ6IFwiNXB4IHNvbGlkICM5OTlcIiB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWNBY3Rpb25cIjoge1xuICAgICAgICBmb250OiBcImluaGVyaXRcIixcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgcGFkZGluZzogXCIycHggNHB4XCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjNDQ0XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogXCIzcHhcIixcbiAgICAgICAgbWFyZ2luTGVmdDogXCI4cHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpY1NvdXJjZVwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxuICAgICAgICBvcGFjaXR5OiAuN1xuICAgIH0sXG4gICAgXCIuY20tbGludFJhbmdlXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBcImxlZnQgYm90dG9tXCIsXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6IFwicmVwZWF0LXhcIixcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogXCIwLjdweFwiLFxuICAgIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWVycm9yXCI6IHsgYmFja2dyb3VuZEltYWdlOiAvKkBfX1BVUkVfXyovdW5kZXJsaW5lKFwiI2QxMVwiKSB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS13YXJuaW5nXCI6IHsgYmFja2dyb3VuZEltYWdlOiAvKkBfX1BVUkVfXyovdW5kZXJsaW5lKFwib3JhbmdlXCIpIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWluZm9cIjogeyBiYWNrZ3JvdW5kSW1hZ2U6IC8qQF9fUFVSRV9fKi91bmRlcmxpbmUoXCIjOTk5XCIpIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWFjdGl2ZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZkZDk5ODBcIiB9LFxuICAgIFwiLmNtLXRvb2x0aXAtbGludFwiOiB7XG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG1hcmdpbjogMFxuICAgIH0sXG4gICAgXCIuY20tbGludFBvaW50XCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdcIlwiJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICBsZWZ0OiBcIi0ycHhcIixcbiAgICAgICAgICAgIGJvcmRlckxlZnQ6IFwiM3B4IHNvbGlkIHRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBib3JkZXJSaWdodDogXCIzcHggc29saWQgdHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbTogXCI0cHggc29saWQgI2QxMVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbnRQb2ludC13YXJuaW5nXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgYm9yZGVyQm90dG9tQ29sb3I6IFwib3JhbmdlXCIgfVxuICAgIH0sXG4gICAgXCIuY20tbGludFBvaW50LWluZm9cIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBib3JkZXJCb3R0b21Db2xvcjogXCIjOTk5XCIgfVxuICAgIH0sXG4gICAgXCIuY20tcGFuZWwuY20tcGFuZWwtbGludFwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJiB1bFwiOiB7XG4gICAgICAgICAgICBtYXhIZWlnaHQ6IFwiMTAwcHhcIixcbiAgICAgICAgICAgIG92ZXJmbG93WTogXCJhdXRvXCIsXG4gICAgICAgICAgICBcIiYgW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2RkZFwiLFxuICAgICAgICAgICAgICAgIFwiJiB1XCI6IHsgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJjpmb2N1cyBbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRfZmFsbGJhY2s6IFwiI2JkZlwiLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJIaWdobGlnaHRcIixcbiAgICAgICAgICAgICAgICBjb2xvcl9mYWxsYmFjazogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIkhpZ2hsaWdodFRleHRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJiB1XCI6IHsgdGV4dERlY29yYXRpb246IFwibm9uZVwiIH0sXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBbbmFtZT1jbG9zZV1cIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogXCIwXCIsXG4gICAgICAgICAgICByaWdodDogXCIycHhcIixcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICB9XG4gICAgfVxufSk7XG5jbGFzcyBMaW50R3V0dGVyTWFya2VyIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3RvcihkaWFnbm9zdGljcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRpYWdub3N0aWNzID0gZGlhZ25vc3RpY3M7XG4gICAgICAgIHRoaXMuc2V2ZXJpdHkgPSBkaWFnbm9zdGljcy5yZWR1Y2UoKG1heCwgZCkgPT4ge1xuICAgICAgICAgICAgbGV0IHMgPSBkLnNldmVyaXR5O1xuICAgICAgICAgICAgcmV0dXJuIHMgPT0gXCJlcnJvclwiIHx8IHMgPT0gXCJ3YXJuaW5nXCIgJiYgbWF4ID09IFwiaW5mb1wiID8gcyA6IG1heDtcbiAgICAgICAgfSwgXCJpbmZvXCIpO1xuICAgIH1cbiAgICB0b0RPTSh2aWV3KSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBlbHQuY2xhc3NOYW1lID0gXCJjbS1saW50LW1hcmtlciBjbS1saW50LW1hcmtlci1cIiArIHRoaXMuc2V2ZXJpdHk7XG4gICAgICAgIGxldCBkaWFnbm9zdGljcyA9IHRoaXMuZGlhZ25vc3RpY3M7XG4gICAgICAgIGxldCBkaWFnbm9zdGljc0ZpbHRlciA9IHZpZXcuc3RhdGUuZmFjZXQobGludEd1dHRlckNvbmZpZykudG9vbHRpcEZpbHRlcjtcbiAgICAgICAgaWYgKGRpYWdub3N0aWNzRmlsdGVyKVxuICAgICAgICAgICAgZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljc0ZpbHRlcihkaWFnbm9zdGljcyk7XG4gICAgICAgIGlmIChkaWFnbm9zdGljcy5sZW5ndGgpXG4gICAgICAgICAgICBlbHQub25tb3VzZW92ZXIgPSAoKSA9PiBndXR0ZXJNYXJrZXJNb3VzZU92ZXIodmlldywgZWx0LCBkaWFnbm9zdGljcyk7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhY2tIb3Zlck9uKHZpZXcsIG1hcmtlcikge1xuICAgIGxldCBtb3VzZW1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IHJlY3QgPSBtYXJrZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChldmVudC5jbGllbnRYID4gcmVjdC5sZWZ0IC0gMTAgLyogSG92ZXIuTWFyZ2luICovICYmIGV2ZW50LmNsaWVudFggPCByZWN0LnJpZ2h0ICsgMTAgLyogSG92ZXIuTWFyZ2luICovICYmXG4gICAgICAgICAgICBldmVudC5jbGllbnRZID4gcmVjdC50b3AgLSAxMCAvKiBIb3Zlci5NYXJnaW4gKi8gJiYgZXZlbnQuY2xpZW50WSA8IHJlY3QuYm90dG9tICsgMTAgLyogSG92ZXIuTWFyZ2luICovKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQ7IHRhcmdldDsgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT0gMSAmJiB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY20tdG9vbHRpcC1saW50XCIpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZW1vdmUpO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5maWVsZChsaW50R3V0dGVyVG9vbHRpcCkpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0TGludEd1dHRlclRvb2x0aXAub2YobnVsbCkgfSk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZW1vdmUpO1xufVxuZnVuY3Rpb24gZ3V0dGVyTWFya2VyTW91c2VPdmVyKHZpZXcsIG1hcmtlciwgZGlhZ25vc3RpY3MpIHtcbiAgICBmdW5jdGlvbiBob3ZlcmVkKCkge1xuICAgICAgICBsZXQgbGluZSA9IHZpZXcuZWxlbWVudEF0SGVpZ2h0KG1hcmtlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyA1IC0gdmlldy5kb2N1bWVudFRvcCk7XG4gICAgICAgIGNvbnN0IGxpbmVQb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChsaW5lUG9zKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0TGludEd1dHRlclRvb2x0aXAub2Yoe1xuICAgICAgICAgICAgICAgICAgICBwb3M6IGxpbmUuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgYWJvdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbTogZGlhZ25vc3RpY3NUb29sdGlwKHZpZXcsIGRpYWdub3N0aWNzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb29yZHM6ICgpID0+IG1hcmtlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtlci5vbm1vdXNlb3V0ID0gbWFya2VyLm9ubW91c2Vtb3ZlID0gbnVsbDtcbiAgICAgICAgdHJhY2tIb3Zlck9uKHZpZXcsIG1hcmtlcik7XG4gICAgfVxuICAgIGxldCB7IGhvdmVyVGltZSB9ID0gdmlldy5zdGF0ZS5mYWNldChsaW50R3V0dGVyQ29uZmlnKTtcbiAgICBsZXQgaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dChob3ZlcmVkLCBob3ZlclRpbWUpO1xuICAgIG1hcmtlci5vbm1vdXNlb3V0ID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQoaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgbWFya2VyLm9ubW91c2VvdXQgPSBtYXJrZXIub25tb3VzZW1vdmUgPSBudWxsO1xuICAgIH07XG4gICAgbWFya2VyLm9ubW91c2Vtb3ZlID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQoaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dChob3ZlcmVkLCBob3ZlclRpbWUpO1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXJrZXJzRm9yRGlhZ25vc3RpY3MoZG9jLCBkaWFnbm9zdGljcykge1xuICAgIGxldCBieUxpbmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGRpYWdub3N0aWMgb2YgZGlhZ25vc3RpY3MpIHtcbiAgICAgICAgbGV0IGxpbmUgPSBkb2MubGluZUF0KGRpYWdub3N0aWMuZnJvbSk7XG4gICAgICAgIChieUxpbmVbbGluZS5mcm9tXSB8fCAoYnlMaW5lW2xpbmUuZnJvbV0gPSBbXSkpLnB1c2goZGlhZ25vc3RpYyk7XG4gICAgfVxuICAgIGxldCBtYXJrZXJzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBpbiBieUxpbmUpIHtcbiAgICAgICAgbWFya2Vycy5wdXNoKG5ldyBMaW50R3V0dGVyTWFya2VyKGJ5TGluZVtsaW5lXSkucmFuZ2UoK2xpbmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFJhbmdlU2V0Lm9mKG1hcmtlcnMsIHRydWUpO1xufVxuY29uc3QgbGludEd1dHRlckV4dGVuc2lvbiA9IC8qQF9fUFVSRV9fKi9ndXR0ZXIoe1xuICAgIGNsYXNzOiBcImNtLWd1dHRlci1saW50XCIsXG4gICAgbWFya2VyczogdmlldyA9PiB2aWV3LnN0YXRlLmZpZWxkKGxpbnRHdXR0ZXJNYXJrZXJzKSxcbn0pO1xuY29uc3QgbGludEd1dHRlck1hcmtlcnMgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlU2V0LmVtcHR5O1xuICAgIH0sXG4gICAgdXBkYXRlKG1hcmtlcnMsIHRyKSB7XG4gICAgICAgIG1hcmtlcnMgPSBtYXJrZXJzLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgbGV0IGRpYWdub3N0aWNGaWx0ZXIgPSB0ci5zdGF0ZS5mYWNldChsaW50R3V0dGVyQ29uZmlnKS5tYXJrZXJGaWx0ZXI7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldERpYWdub3N0aWNzRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIGxldCBkaWFnbm9zdGljcyA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGlhZ25vc3RpY0ZpbHRlcilcbiAgICAgICAgICAgICAgICAgICAgZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljRmlsdGVyKGRpYWdub3N0aWNzIHx8IFtdKTtcbiAgICAgICAgICAgICAgICBtYXJrZXJzID0gbWFya2Vyc0ZvckRpYWdub3N0aWNzKHRyLnN0YXRlLmRvYywgZGlhZ25vc3RpY3Muc2xpY2UoMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH1cbn0pO1xuY29uc3Qgc2V0TGludEd1dHRlclRvb2x0aXAgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBsaW50R3V0dGVyVG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICB1cGRhdGUodG9vbHRpcCwgdHIpIHtcbiAgICAgICAgaWYgKHRvb2x0aXAgJiYgdHIuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHRvb2x0aXAgPSBoaWRlVG9vbHRpcCh0ciwgdG9vbHRpcCkgPyBudWxsIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0b29sdGlwKSwgeyBwb3M6IHRyLmNoYW5nZXMubWFwUG9zKHRvb2x0aXAucG9zKSB9KTtcbiAgICAgICAgcmV0dXJuIHRyLmVmZmVjdHMucmVkdWNlKCh0LCBlKSA9PiBlLmlzKHNldExpbnRHdXR0ZXJUb29sdGlwKSA/IGUudmFsdWUgOiB0LCB0b29sdGlwKTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGZpZWxkID0+IHNob3dUb29sdGlwLmZyb20oZmllbGQpXG59KTtcbmNvbnN0IGxpbnRHdXR0ZXJUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZ3V0dGVyLWxpbnRcIjoge1xuICAgICAgICB3aWR0aDogXCIxLjRlbVwiLFxuICAgICAgICBcIiYgLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgICAgICAgICAgcGFkZGluZzogXCIuMmVtXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tbGludC1tYXJrZXJcIjoge1xuICAgICAgICB3aWR0aDogXCIxZW1cIixcbiAgICAgICAgaGVpZ2h0OiBcIjFlbVwiXG4gICAgfSxcbiAgICBcIi5jbS1saW50LW1hcmtlci1pbmZvXCI6IHtcbiAgICAgICAgY29udGVudDogLypAX19QVVJFX18qL3N2ZyhgPHBhdGggZmlsbD1cIiNhYWZcIiBzdHJva2U9XCIjNzdlXCIgc3Ryb2tlLXdpZHRoPVwiNlwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk01IDVMMzUgNUwzNSAzNUw1IDM1WlwiLz5gKVxuICAgIH0sXG4gICAgXCIuY20tbGludC1tYXJrZXItd2FybmluZ1wiOiB7XG4gICAgICAgIGNvbnRlbnQ6IC8qQF9fUFVSRV9fKi9zdmcoYDxwYXRoIGZpbGw9XCIjZmU4XCIgc3Ryb2tlPVwiI2ZkN1wiIHN0cm9rZS13aWR0aD1cIjZcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMjAgNkwzNyAzNUwzIDM1WlwiLz5gKSxcbiAgICB9LFxuICAgIFwiLmNtLWxpbnQtbWFya2VyLWVycm9yXCI6IHtcbiAgICAgICAgY29udGVudDogLypAX19QVVJFX18qL3N2ZyhgPGNpcmNsZSBjeD1cIjIwXCIgY3k9XCIyMFwiIHI9XCIxNVwiIGZpbGw9XCIjZjg3XCIgc3Ryb2tlPVwiI2Y0M1wiIHN0cm9rZS13aWR0aD1cIjZcIi8+YClcbiAgICB9LFxufSk7XG5jb25zdCBsaW50R3V0dGVyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIGhvdmVyVGltZTogMzAwIC8qIEhvdmVyLlRpbWUgKi8sXG4gICAgICAgICAgICBtYXJrZXJGaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwRmlsdGVyOiBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGluc3RhbGxzIGEgZ3V0dGVyIHNob3dpbmcgbWFya2VycyBmb3JcbmVhY2ggbGluZSB0aGF0IGhhcyBkaWFnbm9zdGljcywgd2hpY2ggY2FuIGJlIGhvdmVyZWQgb3ZlciB0byBzZWVcbnRoZSBkaWFnbm9zdGljcy5cbiovXG5mdW5jdGlvbiBsaW50R3V0dGVyKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtsaW50R3V0dGVyQ29uZmlnLm9mKGNvbmZpZyksIGxpbnRHdXR0ZXJNYXJrZXJzLCBsaW50R3V0dGVyRXh0ZW5zaW9uLCBsaW50R3V0dGVyVGhlbWUsIGxpbnRHdXR0ZXJUb29sdGlwXTtcbn1cbi8qKlxuSXRlcmF0ZSBvdmVyIHRoZSBtYXJrZWQgZGlhZ25vc3RpY3MgZm9yIHRoZSBnaXZlbiBlZGl0b3Igc3RhdGUsXG5jYWxsaW5nIGBmYCBmb3IgZWFjaCBvZiB0aGVtLiBOb3RlIHRoYXQsIGlmIHRoZSBkb2N1bWVudCBjaGFuZ2VkXG5zaW5jZSB0aGUgZGlhZ25vc3RpY3Mgd2VyZSBjcmVhdGVkLCB0aGUgYERpYWdub3N0aWNgIG9iamVjdCB3aWxsXG5ob2xkIHRoZSBvcmlnaW5hbCBvdXRkYXRlZCBwb3NpdGlvbiwgd2hlcmVhcyB0aGUgYHRvYCBhbmQgYGZyb21gXG5hcmd1bWVudHMgaG9sZCB0aGUgZGlhZ25vc3RpYydzIGN1cnJlbnQgcG9zaXRpb24uXG4qL1xuZnVuY3Rpb24gZm9yRWFjaERpYWdub3N0aWMoc3RhdGUsIGYpIHtcbiAgICBsZXQgbFN0YXRlID0gc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKGxTdGF0ZSAmJiBsU3RhdGUuZGlhZ25vc3RpY3Muc2l6ZSlcbiAgICAgICAgZm9yIChsZXQgaXRlciA9IFJhbmdlU2V0Lml0ZXIoW2xTdGF0ZS5kaWFnbm9zdGljc10pOyBpdGVyLnZhbHVlOyBpdGVyLm5leHQoKSlcbiAgICAgICAgICAgIGYoaXRlci52YWx1ZS5zcGVjLmRpYWdub3N0aWMsIGl0ZXIuZnJvbSwgaXRlci50byk7XG59XG5cbmV4cG9ydCB7IGNsb3NlTGludFBhbmVsLCBkaWFnbm9zdGljQ291bnQsIGZvckVhY2hEaWFnbm9zdGljLCBmb3JjZUxpbnRpbmcsIGxpbnRHdXR0ZXIsIGxpbnRLZXltYXAsIGxpbnRlciwgbmV4dERpYWdub3N0aWMsIG9wZW5MaW50UGFuZWwsIHNldERpYWdub3N0aWNzLCBzZXREaWFnbm9zdGljc0VmZmVjdCB9O1xuIiwgImltcG9ydCB7IGxpbmVOdW1iZXJzLCBoaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyLCBoaWdobGlnaHRTcGVjaWFsQ2hhcnMsIGRyYXdTZWxlY3Rpb24sIGRyb3BDdXJzb3IsIHJlY3Rhbmd1bGFyU2VsZWN0aW9uLCBjcm9zc2hhaXJDdXJzb3IsIGhpZ2hsaWdodEFjdGl2ZUxpbmUsIGtleW1hcCB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuZXhwb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBmb2xkR3V0dGVyLCBpbmRlbnRPbklucHV0LCBzeW50YXhIaWdobGlnaHRpbmcsIGRlZmF1bHRIaWdobGlnaHRTdHlsZSwgYnJhY2tldE1hdGNoaW5nLCBmb2xkS2V5bWFwIH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgaGlzdG9yeSwgZGVmYXVsdEtleW1hcCwgaGlzdG9yeUtleW1hcCB9IGZyb20gJ0Bjb2RlbWlycm9yL2NvbW1hbmRzJztcbmltcG9ydCB7IGhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMsIHNlYXJjaEtleW1hcCB9IGZyb20gJ0Bjb2RlbWlycm9yL3NlYXJjaCc7XG5pbXBvcnQgeyBjbG9zZUJyYWNrZXRzLCBhdXRvY29tcGxldGlvbiwgY2xvc2VCcmFja2V0c0tleW1hcCwgY29tcGxldGlvbktleW1hcCB9IGZyb20gJ0Bjb2RlbWlycm9yL2F1dG9jb21wbGV0ZSc7XG5pbXBvcnQgeyBsaW50S2V5bWFwIH0gZnJvbSAnQGNvZGVtaXJyb3IvbGludCc7XG5cbi8vIChUaGUgc3VwZXJmbHVvdXMgZnVuY3Rpb24gY2FsbHMgYXJvdW5kIHRoZSBsaXN0IG9mIGV4dGVuc2lvbnMgd29ya1xuLy8gYXJvdW5kIGN1cnJlbnQgbGltaXRhdGlvbnMgaW4gdHJlZS1zaGFraW5nIHNvZnR3YXJlLilcbi8qKlxuVGhpcyBpcyBhbiBleHRlbnNpb24gdmFsdWUgdGhhdCBqdXN0IHB1bGxzIHRvZ2V0aGVyIGEgbnVtYmVyIG9mXG5leHRlbnNpb25zIHRoYXQgeW91IG1pZ2h0IHdhbnQgaW4gYSBiYXNpYyBlZGl0b3IuIEl0IGlzIG1lYW50IGFzIGFcbmNvbnZlbmllbnQgaGVscGVyIHRvIHF1aWNrbHkgc2V0IHVwIENvZGVNaXJyb3Igd2l0aG91dCBpbnN0YWxsaW5nXG5hbmQgaW1wb3J0aW5nIGEgbG90IG9mIHNlcGFyYXRlIHBhY2thZ2VzLlxuXG5TcGVjaWZpY2FsbHksIGl0IGluY2x1ZGVzLi4uXG5cbiAtIFt0aGUgZGVmYXVsdCBjb21tYW5kIGJpbmRpbmdzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlZmF1bHRLZXltYXApXG4gLSBbbGluZSBudW1iZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcubGluZU51bWJlcnMpXG4gLSBbc3BlY2lhbCBjaGFyYWN0ZXIgaGlnaGxpZ2h0aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuaGlnaGxpZ2h0U3BlY2lhbENoYXJzKVxuIC0gW3RoZSB1bmRvIGhpc3RvcnldKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaGlzdG9yeSlcbiAtIFthIGZvbGQgZ3V0dGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRHdXR0ZXIpXG4gLSBbY3VzdG9tIHNlbGVjdGlvbiBkcmF3aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJhd1NlbGVjdGlvbilcbiAtIFtkcm9wIGN1cnNvcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmRyb3BDdXJzb3IpXG4gLSBbbXVsdGlwbGUgc2VsZWN0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5hbGxvd011bHRpcGxlU2VsZWN0aW9ucylcbiAtIFtyZWluZGVudGF0aW9uIG9uIGlucHV0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudE9uSW5wdXQpXG4gLSBbdGhlIGRlZmF1bHQgaGlnaGxpZ2h0IHN0eWxlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmRlZmF1bHRIaWdobGlnaHRTdHlsZSkgKGFzIGZhbGxiYWNrKVxuIC0gW2JyYWNrZXQgbWF0Y2hpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuYnJhY2tldE1hdGNoaW5nKVxuIC0gW2JyYWNrZXQgY2xvc2luZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuY2xvc2VCcmFja2V0cylcbiAtIFthdXRvY29tcGxldGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuYXV0b2NvbXBsZXRpb24pXG4gLSBbcmVjdGFuZ3VsYXIgc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcucmVjdGFuZ3VsYXJTZWxlY3Rpb24pIGFuZCBbY3Jvc3NoYWlyIGN1cnNvcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmNyb3NzaGFpckN1cnNvcilcbiAtIFthY3RpdmUgbGluZSBoaWdobGlnaHRpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5oaWdobGlnaHRBY3RpdmVMaW5lKVxuIC0gW2FjdGl2ZSBsaW5lIGd1dHRlciBoaWdobGlnaHRpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5oaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyKVxuIC0gW3NlbGVjdGlvbiBtYXRjaCBoaWdobGlnaHRpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMpXG4gLSBbc2VhcmNoXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWFyY2hLZXltYXApXG4gLSBbbGludGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50LmxpbnRLZXltYXApXG5cbihZb3UnbGwgcHJvYmFibHkgd2FudCB0byBhZGQgc29tZSBsYW5ndWFnZSBwYWNrYWdlIHRvIHlvdXIgc2V0dXBcbnRvby4pXG5cblRoaXMgZXh0ZW5zaW9uIGRvZXMgbm90IGFsbG93IGN1c3RvbWl6YXRpb24uIFRoZSBpZGVhIGlzIHRoYXQsXG5vbmNlIHlvdSBkZWNpZGUgeW91IHdhbnQgdG8gY29uZmlndXJlIHlvdXIgZWRpdG9yIG1vcmUgcHJlY2lzZWx5LFxueW91IHRha2UgdGhpcyBwYWNrYWdlJ3Mgc291cmNlICh3aGljaCBpcyBqdXN0IGEgYnVuY2ggb2YgaW1wb3J0c1xuYW5kIGFuIGFycmF5IGxpdGVyYWwpLCBjb3B5IGl0IGludG8geW91ciBvd24gY29kZSwgYW5kIGFkanVzdCBpdFxuYXMgZGVzaXJlZC5cbiovXG5jb25zdCBiYXNpY1NldHVwID0gLypAX19QVVJFX18qLygoKSA9PiBbXG4gICAgbGluZU51bWJlcnMoKSxcbiAgICBoaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyKCksXG4gICAgaGlnaGxpZ2h0U3BlY2lhbENoYXJzKCksXG4gICAgaGlzdG9yeSgpLFxuICAgIGZvbGRHdXR0ZXIoKSxcbiAgICBkcmF3U2VsZWN0aW9uKCksXG4gICAgZHJvcEN1cnNvcigpLFxuICAgIEVkaXRvclN0YXRlLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zLm9mKHRydWUpLFxuICAgIGluZGVudE9uSW5wdXQoKSxcbiAgICBzeW50YXhIaWdobGlnaHRpbmcoZGVmYXVsdEhpZ2hsaWdodFN0eWxlLCB7IGZhbGxiYWNrOiB0cnVlIH0pLFxuICAgIGJyYWNrZXRNYXRjaGluZygpLFxuICAgIGNsb3NlQnJhY2tldHMoKSxcbiAgICBhdXRvY29tcGxldGlvbigpLFxuICAgIHJlY3Rhbmd1bGFyU2VsZWN0aW9uKCksXG4gICAgY3Jvc3NoYWlyQ3Vyc29yKCksXG4gICAgaGlnaGxpZ2h0QWN0aXZlTGluZSgpLFxuICAgIGhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMoKSxcbiAgICBrZXltYXAub2YoW1xuICAgICAgICAuLi5jbG9zZUJyYWNrZXRzS2V5bWFwLFxuICAgICAgICAuLi5kZWZhdWx0S2V5bWFwLFxuICAgICAgICAuLi5zZWFyY2hLZXltYXAsXG4gICAgICAgIC4uLmhpc3RvcnlLZXltYXAsXG4gICAgICAgIC4uLmZvbGRLZXltYXAsXG4gICAgICAgIC4uLmNvbXBsZXRpb25LZXltYXAsXG4gICAgICAgIC4uLmxpbnRLZXltYXBcbiAgICBdKVxuXSkoKTtcbi8qKlxuQSBtaW5pbWFsIHNldCBvZiBleHRlbnNpb25zIHRvIGNyZWF0ZSBhIGZ1bmN0aW9uYWwgZWRpdG9yLiBPbmx5XG5pbmNsdWRlcyBbdGhlIGRlZmF1bHQga2V5bWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlZmF1bHRLZXltYXApLCBbdW5kb1xuaGlzdG9yeV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5oaXN0b3J5KSwgW3NwZWNpYWwgY2hhcmFjdGVyXG5oaWdobGlnaHRpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5oaWdobGlnaHRTcGVjaWFsQ2hhcnMpLCBbY3VzdG9tIHNlbGVjdGlvblxuZHJhd2luZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmRyYXdTZWxlY3Rpb24pLCBhbmQgW2RlZmF1bHQgaGlnaGxpZ2h0XG5zdHlsZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5kZWZhdWx0SGlnaGxpZ2h0U3R5bGUpLlxuKi9cbmNvbnN0IG1pbmltYWxTZXR1cCA9IC8qQF9fUFVSRV9fKi8oKCkgPT4gW1xuICAgIGhpZ2hsaWdodFNwZWNpYWxDaGFycygpLFxuICAgIGhpc3RvcnkoKSxcbiAgICBkcmF3U2VsZWN0aW9uKCksXG4gICAgc3ludGF4SGlnaGxpZ2h0aW5nKGRlZmF1bHRIaWdobGlnaHRTdHlsZSwgeyBmYWxsYmFjazogdHJ1ZSB9KSxcbiAgICBrZXltYXAub2YoW1xuICAgICAgICAuLi5kZWZhdWx0S2V5bWFwLFxuICAgICAgICAuLi5oaXN0b3J5S2V5bWFwLFxuICAgIF0pXG5dKSgpO1xuXG5leHBvcnQgeyBiYXNpY1NldHVwLCBtaW5pbWFsU2V0dXAgfTtcbiIsICJmdW5jdGlvbiBsb2coLi4uYXJnczogYW55W10pIHtcbiAgICBjb25zb2xlLmxvZyguLi5hcmdzKTtcbn1cblxuZXhwb3J0IHsgbG9nIH07IiwgIi8qKlxuICogQSBjdXN0b20gc2Nyb2xsYmFyIGltcGxlbWVudGF0aW9uXG4gKi9cblxuZXhwb3J0IGNsYXNzIFNjcm9sbEhhbmRsZXIge1xuICAgIHByaXZhdGUgZWxlPzogSFRNTEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBoYW5kbGU6IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgc2Nyb2xsX2hvc3Q6IEhUTUxFbGVtZW50O1xuICAgIHByaXZhdGUgc2Nyb2xsOiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIHNjcm9sbF9lbmQ6IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgc2Nyb2xsX2JlZzogSFRNTERpdkVsZW1lbnQ7XG4gICAgcHJpdmF0ZSByZXNpemVfb2JzOiBSZXNpemVPYnNlcnZlcjtcbiAgICBwcml2YXRlIG11dGF0ZV9vYnM6IE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgcHJpdmF0ZSBjdXJyX2hlaWdodDogbnVtYmVyO1xuICAgIHByaXZhdGUgdGFyZ2V0X2hlaWdodDogbnVtYmVyO1xuICAgIHByaXZhdGUgdGFyZ2V0X3BvczogbnVtYmVyO1xuICAgIHByaXZhdGUgY3Vycl9wb3M6IG51bWJlcjtcbiAgICBwcml2YXRlIHNiX2Rpc3RhbmNlOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBzY3JvbGxfYm94X3JhdGlvOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBncmFiX2RpZmY6IG51bWJlcjtcbiAgICBwcml2YXRlIHNjcm9sbF9hbW91bnQ6IG51bWJlcjtcbiAgICBwcml2YXRlIEhBTkRMRV9NT1ZFOiBib29sZWFuO1xuXG4gICAgcHJpdmF0ZSBib3VuZF9oYW5kbGVfd2hlZWw6IChldm50OiBhbnkpID0+IHZvaWQ7XG4gICAgcHJpdmF0ZSBib3VuZF9oYW5kbGVfc2Nyb2xsOiAoZXZudDogYW55KSA9PiB2b2lkO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihlbGU6IEhUTUxFbGVtZW50LCBzY3JvbGxfaG9zdDogSFRNTEVsZW1lbnQgPSBlbGUpIHtcblxuICAgICAgICB0aGlzLnNjcm9sbF9ob3N0ID0gc2Nyb2xsX2hvc3Q7XG5cbiAgICAgICAgdGhpcy5zY3JvbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnNjcm9sbC5jbGFzc0xpc3QuYWRkKFwic2Nyb2xsXCIpO1xuXG5cbiAgICAgICAgdGhpcy5oYW5kbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmhhbmRsZS5jbGFzc0xpc3QuYWRkKFwic2Nyb2xsLWhhbmRsZVwiKTtcblxuICAgICAgICB0aGlzLmhhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy5oYW5kbGVfZG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5oYW5kbGUuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuaGFuZGxlX21vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy5oYW5kbGVfdXAuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5zY3JvbGxfYmVnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zY3JvbGxfYmVnLmNsYXNzTGlzdC5hZGQoXCJzY3JvbGwtYmVnXCIpO1xuXG4gICAgICAgIHRoaXMuc2Nyb2xsX2VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc2Nyb2xsX2VuZC5jbGFzc0xpc3QuYWRkKFwic2Nyb2xsLWVuZFwiKTtcblxuICAgICAgICB0aGlzLnNjcm9sbC5hcHBlbmRDaGlsZCh0aGlzLmhhbmRsZSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsX2JlZyk7XG4gICAgICAgIHRoaXMuc2Nyb2xsLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsX2VuZCk7XG5cbiAgICAgICAgdGhpcy5zY3JvbGxfaG9zdC5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbCk7XG5cbiAgICAgICAgdGhpcy5yZXNpemVfb2JzID0gbmV3IFJlc2l6ZU9ic2VydmVyKHRoaXMuaGFuZGxlX3Jlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tdXRhdGVfb2JzID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5oYW5kbGVfcmVzaXplLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMucmVzaXplX29icy5vYnNlcnZlKHNjcm9sbF9ob3N0KTtcblxuICAgICAgICB0aGlzLmJvdW5kX2hhbmRsZV93aGVlbCA9IHRoaXMuaGFuZGxlX3doZWVsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYm91bmRfaGFuZGxlX3Njcm9sbCA9IHRoaXMuaGFuZGxlX3Njcm9sbC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2Nyb2xsX2Ftb3VudCA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsX2JveF9yYXRpbyA9IDE7XG4gICAgICAgIHRoaXMuc2JfZGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLnRhcmdldF9oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLmN1cnJfaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5jdXJyX3BvcyA9IDA7XG4gICAgICAgIHRoaXMudGFyZ2V0X3BvcyA9IDA7XG4gICAgICAgIHRoaXMuSEFORExFX01PVkUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ncmFiX2RpZmYgPSAwO1xuXG5cbiAgICAgICAgdGhpcy5zZXRfdGFyZ2V0KGVsZSk7XG4gICAgfVxuXG4gICAgc2V0X3RhcmdldCh0YXJnZXQ6IEhUTUxFbGVtZW50KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuZWxlKSB7XG4gICAgICAgICAgICB0aGlzLmVsZS5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5ib3VuZF9oYW5kbGVfd2hlZWwpO1xuICAgICAgICAgICAgdGhpcy5lbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLmJvdW5kX2hhbmRsZV9zY3JvbGwpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVfb2JzLnVub2JzZXJ2ZSh0aGlzLmVsZSk7XG4gICAgICAgICAgICB0aGlzLm11dGF0ZV9vYnMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNpemVfb2JzLm9ic2VydmUodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5tdXRhdGVfb2JzLm9ic2VydmUodGFyZ2V0LCB7XG4gICAgICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKGNvbnN0IGVsZSBvZiBBcnJheS5mcm9tKHRhcmdldC5jaGlsZHJlbikpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZV9vYnMub2JzZXJ2ZShlbGUpO1xuXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5ib3VuZF9oYW5kbGVfd2hlZWwpO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLmJvdW5kX2hhbmRsZV9zY3JvbGwpO1xuXG4gICAgICAgIHRoaXMuZWxlID0gdGFyZ2V0O1xuXG4gICAgICAgIHRoaXMuaGFuZGxlX3Jlc2l6ZSgpO1xuICAgIH1cblxuICAgIGhhbmRsZV9yZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZSkge1xuXG4gICAgICAgICAgICBjb25zdCBjbGllbnRIZWlnaHQgPSB0aGlzLmVsZS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbF9hbW91bnQgPSB0aGlzLmVsZS5zY3JvbGxIZWlnaHQgLSBjbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbF9ib3hfcmF0aW8gPSBjbGllbnRIZWlnaHQgLyB0aGlzLmVsZS5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnRhcmdldF9oZWlnaHQgPSAodGhpcy5zY3JvbGxfYm94X3JhdGlvICogdGhpcy5zY3JvbGwuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0X3BvcyA9ICgodGhpcy5lbGUuc2Nyb2xsVG9wIC8gdGhpcy5zY3JvbGxfYW1vdW50KSAqICh0aGlzLnNjcm9sbC5jbGllbnRIZWlnaHQgLSB0aGlzLnRhcmdldF9oZWlnaHQpKTtcbiAgICAgICAgICAgIHRoaXMuc2JfZGlzdGFuY2UgPSAodGhpcy5zY3JvbGwuY2xpZW50SGVpZ2h0IC0gdGhpcy50YXJnZXRfaGVpZ2h0KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2JfZGlzdGFuY2UgPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGwuY2xhc3NMaXN0LmFkZChcIm5vLXNjcm9sbFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGwuY2xhc3NMaXN0LnJlbW92ZShcIm5vLXNjcm9sbFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5oYW5kbGVfcG9zX2FkanVzdCgpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVfaGVpZ2h0X2FkanVzdCgpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVfc2Nyb2xsZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZV9oZWlnaHRfYWRqdXN0KCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyX2hlaWdodCAhPSB0aGlzLnRhcmdldF9oZWlnaHQgJiYgdGhpcy5lbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSAodGhpcy50YXJnZXRfaGVpZ2h0IC0gdGhpcy5jdXJyX2hlaWdodCkgKiAwLjU7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaWZmKSA+IDAuMDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJfaGVpZ2h0ICs9IGRpZmY7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuaGFuZGxlX2hlaWdodF9hZGp1c3QuYmluZCh0aGlzKSwgMTApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJfaGVpZ2h0ID0gdGhpcy50YXJnZXRfaGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyX2hlaWdodCArIHRoaXMudGFyZ2V0X3BvcyA+IHRoaXMuZWxlLnNjcm9sbEhlaWdodClcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJfaGVpZ2h0IC09ICgodGhpcy5jdXJyX2hlaWdodCArIHRoaXMudGFyZ2V0X3BvcykgLSB0aGlzLmVsZS5zY3JvbGxIZWlnaHQpO1xuXG4gICAgICAgICAgICB0aGlzLmhhbmRsZS5zdHlsZS5oZWlnaHQgPSB0aGlzLmN1cnJfaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlX3Bvc19hZGp1c3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJfcG9zICE9IHRoaXMudGFyZ2V0X3Bvcykge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9ICh0aGlzLnRhcmdldF9wb3MgLSB0aGlzLmN1cnJfcG9zKSAqIDAuNTtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYpID4gMTAwMDAwMDAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJfcG9zICs9IGRpZmY7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuaGFuZGxlX3Bvc19hZGp1c3QuYmluZCh0aGlzKSwgMTApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJfcG9zID0gdGhpcy50YXJnZXRfcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYW5kbGUuc3R5bGUudG9wID0gdGhpcy5jdXJyX3BvcyArIFwicHhcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldF9oYW5kbGVfcG9zX2RpZmYoZGlmZjogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuc2V0X2hhbmRsZV9wb3ModGhpcy50YXJnZXRfcG9zICsgZGlmZik7XG4gICAgfVxuICAgIHNldF9oYW5kbGVfcG9zKHBvczogbnVtYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRfcG9zID0gTWF0aC5tYXgoTWF0aC5taW4ocG9zLCB0aGlzLnNiX2Rpc3RhbmNlKSwgMCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZV9wb3NfYWRqdXN0KCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZV9zY3JvbGxlZCgpO1xuICAgICAgICAgICAgY29uc3QgcmF0aW8gPSB0aGlzLnRhcmdldF9wb3MgLyB0aGlzLnNiX2Rpc3RhbmNlO1xuICAgICAgICAgICAgdGhpcy5lbGUuc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxfYW1vdW50ICogcmF0aW87XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVfc2Nyb2xsZWQoKSB7XG5cbiAgICB9XG5cbiAgICBoYW5kbGVfc2Nyb2xsKGU6IEV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLkhBTkRMRV9NT1ZFKSByZXR1cm47XG4gICAgICAgIHRoaXMuaGFuZGxlX3Jlc2l6ZSgpO1xuICAgIH1cblxuICAgIGhhbmRsZV9tb3ZlKGU6IFBvaW50ZXJFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5IQU5ETEVfTU9WRSkge1xuICAgICAgICAgICAgY29uc3QgeSA9IChlLmNsaWVudFkgLSBnZXRUb3AodGhpcy5zY3JvbGwpKSArIHRoaXMuZ3JhYl9kaWZmO1xuICAgICAgICAgICAgdGhpcy5zZXRfaGFuZGxlX3Bvcyh5KTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlX3VwKGU6IFBvaW50ZXJFdmVudCkge1xuICAgICAgICB0aGlzLmhhbmRsZS5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpO1xuICAgICAgICB0aGlzLkhBTkRMRV9NT1ZFID0gZmFsc2U7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBoYW5kbGVfZG93bihlOiBQb2ludGVyRXZlbnQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGUuc2V0UG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpO1xuICAgICAgICB0aGlzLmdyYWJfZGlmZiA9IC0oZS5jbGllbnRZIC0gZ2V0VG9wKHRoaXMuc2Nyb2xsKSkgKyB0aGlzLnRhcmdldF9wb3M7XG4gICAgICAgIHRoaXMuSEFORExFX01PVkUgPSB0cnVlO1xuICAgIH1cbiAgICBoYW5kbGVfd2hlZWwoZTogV2hlZWxFdmVudCkge1xuICAgICAgICB0aGlzLnNldF9oYW5kbGVfcG9zX2RpZmYoTWF0aC5zaWduKGUuZGVsdGFZKSAqIDUwICogdGhpcy5zY3JvbGxfYm94X3JhdGlvKTtcbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gZ2V0VG9wKGVsZTogSFRNTEVsZW1lbnQgfCBudWxsKSB7XG4gICAgbGV0IHRvcCA9IDA7XG5cbiAgICB3aGlsZSAoZWxlKSB7XG4gICAgICAgIHRvcCArPSBlbGUub2Zmc2V0VG9wO1xuICAgICAgICBlbGUgPSBlbGUucGFyZW50RWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9wO1xufVxuIiwgIlxuY29uc3QgTEFCX0dSQU1NQVJfS0VZID0gXCJsYWItZGF0YVwiO1xuY29uc3QgTEFCX0lOUFVUX0tFWSA9IFwibGFiLWlucHV0LWtleVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2dyYW1tYXIoKSB7XG4gICAgLy8gQ2hlY2sgZm9yIHVybCBlbmNvZGVkIGdyYW1tYXJcbiAgICBsZXQgc2Vzc2lvblRleHQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKExBQl9HUkFNTUFSX0tFWSk7XG4gICAgcmV0dXJuIHNlc3Npb25UZXh0IHx8IGA8PiBBID4gJ0InIEM/IFxcblxcbjw+IEMgPiBcIkRcImA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZ3JhbW1hcihncmFtbWFyOiBzdHJpbmcpIHtcbiAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKExBQl9HUkFNTUFSX0tFWSwgZ3JhbW1hcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfaW5wdXQoKSB7XG4gICAgLy8gQ2hlY2sgZm9yIHVybCBlbmNvZGVkIGdyYW1tYXJcbiAgICBsZXQgc2Vzc2lvblRleHQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKExBQl9JTlBVVF9LRVkpO1xuICAgIHJldHVybiBzZXNzaW9uVGV4dCB8fCBgQkRgO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0X2lucHV0KGlucHV0OiBzdHJpbmcpIHtcbiAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKExBQl9JTlBVVF9LRVksIGlucHV0KTtcbn0iLCAiLyoqXG4gKiBQcmltYXJ5IGludGVyZmFjZSBmb3IgdGhlIHNoZXJwYSBwYXJzZXIgc3lzdGVtLlxuICovXG5cbmltcG9ydCB7IGRlZmluZUxhbmd1YWdlRmFjZXQsIExhbmd1YWdlLCBMYW5ndWFnZVN1cHBvcnQgfSBmcm9tIFwiQGNvZGVtaXJyb3IvbGFuZ3VhZ2VcIjtcbmltcG9ydCB7IElucHV0LCBOb2RlU2V0LCBQYXJzZXIsIFBhcnRpYWxQYXJzZSwgVHJlZSwgVHJlZUZyYWdtZW50LCBOb2RlVHlwZSB9IGZyb20gXCJAbGV6ZXIvY29tbW9uXCI7XG5pbXBvcnQgKiBhcyBzaGVycGEgZnJvbSBcImpzL3NoZXJwYS9zaGVycGFfd2FzbS5qc1wiO1xuaW1wb3J0IHsgdGFncywgVGFnLCBzdHlsZVRhZ3MsIHRhZ0hpZ2hsaWdodGVyIH0gZnJvbSAnQGxlemVyL2hpZ2hsaWdodCc7XG5pbXBvcnQgeyBzeW50YXhIaWdobGlnaHRpbmcsIEhpZ2hsaWdodFN0eWxlLCBkZWZhdWx0SGlnaGxpZ2h0U3R5bGUgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyBsaW50ZXIsIERpYWdub3N0aWMgfSBmcm9tIFwiQGNvZGVtaXJyb3IvbGludFwiO1xuaW1wb3J0IHsgR3JhbW1hckNvbnRleHQgfSBmcm9tIFwiLi9ncmFtbWFyX2NvbnRleHRcIjtcbmltcG9ydCB7IHNldF9ncmFtbWFyIH0gZnJvbSBcIi4vc2Vzc2lvbl9zdG9yYWdlXCI7XG5cbmNsYXNzIFNoZXJwYVBhcnNlciBleHRlbmRzIFBhcnNlciB7XG5cbiAgICBuYW1lczogc3RyaW5nW107XG5cbiAgICB0eXBlczogeyBbbmFtZTogc3RyaW5nXTogbnVtYmVyOyB9ID0ge307XG5cbiAgICBub2RlU2V0OiBOb2RlU2V0O1xuXG4gICAgY3R4OiBHcmFtbWFyQ29udGV4dDtcblxuICAgIGNvbnN0cnVjdG9yKGN0eDogR3JhbW1hckNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcblxuICAgICAgICBsZXQgbmFtZXMgPSBzaGVycGEuZ2V0X3Byb2R1Y3Rpb25fbmFtZXMoKTtcbiAgICAgICAgbmFtZXMucHVzaChcInRva2VuXCIpO1xuICAgICAgICB0aGlzLm5vZGVTZXQgPSBuZXcgTm9kZVNldChuYW1lcy5tYXAoKG5hbWU6IHN0cmluZywgaWQ6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVUeXBlLmRlZmluZSh7IGlkLCB0b3A6IG5hbWUgPT0gXCJzaGVycGE6OmdyYW1tYXJcIiwgbmFtZTogbmFtZS5yZXBsYWNlKFwiOjpcIiwgXCItXCIpIH0pO1xuICAgICAgICB9KSkuZXh0ZW5kKHN0eWxlVGFncyh7XG4gICAgICAgICAgICBcInNoZXJwYV9zeW1ib2wtcHJvZHVjdGlvbl9zeW1ib2whXCI6IHRhZ3MuZGVmaW5pdGlvbktleXdvcmQsXG4gICAgICAgICAgICBcInNoZXJwYV9zeW1ib2wtdGVybWluYWwhXCI6IHRhZ3Muc3RyaW5nLFxuICAgICAgICAgICAgXCJzaGVycGEtcHJvZHVjdGlvbi8uLi5cIjogdGFncy5kZWZpbml0aW9uT3BlcmF0b3IsXG4gICAgICAgICAgICBcInNoZXJwYV9zeW1ib2wtY2xhc3MhXCI6IHRhZ3MuY2xhc3NOYW1lLFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgdGhpcy5uYW1lcyA9IHNoZXJwYS5nZXRfcHJvZHVjdGlvbl9uYW1lcygpO1xuICAgIH1cblxuXG4gICAgY3JlYXRlUGFyc2UoaW5wdXQ6IElucHV0IHwgYW55IHwgc3RyaW5nLCBmcmFnbWVudHM6IFRyZWVGcmFnbWVudFtdLCByYW5nZXM6IHsgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyOyB9W10pOiBQYXJ0aWFsUGFyc2Uge1xuXG4gICAgICAgIGxldCBpbnB1dF9zdHJpbmcgPSBpbnB1dC5yZWFkKHJhbmdlc1swXS5mcm9tLCByYW5nZXNbMF0udG8pO1xuXG4gICAgICAgIGxldCBwYXJzZXIgPSBzaGVycGEuSlNHcmFtbWFyUGFyc2VyLm5ldyhpbnB1dF9zdHJpbmcpO1xuICAgICAgICBsZXQgc3RhY2sgPSBzaGVycGEuZ2V0X2NvZGVtaXJyb3JfcGFyc2VfdHJlZShpbnB1dF9zdHJpbmcpO1xuXG4gICAgICAgIHRoaXMuY3R4LmFkZEdyYW1tYXIoaW5wdXRfc3RyaW5nLCBcIi9cIik7XG5cbiAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoIC0gNF0gPSA0O1xuXG4gICAgICAgIGxldCBub2RlU2V0ID0gdGhpcy5ub2RlU2V0O1xuICAgICAgICBsZXQgbGVuID0gaW5wdXRfc3RyaW5nLmxlbmd0aDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWR2YW5jZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJlZS5idWlsZCh7XG4gICAgICAgICAgICAgICAgICAgIHRvcElEOiAwLFxuICAgICAgICAgICAgICAgICAgICBidWZmZXI6IHN0YWNrLFxuICAgICAgICAgICAgICAgICAgICBub2RlU2V0XG5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdG9wQXQocG9zOiBudW1iZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImVuZFwiLCBwb3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcnNlZFBvczogbGVuLFxuICAgICAgICAgICAgc3RvcHBlZEF0OiBsZW5cblxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8vIFJlc3BvbnNpYmxlIGZvciBidWlsZGluZyB0aGUgUGFyc2VyREIgZm9yIGEgZ2l2ZW4gZ3JhbW1hciBvciBwcm9kdWNpbmcgc2VtYW50aWMgZXJyb3JzLiBcbi8vLyBVc2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIFNoZXJwYVBhcnNlciB0byBwcm9kdWNlIGEgdmlhYmxlIFBhcnNlckJhc2UuXG5mdW5jdGlvbiBTaGVycGFMaW50ZXIoY3R4OiBHcmFtbWFyQ29udGV4dCkge1xuICAgIHJldHVybiBsaW50ZXIoKHZpZXcpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJMaW50aW5nIVwiKVxuXG4gICAgICAgIHNldF9ncmFtbWFyKHZpZXcuc3RhdGUuZG9jLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgIGxldCBtZXNzYWdlczogRGlhZ25vc3RpY1tdID0gW107XG5cbiAgICAgICAgbGV0IHBhcnNlcl9lcnJvcnMgPSBjdHgucGFyc2VfZXJyb3JzO1xuXG4gICAgICAgIGlmIChwYXJzZXJfZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnZlcnRQb3NFcnJvcnNUb0RpYWdub3N0aWNzKHBhcnNlcl9lcnJvcnMsIFwicGFyc2VyXCIsIG1lc3NhZ2VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY3R4LmNyZWF0ZURCKFwiL1wiKSkge1xuICAgICAgICAgICAgY29udmVydFBvc0Vycm9yc1RvRGlhZ25vc3RpY3MoY3R4LmRiX2Vycm9ycywgXCJzZW1hbnRpYy1ldmFsdWF0b3JcIiwgbWVzc2FnZXMpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBsZXQgZGIgPSBjdHguZGI7XG5cbiAgICAgICAgICAgIGlmICghZGIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuXG4gICAgICAgICAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIGEgZGIgd2UgY2FuIGtpY2sgb2ZmIGpvYnMgdG8gZnVydGhlciBwcm9jZXNzXG4gICAgICAgICAgICAvLyB0aGUgZGF0YSBvbiB0byBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiREIgQ3JlYXRlZFwiKVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBzb3VwLlxuICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFzdC1vdXRwdXRcIik7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5uZXJUZXh0ID0gc2hlcnBhLmNyZWF0ZV9ydXN0X2FzdF9vdXRwdXQoZGIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIHNoZXJwYS5Qb3NpdGlvbmVkRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQb3NFcnJvcnNUb0RpYWdub3N0aWNzKGUsIFwiYXN0LWNvbXBpbGVyXCIsIG1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgZS5mcmVlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgfSwge1xuICAgICAgICBkZWxheTogMTMwLFxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRQb3NFcnJvcnNUb0RpYWdub3N0aWNzKGU6IHNoZXJwYS5Qb3NpdGlvbmVkRXJyb3JzIHwgc2hlcnBhLkpTU2hlcnBhU291cmNlRXJyb3JbXSwgc291cmNlOiBzdHJpbmcsIG1lc3NhZ2VzOiBEaWFnbm9zdGljW10gPSBbXSk6IERpYWdub3N0aWNbXSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBlcnJvciA9IChBcnJheS5pc0FycmF5KGUpKSA/IGVbaV0gOiBlLmdldF9lcnJvcl9hdChpKTs7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZnJvbTogZXJyb3Iuc3RhcnRfb2Zmc2V0LFxuICAgICAgICAgICAgICAgIHRvOiBlcnJvci5lbmRfb2Zmc2V0LFxuICAgICAgICAgICAgICAgIHNldmVyaXR5OiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoZXJwYUxhbmcoY3R4OiBHcmFtbWFyQ29udGV4dCkge1xuICAgIGxldCBsYW5nX3N5cyA9IG5ldyBTaGVycGFQYXJzZXIoY3R4KTtcbiAgICByZXR1cm4gbmV3IExhbmd1YWdlU3VwcG9ydChcbiAgICAgICAgbmV3IExhbmd1YWdlKGRlZmluZUxhbmd1YWdlRmFjZXQoeyBjb21tZW50VG9rZW5zOiB7IGJsb2NrOiB7IG9wZW46IFwiLypcIiwgY2xvc2U6IFwiKi9cIiB9IH0gfSksXG4gICAgICAgICAgICBsYW5nX3N5cywgW1xuICAgICAgICAgICAgU2hlcnBhTGludGVyKGN0eCksXG4gICAgICAgICAgICBzeW50YXhIaWdobGlnaHRpbmcoXG4gICAgICAgICAgICAgICAgSGlnaGxpZ2h0U3R5bGUuZGVmaW5lKFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiB0YWdzLmRlZmluaXRpb25PcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBcInN5bi1wcm9kXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiB0YWdzLmRlZmluaXRpb25LZXl3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwic3luLXByb2QtaWRcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHRhZ3Muc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwic3luLXRlcm1cIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHRhZ3MuY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwic3luLWNsYXNzXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0pKVxuICAgICAgICBdLFxuICAgICAgICAgICAgXCJzaGVycGFcIiksIFtcbiAgICBdKTtcbn1cblxuIiwgImltcG9ydCAqIGFzIHNoZXJwYSBmcm9tIFwianMvc2hlcnBhL3NoZXJwYV93YXNtLmpzXCI7XG5cbmV4cG9ydCBjb25zdCBlbnVtIEV2ZW50VHlwZSB7XG4gICAgREJEZWxldGVkID0gXCJkYi1kZWxldGVkXCIsXG4gICAgREJDcmVhdGVkID0gXCJkYi1jcmVhdGVkXCIsXG4gICAgR3JhbW1hckFkZGVkID0gXCJncmFtbWFyLWFkZGVkXCIsXG59XG5cbi8vLyBNYWludGFpbnMgYSBnZW5lcmFsIGNvbnRleHQgdGhhdCB0cmFja3MgdGhlIHN0YXRlIG9mIHRoZSBncmFtbWFyXG4vLy8gYW5kIGl0cyBkZXJpdmF0aXZlc1xuZXhwb3J0IGNsYXNzIEdyYW1tYXJDb250ZXh0IHtcblxuICAgIHByaXZhdGUgc291cF86IHNoZXJwYS5KU1NvdXA7XG5cbiAgICBwcml2YXRlIGRiXzogc2hlcnBhLkpTUGFyc2VyREIgfCBudWxsO1xuXG4gICAgcHVibGljIGxpc3RlbmVyczogTWFwPEV2ZW50VHlwZSwgU2V0PHsgKGN0eDogR3JhbW1hckNvbnRleHQpOiB2b2lkIH0+PjtcblxuICAgIHByaXZhdGUgcGVuZGluZ19ldmVudHM6IEV2ZW50VHlwZVtdO1xuXG4gICAgcHJpdmF0ZSBSVU5OSU5HX0VWRU5UUzogYm9vbGVhbjtcblxuICAgIHByaXZhdGUgY3VycmVudF9wYXJzZV9lcnJvcnM6IHNoZXJwYS5KU1NoZXJwYVNvdXJjZUVycm9yW107XG4gICAgcHJpdmF0ZSBjdXJyZW50X2RiX2Vycm9yczogc2hlcnBhLkpTU2hlcnBhU291cmNlRXJyb3JbXTtcblxuICAgIC8vLyBTaG91bGQgb25seSBiZSBjYWxsZWQgYWZ0ZXIgc2hlcnBhIGlzIGluaXRpYWxpemVkXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc291cF8gPSBzaGVycGEuY3JlYXRlX3NvdXAoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ19ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5SVU5OSU5HX0VWRU5UUyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRiXyA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudF9wYXJzZV9lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50X2RiX2Vycm9ycyA9IFtdO1xuICAgIH1cblxuICAgIGdldCBzb3VwKCk6IHNoZXJwYS5KU1NvdXAge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VwXztcbiAgICB9XG5cbiAgICBnZXQgZGIoKTogc2hlcnBhLkpTUGFyc2VyREIgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGJfO1xuICAgIH1cblxuICAgIGdldCBwYXJzZV9lcnJvcnMoKTogc2hlcnBhLkpTU2hlcnBhU291cmNlRXJyb3JbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRfcGFyc2VfZXJyb3JzO1xuICAgIH1cblxuICAgIGdldCBkYl9lcnJvcnMoKTogc2hlcnBhLkpTU2hlcnBhU291cmNlRXJyb3JbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRfZGJfZXJyb3JzO1xuICAgIH1cblxuICAgIHB1YmxpYyBhZGRHcmFtbWFyKGlucHV0X3N0cmluZzogc3RyaW5nLCBncmFtbWFyX25hbWU6IHN0cmluZykge1xuXG4gICAgICAgIHRoaXMuY3VycmVudF9wYXJzZV9lcnJvcnMubWFwKGUgPT4gZS5mcmVlKCkpO1xuICAgICAgICB0aGlzLmN1cnJlbnRfcGFyc2VfZXJyb3JzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc291cC5hZGRfZ3JhbW1hcihpbnB1dF9zdHJpbmcsIGdyYW1tYXJfbmFtZSk7XG4gICAgICAgICAgICB0aGlzLnNpZ25hbChFdmVudFR5cGUuR3JhbW1hckFkZGVkKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBzaGVycGEuUG9zaXRpb25lZEVycm9ycykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3IgPSBlLmdldF9lcnJvcl9hdChpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50X3BhcnNlX2Vycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZS5mcmVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlREIoZ3JhbW1hcl9uYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMuZGJfKSB7XG4gICAgICAgICAgICB0aGlzLmRiXy5mcmVlKCk7XG4gICAgICAgICAgICB0aGlzLmRiXyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNpZ25hbChFdmVudFR5cGUuREJEZWxldGVkLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJlbnRfZGJfZXJyb3JzLm1hcChlID0+IGUuZnJlZSgpKTtcbiAgICAgICAgdGhpcy5jdXJyZW50X2RiX2Vycm9ycy5sZW5ndGggPSAwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmRiXyA9IHNoZXJwYS5jcmVhdGVfcGFyc2VfZGIoZ3JhbW1hcl9uYW1lLCB0aGlzLnNvdXBfKTtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsKEV2ZW50VHlwZS5EQkNyZWF0ZWQsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIHNoZXJwYS5Qb3NpdGlvbmVkRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvciA9IGUuZ2V0X2Vycm9yX2F0KGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRfZGJfZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLmZyZWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgYWRkTGlzdGVuZXIoZXZlbnQ6IEV2ZW50VHlwZSwgZm46IHsgKGN0eDogR3JhbW1hckNvbnRleHQpOiB2b2lkIH0pIHtcblxuICAgICAgICBpZiAoIXRoaXMubGlzdGVuZXJzLmhhcyhldmVudCkpXG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5zZXQoZXZlbnQsIG5ldyBTZXQpO1xuXG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmdldChldmVudCk/LmFkZChmbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzaWduYWwoZXZlbnQ/OiBFdmVudFR5cGUsIHByb2Nlc3NfcmVzdDogYm9vbGVhbiA9IHRydWUpIHtcbiAgICAgICAgaWYgKGV2ZW50KVxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nX2V2ZW50cy5wdXNoKGV2ZW50KTtcblxuICAgICAgICBpZiAodGhpcy5SVU5OSU5HX0VWRU5UUylcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0aGlzLlJVTk5JTkdfRVZFTlRTID0gdHJ1ZVxuXG4gICAgICAgIGxldCBlO1xuXG4gICAgICAgIHdoaWxlICgoZSA9IHRoaXMucGVuZGluZ19ldmVudHMuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycy5nZXQoZSkgPz8gW107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcHJvY2Vzc19yZXN0KSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuUlVOTklOR19FVkVOVFMgPSBmYWxzZTtcbiAgICB9XG59IiwgIi8qKlxuICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgcGFyc2luZyBpbnB1dHMgdXNpbmcgY29tcGlsZWQgcGFyc2VycyBcbiAqL1xuaW1wb3J0ICogYXMgc2hlcnBhIGZyb20gXCJqcy9zaGVycGEvc2hlcnBhX3dhc20uanNcIjtcbmltcG9ydCB7IEV2ZW50VHlwZSwgR3JhbW1hckNvbnRleHQgfSBmcm9tIFwiLi9ncmFtbWFyX2NvbnRleHRcIjtcbmltcG9ydCB7IFZpZXdQbHVnaW4sIERlY29yYXRpb25TZXQsIFZpZXdVcGRhdGUgfSBmcm9tIFwiQGNvZGVtaXJyb3Ivdmlld1wiXG5pbXBvcnQgeyBTdGF0ZUZpZWxkLCBTdGF0ZUVmZmVjdCwgUmFuZ2UgfSBmcm9tIFwiQGNvZGVtaXJyb3Ivc3RhdGVcIlxuaW1wb3J0IHsgRWRpdG9yVmlldywgRGVjb3JhdGlvbiB9IGZyb20gXCJAY29kZW1pcnJvci92aWV3XCJcbmltcG9ydCB7IHNldF9pbnB1dCB9IGZyb20gXCIuL3Nlc3Npb25fc3RvcmFnZVwiO1xuXG5cbmNvbnN0IGhlYWRfZGVjID0gRGVjb3JhdGlvbi5tYXJrKHsgYXR0cmlidXRlczogeyBzdHlsZTogXCJiYWNrZ3JvdW5kLWNvbG9yOiByZWRcIiB9IH0pO1xuY29uc3Qgc2Nhbl9kZWMgPSBEZWNvcmF0aW9uLm1hcmsoeyBhdHRyaWJ1dGVzOiB7IHN0eWxlOiBcImJhY2tncm91bmQtY29sb3I6IGJsdWVcIiB9IH0pO1xuY29uc3QgZW5kX2RlYyA9IERlY29yYXRpb24ubWFyayh7IGF0dHJpYnV0ZXM6IHsgc3R5bGU6IFwiYmFja2dyb3VuZC1jb2xvcjogZ3JlZW5cIiB9IH0pO1xuXG5jb25zdCBoaWdobGlnaHRfZWZmZWN0ID0gU3RhdGVFZmZlY3QuZGVmaW5lPFJhbmdlPERlY29yYXRpb24+W10+KCk7XG5jb25zdCBmaWx0ZXJfZWZmZWN0cyA9IFN0YXRlRWZmZWN0LmRlZmluZTwoKGZyb206IG51bWJlciwgdG86IG51bWJlcikgPT4gYm9vbGVhbik+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZXJIb3N0KGN0eDogR3JhbW1hckNvbnRleHQsIHtcbiAgICBkZWJ1Z2dlcl9zdGFydF9zdG9wX2J1dHRvbixcbiAgICBkZWJ1Z2dlcl9zdGVwX2J1dHRvbixcbiAgICBkZWJ1Z2dlcl9pbnRvX2J1dHRvbixcbiAgICBkZWJ1Z2dlcl9vdXRfYnV0dG9uLFxuICAgIGRlYnVnZ2VyX291dHB1dCxcbiAgICBkZWJ1Z2dlcl9lbnRyeV9zZWxlY3Rpb24sXG4gICAgZGVidWdnZXJfb3B0aW1pemVfY2hlY2tib3hcbn06IHtcbiAgICBkZWJ1Z2dlcl9zdGFydF9zdG9wX2J1dHRvbjogSFRNTEJ1dHRvbkVsZW1lbnQsXG4gICAgZGVidWdnZXJfc3RlcF9idXR0b246IEhUTUxCdXR0b25FbGVtZW50LFxuICAgIGRlYnVnZ2VyX2ludG9fYnV0dG9uOiBIVE1MQnV0dG9uRWxlbWVudCxcbiAgICBkZWJ1Z2dlcl9vdXRfYnV0dG9uOiBIVE1MQnV0dG9uRWxlbWVudCxcbiAgICBkZWJ1Z2dlcl9vdXRwdXQ6IEhUTUxEaXZFbGVtZW50LFxuICAgIGRlYnVnZ2VyX2VudHJ5X3NlbGVjdGlvbjogSFRNTFNlbGVjdEVsZW1lbnQsXG4gICAgZGVidWdnZXJfb3B0aW1pemVfY2hlY2tib3g6IEhUTUxJbnB1dEVsZW1lbnQsXG59KSB7XG4gICAgbGV0IHZpZXc6IEVkaXRvclZpZXcgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgYnl0ZWNvZGU6IHNoZXJwYS5KU0J5dGVjb2RlIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IHN0YXRlczogc2hlcnBhLkpTUGFyc2VTdGF0ZXMgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgcGFyc2VyOiBzaGVycGEuSlNCeXRlQ29kZVBhcnNlciB8IG51bGwgPSBudWxsO1xuICAgIGxldCBQQVJTSU5HOiBib29sZWFuID0gZmFsc2U7XG4gICAgbGV0IGRlYnVnZ2VyX3N0ZXBzOiBhbnlbXSA9IFtdO1xuICAgIGxldCBkZWJ1Z2dlcl9vZmZzZXQ6IG51bWJlciA9IC0xO1xuICAgIGxldCBwbGF5X2ludGVydmFsID0gLTE7XG4gICAgbGV0IG9wdGltaXplID0gZmFsc2U7XG4gICAgbGV0IGFjdGl2ZV9zZWFyY2hfc3ltYm9sczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gICAgbGV0IGFjdGl2ZV9zdGF0ZV9zb3VyY2UgPSAnJztcbiAgICBsZXQgYWN0aXZlX3NjYW5uZXJfc3RhdGVfc291cmNlID0gJyc7XG4gICAgbGV0IHBhcnNlcl9vZmY6IFtudW1iZXIsIG51bWJlcl0gPSBbMCwgMF07XG4gICAgbGV0IHNjYW5uZXJfb2ZmOiBbbnVtYmVyLCBudW1iZXJdID0gWzAsIDBdO1xuXG4gICAgY3R4LmFkZExpc3RlbmVyKEV2ZW50VHlwZS5HcmFtbWFyQWRkZWQsIGN0eCA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiR3JhbW1hciBBZGRlZFwiKVxuICAgICAgICBzdGF0ZXMgPSBudWxsO1xuICAgIH0pXG5cbiAgICBjdHguYWRkTGlzdGVuZXIoRXZlbnRUeXBlLkRCRGVsZXRlZCwgY3R4ID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJEQkRlbGV0ZWRcIilcbiAgICAgICAgZGVzdHJveV9zdGF0ZXMoKTtcbiAgICB9KVxuXG4gICAgY3R4LmFkZExpc3RlbmVyKEV2ZW50VHlwZS5EQkNyZWF0ZWQsIGN0eCA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiREJDcmVhdGVkXCIpXG5cbiAgICAgICAgLy8gTm93IHdlIGNhbiBjcmVhdGUgYSBwYXJzZXIuIFxuICAgICAgICBsZXQgZGIgPSBjdHguZGI7XG5cbiAgICAgICAgaWYgKCFkYikgcmV0dXJuO1xuXG4gICAgICAgIGNvbmZpZ3VyZV9lbnRyeV9vcHRpb25zKGRiKTtcbiAgICB9KVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlX3BhcnNlcl9kYXRhKCkge1xuXG4gICAgICAgIGlmIChzdGF0ZXMpIHJldHVybjtcbiAgICAgICAgaWYgKCFjdHguZGIpIHJldHVybjtcblxuICAgICAgICBsZXQgZGIgPSBjdHguZGI7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0YXRlcyA9IHNoZXJwYS5jcmVhdGVfcGFyc2VyX3N0YXRlcyhkYiwgb3B0aW1pemUpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coc3RhdGVzKTtcbiAgICAgICAgICAgIGJ5dGVjb2RlID0gc2hlcnBhLmNyZWF0ZV9ieXRlY29kZShkYiwgc3RhdGVzKTtcbiAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBzb3VwLlxuICAgICAgICAgICAgbGV0IG91dHB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnl0ZWNvZGUtb3V0cHV0XCIpO1xuICAgICAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5pbm5lclRleHQgPSBzaGVycGEuY3JlYXRlX2J5dGVjb2RlX2Rpc2Fzc2VtYmx5KGJ5dGVjb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYikgcmV0dXJuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ3VyZV9lbnRyeV9vcHRpb25zKGRiOiBzaGVycGEuSlNQYXJzZXJEQikge1xuICAgICAgICBkZWJ1Z2dlcl9lbnRyeV9zZWxlY3Rpb24uaW5uZXJIVE1MID0gXCJcIjtcblxuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5X25hbWUgb2Ygc2hlcnBhLmdldF9lbnRyeV9uYW1lcyhkYikpIHtcbiAgICAgICAgICAgIGxldCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgb3B0aW9uLmlubmVyVGV4dCA9IGVudHJ5X25hbWU7XG4gICAgICAgICAgICBvcHRpb24udmFsdWUgPSBlbnRyeV9uYW1lO1xuICAgICAgICAgICAgZGVidWdnZXJfZW50cnlfc2VsZWN0aW9uLmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95X3BhcnNlcigpIHtcbiAgICAgICAgaWYgKHBhcnNlcikge1xuICAgICAgICAgICAgcGFyc2VyLmZyZWUoKTtcbiAgICAgICAgICAgIHBhcnNlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95X3N0YXRlcygpIHtcbiAgICAgICAgaWYgKHN0YXRlcykge1xuICAgICAgICAgICAgc3RhdGVzLmZyZWUoKTtcbiAgICAgICAgICAgIHN0YXRlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVfcGFyc2VyKCkge1xuICAgICAgICBpZiAoISh2aWV3ICYmIGJ5dGVjb2RlICYmIGN0eC5kYikpIHJldHVybjtcbiAgICAgICAgZGVzdHJveV9wYXJzZXIoKVxuICAgICAgICBwYXJzZXIgPSBzaGVycGEuSlNCeXRlQ29kZVBhcnNlci5uZXcodmlldy5zdGF0ZS5kb2MudG9TdHJpbmcoKSwgYnl0ZWNvZGUpO1xuICAgICAgICBwYXJzZXIuaW5pdChkZWJ1Z2dlcl9lbnRyeV9zZWxlY3Rpb24udmFsdWUsIGJ5dGVjb2RlLCBjdHguZGIpO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RvcF9wYXJzZXIoKSB7XG4gICAgICAgIGlmICghUEFSU0lORykgcmV0dXJuO1xuICAgICAgICBkZXN0cm95X3BhcnNlcigpO1xuICAgICAgICB0b2dnbGVfcGxheSh0cnVlKTtcbiAgICAgICAgUEFSU0lORyA9IGZhbHNlO1xuICAgICAgICBkZWJ1Z2dlcl9zdGFydF9zdG9wX2J1dHRvbi5pbm5lckhUTUwgPSBcInN0YXJ0XCI7XG4gICAgICAgIGRlYnVnZ2VyX3N0YXJ0X3N0b3BfYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJzdGFydGVkXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0X3BhcnNlcigpIHtcblxuICAgICAgICBpZiAoISh2aWV3ICYmIGN0eC5kYiAmJiAhUEFSU0lORykpIHJldHVybjtcblxuICAgICAgICBjcmVhdGVfcGFyc2VyX2RhdGEoKTtcblxuICAgICAgICBpZiAoIShzdGF0ZXMgJiYgYnl0ZWNvZGUpKSByZXR1cm47XG5cbiAgICAgICAgZGVidWdnZXJfc3RhcnRfc3RvcF9idXR0b24uaW5uZXJIVE1MID0gXCJzdG9wXCI7XG4gICAgICAgIGRlYnVnZ2VyX3N0YXJ0X3N0b3BfYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJzdGFydGVkXCIpO1xuXG4gICAgICAgIGNyZWF0ZV9wYXJzZXIoKTtcblxuICAgICAgICBpZiAoIXBhcnNlcikgcmV0dXJuO1xuXG4gICAgICAgIGRlYnVnZ2VyX29mZnNldCA9IC0xO1xuICAgICAgICBhY3RpdmVfc2VhcmNoX3N5bWJvbHMuY2xlYXIoKTtcbiAgICAgICAgZGVidWdnZXJfc3RlcHMubGVuZ3RoID0gMDtcbiAgICAgICAgZGVidWdnZXJfb3V0cHV0LmlubmVyVGV4dCA9IFwiXCI7XG4gICAgICAgIGFjdGl2ZV9zdGF0ZV9zb3VyY2UgPSBcIlwiO1xuICAgICAgICBhY3RpdmVfc2Nhbm5lcl9zdGF0ZV9zb3VyY2UgPSBcIlwiO1xuXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyB1c2VyRXZlbnQ6IFwiZGVidWdnZXIuc3RhcnRcIiB9KVxuICAgICAgICBQQVJTSU5HID0gdHJ1ZTtcblxuICAgICAgICBzdGVwX2ZvcndhcmQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGVwX2ZvcndhcmQoKSB7XG4gICAgICAgIGlmICh2aWV3ICYmIHBhcnNlciAmJiBzdGF0ZXMgJiYgYnl0ZWNvZGUgJiYgY3R4LmRiICYmIFBBUlNJTkcpIHtcblxuICAgICAgICAgICAgbGV0IGRiID0gY3R4LmRiO1xuICAgICAgICAgICAgZGVidWdnZXJfb2Zmc2V0ICs9IDE7XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Z2dlcl9vZmZzZXQgPj0gZGVidWdnZXJfc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgZGVidWdnZXJfc3RlcHMucHVzaCguLi5yZXN1bHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnZ2VyX29mZnNldCA+PSBkZWJ1Z2dlcl9zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlX3BsYXkodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWJ1Z2dlcl9vZmZzZXQgPSBNYXRoLm1pbihkZWJ1Z2dlcl9vZmZzZXQsIGRlYnVnZ2VyX3N0ZXBzLmxlbmd0aCAtIDEpO1xuXG4gICAgICAgICAgICBsZXQgc3RlcDtcbiAgICAgICAgICAgIG91dGVyOiB3aGlsZSAoKHN0ZXAgPSBkZWJ1Z2dlcl9zdGVwc1tkZWJ1Z2dlcl9vZmZzZXRdKSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RlcC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTaGlmdFRva2VuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVfc2VhcmNoX3N5bWJvbHMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRXhlY3V0ZUluc3RydWN0aW9uXCI6IHtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0ZXAuaXNfc2Nhbm5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZV9zY2FubmVyX3N0YXRlX3NvdXJjZSA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9rZW5fb2Zmc2V0ID0gc2hlcnBhLmdldF9kZWJ1Z190b2tfb2Zmc2V0cyhzdGVwLmluc3RydWN0aW9uLCBieXRlY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuX29mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJfb2ZmWzBdID0gdG9rZW5fb2Zmc2V0LnN0YXJ0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyX29mZlsxXSA9IHRva2VuX29mZnNldC5lbmQgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVidWdfc3ltYm9sczogbnVtYmVyW10gPSBzaGVycGEuZ2V0X2RlYnVnX3N5bWJvbF9pZHMoc3RlcC5pbnN0cnVjdGlvbiwgYnl0ZWNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWJ1Z19zeW1ib2xzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdfc3ltYm9scy5mb3JFYWNoKHMgPT4gYWN0aXZlX3NlYXJjaF9zeW1ib2xzLmFkZChzaGVycGEuZ2V0X3N5bWJvbF9uYW1lX2Zyb21faWQocywgZGIpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBzaGVycGEuZ2V0X2RlYnVnX3N0YXRlX25hbWUoc3RlcC5pbnN0cnVjdGlvbiwgYnl0ZWNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZV9zdGF0ZV9zb3VyY2UgPSBzaGVycGEuZ2V0X3N0YXRlX3NvdXJjZV9zdHJpbmcobmFtZSwgc3RhdGVzLCBkYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9rZW5fb2Zmc2V0ID0gc2hlcnBhLmdldF9kZWJ1Z190b2tfb2Zmc2V0cyhzdGVwLmluc3RydWN0aW9uLCBieXRlY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuX29mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FubmVyX29mZlswXSA9IHRva2VuX29mZnNldC5zdGFydCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5uZXJfb2ZmWzFdID0gdG9rZW5fb2Zmc2V0LmVuZCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBzaGVycGEuZ2V0X2RlYnVnX3N0YXRlX25hbWUoc3RlcC5pbnN0cnVjdGlvbiwgYnl0ZWNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZV9zY2FubmVyX3N0YXRlX3NvdXJjZSA9IHNoZXJwYS5nZXRfc3RhdGVfc291cmNlX3N0cmluZyhuYW1lLCBzdGF0ZXMsIGRiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyX291dHB1dC5pbm5lclRleHQgPSBKU09OLnN0cmluZ2lmeShzdGVwLCB1bmRlZmluZWQsIDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBcIlxcblxcblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBbLi4uYWN0aXZlX3NlYXJjaF9zeW1ib2xzXS5qb2luKFwiIHwgXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBcIlxcblxcblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBzaGVycGEuY3JlYXRlX2luc3RydWN0aW9uX2Rpc2Fzc2VtYmx5KHN0ZXAuaW5zdHJ1Y3Rpb24sIGJ5dGVjb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgXCJcXG5cXG5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgbWFya1NvdXJjZShhY3RpdmVfc3RhdGVfc291cmNlLCBwYXJzZXJfb2ZmKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgXCJcXG5cXG5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgbWFya1NvdXJjZShhY3RpdmVfc2Nhbm5lcl9zdGF0ZV9zb3VyY2UsIHNjYW5uZXJfb2ZmKVxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlZmZlY3RzOiBhbnlbXSA9IFtmaWx0ZXJfZWZmZWN0cy5vZigoZnJvbSwgdG8pID0+IGZhbHNlKV1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHsgaGVhZF9wdHIsIHNjYW5fcHRyIH0gPSBzdGVwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3RzLnB1c2goaGlnaGxpZ2h0X2VmZmVjdC5vZihbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZF9kZWMucmFuZ2UoaGVhZF9wdHIsIGhlYWRfcHRyICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nhbl9wdHIgPiBoZWFkX3B0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdHMucHVzaChoaWdobGlnaHRfZWZmZWN0Lm9mKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nhbl9kZWMucmFuZ2Uoc2Nhbl9wdHIsIHNjYW5fcHRyICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pXG4gICAgICAgICAgICAgICAgICAgIH0gYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVidWdnZXJfb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtYXJrU291cmNlKHNvdXJjZTogc3RyaW5nLCBvZmZzZXRzOiBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLnNsaWNlKDAsIG9mZnNldHNbMF0pICsgXCJ8XCIgKyBzb3VyY2Uuc2xpY2UoLi4ub2Zmc2V0cykgKyBcInxcIiArIHNvdXJjZS5zbGljZShvZmZzZXRzWzFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvZ2dsZV9wbGF5KGZvcmNlX3N0b3A6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgICAgICBpZiAocGxheV9pbnRlcnZhbCA+PSAwIHx8IGZvcmNlX3N0b3ApIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocGxheV9pbnRlcnZhbCk7XG4gICAgICAgICAgICBwbGF5X2ludGVydmFsID0gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoUEFSU0lORykge1xuICAgICAgICAgICAgcGxheV9pbnRlcnZhbCA9IHNldEludGVydmFsKHN0ZXBfZm9yd2FyZCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWJ1Z2dlcl9vcHRpbWl6ZV9jaGVja2JveC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGUgPT4ge1xuICAgICAgICBzdG9wX3BhcnNlcigpO1xuICAgICAgICBkZXN0cm95X3N0YXRlcygpO1xuICAgICAgICBvcHRpbWl6ZSA9IGRlYnVnZ2VyX29wdGltaXplX2NoZWNrYm94LmNoZWNrZWQ7XG4gICAgfSlcblxuICAgIGRlYnVnZ2VyX3N0ZXBfYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBzdGVwX2ZvcndhcmQpO1xuXG4gICAgZGVidWdnZXJfaW50b19idXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGUgPT4gdG9nZ2xlX3BsYXkoKSk7XG5cbiAgICBkZWJ1Z2dlcl9zdGFydF9zdG9wX2J1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XG4gICAgICAgIGlmIChQQVJTSU5HKVxuICAgICAgICAgICAgc3RvcF9wYXJzZXIoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3RhcnRfcGFyc2VyKCk7XG4gICAgfSk7XG5cbiAgICBkZWJ1Z2dlcl9lbnRyeV9zZWxlY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBlID0+IHtcbiAgICAgICAgc3RvcF9wYXJzZXIoKTtcbiAgICB9KTtcblxuICAgIHN0b3BfcGFyc2VyKCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgICAgICB1cGRhdGUodXBkYXRlOiBWaWV3VXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuZmluZChlID0+IGUuaXNVc2VyRXZlbnQoXCJkZWJ1Z2dlci5zdGFydFwiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTdGFydGVkXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodXBkYXRlLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcF9wYXJzZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHt9KSxcbiAgICAgICAgRWRpdG9yVmlldy51cGRhdGVMaXN0ZW5lci5vZihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2V0X2lucHV0KGUuc3RhdGUuZG9jLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgdmlldyA9IGUudmlldztcbiAgICAgICAgfSksXG4gICAgICAgIFN0YXRlRmllbGQuZGVmaW5lKHtcbiAgICAgICAgICAgIGNyZWF0ZSgpIHsgcmV0dXJuIERlY29yYXRpb24ubm9uZSB9LFxuICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHRyLmNoYW5nZXMpXG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKGhpZ2hsaWdodF9lZmZlY3QpKSB2YWx1ZSA9IHZhbHVlLnVwZGF0ZSh7IGFkZDogZWZmZWN0LnZhbHVlLCBzb3J0OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoZmlsdGVyX2VmZmVjdHMpKSB2YWx1ZSA9IHZhbHVlLnVwZGF0ZSh7IGZpbHRlcjogZWZmZWN0LnZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3ZpZGUoZikgeyByZXR1cm4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYpIH1cbiAgICAgICAgfSlcbiAgICBdXG59IiwgImltcG9ydCB7IFNjcm9sbEhhbmRsZXIgfSBmcm9tICcuJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJy4vbG9nZ2VyJztcblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBpbnRlcmFjdGlvbiBiZXR3ZWVuIHRoZSBkb2N1bWVudHMgYnJvd3NlclxuICogaWZyYW1lIGFuZCB0aGUgbGFiIHBhZ2UuIFxuKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChkb2NzX2lmcmFtZTogSFRNTElGcmFtZUVsZW1lbnQsIGRvY3NfaG9zdDogSFRNTElGcmFtZUVsZW1lbnQpIHtcblxuICAgIGlmIChkb2NzX2lmcmFtZS50YWdOYW1lID09IFwiSUZSQU1FXCIpIHtcblxuICAgICAgICBsZXQgaGFuZGxlciA9IG5ldyBTY3JvbGxIYW5kbGVyKGRvY3NfaWZyYW1lLCBkb2NzX2hvc3QpO1xuXG4gICAgICAgIC8vIFRyeSB0byBkZWNvZGUgdXJsIHRvIGdldCBhIHJlZmVyZW5jZSBkb2N1bWVudCBhbmQgbG9jYXRpb24uIFxuICAgICAgICAvLyBpZiBvbmUgZG9lcyBub3QgZXhpc3QsIHRoZW4gd2Ugc2hvdWxkIGxvYWQgdGhlIGRvYyBwYWdlXG4gICAgICAgIC8vIHVzaW5nIHRoYXQgYWRkcmVzcyBvdGhlcndpc2UsIGxvYWQgdGhlIHJvb3QgZG9jcyBwYXRoLlxuXG4gICAgICAgIGxldCBoYXNoID0gZG9jdW1lbnQubG9jYXRpb24uaGFzaDtcblxuICAgICAgICBpZiAoaGFzaC5zbGljZSgwLCA2KSA9PSBcIiNwYWdlOlwiKSB7XG4gICAgICAgICAgICBkb2NzX2lmcmFtZS5zcmMgPSBoYXNoLnNsaWNlKDYpLnJlcGxhY2UoXCIvXFwlMmYvZ1wiLCBcIi9cIik7XG4gICAgICAgICAgICBkb2NzX2hvc3QuY2xhc3NMaXN0LmFkZChcImxvYWRpbmdcIik7XG4gICAgICAgICAgICBkb2NzX2hvc3QuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvZyhcIkNvbmZpZ3VyaW5nIGRvY3MgaW50ZWdyYXRpb25cIik7XG5cbiAgICAgICAgZG9jc19pZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdyA9PiB7XG4gICAgICAgICAgICBsZXQgZG9jc19kb2MgPSBkb2NzX2lmcmFtZS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgICAgICBpZiAoZG9jc19kb2MpIHtcbiAgICAgICAgICAgICAgICBsZXQgaHRtbF9lbGVtZW50ID0gZG9jc19kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGRvY3NfZG9jLmJvZHkuY2xhc3NMaXN0LmFkZChcImxhYi1pZnJhbWVcIik7XG4gICAgICAgICAgICAgICAgaHRtbF9lbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblxuICAgICAgICAgICAgICAgIGhhbmRsZXIuc2V0X3RhcmdldChodG1sX2VsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBkZWZhdWx0IGFjdGlvbiBvbiBtb3N0IGFuY2hvcnNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFuY2hvciBvZiBBcnJheS5mcm9tKGRvY3NfZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYVwiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG9jc19ob3N0LmNsYXNzTGlzdC5yZW1vdmUoXCJsb2FkaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuXG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBhbGVydChcIkRvY3MgZnJhbWUgbm90IGNvcnJlY3RseSBjb25uZWN0ZWQsIGNhbm5vdCBpbnRlZ3JhdGUgZG9jc1wiKTtcbiAgICB9XG5cblxufSIsICJpbXBvcnQgaW5pdF9zaGVycGEsICogYXMgc2hlcnBhIGZyb20gXCJqcy9zaGVycGEvc2hlcnBhX3dhc20uanNcIjtcbmltcG9ydCB7IGJhc2ljU2V0dXAsIEVkaXRvclZpZXcsIH0gZnJvbSAnY29kZW1pcnJvcic7XG5pbXBvcnQgeyBsb2cgfSBmcm9tICdqcy9sYWIvbG9nZ2VyJztcbmltcG9ydCB7IFNjcm9sbEhhbmRsZXIgfSBmcm9tIFwiLi4vY29udHJvbHMvc2Nyb2xsXCI7XG5pbXBvcnQgZG9jc19oYW5kbGVyIGZyb20gJy4vZG9jc19oYW5kbGVyJztcbmltcG9ydCB7IHNoZXJwYUxhbmcgfSBmcm9tICcuL3NoZXJwYV9sYW5nJztcbmltcG9ydCB7IHBhcnNlckhvc3QgfSBmcm9tICcuL3BhcnNlcic7XG5pbXBvcnQgeyBHcmFtbWFyQ29udGV4dCB9IGZyb20gJy4vZ3JhbW1hcl9jb250ZXh0JztcbmltcG9ydCB7IGdldF9ncmFtbWFyLCBnZXRfaW5wdXQgfSBmcm9tIFwiLi9zZXNzaW9uX3N0b3JhZ2VcIjtcblxuZXhwb3J0IHsgZG9jc19oYW5kbGVyLCBTY3JvbGxIYW5kbGVyIH07XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIChcbiAgICB7XG4gICAgICAgIGNvZGVtaXJyb3JfZ3JhbW1hcl9ob3N0LFxuICAgICAgICBjb2RlbWlycm9yX3BhcnNlcl9ob3N0LFxuICAgICAgICBkaXNhc3NlbWJseV9vdXRwdXQsXG4gICAgICAgIGRlYnVnZ2VyX3N0YXJ0X3N0b3BfYnV0dG9uLFxuICAgICAgICBkZWJ1Z2dlcl9zdGVwX2J1dHRvbixcbiAgICAgICAgZGVidWdnZXJfaW50b19idXR0b24sXG4gICAgICAgIGRlYnVnZ2VyX291dF9idXR0b24sXG4gICAgICAgIGRlYnVnZ2VyX291dHB1dCxcbiAgICAgICAgZGVidWdnZXJfZW50cnlfc2VsZWN0aW9uLFxuICAgICAgICBkZWJ1Z2dlcl9vcHRpbWl6ZV9jaGVja2JveFxuICAgIH06IHtcbiAgICAgICAgY29kZW1pcnJvcl9ncmFtbWFyX2hvc3Q6IEVsZW1lbnQ7XG4gICAgICAgIGNvZGVtaXJyb3JfcGFyc2VyX2hvc3Q6IEVsZW1lbnQ7XG4gICAgICAgIGRpc2Fzc2VtYmx5X291dHB1dDogRWxlbWVudDtcbiAgICAgICAgZGVidWdnZXJfc3RhcnRfc3RvcF9idXR0b246IEhUTUxCdXR0b25FbGVtZW50LFxuICAgICAgICBkZWJ1Z2dlcl9zdGVwX2J1dHRvbjogSFRNTEJ1dHRvbkVsZW1lbnQsXG4gICAgICAgIGRlYnVnZ2VyX2ludG9fYnV0dG9uOiBIVE1MQnV0dG9uRWxlbWVudCxcbiAgICAgICAgZGVidWdnZXJfb3V0X2J1dHRvbjogSFRNTEJ1dHRvbkVsZW1lbnQsXG4gICAgICAgIGRlYnVnZ2VyX291dHB1dDogSFRNTERpdkVsZW1lbnQsXG4gICAgICAgIGRlYnVnZ2VyX2VudHJ5X3NlbGVjdGlvbjogSFRNTFNlbGVjdEVsZW1lbnQsXG4gICAgICAgIGRlYnVnZ2VyX29wdGltaXplX2NoZWNrYm94OiBIVE1MSW5wdXRFbGVtZW50LFxuICAgIH1cbikge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgaW5pdF9zaGVycGEoKTtcbiAgICAgICAgbG9nKFwiU2hlcnBhIFdBU00gUnVudGltZSBpbml0aWFsaXplZFwiKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgICAgYWxlcnQoXCJTaGVycGEgRmFpbGVkIHRvIExvYWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgY3R4ID0gbmV3IEdyYW1tYXJDb250ZXh0KCk7XG5cbiAgICBjb25zdCBwYXJzZXJfZWRpdG9yID0gbmV3IEVkaXRvclZpZXcoe1xuICAgICAgICBkb2M6IGdldF9pbnB1dCgpLFxuICAgICAgICBleHRlbnNpb25zOiBbYmFzaWNTZXR1cCwgcGFyc2VySG9zdChjdHgsIHtcbiAgICAgICAgICAgIGRlYnVnZ2VyX3N0YXJ0X3N0b3BfYnV0dG9uLFxuICAgICAgICAgICAgZGVidWdnZXJfc3RlcF9idXR0b24sXG4gICAgICAgICAgICBkZWJ1Z2dlcl9pbnRvX2J1dHRvbixcbiAgICAgICAgICAgIGRlYnVnZ2VyX291dF9idXR0b24sXG4gICAgICAgICAgICBkZWJ1Z2dlcl9vdXRwdXQsXG4gICAgICAgICAgICBkZWJ1Z2dlcl9lbnRyeV9zZWxlY3Rpb24sXG4gICAgICAgICAgICBkZWJ1Z2dlcl9vcHRpbWl6ZV9jaGVja2JveFxuICAgICAgICB9KV0sXG4gICAgICAgIHBhcmVudDogY29kZW1pcnJvcl9wYXJzZXJfaG9zdFxuICAgIH0pO1xuXG4gICAgY29uc3QgZ3JhbW1hcl9lZGl0b3IgPSBuZXcgRWRpdG9yVmlldyh7XG4gICAgICAgIGRvYzogZ2V0X2dyYW1tYXIoKSxcblxuICAgICAgICBleHRlbnNpb25zOiBbYmFzaWNTZXR1cCxcbiAgICAgICAgICAgIHNoZXJwYUxhbmcoY3R4KSxcbiAgICAgICAgICAgIEVkaXRvclZpZXcuZWRpdG9yQXR0cmlidXRlcy5vZih7IGNsYXNzOiBcIkNvZGVtaXJyb3JcIiB9KSxcbiAgICAgICAgXSxcbiAgICAgICAgcGFyZW50OiBjb2RlbWlycm9yX2dyYW1tYXJfaG9zdFxuICAgIH0pO1xuXG59XG5cbiJdLAogICJtYXBwaW5ncyI6ICI7QUFBQSxJQUFJO0FBRUosSUFBTSxvQkFBcUIsT0FBTyxnQkFB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QUEsRUFDWixDQUFDO0FBRUw7IiwKICAibmFtZXMiOiBbIm5hbWUiLCAicHRyIiwgInN0cmluZyIsICJhZGQiLCAidG9wIiwgIm51bWJlciIsICJNYXBNb2RlIiwgImRvYyIsICJpbnNlcnQiLCAiaSIsICJjb21wYXJlIiwgImNvbmZpZyIsICJfYSIsICJwcmVjIiwgImNvbnRlbnQiLCAiYmFzZSIsICJzY3JvbGxJbnRvVmlldyIsICJDaGFyQ2F0ZWdvcnkiLCAicmVxdWlyZSIsICJwaHJhc2UiLCAibmFtZSIsICJkZWZhdWx0cyIsICJjdXIiLCAibGF5ZXIiLCAiaGVhcCIsICJzcGVjIiwgIm5hbWUiLCAiZG9jIiwgImN1ciIsICJ0b3AiLCAicmVjdCIsICJuYW1lIiwgImluc2VydCIsICJpZSIsICJnZWNrbyIsICJjaHJvbWUiLCAiZmxhdHRlbiIsICJwb3MiLCAic2lkZSIsICJfYSIsICJ2aWV3IiwgIkJsb2NrVHlwZSIsICJkZWNvcmF0aW9ucyIsICJ0IiwgIkRpcmVjdGlvbiIsICJ0eXBlIiwgImNvbnRlbnQiLCAiaW5zaWRlIiwgImhhbmRsZXJzIiwgImV2ZW50IiwgImV4dGVuZCIsICJRdWVyeVR5cGUiLCAiYmFzZSIsICJnYXAiLCAiZnJvbSIsICJ0byIsICJzY3JvbGxJbnRvVmlldyIsICJrZXkiLCAiY29uZmlnIiwgImkiLCAic2hpZnQiLCAibWV0YSIsICJhZGQiLCAiY29tbWFuZCIsICJjbWQiLCAicGllY2VzIiwgImxheWVyIiwgImRlY28iLCAibSIsICJldmVudCIsICJjdXIiLCAiX2EiLCAidCIsICJpIiwgIl9hIiwgImNvbmZpZyIsICJ0IiwgInRvcCIsICJjdXIiLCAidG9wIiwgImNvbmZpZyIsICJndXR0ZXIiLCAiY3VyIiwgImd1dHRlcnMiLCAiYXNBcnJheSIsICJhZGQiLCAiZXZlbnQiLCAibnVtYmVyIiwgIlJhbmdlIiwgImNvbmZpZyIsICJuYW1lIiwgInR5cGVzIiwgImFkZCIsICJJdGVyTW9kZSIsICJjb25maWciLCAiX2EiLCAiY3VyIiwgImNoaWxkcmVuIiwgInBvc2l0aW9ucyIsICJub2RlIiwgImJ1ZmZlciIsICJkYXRhIiwgImxlbmd0aCIsICJsb29rQWhlYWQiLCAiYmFzZSIsICJub2RlU2l6ZSIsICJub2RlU3RhcnQiLCAiZnJvbSIsICJ0byIsICJSYW5nZSIsICJzdHJpbmciLCAiYmFzZSIsICJ0IiwgInNhbWVBcnJheSIsICJjb25maWciLCAidGFncyIsICJoYXNDaGlsZCIsICJuYW1lIiwgInRvcCIsICJkYXRhIiwgImJhc2UiLCAiZG9jIiwgIl9hIiwgImxhbmd1YWdlIiwgImJhc2UiLCAiY3VyIiwgImNsb3NpbmciLCAiZG9jIiwgImhlYWQiLCAibGluZSIsICJjdXIiLCAiY3VyIiwgIl9hIiwgImZyb20iLCAidG8iLCAiY29uZmlnIiwgImJhc2VUaGVtZSQxIiwgIl9hIiwgImZyb20iLCAidG8iLCAiYmFzZVRoZW1lIiwgImRlY29yYXRpb25zIiwgImNvbmZpZyIsICJjdXIiLCAiYnJhY2tldCIsICJwb3MiLCAibmFtZSIsICJuYW1lIiwgImNvbmZpZyIsICJjb21tZW50IiwgImVtcHR5IiwgImlzQWRqYWNlbnQiLCAiY29uZmlnIiwgImNvbW1hbmQiLCAiX2EiLCAibm9uZSIsICJpc0FkamFjZW50IiwgInQiLCAiY29uZmlnIiwgImJyYWNrZXQiLCAiZXh0ZW5kIiwgIl9hIiwgImN1ciIsICJuZXh0Q2hhciIsICJpbnNlcnQiLCAiY2hhbmdlcyIsICJjdXIiLCAibmFtZSIsICJkb2MiLCAiX2EiLCAiYmFzZVRoZW1lJDEiLCAid29yZCIsICJjb25maWciLCAiUXVlcnlUeXBlIiwgImRvYyIsICJhZGQiLCAiZnJvbSIsICJ0byIsICJjdXIiLCAiX2EiLCAiY29uZmlnIiwgIm5hbWUiLCAiY29udGVudCIsICJwaHJhc2UiLCAiYmFzZVRoZW1lIiwgInR5cGVzIiwgIl9hIiwgInNjb3JlIiwgImNvbmZpZyIsICJjb250ZW50IiwgIm9mZiIsICJzY3JvbGxJbnRvVmlldyIsICJ0b3AiLCAiY29tcGFyZSIsICJub25lIiwgImJhc2VUaGVtZSIsICJkZWZhdWx0cyIsICJpbnB1dEhhbmRsZXIiLCAiaW5zZXJ0IiwgImJyYWNrZXQiLCAiZG9jIiwgImNvbmZpZyIsICJiYXNlVGhlbWUiLCAic3RhdGUiLCAiYmFzZVRoZW1lIiwgInRvZ2dsZVBhbmVsIiwgInRvZ2dsZVBhbmVsIiwgImNvbmZpZyIsICJuYW1lIiwgIl9hIiwgImtleXMiLCAicm0iLCAiY29udGVudCIsICJiYXNlVGhlbWUiLCAidG9wIiwgIm5hbWUiLCAiY3R4IiwgIm5hbWUiXQp9Cg==
