@{#![allow(unused)]
#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

/// ### `radlr` Rust Parser
///
/// - **GENERATOR**: radlr 1.0.0-beta2
/// - **SOURCE**: UNDEFINED
///
/// #### WARNING:
///
/// This is a generated file. Any changes to this file may be **overwritten
/// without notice**.
///
/// #### License:
/// Copyright (c) 2020-2024 Anthony Weathersby
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy
/// of this software and associated documentation files (the 'Software'), to
/// deal in the Software without restriction, including without limitation the
/// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
/// sell copies of the Software, and to permit persons to whom the Software is
/// furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice shall be included in
/// all copies or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
/// IN THE SOFTWARE

use radlr_rust_runtime::parsers::ast::{Tk, Reducer, Node};
use std::{collections::HashMap, marker::PhantomData};

#ast_nodes(TYPES, STRUCTS, ANY_ENUMS)
  
@RULES.iter#rule_function()}

#_ {@"This is a comment function. Since we never call it, it has the same effect as a comment in other languages."}


#any_rust_type any:obj{ 
  @any.name match @any.has_token { true { <Token> } }
}

#any_rust_type_impl any:obj{ 
  @any.name match @any.has_token { true { <Token: Tk> } }
}

#ty_to_rust ty:obj {
  match ty.#type {
    "Token"       { Token }
    "TokenRange"  { TokenRange }
    "String"      { String } 
    "Bool"        { bool }
    "I8"          { i8 }
    "I16"         { i16 }
    "I32"         { i32 }
    "I64"         { i64 }
    "U8"          { u8 }
    "U16"         { u16 }
    "U32"         { u32 }
    "U64"         { u64 }
    "F32"         { f32 }
    "F64"         { f64 }
    "Struct"      { 
      match ty.is_empty {
        true { @ty.name  }
        { Box<@ty.name<Token>> }
      }
    }
  "Any"  { #any_rust_type(@ANY_ENUMS.[@ty.index]) }
    { @{ [TODO: ScalarType @type_name ] } }
  }
}

#ty_to_cap_name ty:obj {
  match ty.#type {
    "Struct"  { @ty.name }
    "Any"     { @ANY_ENUMS.[@ty.index].name }
    { @ty.#type }
  }
}

#ty_to_ast_name ty:obj {
  @agg_type={ @ty.agg_type }
  match @agg_type {
    "Map" {  #ty_to_cap_name(ty.key)#ty_to_cap_name(ty.val) }
    "Vec" { 
      match ty.val.#type {
        "Any"  { @ANY_ENUMS.[@ty.val.index].name s }
        { #ty_to_cap_name(ty.val)s }
      }  
    }
    {  
      match ty.val.#type {
        None {  /* wah wah */ }
        { #ty_to_cap_name(ty.val) }
      }
    }
  }
}

#ast_node_rust_type ty:obj {
  @agg_type={ @ty.agg_type }
  match @agg_type {
    "Map" { 
      HashMap<#ty_to_rust(ty.key),#ty_to_rust(ty.val)>
    }
    "Vec" {
      match ty.val.#type {
        "Any"  { 
          /* @ty.val.index */ Vec<#any_rust_type(@ANY_ENUMS.[@ty.val.index])> 
        }
        { Vec<#ty_to_rust(ty.val)> }
      }
    }
    {
      match ty.val.#type {
        None {  /* wah wah */ }
        { #ty_to_rust(ty.val) }
      } 
    }
  }
}

#_{ Escaping of names that full under Rust's reserved identifier set. }
#esc_ ts:str {
  match ts {
    "type" | "enum" | "struct" | "ref" { r# @[ts] }
    { @[ts] }
  }
}

#ast_nodes types:obj structs:obj any_enums:obj {
  
  #_{ AST DECLARATION -------------------------------------------------------------------------- }

  #any_enum_ast_declaration { @self.name(#any_rust_type(self)),\ @; }
  #struct_ast_declaration { 
    match @self.is_empty {
      true { @self.name(@self.name),\ @; }
      { @self.name(Box<@self.name<Token>>),\ @;  }
    } 
  }

  #type_entry { 
    match (@self.agg_type, @self.val.#type) { 
      (None, "Token") | (None, "Any") { }
      (_ , "Any") {
        /* @self.val.index */\ @;
        match @ANY_ENUMS.[self.val.index].is_root {
          true { #ty_to_ast_name(self)(#ast_node_rust_type(self)),\ @; }
        }
      }
      { #ty_to_ast_name(self)(#ast_node_rust_type(self)),\ @;}
    }
  }

  #[derive(Clone,\ Debug,\ Default)]\n
  #[repr(C, u32)]\n
  pub\ enum\ @AST_NAME<Token:Tk>\ {
    #[default]@;
    None,\ @;
    Token(Token),\ @;
    @types.iter#type_entry()
    @any_enums.iter#any_enum_ast_declaration()
    @structs.iter#struct_ast_declaration()
  }\n\n

  #_{ ------------------------------------------------------------------------------------------ }

  #_{ TYPE DECLARATIONS ------------------------------------------------------------------------ }

  impl<Token:Tk>\ @AST_NAME<Token> { 
    pub\ fn\ to_token(self)\ ->\ Option<Token>\ { @;
      mat ch\ self\ {
        @AST_NAME::Token(val)\ =>\ Some(val),@;
        _\ =>\ None,@;
      }
    }
  } \n\n

  #type_types {

    #impls {
      match (self.agg_type, self.val.#type) {
        (None, "Any") { }
        
        ("Vec", "Token") { 
          impl<Token:Tk>\ @AST_NAME<Token> { 
            pub\ fn\ into_#ty_to_ast_name(self) (self)\ ->\ Option<#ast_node_rust_type(self)>\ { @;
              mat ch\ self\ {
                @AST_NAME::#ty_to_ast_name(self)(val)\ =>\ Some(val),@;
                _\ =>\ None,@;
              }
            }
          } \n\n
        }
        (_ , "Any") {
          match @ANY_ENUMS.[self.val.index].is_root {
            true {
              impl<Token:Tk>\ @AST_NAME<Token> { 
                pub\ fn\ into_#ty_to_ast_name(self) (self)\ ->\ Option<#ast_node_rust_type(self)>\ { @;
                  mat ch\ self\ {
                    @AST_NAME::#ty_to_ast_name(self)(val)\ =>\ Some(val),@;
                    _\ =>\ None,@;
                  }
                }
              } \n\n

              impl<Token:Tk>\ From<#ast_node_rust_type(self)>\ for\ @AST_NAME<Token> { 
                fn\ from(value: #ast_node_rust_type(self))\ ->\ Self\ {
                  Self::#ty_to_ast_name(self)(value) @;
                }@;
              }

              \n\n
            }
          }
        }
        {
          impl<Token:Tk>\ @AST_NAME<Token> { 
            pub\ fn\ into_#ty_to_ast_name(self) (self)\ ->\ Option<#ast_node_rust_type(self)>\ { @;
              mat ch\ self\ {
                @AST_NAME::#ty_to_ast_name(self)(val)\ =>\ Some(val),@;
                _\ =>\ None,@;
              }
            }
          } \n\n

          impl<Token:Tk>\ From<#ast_node_rust_type(self)>\ for\ @AST_NAME<Token> { 
            fn\ from(value: #ast_node_rust_type(self))\ ->\ Self\ {
              Self::#ty_to_ast_name(self)(value) @;
            }@;
          }

          \n\n
        }
      }
    }

    @self.iter#impls()
  }

  @types.()

  #_{ ------------------------------------------------------------------------------------------ }

  #_{ ANY DECLARATIONS ------------------------------------------------------------------------- }

  #any_enum {
    @enum_type={ #any_rust_type(self) }
    #iter_types { 
      match (self.agg_type, self.val.#type , self.val.is_empty, self.is_root) {
          (None, "Struct", true, _) { 
             #ty_to_ast_name(self)(#ast_node_rust_type(self)),\ @;
          }
          { #ty_to_ast_name(self)(#ast_node_rust_type(self)),\ @; }
      }
    }

    #[derive(Clone,\ Debug,\ Default)]\n
    pub\ enum\ #any_rust_type_impl(self) {
      #[default] @;
      None, @;
      @self.types.iter#iter_types()
    }
    \n\n
  }

  @any_enums.iter#any_enum()

  #type_any_enums {

    #impls {
      @enum_type={ #any_rust_type(self) }

      #any_type_to_any ANY_NAME:str {
        @AST_NAME::#ty_to_ast_name(self)(val)\ =>\ Some(@ANY_NAME::#ty_to_ast_name(self)(val)),@;
      }

      impl<Token:Tk>\ @AST_NAME<Token> { 
        pub\ fn\ into_@self.name (self)\ ->\ Option<@enum_type>\ { @;
          mat ch\ self\ {
            @AST_NAME::@self.name (val)\ =>\ Some(val),@;
            @self.types.iter#any_type_to_any(self.name)
            _\ =>\ None,@;
          }
        }
      } \n\n

      impl<Token:Tk>\ From<@enum_type>\ for\ @AST_NAME<Token> { 
        fn\ from(value:\ @enum_type )\ ->\ Self\ {
          Self::@self.name(value) @;
        }@;
      }

      \n\n
    }

    @self.iter#impls()
  }

  @any_enums.()

  #_{ ------------------------------------------------------------------------------------------ }

  #_{ STRUCT DECLARATIONS----------------------------------------------------------------------- }

  #type_structs {

    #token_entry { 
      match self.has_token {
        true { @AST_NAME::@self.name(n)\ =>\ { n.tok.clone()@; } @; } 
      }
    }

    #hash_entry { @AST_NAME::@self.name(n)\ =>\ n.hash(hasher), @; }

    impl<Token:Tk>\ @AST_NAME<Token>\ {
      pub\ fn\ token\ (&self)\ ->\ Token\ {@;
        ma tch\ self\ { 
          @self.iter#token_entry()
          @AST_NAME::Token(tok)\ =>\ tok.clone(),
          _\ =>\ Default::default()
        }
      }
    }

    \n\n
    /*
    impl<Token:Tk>\ std::hash::Hash\ for\ @AST_NAME<Token>\ {
      fn\ hash<H:\ std::hash::Hasher>(&self,\ hasher:\ &mut\ H) {
        ma tch\ self { 
          @self.iter#hash_entry()
          _ => {}
        }
      }
    }
    */

    #struct_define {
      #prop_define {
        pub\ #esc_(@self.name):\ #ast_node_rust_type(self.type), @;
      }

      match self.props.#len {
        0 { 
          @rust_struct_type={ self.name }
          \n\n
          #[derive(\ Clone,\ Copy,\ Debug,\ Default\ )] 

          \n
          pub\ struct\ @self.name();

          \n\n
          impl<Token:Tk>\ @AST_NAME<Token> { 
            pub\ fn\ into_@self.name (self)\ ->\ Option<@rust_struct_type>\ { @;
              mat ch\ self\ {
                @AST_NAME::@self.name(val)\ =>\ Some(val),@;
                _\ =>\ None,@;
              }
            }
          } \n\n

          impl<Token:Tk>\ From<@rust_struct_type>\ for\ @AST_NAME<Token> { 
            fn\ from(value:\ @rust_struct_type )\ ->\ Self\ {
              Self::@self.name(value) @;
            }@;
          }
        }
        { 

          @rust_struct_type={ "Box<" + self.name + "<Token>>" }
          \n\n
          #[derive(\ Clone,\ Debug,\ Default\ )]

          \n
          pub\ struct\ @self.name<Token:Tk>{ 
            @self.props.iter#prop_define()
            match self.has_token {
              false {
                _tok: PhantomData<Token>
              }
            }
          }

          \n\n
          impl<Token:Tk>\ @AST_NAME<Token> { 
            pub\ fn\ into_@self.name (self)\ ->\ Option<@rust_struct_type>\ { @;
              mat ch\ self\ {
                @AST_NAME::@self.name(val)\ =>\ Some(val),@;
                _\ =>\ None,@;
              }
            }
          } \n\n

          impl<Token:Tk>\ From<@rust_struct_type>\ for\ @AST_NAME<Token> { 
            fn\ from(value:\ @rust_struct_type )\ ->\ Self\ {
              Self::@self.name(value) @;
            }@;
          }
        }
      }
    }

    @self.iter#struct_define()
  }

  @structs.()

  #_{ ------------------------------------------------------------------------------------------ }
}

#rule_function {

  #_{ GRAPH NODE RENDERERS --------------------------------------------------------------------- }


  #type_AnyConvertNode ref:str {    
    /*  @self.init.agg_type\ @self.init.val */
    match @self.init.#type {
      "SymNode" { 
        let\ @ref\ =\ nodes[@self.init.index].clone();@;
        let\ @ref\ =\ unsafe{\ @ref . into_@ANY_ENUMS.[@self.index].name() .unwrap_unchecked()\ }; @;
      }
      {
        @self.init.(ref) 
        /*\ Don't\ know\ what\ to\ do!\ @self.index */
      }
    }
  }

  #type_StrNode ref:str {    
    @self.init.(ref)

    match (self.init.agg_type, self.init.val.#type) {
      ("Vec", "Token") {  let\ @ref\ =\ Token::from_slice (&@ref) .to_string(); }
      (_, "Token")     {  let\ @ref\ =\ @ref. to_string(); }
      { let\ @ref:String\ =\ String::default();  }
    }@;
  }

  #type_NumNode ref:str {
    match self.init {
      & { 
        @self.init.(ref)

        match (self.init.agg_type, self.init.val.#type) {
          ("Vec", _) | ("Map", _)  { let\ @ref\ =\ @ref. len()\ as\ #ty_to_rust(@self.val); }
          (_, "Token")  {  let\ @ref:\ #ty_to_rust(@self.val)\ = \ @ref . to_string().parse().unwrap_or_default(); }
          (_, "String")  {  let\ @ref:\ #ty_to_rust(@self.val)\ = \ @ref . parse().unwrap_or_default(); }
          (_, _)  {  let\ @ref\ = @ref\ as\ #ty_to_rust(@self.val); }
          { @{ [TODO: num convert (@self.init.agg_type, @self.init.val) ] }  }
        }
        @;
      }
      { let\ @ref\ =\ @self.literal;@; }
    }
  }

  #type_TokNode ref:str {
    let\ @ref\ =\ tokens[@self.index].clone();@;
  }

  #type_TokRuleNode ref:str {
    let\ @ref\ =\ nterm_tok.clone();@;
  }

  #type_TrimNode ref:str {
    @self.init.(ref)

    let\ @ref\ =\ @ref . trim(@self.start, @self.end);@;
  }

  #type_SymNode r:str {
    match (self.agg_type, self.val.#type) {
      (None, "Token") { 
        let\ @r\ =\ nodes[@self.index].clone();@;
        let\ @r\ =\ @r. to_token().unwrap();@; 
      }
      (_, Some) { 
        let\ @r\ =\ std::mem::take(&mut\ nodes[@self.index]@;);@;
        let\ @r\ =\ unsafe{\ @r. into_#ty_to_ast_name(self)().unwrap_unchecked()\ };@; 
      }
    }
  }

  #type_AddNode ref:str {
    
    @ref_l={ @ref + "_l" }
    @ref_r={ @ref + "_r" }

    @self.right.(@ref_r)
    @self.left.(@ref_l)

    match (self.left.agg_type, self.right.agg_type) {
      ("Vec",  "Vec") | ("Map",  "Map") {
        let\ mut\ @ref\ =\ @ref_l; @;
        @ref . extend ( @ref_r ) ; @;
      }

      ("Vec",  "Map") { vec_map }

      ("Map",  "Vec") { map_vec }

      ("Vec",  _) {
        match self.right.val.#type {
          { 
            let\ mut\ @ref\ =\ @ref_l; @;
            @ref . push ( @ref_r ) ; @;
          }
        }
      }

      (_,  "Vec") { add_vec }

      ("Map",  _) { map_add }

      (_,  "Map") { add_map }

      (_, _) { let\ mut\ @ref\ =\ @ref_l\ +\ @ref_r; @; }
    }
  }

  #type_MulNode ref:str {
    
    @ref_l={ @ref + "_l" }
    @ref_r={ @ref + "_r" }

    @self.right.(@ref_r)
    @self.left.(@ref_l)

    match (self.left.agg_type, self.right.agg_type) {
      (None, None) { let\ mut\ @ref\ =\ @ref_l\ *\ @ref_r; @; }
    }
  }

  #type_SubNode ref:str {
    
    @ref_l={ @ref + "_l" }
    @ref_r={ @ref + "_r" }

    @self.right.(@ref_r)
    @self.left.(@ref_l)

    match (self.left.agg_type, self.right.agg_type) {
      (None, None) { let\ mut\ @ref\ =\ @ref_l\ -\ @ref_r; @; }
    }
  }

  #type_DivNode ref:str {
    
    @ref_l={ @ref + "_l" }
    @ref_r={ @ref + "_r" }

    @self.right.(@ref_r)
    @self.left.(@ref_l)

    match (self.left.agg_type, self.right.agg_type) {
      (None, None) { let\ mut\ @ref\ =\ @ref_l\ /\ @ref_r; @; }
    }
  }

  #type_VecNode ref:str {

    #vec_elements_initializers ref:str {
      @ref={ ref + "_" + _index_ }
      @self.(ref)@;
    }

    #vec_elements_names ref:str {
      @ref={ ref + "_" + _index_ }
      @ref match _iter_last_ { & { } { , } }@;
    }

    /* @self.init.#len */

    match self.init.#len {
      0 {
        let\ @ref:\ #ast_node_rust_type(@self)\  =\ vec![];@;
      }
      {
        @self.init.iter#vec_elements_initializers(ref) 
        let\ @ref\ =\ vec![\ @self.init.iter#vec_elements_names(ref)\ ];@;
      }
    }

    
  }


  #type_MapNode ref:str {

    @ref_key={ @ref + "_key" }
    @ref_val={ @ref + "_val" }

    @self.left.(@ref_key)
    @self.right.(@ref_val)

    let\ mut\ @ref\ =\ HashMap::new();@;
    @ref . insert(@ref_key, @ref_val); @;
  }

  #type_BoolNode ref:str {
    match self.init {
      { let\ @ref\ =\ false ; @; }
      Some { 
        @self.init.(ref)
        match (@self.init.agg_type, @self.init.val.#type) {
          (Some, _) | (None, "Token") | (None, "String") {
            let\ @ref\ =\ @ref . len() > 0;@;
          }
          (None, "U64") | (None, "U32") | (None, "U16") | (None, "U8") |
          (None, "I64") | (None, "I32") | (None, "I16") | (None, "I8") {
            let\ @ref\ =\ @ref != 0;@;
          }
          (None, "F64") | (None, "F32") {
            let\ @ref\ =\ @ref != 0.0;@;
          }
          { let\ @ref\ =\ false ; @; }
        }
      }
    }
  }

  #_{ ------------------------------------------------------------------------------------------ }

  #_{ Initializers ----------------------------------------------------------------------------- }

  #type_StructInitializer {

    #print_struct_initializer {
      match self.node {
        Some { @self.node.(#esc_(@self.name)) @;}
        None { let\ @self.name\ =\ Default::default(); @;@; }
      }
    }
    
    #print_struct_assign { #esc_(@self.name), @; }

    match self.props.#len {
      0 { 
        @AST_NAME::@self.name(@self.name())
      }
      {
        let\ nodes = unsafe { &mut *nodes }; @;@;
        
        @self.props.iter#print_struct_initializer()
      
        match self.has_token { false { let\ _tok\ = Default::default(); @;@; } }

        @AST_NAME::@self.name(Box::new(@self.name{
          @self.props.iter#print_struct_assign()
          match self.has_token { false { _tok, @; } }
        }))
      }
    }
  }

  #type_Initializer {
    @out={ "out" }
    @agg_type={ @self.node.agg_type }
    @key_type={ @self.node.key.#type }
    @val_type={ @self.node.val.#type }

    let\ nodes = unsafe { &mut *nodes };@;
    
    @self.node.(@out)

    match (@agg_type, @val_type) {
      ("Vec", "Token") { @AST_NAME::Tokens(@out) @; }
      ( None, "Token") { @AST_NAME::Token(@out) @; }
      { @out . into() @; }
    }
  }

  #_{ 
      Here we iterate through each rule and print out a 
      function that is used to build an AST node from 
      a rule's symbols 
    }

  @r={ self }

  \n
  fn\ rule_@self.id /* @r.init.comment */  <Token:Tk>(
    \ nodes:\ *mut\ [@AST_NAME<Token>],@;\ tokens: &[Token],@;\ nterm_tok:\ Token 
  )\ ->\ @AST_NAME<Token>\ { 
    @r.init.()
  }
  \n

  #_{ ------------------------------------------------------------------------------------------ }
}

#_{ Rule LUT ----------------------------------------------------------------------------------- }
 
#print_rule_lookup { rule_@self.id,\ @; }

\n

pub\ struct\ ReduceRules<Token:Tk>( 
  pub\ [Reducer<Token, @AST_NAME<Token>>;@RULES.#len] @;
);

\n\n

impl<Token:Tk>\ ReduceRules<Token>{
  pub\ const\ fn\ new ()\ ->\ Self\ { @;
    Self([@RULES.iter#print_rule_lookup()]) @;
  } @;
}

\n\n

impl<Token:Tk>\ AsRef<[Reducer<Token,\ @AST_NAME<Token>>]>\ for\ ReduceRules<Token> { @;
  fn\ as_ref(&self)\ ->\ &[Reducer<Token,\ @AST_NAME<Token>>] { @;
    &self.0 @;
  } @;
}

#_{ -------------------------------------------------------------------------------------------- }