use std::{fmt::Debug, hash::Hash};

use radlr_compiler_frontend::{
  array_vec::ArrayVec,
  item::{Item, ItemIndex},
  parser_db::ParserDatabase,
  rule::Rule,
  symbol::{PrecedentDBTerm, PrecedentSymbol, SymbolId},
  DBNonTermKey,
  DBRuleKey,
  DBTermKey,
  GraphType,
};

pub struct State {
  /// Globally unique identifier for this state.
  pub hash_id: u64,
  pub is_root: bool,
  pub is_leaf: bool,
  pub is_goto: bool,
  pub sym:     PrecedentSymbol,
  pub parent:  *const State,
  pub kernel:  ArrayVec<4, StateItem>,
  pub invalid: std::sync::atomic::AtomicBool,
}

impl State {
  pub fn get_predecessor(&self, hash_id: u64) -> Option<&State> {
    if hash_id == self.hash_id {
      Some(self)
    } else if !self.parent.is_null() {
      unsafe { self.parent.as_ref().unwrap().get_predecessor(hash_id) }
    } else {
      None
    }
  }

  pub fn parent(&self) -> Option<&State> {
    if !self.parent.is_null() {
      Some(unsafe { &*self.parent })
    } else {
      None
    }
  }

  pub fn kernel(&self) -> impl Iterator<Item = StateItem> + '_ {
    self.kernel.as_slice().iter().map(|i| i.to_origin_state(self))
  }
}

/// Indicates the State type that generated
/// the item
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[allow(non_camel_case_types)]
pub enum Origin {
  None,
  /// The goal non-terminal that this item or it's predecessors will reduce to
  NonTermGoal(DBNonTermKey),
  /// The goal symbol id that this item or its predecessors will recognize
  TerminalGoal(DBTermKey, u16),
  /// The hash and state of the goal items set the peek item will resolve to
  Peek(u32),
  Fork(DBRuleKey),
  Closure,
  Goto,
  __OOS_CLOSURE__,
  __OOS_ROOT__,
  __OOS_SCANNER_ROOT__(PrecedentDBTerm),
  /// Generated when the a goal non-terminal is completed.
  /// Goal non-terminals are determined by the
  /// root state (`StateId(0)`) kernel items
  GoalCompleteOOS,
}

impl Hash for Origin {
  fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
    match self {
      Origin::Peek(resolve_id) => resolve_id.hash(state),
      Origin::TerminalGoal(resolve_id, prec) => {
        resolve_id.hash(state);
        prec.hash(state);
      }
      Origin::Fork(resolve_id) => {
        resolve_id.hash(state);
      }
      _ => {}
    }

    std::mem::discriminant(self).hash(state)
  }
}

impl Default for Origin {
  fn default() -> Self {
    Self::None
  }
}

impl Origin {
  #[cfg(debug_assertions)]
  pub fn _debug_string_(&self) -> String {
    match self {
      Origin::NonTermGoal(nterm) => {
        format!("NonTermGoal[ {:?} ]", nterm)
      }
      Origin::TerminalGoal(sym_id, prec) => {
        format!("TerminalGoal[ {:?} {prec} ]", sym_id)
      }
      _ => format!("{:?}", self),
    }
  }

  pub fn is_none(&self) -> bool {
    matches!(self, Origin::None)
  }

  pub fn is_out_of_scope(&self) -> bool {
    matches!(self, Origin::GoalCompleteOOS | Origin::__OOS_CLOSURE__ | Origin::__OOS_ROOT__ | Origin::__OOS_SCANNER_ROOT__(..))
  }

  pub fn is_scanner_oos(&self) -> bool {
    matches!(self, Origin::__OOS_SCANNER_ROOT__(..))
  }

  pub fn get_symbol(&self, db: &ParserDatabase) -> SymbolId {
    match self {
      Origin::TerminalGoal(sym_id, ..) => db.sym(*sym_id),
      _ => SymbolId::Undefined,
    }
  }

  pub fn get_symbol_key(&self) -> DBTermKey {
    match self {
      Origin::TerminalGoal(sym_id, ..) => *sym_id,
      _ => DBTermKey::default(),
    }
  }

  pub fn is_oos(&self) -> bool {
    match self {
      Self::__OOS_ROOT__ | Self::__OOS_CLOSURE__ | Self::__OOS_SCANNER_ROOT__(..) => true,
      _ => false,
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct StateId(pub usize);

impl Debug for StateId {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut t = f.debug_tuple("StateId");
    t.field(&self.index());
    t.finish()
  }
}

impl Hash for StateId {
  fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
    self.index().hash(state)
  }
}

impl Default for StateId {
  fn default() -> Self {
    Self(usize::MAX)
  }
}

impl StateId {
  pub fn index(&self) -> usize {
    (self.0 & 0x0F_FF_FF_FF) as usize
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Default)]
pub struct AnnotatedStateId {
  id:       StateId,
  sub_type: GraphIdSubType,
}

impl Debug for AnnotatedStateId {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut t = f.debug_tuple("AnnotatedStateId");
    t.field(&self.id);
    t.field(&self.subtype());
    t.finish()
  }
}

impl AnnotatedStateId {
  pub fn new(index: StateId, sub_type: GraphIdSubType) -> Self {
    Self { id: index, sub_type }
  }

  pub fn to_post_reduce(&self) -> Self {
    Self::new(self.id, GraphIdSubType::PostReduce)
  }

  pub fn to_goto(&self) -> Self {
    Self::new(self.id, GraphIdSubType::Goto)
  }

  pub fn subtype(&self) -> GraphIdSubType {
    self.sub_type
  }

  /// Indicates the state was generated by transitioning from a goal state to
  /// items that follow from non-terms of goal items.
  pub fn is_oos(&self) -> bool {
    match self.subtype() {
      GraphIdSubType::ExtendSled | GraphIdSubType::ExtendedClosure => true,
      _ => false,
    }
  }

  pub fn is_root(&self) -> bool {
    self.subtype() == GraphIdSubType::Root
  }

  pub fn root() -> Self {
    Self { id: StateId(0), sub_type: GraphIdSubType::Root }
  }
}

impl From<AnnotatedStateId> for StateId {
  fn from(value: AnnotatedStateId) -> Self {
    value.id
  }
}

// STATE ID -------------------------------------------------------------
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Default)]
pub enum GraphIdSubType {
  Root    = 0,
  Regular,
  Goto,
  PostReduce,
  ExtendedClosure,
  ExtendSled,
  #[default]
  Invalid = 0xF,
}

impl GraphIdSubType {
  /// A single use subtype to represent the transition from a an
  /// in-scope state to an out-of-scope state, item, or closure.
  pub fn is_oos_entry(&self) -> bool {
    *self == GraphIdSubType::ExtendSled
  }

  pub fn is_oos_closure(&self) -> bool {
    *self == GraphIdSubType::ExtendedClosure
  }

  pub fn extended_entry_base() -> Self {
    GraphIdSubType::ExtendSled
  }

  pub fn root() -> Self {
    GraphIdSubType::Root
  }

  pub fn is_invalid(&self) -> bool {
    *self == GraphIdSubType::Invalid
  }

  pub fn is_root(&self) -> bool {
    *self == GraphIdSubType::Root
  }

  pub fn is_rootish(&self) -> bool {
    *self == GraphIdSubType::Root
  }

  pub fn is_post_reduce(&self) -> bool {
    *self == GraphIdSubType::PostReduce
  }

  pub fn is_goto(&self) -> bool {
    *self == GraphIdSubType::Goto
  }
}

#[derive(Clone, Copy)]
pub struct StateItem {
  pub item:   Item,
  /// The form of the state the item's initial position originates from.
  pub origin: Origin,
  /// The graph state properties the item originated from
  //pub origin_state: StateId,
  pub state: *const State,

  pub is_oos:       bool,
  pub is_oos_entry: bool,
}

impl Default for StateItem {
  fn default() -> Self {
    Self {
      item:         Default::default(),
      origin:       Default::default(),
      state:        std::ptr::null(),
      is_oos:       Default::default(),
      is_oos_entry: Default::default(),
    }
  }
}

impl AsRef<Item> for StateItem {
  fn as_ref(&self) -> &Item {
    &self.item
  }
}

impl Hash for StateItem {
  fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
    (self.item, self.origin, self.state as usize).hash(state)
  }
}

impl PartialEq for StateItem {
  fn eq(&self, other: &Self) -> bool {
    let a = (self.item, self.origin, self.state as usize);
    let b = (other.item, other.origin, other.state as usize);
    a == b
  }
}

impl Eq for StateItem {}

impl PartialOrd for StateItem {
  fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
    let a = (self.item, self.origin, self.state as usize);
    let b = (other.item, other.origin, other.state as usize);
    Some(a.cmp(&b))
  }
}

impl Ord for StateItem {
  fn cmp(&self, other: &Self) -> std::cmp::Ordering {
    self.partial_cmp(other).unwrap()
  }
}

impl StateItem {
  /// The precedence of this items origin if this item has a
  /// [Origin::TerminalGoal] origin type.
  pub fn origin_precedence(&self) -> u16 {
    match self.origin {
      Origin::TerminalGoal(_, prec) => prec,
      _ => 0,
    }
  }

  pub fn increment(&self) -> Option<Self> {
    match self.item.increment() {
      Some(item) => Some(Self { item, ..*self }),
      None => None,
    }
  }

  pub fn decrement(&self) -> Option<Self> {
    match self.item.decrement() {
      Some(item) => Some(Self { item, ..*self }),
      None => None,
    }
  }

  pub fn to_oos_entry(&self) -> Self {
    Self { is_oos_entry: true, ..*self }
  }

  pub fn state(&self) -> &State {
    debug_assert!(!self.state.is_null());
    unsafe { self.state.as_ref().unwrap_unchecked() }
  }

  #[inline]
  pub fn to_origin_state(&self, state: *const State) -> Self {
    Self { state, ..self.clone() }
  }

  #[inline]
  pub fn to_origin(&self, origin: Origin) -> Self {
    Self { origin, ..self.clone() }
  }

  #[inline]
  pub fn is_canonical(&self) -> bool {
    *self == self.to_canonical()
  }

  pub fn is_out_of_scope(&self) -> bool {
    self.is_oos()
  }

  #[inline]
  pub fn to_canonical(&self) -> Self {
    Self { origin: Default::default(), state: std::ptr::null(), ..self.clone() }
  }

  #[inline]
  pub fn is_oos(&self) -> bool {
    self.origin.is_oos()
  }

  #[inline]
  pub fn as_from(&self, other: &Self) -> Self {
    Self { item: self.item.as_from(other.item), ..*self }
  }

  #[inline]
  pub fn as_from_index(&self, from: ItemIndex) -> Self {
    Self { item: self.item.as_from_index(from), ..*self }
  }

  #[inline]
  /// Creates a new [ItemRef] with the same rule info as the original, but
  /// with the meta info of `other`. Resets goto metadata
  pub fn align(&self, other: &Self) -> Self {
    Self { item: self.item.align(&other.item), ..*self }
  }
}

impl Debug for StateItem {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    Ok(())
  }
}

/// Represents either a FIRST or a FOLLOW depending on whether the root item
/// is incomplete or not.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]
pub struct TransitionPair {
  pub kernel:       StateItem,
  pub next:         StateItem,
  pub sym:          SymbolId,
  pub allow_assign: bool,
  pub prec:         u16,
}

pub type Lookahead = TransitionPair;
pub type Lookaheads = Vec<Lookahead>;

impl TransitionPair {
  pub fn is_kernel_terminal(&self) -> bool {
    !self.is_eoi_complete() && self.kernel.as_ref().index == self.next.as_ref().index
  }

  /// True if the kernel item is the same as the next item, and both are
  /// complete. Indicates a situation where the item has reached some goal
  /// state and the FOLLOW set is empty.
  pub fn is_eoi_complete(&self) -> bool {
    self.kernel.as_ref().is_complete() && self.kernel.as_ref().index == self.next.as_ref().index
  }

  #[cfg(debug_assertions)]
  pub fn _debug_string_(&self, db: &ParserDatabase) -> String {
    Default::default()
    /*   format!(
      "\nsym {}{{{}}} oos:{}\n  base: {}\n  next: {}",
      self.sym.debug_string(db),
      self.prec,
      self.is_out_of_scope(),
      self.kernel._debug_string_w_db_(db),
      self.next._debug_string_w_db_(db)
    ) */
  }
}

impl From<(StateItem, StateItem, GraphType, &[Rule])> for TransitionPair {
  fn from((root, next, mode, rules): (StateItem, StateItem, GraphType, &[Rule])) -> Self {
    Self {
      kernel: root,
      next,
      allow_assign: true,
      sym: if next.as_ref().is_complete() { SymbolId::Default } else { next.as_ref().sym_id(rules) },
      prec: next.as_ref().precedence(mode, rules),
    }
  }
}

impl From<(&StateItem, &StateItem, GraphType, &[Rule])> for TransitionPair {
  fn from((root, next, mode, rules): (&StateItem, &StateItem, GraphType, &[Rule])) -> Self {
    (*root, *next, mode, rules).into()
  }
}
