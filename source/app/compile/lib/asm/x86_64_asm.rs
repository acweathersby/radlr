//! This following is a list of registers that a reserved for s&pecific purposes:&
//! ### While in recognizer mode states:
//! - r15 - stores the state metadata
//! - rbx - stores the address of the [parser context](hctk::types::ASMParserContext)
//! - rbp - stores the address of the [reader](hctk::types::CharacterReader)
//! ### While in scanner mode states:
//! Same as above, with the additional registers:
//! - rdx - stores packed character data. see [hctk::types::SymbolReader::get_type_info]
//! - r12 - stores token offset data: byte offset in high 32, and codepoint offset in lower 32
//! - r13 - stores token length data: byte length in high 32, and codepoint length in lower 32
//! - r14 - stores accepted token offset data

use core::num;
use hctk::bytecode::BytecodeOutput;
use hctk::debug::grammar;
use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::collections::VecDeque;
use std::io::Result;
use std::io::Write;

use hctk::grammar::get_exported_productions;
use hctk::grammar::ExportedProduction;
use hctk::types::*;

use crate::builder::table::BranchData;
use crate::builder::table::BranchTableData;
use crate::builder::table::TableType;
use crate::options::BuildOptions;
use crate::writer::x86_64_writer::X8664Writer;

const parse_context_size: usize = std::mem::size_of::<ParseContext<UTF8StringReader>>();

const stack_ref_size: usize = std::mem::size_of::<Vec<u8>>();

const token_size: usize = std::mem::size_of::<ParseToken>();

pub fn write_preamble<W: Write, T: X8664Writer<W>>(
  grammar: &GrammarStore,
  writer: &mut T,
) -> Result<()>
{
  // Disclaimer and constants
  writer
    .comment_line("This is a parser generated by the Hydrocarbon Toolkit.")?
    .comment_line("Any modifications may be overwritten without warning!")?
    .newline()?
    .constant("ParseAction_Undefined            ", &(0).to_string())?
    .constant("ParseAction_CompleteState        ", &(1).to_string())?
    .constant("ParseAction_FailState            ", &(2).to_string())?
    .constant("ParseAction_ScannerToken         ", &(3).to_string())?
    .constant("ParseAction_Fork                 ", &(4).to_string())?
    .constant("ParseAction_Shift                ", &(5).to_string())?
    .constant("ParseAction_Reduce               ", &(6).to_string())?
    .constant("ParseAction_Accept               ", &(7).to_string())?
    .constant("ParseAction_Error                ", &(8).to_string())?
    .constant("FAIL_STATE_MASK                  ", &FAIL_STATE_MASK.to_string())?
    .constant("NORMAL_STATE_MASK                ", &NORMAL_STATE_MASK.to_string())?
    .constant("PEEK_MODE_FLAG                   ", &PEEK_MODE_FLAG.to_string())?
    .constant(
      "PEEK_MODE_FLAG_INVERT            ",
      &(!(PEEK_MODE_FLAG as u64)).to_string(),
    )?
    .constant("PRODUCTION_META_MASK             ", &PRODUCTION_META_MASK.to_string())?
    .constant(
      "PRODUCTION_META_MASK_INVERT      ",
      &PRODUCTION_META_MASK_INVERT.to_string(),
    )?
    .constant(
      "STATE_TYPE_MASK                  ",
      &(NORMAL_STATE_MASK + FAIL_STATE_MASK).to_string(),
    )?
    .constant(
      "STATE_TYPE_MASK_INVERT           ",
      &(!((NORMAL_STATE_MASK + FAIL_STATE_MASK) as u64)).to_string(),
    )?
    .constant("TOKEN_TYPE_META_MASK_INVERT      ", &(0xFFFF_FFFFu64.to_string()))?
    .constant(
      "STACK_ADDRESS_OFFSET             ",
      &(parse_context_size - stack_ref_size).to_string(),
    )?
    .constant("rbx_peek_token_offset            ", &(8 * 0).to_string())?
    .constant("rbx_anchor_token_offset          ", &(8 * 4).to_string())?
    .constant("rbx_assert_token_offset          ", &(8 * 8).to_string())?
    .constant("rbx_foreign_rsp_offset           ", &(8 * 12).to_string())?
    .constant("rbx_local_rsp_offset             ", &(8 * 13).to_string())?
    .constant("rbx_local_stack_base             ", &(8 * 14).to_string())?
    .constant("rbx_state_u64_data_offset        ", &(8 * 15).to_string())?
    .constant("rbx_parse_action_ptr             ", &(8 * 16).to_string())?
    .constant("rbx_block_length                 ", &(8 * 17).to_string())?
    .constant("rbx_block_ptr                    ", &(8 * 18).to_string())?
    .constant("rbx_block_base                   ", &(8 * 19).to_string())?
    .constant("rbx_struct_reader_ptr_offset     ", &(8 * 20).to_string())?
    .constant("rbx_fn_get_block_data            ", &(8 * 21).to_string())?
    .constant("rbx_fn_get_line_data             ", &(8 * 22).to_string())?
    .constant("rbx_fn_get_length_data           ", &(8 * 23).to_string())?
    .constant("rbx_fn_next                      ", &(8 * 24).to_string())?
    .constant("rbx_fn_set_cursor                ", &(8 * 25).to_string())?
    .constant("tok_byte_offset                  ", &(4 * 0).to_string())?
    .constant("tok_cp_offset                    ", &(4 * 1).to_string())?
    .constant("tok_byte_length                  ", &(4 * 2).to_string())?
    .constant("tok_cp_length                    ", &(4 * 3).to_string())?
    // Scan byte offset and line number are aliases
    .constant("tok_padding                      ", &(4 * 4).to_string())?
    .constant("tok_type                         ", &(4 * 5).to_string())?
    .constant("tok_line_number                  ", &(4 * 6).to_string())?
    .constant("tok_line_offset                  ", &(4 * 7).to_string())?
    .newline()?
    .newline()?;

  writer.section(".text")?;

  // Entry Points

  writer
    .commented_code(
      "global construct_context",
      "adjust stack information and initializes context variables",
    )?
    .commented_code(
      "global prime_context",
      "resets context and pops a starting state onto the stack",
    )?
    .commented_code(
      "global destroy_context",
      "freezes any extend stacks that been allocated to the context",
    )?
    .commented_code(
      "global next",
      "continue processing from the last state and yield the next action",
    )?
    .commented_code(
      "extern hctk_extend_stack",
      "acquire a new parse stack and move the contents of the old stack to the new one",
    )?
    .commented_code(
      "extern hctk_get_stack_pointer",
      "acquire the pointer to the stack buffer",
    )?
    .commented_code(
      "extern hctk_get_stack_size",
      "acquire the QWORD size of the stack buffer ",
    )?
    .code("default rel")?
    .newline()?
    .newline()?;

  writer
    .label("construct_context", false)?
    .code("push rbx")?
    .code("mov rbx, rdi")?
    .newline()?
    .comment_line("  Reserve the start of our state stack")?
    .code("lea rdi, [rbx + STACK_ADDRESS_OFFSET]")?
    .code("call hctk_get_stack_pointer")?
    .code("mov [rbx + rbx_local_stack_base], rax")?
    .code("lea rdi, [rbx + STACK_ADDRESS_OFFSET]")?
    .code("call hctk_get_stack_size")?
    .code("mov r10, [rbx + rbx_local_stack_base]")?
    .code("add r10, rax")?
    .code("mov [rbx + rbx_local_rsp_offset], r10")?
    .newline()?
    .comment_line("  Save our state stack")?
    .newline()?
    .code("pop rbx")?
    .newline()?
    .code("ret")?;

  writer
    .label("prime_context", false)?
    .inline(restore_context_external)?
    .comment_line("  Configure our parse state")?
    .comment_line("  Set the normal mode for our parse state")?
    .code("mov r10, ( NORMAL_STATE_MASK )")?
    .code("mov [rbx + rbx_state_u64_data_offset], r10")?
    .code("mov r11, rsi")?
    .code("xor esi, esi")?
    .comment_line("Initialize the block data")?
    .inline(update_block_data)?
    .inline_grammar(grammar, |writer, grammar: &GrammarStore| -> Result<&mut T> {
      // Create a simple lookup for a production entrypoint
      let vec = get_exported_productions(grammar);
      let last = vec.len() - 1;
      for (
        i,
        ExportedProduction {
          export_name,
          guid_name,
          ..
        },
      ) in vec.iter().enumerate()
      {
        let (is_first, is_last) = (i == 0, last == i);

        if !is_first {
          writer.label(&format!("opt_{}", i), true)?;
        }
        writer.commented_code(
          &format!("cmp  r11, {}", i),
          &format!("{} as {}", guid_name, export_name),
        )?;
        if !is_last {
          writer.code(&format!("jne .opt_{}", i + 1))?;
        } else {
          writer.code("jne .push_state")?;
        }
        writer.code(&format!("lea rax, [rel state_{}]", guid_name))?;
        if !is_last {
          writer.code("jmp .push_state")?;
        }
      }
      Ok(writer)
    })?
    .label("push_state", true)?
    .comment_line("  Add our return address")?
    .code("lea r10, [rel end_parse]")?
    .code("push r10")?
    .comment_line("  Add our stack sentinel")?
    .code("xor r10d, r10d")?
    .code("push r10")?
    .code("push r10")?
    .comment_line("  Push our entry state onto the stack")?
    .commented_code("mov r15, NORMAL_STATE_MASK", "state metadata")?
    .commented_code("push r15", "state metadata")?
    .commented_code("push rax", "state address")?
    .inline(save_context_external)?
    .code("ret")?;

  writer.newline()?.label("scan_handler", false)?;
  write_extend_stack_checker(writer, token_size as u32 * 2 + 8 * 12)?
    // Load data for new parse run. We create a new context
    // stores the just the offsets for tokens in the rbp register.
    .inline(save_context_internal)?
    .newline()?
    .comment_line("Update line number and offset info")?
    .code("mov rdi, [rbx + rbx_struct_reader_ptr_offset]")?
    .code("call [rbx + rbx_fn_get_line_data]")?
    .inline(restore_context_internal)?
    .comment_line("setup new context for scanner ------- ")?
    .code("push r15")?
    .commented_code("push rax", "line information")?
    .commented_code("push r14", "push the target token address")?
    .commented_code("push r12", "save the return address in the stack")?
    .code("lea r10, [rel scanner_complete]")?
    .commented_code("push r10", "push the address of the completer code")?
    .code("push 0")?
    .code("push 0")?
    .commented_code("mov r15, NORMAL_STATE_MASK", "set scanner state metadata")?
    .inline(save_context_internal)?
    .code("mov rsi, r14")?
    .code("mov rdi, [rbx + rbx_struct_reader_ptr_offset]")?
    .code("call [rbx + rbx_fn_set_cursor]")?
    .code("mov rdx, rax")?
    .inline(restore_context_internal)?
    .code("mov r8, r13")?
    .code("mov r12,  [r14 + tok_byte_offset]")?
    .code("mov r13,  [r14 + tok_byte_length]")?
    .code("jmp r8")?
    .newline()?
    .label("scanner_complete", false)?
    .code("test r15, FAIL_STATE_MASK")?
    .code("jz .create_token")?
    .label("create_token", true)?
    .commented_code("pop rdi", "pop the state return address")?
    .commented_code("pop rax", "pop the target token address")?
    .commented_code("pop r8", "line info")?
    .code("mov rcx, [rax + tok_byte_offset]")?
    .code("sub r14, rcx")?
    .code("mov [rax + tok_byte_length], r14")?
    .code("mov [rax + tok_line_number], r8")?
    .code("mov [rax + tok_padding], r15")?
    .code("mov rax, r15")?
    .code("shr rax, 32")?
    .code("pop r15")?
    .code("jmp rdi")?
    .newline()?;

  writer
    .newline()?
    .label("next", false)?
    .inline(restore_context_external)?
    .newline()?
    .label("dispatch_loop", false)?
    .commented_code("pop r8", "state address")?
    .commented_code("pop r9", "state metadata")?
    .newline()?
    .comment_line("Test for bottom of stack sentinel")?
    .commented_code("test r9,r9", "test to see if state metadata is 0")?
    .commented_code("jnz .have_state", "stop parsing if we have no more actions")?
    .code("pop r10")?
    .code("jmp r10")?
    .newline()?
    .label("have_state", true)?
    .comment_line("Test for state appropriateness in current context")?
    .commented_code("mov r10, r15", "get copy of our context state")?
    .commented_code("and r10, STATE_TYPE_MASK", "mask out the mode")?
    .commented_code(
      "test r10, r9",
      "if this is zero then we are not allowed to use this state in the current context",
    )?
    .code("jz dispatch_loop")?
    .newline()?
    .comment_line("Dispatch!")?
    .commented_code("jmp r8", "go to the state")?
    .newline()?;

  writer
    .label("emit_action", false)?
    .comment_line("  Save our parse state")?
    .code("mov [rbx + rbx_state_u64_data_offset], r15")?
    .inline(save_context_external)?
    .code("xor eax, eax")?
    .code("inc eax")?
    .code("ret")?
    .newline()?;

  writer
    .label("end_parse", false)?
    .code("mov rax, [rbx + rbx_parse_action_ptr]")?
    .code("mov DWORD [rax], ParseAction_Accept")?
    .code("mov r10, r15")?
    .code("mov r11, PRODUCTION_META_MASK")?
    .code("and r10, r11")?
    .code("mov DWORD [rax + 8], r10d")?
    .inline(save_context_external)?
    .code("ret")?
    .newline()?;

  writer
    .newline()?
    .label("destroy_context", false)?
    .code("ret")?
    .newline()?;

  writer
    .label("extend_stack", false)?
    // write_extend_stack_checker:
    // Loads rax for the difference and rcx for the return
    // address
    .code("push rcx")?
    .inline(save_context_internal)?
    .code("push rax")?
    .code("lea rdi, [rbx + STACK_ADDRESS_OFFSET]")?
    .code("call hctk_extend_stack")?
    .code("cmp rax, 0")?
    .code("je .extend_stack_fail")?
    .code("lea rdi, [rbx + STACK_ADDRESS_OFFSET]")?
    .code("call hctk_get_stack_pointer")?
    .code("mov [rbx + rbx_local_stack_base], rax")?
    .code("lea rdi, [rbx + STACK_ADDRESS_OFFSET]")?
    .code("call hctk_get_stack_size")?
    .code("mov r10, [rbx + rbx_local_stack_base]")?
    .code("add r10, rax")?
    .code("pop rax")?
    .code("sub r10, rax")?
    .code("mov [rbx + rbx_local_rsp_offset], r10")?
    .inline(restore_context_internal)?
    .code("pop rcx")?
    .code("jmp rcx")?
    .label("extend_stack_fail", true)?
    .inline(save_context_external)?
    .code("xor eax, eax")?
    .code("ret")?
    .newline()?;

  writer
    .comment_line("Attempt to extend our parse input window:")?
    .label("extend_input_block", false)?
    .inline(update_block_data)?
    .code("mov rax, [rbx + rbx_parse_action_ptr]")?
    .code("mov DWORD [rax], ParseAction_Shift")?
    .code("mov rcx, r9")?
    .code("sub rcx, r12")?
    .code("mov [rax + 8 + tok_byte_length], rcx")?
    .code("mov [rax + 8 + tok_byte_offset], r12")?
    .code("mov [rax + 8 + tok_line_number], r13")?
    .code("mov QWORD [rax + 8 + tok_padding], 0")?
    .code("mov [rax + 40 + tok_byte_length], r8")?
    .code("mov [rax + 40 + tok_byte_offset], r9")?
    .code("mov [rax + 40 + tok_line_number], r10")?
    .code("mov [rax + 40 + tok_padding], r11")?
    .inline(save_context_external)?
    .code("ret")?;

  write_emit_shift(writer)?;
  write_emit_reduce(writer)?;

  Ok(())
}

fn write_emit_shift<W: Write, T: X8664Writer<W>>(writer: &mut T) -> Result<&mut T>
{
  writer
    .label("emit_shift", false)?
    .code("lea rsi, [rbx + rbx_assert_token_offset]")?
    .code("lea rdi, [rbx + rbx_anchor_token_offset]")?
    .code("mov r8, [rsi + tok_byte_length]")?
    .code("mov r9, [rsi + tok_byte_offset]")?;

  writer
    .code("mov r12, [rdi + tok_byte_offset]")?
    .code("mov r13, [rdi + tok_line_number]")?
    .code("mov r10, [rsi + tok_line_number]")?
    .code("mov r11, [rsi + tok_padding]")?;

  writer
    .comment_line("Set the anchor and assert tokens to the same values:")?
    .code("mov [rsi + tok_line_number], r10")?
    .code("mov [rdi + tok_line_number], r10")?;

  if false {
    writer
      .comment_line("Zero out our internal token values:")?
      .code("xor rcx, rcx")?
      .code("mov QWORD [rsi + tok_byte_length], rcx")?
      .code("mov QWORD [rdi + tok_byte_length], rcx")?
      .code("mov QWORD [rsi + tok_padding], rcx")?
      .code("mov QWORD [rdi + tok_padding], rcx")?;
  } else {
    writer
      .code("pxor xmm1, xmm1")?
      .code("movdqu [rsi + tok_byte_length], xmm1")?
      .code("movdqu [rdi + tok_byte_length], xmm1")?;
  }
  writer
    .comment_line("Add length to offset in our internal tokens:")?
    .code("mov rcx, r9")?
    .code("add rcx, r8")?
    .code("mov [rsi + tok_byte_offset], rcx")?
    .code("mov [rdi + tok_byte_offset], rcx")?;

  writer
    .comment_line("Output the shift action:")?
    .code("mov rax, [rbx + rbx_parse_action_ptr]")?
    .code("mov DWORD [rax], ParseAction_Shift")?
    .code("mov rcx, r9")?
    .code("sub rcx, r12")?
    .code("mov [rax + 8 + tok_byte_length], rcx")?
    .code("mov [rax + 8 + tok_byte_offset], r12")?
    .code("mov [rax + 8 + tok_line_number], r13")?
    .code("mov QWORD [rax + 8 + tok_padding], 0")?
    .code("mov [rax + 40 + tok_byte_length], r8")?
    .code("mov [rax + 40 + tok_byte_offset], r9")?
    .code("mov [rax + 40 + tok_line_number], r10")?
    .code("mov [rax + 40 + tok_padding], r11")?
    .inline(save_context_external)?
    .code("ret")
}

fn write_emit_reduce<W: Write, T: X8664Writer<W>>(writer: &mut T) -> Result<&mut T>
{
  writer
    .label("emit_reduce", false)?
    .code("mov rax, [rbx + rbx_parse_action_ptr]")?
    .code("mov DWORD [rax], ParseAction_Reduce")?
    .code("mov [rax + 8 + 0], r8d")?
    .code("mov [rax + 8 + 4], r9d")?
    .code("mov [rax + 8 + 8], r10d")?
    .inline(save_context_external)?
    .code("ret")
}

/// Set our parse view the cursor position defined in `rsi` so that we
/// can select read enough bytes to satisfy the view length requirements
/// of the current state
fn update_block_data<W: Write, T: X8664Writer<W>>(writer: &mut T) -> Result<&mut T>
{
  writer
    .code("mov rdi, [rbx + rbx_struct_reader_ptr_offset]")?
    .code("mov rsi, 0")?
    .code("lea rdx, [rbx + rbx_block_ptr]")?
    .code("lea rcx, [rbx + rbx_block_length]")?
    .inline(save_context_internal)?
    .code("call [rbx + rbx_fn_get_block_data]")?
    .inline(restore_context_internal)
}

fn restore_context_external<W: Write, T: X8664Writer<W>>(writer: &mut T)
  -> Result<&mut T>
{
  writer
    .comment_line("Restoring context")?
    .commented_code("push r12", "preserve r12")?
    .commented_code("push r13", "preserve r13")?
    .commented_code("push r14", "preserve r14")?
    .commented_code("push r15", "preserve r15")?
    .commented_code("push rbx", "preserve rbx")?
    .commented_code("push rbp", "preserve the base pointer")?
    .commented_code("mov rbx, rdi", "make our offsets relative to the parse context")?
    .commented_code(
      "mov [rbx + rbx_parse_action_ptr], rsi",
      "preserve reference to our action",
    )?
    .commented_code("mov rbp, rsp", "preserve the outside stack")?
    .commented_code(
      "mov rsp, [rbx + rbx_local_rsp_offset]",
      "restore our local state stack",
    )?
    .code("mov r15, [rbx + rbx_state_u64_data_offset]")
}

fn save_context_external<W: Write, T: X8664Writer<W>>(writer: &mut T) -> Result<&mut T>
{
  writer
    .comment_line("Saving context")?
    .code("mov [rbx + rbx_state_u64_data_offset], r15")?
    .commented_code("mov [rbx + rbx_local_rsp_offset], rsp", "preserve our local stack")?
    .commented_code("mov rsp, rbp", "restore outside stack")?
    .commented_code("pop rbp", "restore the base pointer")?
    .commented_code("pop rbx", "restore rbx")?
    .commented_code("pop r15", "restore r15")?
    .commented_code("pop r14", "restore r14")?
    .commented_code("pop r13", "restore r13")?
    .commented_code("pop r12", "restore r12")
}

fn save_context_internal<W: Write, T: X8664Writer<W>>(writer: &mut T) -> Result<&mut T>
{
  writer
    .comment_line("Saving context")?
    .commented_code("XCHG rbp, rsp", "preserve our local stack")
}
fn restore_context_internal<W: Write, T: X8664Writer<W>>(writer: &mut T)
  -> Result<&mut T>
{
  writer
    .comment_line("Restoring context")?
    .commented_code("XCHG rsp, rbp", "restore our local stack")
}

pub fn write_state<W: Write, T: X8664Writer<W>>(
  build_options: &BuildOptions,
  output: &BytecodeOutput,
  writer: &mut T,
  mut address: usize,
  predefined_name: Option<&String>,
  mut is_scanner: bool,
  referenced: &mut Vec<u32>,
) -> Result<(usize, String)>
{
  let BytecodeOutput {
    bytecode,
    offset_to_state_name,
    ..
  } = output;

  let mut name = String::new();

  if address >= bytecode.len() {
    return Ok((bytecode.len(), name));
  }

  if let Some((asm_state_name, ir_state_name)) = if predefined_name.is_some() {
    Some((predefined_name.unwrap().clone(), String::new()))
  } else if let Some(name) = offset_to_state_name.get(&(address as u32)) {
    Some((create_named_state_label(name), name.clone()))
  } else {
    None
  } {
    writer.label(&format!("{}", asm_state_name), false)?;

    name = ir_state_name.clone();

    if let Some(state) = output.ir_states.get(&ir_state_name) {
      match state.get_type() {
        IRStateType::ProductionStart
        | IRStateType::ScannerStart
        | IRStateType::ProductionGoto
        | IRStateType::ScannerGoto => {
          println!("{} {}", asm_state_name, ir_state_name);
          // TODO right checker for handling stack expansion.
          if state.get_stack_depth() > 0 {
            let needed_size = state.get_stack_depth() * 2 * 8;
            write_extend_stack_checker(writer, needed_size)?;
          }
        }
        _ => {}
      }

      is_scanner = state.is_scanner();
    }

    while address < bytecode.len() {
      match bytecode[address] & INSTRUCTION_HEADER_MASK {
        INSTRUCTION::I00_PASS => {
          address += 1;
          writer.code("mov rax, STATE_TYPE_MASK_INVERT")?;
          writer.code("and r15, rax")?;
          writer.code("or r15, NORMAL_STATE_MASK")?;
          writer.code("jmp dispatch_loop")?;
          break;
        }

        INSTRUCTION::I01_CONSUME => {
          if is_scanner {
            // Reminder:
            // r12 is token offset
            // r13 is token length
            if bytecode[address] & 1 == 1 {
              writer.code("xor r13d, r13d")?;
            } else {
              writer.code("add r12, r13")?;
            }
            writer
              .inline(save_context_internal)?
              .code("mov rsi, r13")?
              .code("shr rsi, 32")?
              .code("mov rdi, [rbx + rbx_struct_reader_ptr_offset]")?
              .code("call [rbx + rbx_fn_next]")?
              .code("mov rdx, rax")?
              .inline(restore_context_internal)?;
          } else {
            writer.code("xor eax, eax")?;
            if bytecode[address] & 1 == 1 {
              writer
                .code("mov [rbx + rbx_assert_token_offset + tok_byte_length], rax")?;
            }

            let return_label = create_offset_label(address);

            writer
              .code("push r15")?
              .code(&format!("lea rax, [rel .{}]", return_label))?
              .code("push rax")?
              .code("jmp emit_shift")?
              .label(&return_label, true)?;
          }

          address += 1;
        }

        INSTRUCTION::I02_GOTO => {
          let goto_offset = bytecode[address] & GOTO_STATE_ADDRESS_MASK;

          let name = if let Some(name) = offset_to_state_name.get(&goto_offset) {
            create_named_state_label(name)
          } else {
            create_offset_label(address)
          };

          referenced.push(goto_offset);

          if bytecode[address + 1] & INSTRUCTION_HEADER_MASK == INSTRUCTION::I00_PASS {
            // Simply perform a jump to the applicable code
            // skipping the pass instruction entirely
            writer.code(&format!("jmp {}", name))?;
            address += 2;
            break;
          } else {
            writer
              .code(&format!("mov rax, NORMAL_STATE_MASK"))?
              .code("push rax")?
              .code(&format!("lea rax, [rel {}]", name))?
              .code("push rax")?;
          }
          address += 1;
        }

        INSTRUCTION::I03_SET_PROD => {
          let production_id = bytecode[address] & INSTRUCTION_CONTENT_MASK;
          writer
            .comment_line("Set production")?
            .code("mov rax, PRODUCTION_META_MASK_INVERT")?
            .code("and r15, rax")?
            .code(&format!("add r15, {}", production_id))?;
          address += 1;
        }

        INSTRUCTION::I04_REDUCE => {
          let instruction = bytecode[address];
          let symbol_count = instruction >> 16 & 0x0FFF;
          let body_id = instruction & 0xFFFF;

          let return_label = create_offset_label(address);
          writer
            .code("mov r8d, r15d")?
            .code("and r8d, PRODUCTION_META_MASK")?
            .code(&format!("mov r9d, {}", body_id))?
            .code(&format!("mov r10d, {}", symbol_count))?
            .code("push r15")?
            .code(&format!("lea rax, [rel .{}]", return_label))?
            .code("push rax")?
            .code("jmp emit_reduce")?
            .label(&return_label, true)?;
          writer.commented_code("nop", "reduce")?;
          address += 1;
        }

        INSTRUCTION::I05_TOKEN => {
          let value = bytecode[address] & 0x00FF_FFFF;
          writer
            .comment_line("Set token")?
            .commented_code("mov r14, r12", "token offset")?
            .code("mov rax, TOKEN_TYPE_META_MASK_INVERT")?
            .code("and r15, rax")?
            .code(&format!("mov rax, {}", (value as u64) << 32))?
            .code("add r15, rax")?;
          address += 1;
        }

        INSTRUCTION::I06_FORK_TO => {
          let instruction = bytecode[address];
          let instruction = instruction & INSTRUCTION_CONTENT_MASK;
          let target_production = instruction & 0xFFFF;
          let num_of_states = (instruction >> 16) & 0xFFFF;

          for state in &bytecode[(address + 1)..(address + 1 + num_of_states as usize)] {
            referenced.push((*state) & GOTO_STATE_ADDRESS_MASK)
          }

          address += (1 + num_of_states) as usize;
          writer.commented_code("nop", "fork")?;
          writer.code("jmp emit_action")?;
          break;
        }

        INSTRUCTION::I07_SCAN => {
          address += 1;
          writer.commented_code("nop", "scan")?;
        }

        INSTRUCTION::I08_NOOP => {
          address += 1;
          writer.commented_code("nop", "no operation")?;
        }

        INSTRUCTION::I09_VECTOR_BRANCH | INSTRUCTION::I10_HASH_BRANCH => {
          if let Some(data) = BranchTableData::from_bytecode(address, output) {
            let table_name = create_offset_label(address);

            writer.label(&table_name, false)?;

            let TableHeaderData {
              input_type,
              lexer_type,
              scanner_address,
              ..
            } = data.data;
            let branches = &data.branches;

            match input_type {
              INPUT_TYPE::T02_TOKEN => {
                if (lexer_type == LEXER_TYPE::ASSERT) {
                  writer
                    .comment_line("retrieving assert token data")?
                    .code("mov r10, PEEK_MODE_FLAG_INVERT")?
                    .commented_code("and rcx, r10", "unset peek mode")?
                    // set_base_token
                    .code("lea r14, [rel rbx + rbx_assert_token_offset]")?
                } else {
                  writer
                    .comment_line("retrieving peek token data")?
                    .code("lea r14, [rbx + rbx_peek_token_offset]")?
                    .code("mov r9, r14")?
                    .code("test ecx, PEEK_MODE_FLAG")?
                    .code("jnz .increment_peek")?
                    .code("lea r9, [rbx + rbx_assert_token_offset]")?
                    .code("or ecx, PEEK_MODE_FLAG")?
                    .label(".increment_peek", true)?
                    .newline()? // Update byte
                    .code("mov r10, [r9 + tok_byte_offset]")?
                    .code("mov r11, [r9 + tok_byte_length]")?
                    .code("add r10, r11")?
                    .code("mov [r14 + tok_byte_offset], r10")?
                    .newline()?
                };
                if data.has_trivial_comparisons() {
                  fn string_to_byte_num_and_mask(
                    string: &str,
                    sym: &Symbol,
                  ) -> (usize, usize)
                  {
                    string.as_bytes().iter().enumerate().fold(
                      (0, 0),
                      |(val, mask), (i, v)| {
                        let shift_amount = 8 * i;
                        (
                          val | ((*v as usize) << shift_amount),
                          mask | (0xFF << shift_amount),
                        )
                      },
                    )
                  }

                  writer
                    .label(&format!("pre_block_check_{}", table_name), false)?
                    .code("mov r9, [rbx + rbx_block_ptr]")?
                    .code("mov r8, [rbx + rbx_block_base]")?
                    .code("mov r11, [rbx + rbx_block_length]")?
                    .code("mov r10d, [r14 + tok_byte_offset]")?
                    .code("add r11, r8")?
                    .code("cmp r10, r11")?
                    .code(&format!("jl post_block_check_{}", table_name))?
                    .code(&format!("lea r10, [ pre_block_check_{} ] ", table_name))?
                    .code("push r15")?
                    .code("push r10")?
                    .code("jmp extend_input_block")?
                    .label(&format!("post_block_check_{}", table_name), false)?
                    .code("add r9, r10")?
                    .code("sub r9, r8")?
                    .code("mov r8, [r9 + 0]")?
                    .comment_line("TODO: Should check that our block is large enough to view the max required slice")?;

                  for (address, branch) in &data.branches {
                    let sym = data.get_branch_symbol(branch).unwrap();

                    let next_branch_label = format!("next_{}_{}", table_name, address);

                    let branch_name = if branch.is_skipped {
                      create_table_skip_label(&table_name)
                    } else {
                      create_table_branch_label(&table_name, address)
                    };

                    for string in {
                      match sym.guid {
                        id if id.isDefinedSymbol() => {
                          vec![output
                            .grammar
                            .symbols_string_table
                            .get(&id)
                            .unwrap()
                            .as_str()]
                        }
                        SymbolID::GenericSpace => {
                          vec![" "]
                        }
                        _ => vec![""],
                      }
                    } {
                      match sym.byte_length {
                        len if len == 1 => {
                          writer.code(&format!(
                            "cmp r8b, 0x{:X}",
                            string_to_byte_num_and_mask(string, sym).0
                          ))?;
                        }
                        len if len <= 8 => {
                          let (byte_string, mask) =
                            string_to_byte_num_and_mask(string, sym);
                          writer
                            .code(&format!("mov r11, 0x{:X}", byte_string))?
                            .code(&format!("mov r10, 0x{:X}", mask))?
                            .code("mov rax, r8")?
                            .code("and rax, r10")?
                            .code("cmp rax, r11")?;
                        }
                        len if len <= 4 => {}
                        len if len <= 16 => {}
                        len if len <= 32 => {}
                        _ => {}
                      }
                      writer
                        .code(&format!("jne .{}", next_branch_label))?
                        .code(&format!(
                          "mov r8, 0x{:X}",
                          ((sym.byte_length as usize)
                            | ((sym.code_point_length as usize) << 32))
                        ))?
                        .code("mov [r14 + tok_byte_length], r8")?
                        .code(&format!(
                          "mov DWORD [r14 + tok_type], {}",
                          sym.bytecode_id
                        ))?
                        // 9*
                        .code(&format!("jmp {}", branch_name))?
                        .label(&next_branch_label, true)?;
                    }
                  }
                  writer.code(&format!("jmp {}_default", table_name))?;
                } else {
                  referenced.push(scanner_address);

                  let scan_state = output
                    .offset_to_state_name
                    .get(&(scanner_address as u32))
                    .unwrap();

                  if (lexer_type == LEXER_TYPE::ASSERT) {
                    writer
                      .comment_line(
                        "Bypass the token scanner if token is already typed.",
                      )?
                      .code("mov eax, [r14 + tok_type]")?
                      .code("cmp eax, 0")?
                      .code("jne .cached")?;
                  }

                  writer
                    .code(&format!(
                      "lea r13, [rel {}]",
                      create_named_state_label(scan_state)
                    ))?
                    .code("lea r12, [rel .cached]")?
                    .code("jmp scan_handler")?
                    .label("cached", true)?;

                  write_default_table_jumps(&data, writer, &table_name)?;
                }
              }
              INPUT_TYPE::T01_PRODUCTION => {
                writer
                  .comment_line("get production value")?
                  .code("mov rax, r15")?
                  .code("and rax, PRODUCTION_META_MASK")?;

                write_default_table_jumps(&data, writer, &table_name)?;
              }
              _ => {
                match input_type {
                  INPUT_TYPE::T05_BYTE => {
                    writer
                      .code("mov r13, 0x0000000100000001")?
                      .comment_line("Load the byte data in the low 8 bits")?
                      .code("mov eax, edx")?
                      .code("and eax, 0xFF")?;
                  }
                  INPUT_TYPE::T03_CLASS => {
                    writer
                      .code("mov r13, 0x0000010000000000")?
                      .code("mov r13w, dx")?
                      .code("shr r13, 8")?
                      .comment_line("Load the class data in the high 16 bits")?
                      .code("mov eax, edx")?
                      .code("shr rax, 16")?;
                  }
                  INPUT_TYPE::T04_CODEPOINT => {
                    writer
                      .code("mov r13, 0x0000010000000000")?
                      .code("mov r13w, dx")?
                      .code("shr r13, 8")?
                      .comment_line("Load the codepoint data in the high 32 bits")?
                      .code("mov rax, rdx")?
                      .code("shr rax, 32")?;
                  }
                  _ => {}
                };

                write_default_table_jumps(&data, writer, &table_name)?;
              }
            }

            // Write branches, ending with the default branch.

            let mut skip_written = false;

            for (address, is_skip) in branches
              .values()
              .map(|p| (p.address, p.is_skipped))
              .collect::<BTreeSet<_>>()
              .iter()
            {
              if *is_skip {
                if skip_written {
                  continue;
                }
                skip_written = true;
                let branch_name = create_table_skip_label(&table_name);
                writer
                  .label(&branch_name, false)?
                  .comment_line(&format!("Skip this token",))?;
                match lexer_type {
                  LEXER_TYPE::ASSERT => {
                    writer.code("lea rsi, [rbx + rbx_assert_token_offset]")?
                  }
                  _ => writer.code("lea rsi, [rbx + rbx_peek_token_offset]")?,
                }
                .code("mov r8, [rsi + tok_byte_length]")?
                .code("mov r9, [rsi + tok_byte_offset]")?
                .code("add r9, r8")?
                .code("mov QWORD [rsi + tok_padding], 0")?
                .code("mov QWORD [rsi + tok_byte_length], 0")?
                .code("mov r10, [rsi + tok_line_number]")?
                .code("mov [rsi + tok_line_number], r10")?
                .code("mov [rsi + tok_byte_offset], r9")?
                .code(&format!("jmp {}", table_name))?;
              } else {
                write_state(
                  build_options,
                  output,
                  writer,
                  *address,
                  Some(&create_table_branch_label(&table_name, address)),
                  is_scanner,
                  referenced,
                )?;
              }
            }

            address = write_state(
              build_options,
              output,
              writer,
              (bytecode[address + 3] as usize) + address,
              Some(&format!("{}_default", table_name)),
              is_scanner,
              referenced,
            )?
            .0;
            break;
          } else {
            return Err(std::io::Error::new(
              std::io::ErrorKind::InvalidData,
              "Invalid branch data",
            ));
          }
        }

        INSTRUCTION::I11_SET_FAIL_STATE => {
          address += 1;
          writer.commented_code("nop", "set fail state")?;
        }

        INSTRUCTION::I12_REPEAT => {
          address += 1;
          writer.commented_code("nop", "repeats")?;
        }

        INSTRUCTION::I13_NOOP => {
          address += 1;
          writer.commented_code("nop", "no operation 13")?;
        }

        INSTRUCTION::I14_ASSERT_CONSUME => {
          address += 1;
          writer.commented_code("nop", "assert consume")?;
        }
        INSTRUCTION::I15_FAIL => {
          address += 1;
          writer.code("mov rax, STATE_TYPE_MASK_INVERT")?;
          writer.code("and r15, rax")?;
          writer.code("or r15, FAIL_STATE_MASK")?;
          writer.code("jmp dispatch_loop")?;
          break;
        }
        _ => {
          address += 1;
          writer.code("nop")?;
        }
      }
    }
  } else {
    writer.code("nop")?;
    address += 1;
  }

  Ok((address, name))
}

fn create_table_skip_label(table_name: &String) -> String
{
  format!("t_{}_skip", table_name)
}

fn create_table_branch_label(table_name: &String, address: &usize) -> String
{
  format!("t_{}_{}", table_name, address)
}

fn write_default_table_jumps<'a, W: Write, T: X8664Writer<W>>(
  data: &BranchTableData,
  writer: &'a mut T,
  table_name: &String,
) -> Result<&'a mut T>
{
  let TableHeaderData {
    table_meta,
    table_length,
    input_type,
    ..
  } = data.data;

  let is_infallible = input_type == INPUT_TYPE::T01_PRODUCTION;

  if matches!(data.table_type, TableType::Vector) && data.branches.len() > 8 {
    // Jump table
    writer
      .code(&format!("sub rax, {}", table_meta))?
      .code(&format!("jl {}_default", table_name))?
      .code(&format!("cmp rax, {}", table_length))?
      .code(&format!("jg {}_default", table_name))?
      .code("lea r10, [ .table ]")?
      .code("mov r11, r10")?
      .code("shl rax, 1")?
      .code("add r11, rax")?
      .code("xor eax, eax")?
      .code("mov ax, [r11]")?
      .code("add r10, rax")?
      .code("jmp r10")?
      .newline()?
      .newline()?
      .write_internal(b"align 2")?
      .label(&format!("table"), true)?;
    for BranchData { address, .. } in data
      .branches
      .iter()
      .map(|(_, b)| (b.value, b))
      .collect::<BTreeMap<_, _>>()
      .values()
    {
      writer.code(&format!(
        "DW ( t_{}_{} - {}.table ) ",
        table_name, address, table_name
      ))?;
    }
  } else if false && is_infallible {
    // Binary search
    // Sort based on value
  } else {
    // Linear probe
    for BranchData {
      value: discriminant,
      address,
      ..
    } in data.branches.values()
    {
      writer
        .code(&format!("cmp rax, {}", discriminant))?
        .code(&format!("je {}", &format!("t_{}_{}", table_name, address)))?;
    }
    writer.code(&format!("jmp {}_default", table_name))?;
  }

  Ok(writer)
}

fn write_extend_stack_checker<W: Write, T: X8664Writer<W>>(
  writer: &mut T,
  needed_size: u32,
) -> Result<&mut T>
{
  writer
    .code("mov rax, rsp")?
    .code("mov rcx, [rbx + rbx_local_stack_base]")?
    .code("sub rax, rcx")?
    .code(&format!("cmp rax, {}", needed_size))?
    .code("jg .start")?
    .code("lea rcx, [rel .start]")?
    .code("jmp extend_stack")?
    .label("start", true)
}

fn create_named_state_label(name: &String) -> String
{
  format!("state_{}", name)
}

fn create_offset_label(offset: usize) -> String
{
  format!("off_{:X}", offset)
}

pub fn compile_from_bytecode<W: Write, T: X8664Writer<W>>(
  build_options: &BuildOptions,
  output: &BytecodeOutput,
  writer: &mut T,
) -> Result<()>
{
  write_preamble(output.grammar, writer)?;

  let mut offset = FIRST_STATE_ADDRESS as usize;

  let mut addresses = output
    .ir_states
    .values()
    .filter(|s| !s.is_scanner())
    .map(|s| output.state_name_to_offset.get(&s.get_name()).unwrap())
    .cloned()
    .collect::<VecDeque<_>>();

  let mut seen = BTreeSet::new();

  while let Some(address) = addresses.pop_front() {
    if (seen.insert(address)) {
      eprintln!("{:X}", address);
      let mut referenced_addresses = Vec::new();

      write_state(
        build_options,
        output,
        writer,
        address as usize,
        None,
        false,
        &mut referenced_addresses,
      )?;

      for address in referenced_addresses {
        addresses.push_front(address);
      }
    }
  }

  Ok(())
}
