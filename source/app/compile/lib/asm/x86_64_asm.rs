//! This following is a list of registers that a reserved for specific purposes:
//! ### While in recognizer mode states:
//! - r15 - stores the state metadata
//! - rbx - stores the address of the [parser context](hctk::types::ASMParserContext)
//! - rbp - stores the address of the [reader](hctk::types::CharacterReader)
//! ### While in scanner mode states:
//! Same as above, with the additional registers:
//! - rdx - stores packed character data. see [hctk::types::SymbolReader::get_type_info]
//! - r12 - stores token offset data: byte offset in high 32, and codepoint offset in lower 32
//! - r13 - stores token length data: byte length in high 32, and codepoint length in lower 32
//! - r14 - stores accepted token offset data

use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::io::Result;
use std::io::Write;

use hctk::bytecode::constants::*;
use hctk::bytecode::BytecodeOutput;

use hctk::grammar::get_exported_productions;
use hctk::grammar::ExportedProduction;
use hctk::types::*;

use crate::writer::x86_64_writer::X8664Writer;

pub fn _undefined<W: Write, T: X8664Writer<W>>(
    _grammar: &GrammarStore,
    _bytecode: &[u32],
    _writer: &mut T,
) -> Result<()>
{
    Ok(())
}

const parse_context_size: usize =
    std::mem::size_of::<ParseContext<UTF8StringReader>>();

const stack_ref_size: usize = std::mem::size_of::<Vec<u8>>();

const token_size: usize = std::mem::size_of::<ParseToken>();

pub fn write_preamble<W: Write, T: X8664Writer<W>>(
    grammar: &GrammarStore,
    writer: &mut T,
) -> Result<()>
{
    // Disclaimer and constants
    writer
        .comment_line("This is a parser generated by the Hydrocarbon Toolkit.")?
        .comment_line("Any modifications may be overwritten without warning!")?
        .newline()?
        .constant("ParseAction_Undefined      ", &(0).to_string())?
        .constant("ParseAction_CompleteState  ", &(1).to_string())?
        .constant("ParseAction_FailState      ", &(2).to_string())?
        .constant("ParseAction_ScannerToken   ", &(3).to_string())?
        .constant("ParseAction_Fork           ", &(4).to_string())?
        .constant("ParseAction_Shift          ", &(5).to_string())?
        .constant("ParseAction_Reduce         ", &(6).to_string())?
        .constant("ParseAction_Accept         ", &(7).to_string())?
        .constant("ParseAction_Error          ", &(8).to_string())?
        .constant("FAIL_STATE_MASK          ", &FAIL_STATE_MASK.to_string())?
        .constant("NORMAL_STATE_MASK        ", &NORMAL_STATE_MASK.to_string())?
        .constant("PEEK_MODE_FLAG           ", &PEEK_MODE_FLAG.to_string())?
        .constant(
            "PEEK_MODE_FLAG_INVERT    ",
            &(!(PEEK_MODE_FLAG as u64)).to_string(),
        )?
        .constant(
            "PRODUCTION_META_MASK           ",
            &PRODUCTION_META_MASK.to_string(),
        )?
        .constant(
            "PRODUCTION_META_MASK_INVERT           ",
            &PRODUCTION_META_MASK_INVERT.to_string(),
        )?
        .constant(
            "STATE_TYPE_MASK        ",
            &(NORMAL_STATE_MASK + FAIL_STATE_MASK).to_string(),
        )?
        .constant(
            "STATE_TYPE_MASK_INVERT        ",
            &(!((NORMAL_STATE_MASK + FAIL_STATE_MASK) as u64)).to_string(),
        )?
        .constant(
            "TOKEN_TYPE_META_MASK_INVERT           ",
            &(0xFFFF_FFFFu64.to_string()),
        )?
        .constant(
            "STACK_ADDRESS_OFFSET     ",
            &(parse_context_size - stack_ref_size).to_string(),
        )?
        .constant("rbx_peek_token_offset            ", &(8 * 0).to_string())?
        .constant("rbx_anchor_token_offset          ", &(8 * 4).to_string())?
        .constant("rbx_assert_token_offset          ", &(8 * 8).to_string())?
        .constant("rbx_foreign_rsp_offset           ", &(8 * 12).to_string())?
        .constant("rbx_local_rsp_offset             ", &(8 * 13).to_string())?
        .constant("rbx_local_stack_base             ", &(8 * 14).to_string())?
        .constant("rbx_state_u64_data_offset        ", &(8 * 15).to_string())?
        .constant("rbx_action_pointer               ", &(8 * 16).to_string())?
        .constant("rbx_struct_reader_ptr_offset     ", &(8 * 17).to_string())?
        .constant("rbx_fn_get_line_data             ", &(8 * 18).to_string())?
        .constant("rbx_fn_get_length_data           ", &(8 * 19).to_string())?
        .constant("rbx_fn_next                      ", &(8 * 20).to_string())?
        .constant("rbx_fn_set_cursor                ", &(8 * 21).to_string())?
        .constant("tok_byte_offset                  ", &(4 * 0).to_string())?
        .constant("tok_cp_offset                    ", &(4 * 1).to_string())?
        .constant("tok_byte_length                  ", &(4 * 2).to_string())?
        .constant("tok_cp_length                    ", &(4 * 3).to_string())?
        // Scan byte offset and line number are aliases
        .constant("tok_scan_byte_offset             ", &(4 * 4).to_string())?
        .constant("tok_line_number                  ", &(4 * 4).to_string())?
        .constant("tok_line_offset                  ", &(4 * 5).to_string())?
        .constant("tok_padding                      ", &(4 * 6).to_string())?
        .constant("tok_type                         ", &(4 * 7).to_string())?
        .newline()?
        .newline()?;

    writer.section(".text")?;

    // Entry Points

    writer
        .commented_code(
            "global construct_context",
            "adjust stack information and initializes context variables",
        )?
        .commented_code(
            "global prime_context",
            "resets context and pops a starting state onto the stack",
        )?
        .commented_code(
            "global destroy_context",
            "freezes any extend stacks that been allocated to the context",
        )?
        .commented_code(
            "global next",
            "continue processing from the last state and yield the next action",
        )?
        .commented_code(
            "extern hctk_extend_stack",
            "acquire a new parse stack and move the contents of the old stack to the new one",
        )?
        .commented_code(
            "extern hctk_get_stack_pointer",
            "acquire the pointer to the stack buffer",
        )?
        .commented_code(
            "extern hctk_get_stack_size",
            "acquire the QWORD size of the stack buffer ",
        )?
        .code("default rel")?
        .newline()?
        .newline()?;

    writer
        .label("construct_context", false)?
        .code("push rbx")?
        .code("mov rbx, rdi")?
        .newline()?
        .comment_line("  Reserve the start of our state stack")?
        .code("lea rdi, [rbx + STACK_ADDRESS_OFFSET]")?
        .code("call hctk_get_stack_pointer")?
        .code("mov [rbx + rbx_local_stack_base], rax")?
        .code("lea rdi, [rbx + STACK_ADDRESS_OFFSET]")?
        .code("call hctk_get_stack_size")?
        .code("mov r10, [rbx + rbx_local_stack_base]")?
        .code("add r10, rax")?
        .code("mov [rbx + rbx_local_rsp_offset], r10")?
        .newline()?
        .comment_line("  Save our state stack")?
        .newline()?
        .code("pop rbx")?
        .newline()?
        .code("ret")?;

    writer
        .label("prime_context", false)?
        .inline(restore_context_external)?
        .comment_line("  Configure our parse state")?
        .comment_line("  Set the normal mode for our parse state")?
        .code("mov r10, ( NORMAL_STATE_MASK )")?
        .code("mov [rbx + rbx_state_u64_data_offset], r10")?
        .code("mov r11, rsi")?
        .code("xor esi, esi")?
        .inline_grammar(
            grammar,
            |writer, grammar: &GrammarStore| -> Result<&mut T> {
                // Create a simple lookup for a production entrypoint
                let vec = get_exported_productions(grammar);
                let last = vec.len() - 1;
                for (
                    i,
                    ExportedProduction {
                        export_name,
                        guid_name,
                        ..
                    },
                ) in vec.iter().enumerate()
                {
                    let (is_first, is_last) = (i == 0, last == i);

                    if !is_first {
                        writer.label(&format!("opt_{}", i), true)?;
                    }
                    writer.commented_code(
                        &format!("cmp  r11, {}", i),
                        &format!("{} as {}", guid_name, export_name),
                    )?;
                    if !is_last {
                        writer.code(&format!("jne .opt_{}", i + 1))?;
                    } else {
                        writer.code("jne .push_state")?;
                    }
                    writer
                        .code(&format!("lea rax, [rel state_{}]", guid_name))?;
                    if !is_last {
                        writer.code("jmp .push_state")?;
                    }
                }
                Ok(writer)
            },
        )?
        .label("push_state", true)?
        .comment_line("  Add our return address")?
        .code("lea r10, [rel end_parse]")?
        .code("push r10")?
        .comment_line("  Add our stack sentinel")?
        .code("xor r10d, r10d")?
        .code("push r10")?
        .code("push r10")?
        .comment_line("  Push our entry state onto the stack")?
        .commented_code("mov r15, NORMAL_STATE_MASK", "state metadata")?
        .commented_code("push r15", "state metadata")?
        .commented_code("push rax", "state address")?
        .inline(save_context_external)?
        .code("ret")?;

    writer.newline()?.label("scan_handler", false)?;
    write_extend_stack_checker(writer, token_size as u32 * 2 + 8 * 12)?
        // Load data for new parse run. We create a new context
        // stores the just the offsets for tokens in the rbp register.
        .inline(save_context_internal)?
        .newline()?
        .comment_line("Update line number and offset info")?
        .code("mov rdi, [rbx + rbx_struct_reader_ptr_offset]")?
        .code("call [rbx + rbx_fn_get_line_data]")?
        .inline(restore_context_internal)?
        .comment_line("setup new context for scanner ------- ")?
        .code("push r15")?
        .commented_code("push rax", "line information")?
        .commented_code("push r14", "push the target token address")?
        .commented_code("push r12", "save the return address in the stack")?
        .code("lea r10, [rel scanner_complete]")?
        .commented_code("push r10", "push the address of the completer code")?
        .code("push 0")?
        .code("push 0")?
        .commented_code(
            "mov r15, NORMAL_STATE_MASK",
            "set scanner state metadata",
        )?
        .inline(save_context_internal)?
        .code("mov rsi, r14")?
        .code("mov rdi, [rbx + rbx_struct_reader_ptr_offset]")?
        .code("call [rbx + rbx_fn_set_cursor]")?
        .code("mov rdx, rax")?
        .inline(restore_context_internal)?
        .code("mov r8, r13")?
        .code("mov r12,  [r14 + tok_byte_offset]")?
        .code("mov r13,  [r14 + tok_byte_length]")?
        .code("jmp r8")?
        .newline()?
        .label("scanner_complete", false)?
        .code("test r15, FAIL_STATE_MASK")?
        .code("jz .create_token")?
        .label("create_token", true)?
        .commented_code("pop rdi", "pop the state return address")?
        .commented_code("pop rax", "pop the target token address")?
        .commented_code("pop r8", "line info")?
        .code("mov rcx, [rax + tok_byte_offset]")?
        .code("sub r14, rcx")?
        .code("mov [rax + tok_byte_length], r14")?
        .code("mov [rax + tok_line_number], r8")?
        .code("mov [rax + tok_padding], r15")?
        .code("mov rax, r15")?
        .code("shr rax, 32")?
        .code("pop r15")?
        .code("jmp rdi")?
        .newline()?;

    writer
        .newline()?
        .label("next", false)?
        .inline(restore_context_external)?
        .newline()?
        .label("dispatch_loop", false)?
        .commented_code("pop r8", "state address")?
        .commented_code("pop r9", "state metadata")?
        .newline()?
        .comment_line("Test for bottom of stack sentinel")?
        .commented_code("test r9,r9", "test to see if state metadata is 0")?
        .commented_code(
            "jnz .have_state", "stop parsing if we have no more actions",
        )?
        .code("pop r10")?
        .code("jmp r10")?
        .newline()?
        .label("have_state", true)?
        .comment_line("Test for state appropriateness in current context")?
        .commented_code("mov r10, r15", "get copy of our context state")?
        .commented_code("and r10, STATE_TYPE_MASK", "mask out the mode")?
        .commented_code(
            "test r10, r9",
            "if this is zero then we are not allowed to use this state in the current context",
        )?
        .code("jz dispatch_loop")?
        .newline()?
        .comment_line("Dispatch!")?
        .commented_code("jmp r8", "go to the state")?
        .newline()?;

    writer
        .label("emit_action", false)?
        .comment_line("  Save our parse state")?
        .code("mov [rbx + rbx_state_u64_data_offset], r15")?
        .inline(save_context_external)?
        .code("xor eax, eax")?
        .code("inc eax")?
        .code("ret")?
        .newline()?;

    writer
        .label("end_parse", false)?
        .code("mov rax, [rbx + rbx_action_pointer]")?
        .code("mov DWORD [rax], ParseAction_Accept")?
        .code("mov r10, r15")?
        .code("mov r11, PRODUCTION_META_MASK")?
        .code("and r10, r11")?
        .code("mov DWORD [rax + 8], r10d")?
        .inline(save_context_external)?
        .code("ret")?
        .newline()?;

    writer
        .newline()?
        .label("destroy_context", false)?
        .code("ret")?
        .newline()?;

    writer
        .label("extend_stack", false)?
        // write_extend_stack_checker:
        // Loads rax for the difference and rcx for the return
        // address
        .code("push rcx")?
        .inline(save_context_internal)?
        .code("push rax")?
        .code("lea rdi, [rbx + STACK_ADDRESS_OFFSET]")?
        .code("call hctk_extend_stack")?
        .code("cmp rax, 0")?
        .code("je .extend_stack_fail")?
        .code("lea rdi, [rbx + STACK_ADDRESS_OFFSET]")?
        .code("call hctk_get_stack_pointer")?
        .code("mov [rbx + rbx_local_stack_base], rax")?
        .code("lea rdi, [rbx + STACK_ADDRESS_OFFSET]")?
        .code("call hctk_get_stack_size")?
        .code("mov r10, [rbx + rbx_local_stack_base]")?
        .code("add r10, rax")?
        .code("pop rax")?
        .code("sub r10, rax")?
        .code("mov [rbx + rbx_local_rsp_offset], r10")?
        .inline(restore_context_internal)?
        .code("pop rcx")?
        .code("jmp rcx")?
        .label("extend_stack_fail", true)?
        .inline(save_context_external)?
        .code("xor eax, eax")?
        .code("ret")?
        .newline()?;

    write_emit_shift(writer)?;
    write_emit_reduce(writer)?;

    Ok(())
}

fn restore_context_external<W: Write, T: X8664Writer<W>>(
    writer: &mut T,
) -> Result<&mut T>
{
    writer
        .comment_line("Restoring context")?
        .commented_code("push r12", "preserve r12")?
        .commented_code("push r13", "preserve r13")?
        .commented_code("push r14", "preserve r14")?
        .commented_code("push r15", "preserve r15")?
        .commented_code("push rbx", "preserve rbx")?
        .commented_code("push rbp", "preserve the base pointer")?
        .commented_code(
            "mov rbx, rdi",
            "make our offsets relative to the parse context",
        )?
        .commented_code(
            "mov [rbx + rbx_action_pointer], rsi",
            "preserve reference to our action",
        )?
        .commented_code("mov rbp, rsp", "preserve the outside stack")?
        .commented_code(
            "mov rsp, [rbx + rbx_local_rsp_offset]",
            "restore our local state stack",
        )?
        .code("mov r15, [rbx + rbx_state_u64_data_offset]")
}

fn save_context_external<W: Write, T: X8664Writer<W>>(
    writer: &mut T,
) -> Result<&mut T>
{
    writer
        .comment_line("Saving context")?
        .code("mov [rbx + rbx_state_u64_data_offset], r15")?
        .commented_code(
            "mov [rbx + rbx_local_rsp_offset], rsp",
            "preserve our local stack",
        )?
        .commented_code("mov rsp, rbp", "restore outside stack")?
        .commented_code("pop rbp", "restore the base pointer")?
        .commented_code("pop rbx", "restore rbx")?
        .commented_code("pop r15", "restore r15")?
        .commented_code("pop r14", "restore r14")?
        .commented_code("pop r13", "restore r13")?
        .commented_code("pop r12", "restore r12")
}

fn save_context_internal<W: Write, T: X8664Writer<W>>(
    writer: &mut T,
) -> Result<&mut T>
{
    writer
        .comment_line("Saving context")?
        .commented_code("XCHG rbp, rsp", "preserve our local stack")
}
fn restore_context_internal<W: Write, T: X8664Writer<W>>(
    writer: &mut T,
) -> Result<&mut T>
{
    writer
        .comment_line("Restoring context")?
        .commented_code("XCHG rsp, rbp", "restore our local stack")
}

pub fn write_state<W: Write, T: X8664Writer<W>>(
    output: &BytecodeOutput,
    writer: &mut T,
    mut offset: usize,
    name: Option<&String>,
    mut is_scanner: bool,
) -> Result<usize>
{
    let BytecodeOutput {
        bytecode,
        offset_to_state_name,
        ..
    } = output;

    if offset >= bytecode.len() {
        return Ok(bytecode.len());
    }
    if let Some((asm_state_name, ir_state_name)) = if name.is_some() {
        Some((name.unwrap().clone(), String::new()))
    } else if let Some(name) = offset_to_state_name.get(&(offset as u32)) {
        Some((create_named_state_label(name), name.clone()))
    } else {
        None
    } {
        writer.label(&format!("{}", asm_state_name), false)?;

        if let Some(state) = output.ir_states.get(&ir_state_name) {
            match state.get_type() {
                IRStateType::ProductionStart
                | IRStateType::ScannerStart
                | IRStateType::ProductionGoto
                | IRStateType::ScannerGoto => {
                    println!("{} {}", asm_state_name, ir_state_name);
                    // TODO right checker for handling stack expansion.
                    if state.get_stack_depth() > 0 {
                        let needed_size = state.get_stack_depth() * 2 * 8;
                        write_extend_stack_checker(writer, needed_size)?;
                    }
                }
                _ => {}
            }

            is_scanner = state.is_scanner();
        }

        while offset < bytecode.len() {
            match bytecode[offset] & INSTRUCTION_HEADER_MASK {
                INSTRUCTION::I00_PASS => {
                    offset += 1;
                    writer.code("mov rax, STATE_TYPE_MASK_INVERT")?;
                    writer.code("and r15, rax")?;
                    writer.code("or r15, NORMAL_STATE_MASK")?;
                    writer.code("jmp dispatch_loop")?;
                    break;
                }

                INSTRUCTION::I01_CONSUME => {
                    if is_scanner {
                        // Reminder:
                        // r12 is token offset
                        // r13 is token length
                        if bytecode[offset] & 1 == 1 {
                            writer.code("xor r13d, r13d")?;
                        } else {
                            writer.code("add r12, r13")?;
                        }
                        writer
                            .inline(save_context_internal)?
                            .code("mov rsi, r13")?
                            .code("shr rsi, 32")?
                            .code(
                                "mov rdi, [rbx + rbx_struct_reader_ptr_offset]",
                            )?
                            .code("call [rbx + rbx_fn_next]")?
                            .code("mov rdx, rax")?
                            .inline(restore_context_internal)?;
                    } else {
                        writer.code("xor eax, eax")?;
                        if bytecode[offset] & 1 == 1 {
                            writer
                            .code("mov [rbx + rbx_assert_token_offset + tok_byte_length], rax")?;
                        }

                        let return_label = create_offset_label(offset);

                        writer
                            .code("push r15")?
                            .code(&format!("lea rax, [rel .{}]", return_label))?
                            .code("push rax")?
                            .code("jmp emit_shift")?
                            .label(&return_label, true)?;
                    }

                    offset += 1;
                }

                INSTRUCTION::I02_GOTO => {
                    let goto_offset =
                        bytecode[offset] & GOTO_INSTRUCTION_OFFSET_MASK;

                    let name = if let Some(name) =
                        offset_to_state_name.get(&goto_offset)
                    {
                        create_named_state_label(name)
                    } else {
                        create_offset_label(offset)
                    };

                    if bytecode[offset + 1] & INSTRUCTION_HEADER_MASK
                        == INSTRUCTION::I00_PASS
                    {
                        // Simply perform a jump to the applicable code
                        // skipping the pass instruction entirely
                        writer.code(&format!("jmp {}", name))?;
                        offset += 2;
                        break;
                    } else {
                        writer
                            .code(&format!("mov rax, NORMAL_STATE_MASK"))?
                            .code("push rax")?
                            .code(&format!("lea rax, [rel {}]", name))?
                            .code("push rax")?;
                    }
                    offset += 1;
                }

                INSTRUCTION::I03_SET_PROD => {
                    let production_id =
                        bytecode[offset] & INSTRUCTION_CONTENT_MASK;
                    writer
                        .comment_line("Set production")?
                        .code("mov rax, PRODUCTION_META_MASK_INVERT")?
                        .code("and r15, rax")?
                        .code(&format!("add r15, {}", production_id))?;
                    offset += 1;
                }

                INSTRUCTION::I04_REDUCE => {
                    let instruction = bytecode[offset];
                    let symbol_count = instruction >> 16 & 0x0FFF;
                    let body_id = instruction & 0xFFFF;

                    let return_label = create_offset_label(offset);
                    writer
                        .code("mov r8d, r15d")?
                        .code("and r8d, PRODUCTION_META_MASK")?
                        .code(&format!("mov r9d, {}", body_id))?
                        .code(&format!("mov r10d, {}", symbol_count))?
                        .code("push r15")?
                        .code(&format!("lea rax, [rel .{}]", return_label))?
                        .code("push rax")?
                        .code("jmp emit_reduce")?
                        .label(&return_label, true)?;
                    writer.commented_code("nop", "reduce")?;
                    offset += 1;
                }

                INSTRUCTION::I05_TOKEN => {
                    let value = bytecode[offset] & 0x00FF_FFFF;
                    writer
                        .comment_line("Set token")?
                        .commented_code("mov r14, r12", "token offset")?
                        .code("mov rax, TOKEN_TYPE_META_MASK_INVERT")?
                        .code("and r15, rax")?
                        .code(&format!("mov rax, {}", (value as u64) << 32))?
                        .code("add r15, rax")?;
                    offset += 1;
                }

                INSTRUCTION::I06_FORK_TO => {
                    let instruction = bytecode[offset];
                    let instruction = instruction & INSTRUCTION_CONTENT_MASK;
                    let target_production = instruction & 0xFFFF;
                    let num_of_states = (instruction >> 16) & 0xFFFF;
                    offset += (1 + num_of_states) as usize;
                    writer.commented_code("nop", "fork")?;
                    writer.code("jmp emit_action")?;
                    break;
                }

                INSTRUCTION::I07_SCAN => {
                    offset += 1;
                    writer.commented_code("nop", "scan")?;
                }

                INSTRUCTION::I08_NOOP => {
                    offset += 1;
                    writer.commented_code("nop", "no operation")?;
                }

                INSTRUCTION::I09_VECTOR_BRANCH => {
                    let (
                        table_name,
                        input_type,
                        lexer_type,
                        table_length,
                        table_meta,
                        scanner_offset,
                    ) = extract_table_data(offset, bytecode);

                    writer.label(&table_name, false)?;

                    let mut is_infallible = false;
                    create_value_lookup(
                        input_type,
                        lexer_type,
                        scanner_offset,
                        &mut is_infallible,
                        writer,
                        offset,
                        output,
                    )?;

                    // Write default handling code.
                    writer
                        .code(&format!("sub rax, {}", table_meta))?
                        .code(&format!("jl {}_default", table_name))?
                        .code(&format!("cmp rax, {}", table_length))?
                        .code(&format!("jg {}_default", table_name))?;

                    let index_map = bytecode
                        [(offset + 4)..(offset + 4 + table_length as usize)]
                        .iter()
                        .enumerate()
                        .map(|(i, v)| (i, (i as u32, *v == 0xFFFF_FFFF)))
                        .collect();

                    // Extract our table values
                    create_branch_handler(
                        &index_map,
                        true,
                        true,
                        is_infallible,
                        writer,
                        &table_name,
                    )?;

                    // Offset to next state
                    offset = write_branches(
                        index_map
                            .values()
                            .cloned()
                            .map(|(a, b)| (a as usize, b))
                            .collect(),
                        offset + 4 + table_length as usize,
                        output,
                        writer,
                        table_name,
                        is_scanner,
                        lexer_type,
                    )?;

                    break;
                }

                INSTRUCTION::I10_HASH_BRANCH => {
                    let (
                        table_name,
                        input_type,
                        lexer_type,
                        table_length,
                        _,
                        scanner_offset,
                    ) = extract_table_data(offset, bytecode);

                    writer.label(&table_name, false)?;
                    let mut is_infallible = false;

                    create_value_lookup(
                        input_type,
                        lexer_type,
                        scanner_offset,
                        &mut is_infallible,
                        writer,
                        offset,
                        output,
                    )?;
                    let entries = &bytecode
                        [(offset + 4)..(offset + 4 + table_length as usize)];

                    // maps offsets to indices
                    let offset_map = entries
                        .iter()
                        .map(|e| (e >> 11) & 0x7FF)
                        .collect::<BTreeSet<_>>()
                        .into_iter()
                        .enumerate()
                        .map(|(i, v)| (v, (i, v == 0x7FF)))
                        .collect::<BTreeMap<_, _>>();

                    // Extract our table values
                    create_branch_handler(
                        &entries
                            .iter()
                            .map(|v| {
                                let offset = (*v >> 11) & 0x7FF;
                                (
                                    // Extract the index value from the hash offset
                                    (offset_map.get(&offset).unwrap().0),
                                    // Extract the value from the hash entry
                                    (v & 0x7FF, offset == 0x7FF),
                                )
                            })
                            .collect(),
                        true,
                        true,
                        is_infallible,
                        writer,
                        &table_name,
                    )?;

                    offset = write_branches(
                        offset_map.values().cloned().collect(),
                        offset + 4 + table_length as usize,
                        output,
                        writer,
                        table_name,
                        is_scanner,
                        lexer_type,
                    )?;

                    break;
                }

                INSTRUCTION::I11_SET_FAIL_STATE => {
                    offset += 1;
                    writer.commented_code("nop", "set fail state")?;
                }

                INSTRUCTION::I12_REPEAT => {
                    offset += 1;
                    writer.commented_code("nop", "repeats")?;
                }

                INSTRUCTION::I13_NOOP => {
                    offset += 1;
                    writer.commented_code("nop", "no operation 13")?;
                }

                INSTRUCTION::I14_ASSERT_CONSUME => {
                    offset += 1;
                    writer.commented_code("nop", "assert consume")?;
                }
                INSTRUCTION::I15_FAIL => {
                    offset += 1;
                    writer.code("mov rax, STATE_TYPE_MASK_INVERT")?;
                    writer.code("and r15, rax")?;
                    writer.code("or r15, FAIL_STATE_MASK")?;
                    writer.code("jmp dispatch_loop")?;
                    break;
                }
                _ => {
                    offset += 1;
                    writer.code("nop")?;
                }
            }
        }
    } else {
        writer.code("nop")?;
        offset += 1;
    }

    Ok(offset)
}

fn write_emit_shift<W: Write, T: X8664Writer<W>>(
    writer: &mut T,
) -> Result<&mut T>
{
    writer
        .label("emit_shift", false)?
        .code("lea rsi, [rbx + rbx_assert_token_offset]")?
        .code("lea rdi, [rbx + rbx_anchor_token_offset]")?
        .code("mov r12, [rdi + tok_byte_offset]")?
        .code("mov r13, [rdi + tok_line_number]")?
        .code("mov r8, [rsi + tok_byte_length]")?
        .code("mov r9, [rsi + tok_byte_offset]")?
        .code("mov r10, [rsi + tok_line_number]")?
        .code("mov r11, [rsi + tok_padding]")?
        .code("mov rcx, r9")?
        .code("add rcx, r8")?
        .code("mov QWORD [rsi + tok_byte_length], 0")?
        .code("mov [rsi + tok_byte_offset], rcx")?
        .code("mov [rsi + tok_line_number], r10")?
        .code("mov QWORD [rsi + tok_padding], 0")?
        .code("mov QWORD [rdi + tok_byte_length], 0")?
        .code("mov [rdi + tok_byte_offset], rcx")?
        .code("mov [rdi + tok_line_number], r10")?
        .code("mov QWORD [rdi + tok_padding], 0")?
        .code("mov rax, [rbx + rbx_action_pointer]")?
        .code("mov DWORD [rax], ParseAction_Shift")?
        .code("mov rcx, r9")?
        .code("sub rcx, r12")?
        .code("mov [rax + 8 + tok_byte_length], rcx")?
        .code("mov [rax + 8 + tok_byte_offset], r12")?
        .code("mov [rax + 8 + tok_line_number], r13")?
        .code("mov QWORD [rax + 8 + tok_padding], 0")?
        .code("mov [rax + 40 + tok_byte_length], r8")?
        .code("mov [rax + 40 + tok_byte_offset], r9")?
        .code("mov [rax + 40 + tok_line_number], r10")?
        .code("mov [rax + 40 + tok_padding], r11")?
        .inline(save_context_external)?
        .code("ret")
}

fn write_emit_reduce<W: Write, T: X8664Writer<W>>(
    writer: &mut T,
) -> Result<&mut T>
{
    writer
        .label("emit_reduce", false)?
        .code("mov rax, [rbx + rbx_action_pointer]")?
        .code("mov DWORD [rax], ParseAction_Reduce")?
        .code("mov [rax + 8 + 0], r8d")?
        .code("mov [rax + 8 + 4], r9d")?
        .code("mov [rax + 8 + 8], r10d")?
        .inline(save_context_external)?
        .code("ret")
}

fn write_extend_stack_checker<W: Write, T: X8664Writer<W>>(
    writer: &mut T,
    needed_size: u32,
) -> Result<&mut T>
{
    writer
        .code("mov rax, rsp")?
        .code("mov rcx, [rbx + rbx_local_stack_base]")?
        .code("sub rax, rcx")?
        .code(&format!("cmp rax, {}", needed_size))?
        .code("jg .start")?
        .code("lea rcx, [rel .start]")?
        .code("jmp extend_stack")?
        .label("start", true)
}

fn write_branches<W: Write, T: X8664Writer<W>>(
    table_branches: Vec<(usize, bool)>,
    mut offset: usize,
    output: &BytecodeOutput,
    writer: &mut T,
    table_name: String,
    is_scanner: bool,
    lexer_type: u32,
) -> Result<usize>
{
    for (index, is_skip) in table_branches {
        let branch_name = format!("{}_{}", table_name, index);
        if is_skip {
            writer
                .label(&branch_name, false)?
                .comment_line(&format!("Skip this token",))?;
            match lexer_type {
                LEXER_TYPE::ASSERT => {
                    writer.code("lea rsi, [rbx + rbx_assert_token_offset]")?
                }
                _ => writer.code("lea rsi, [rbx + rbx_peek_token_offset]")?,
            }
            .code("mov r8, [rsi + tok_byte_length]")?
            .code("mov r9, [rsi + tok_byte_offset]")?
            .code("add r9, r8")?
            .code("mov QWORD [rsi + tok_padding], 0")?
            .code("mov QWORD [rsi + tok_byte_length], 0")?
            .code("mov r10, [rsi + tok_line_number]")?
            .code("mov [rsi + tok_line_number], r10")?
            .code("mov [rsi + tok_byte_offset], r9")?
            .code(&format!("jmp {}", table_name))?;
        } else {
            offset = write_state(
                output,
                writer,
                offset,
                Some(&branch_name),
                is_scanner,
            )?;
        }
    }

    offset = write_state(
        output,
        writer,
        offset,
        Some(&format!("{}_default", table_name)),
        is_scanner,
    )?;

    Ok(offset)
}

fn extract_table_data(
    offset: usize,
    bytecode: &Vec<u32>,
) -> (String, u32, u32, u32, u32, u32)
{
    let table_name = create_offset_label(offset);
    let i = offset;
    let (first, scanner_offset, third) =
        (bytecode[i], bytecode[i + 1], bytecode[i + 2]);

    let input_type = (first >> 22) & 0x7;
    let lexer_type = (first >> 26) & 0x3;
    let table_length = (third >> 16) & 0xFFFF;
    let table_meta = third & 0xFFFF;
    (
        table_name,
        input_type,
        lexer_type,
        table_length,
        table_meta,
        scanner_offset,
    )
}
fn create_named_state_label(name: &String) -> String
{
    format!("state_{}", name)
}

fn create_offset_label(offset: usize) -> String
{
    format!("off_{:X}", offset)
}

fn create_value_lookup<W: Write, T: X8664Writer<W>>(
    input_type: u32,
    lexer_type: u32,
    scanner_offset: u32,
    is_infallible: &mut bool,
    writer: &mut T,
    offset: usize,
    output: &BytecodeOutput,
) -> Result<()>
{
    match input_type {
        INPUT_TYPE::T01_PRODUCTION => {
            *is_infallible = true;
            writer
                .comment_line("get production value")?
                .code("mov rax, r15")?
                .code("and rax, PRODUCTION_META_MASK")?;
        }
        INPUT_TYPE::T02_TOKEN => {
            let label_name = create_offset_label(offset);
            let scan_state = output
                .offset_to_state_name
                .get(&(scanner_offset as u32))
                .unwrap();
            if (lexer_type == LEXER_TYPE::ASSERT) {
                writer
                    .comment_line("retrieving assert token data")?
                    .label(&label_name, false)?
                    .code("mov r10, PEEK_MODE_FLAG_INVERT")?
                    .commented_code("and rcx, r10", "unset peek mode")?
                    // set_base_token
                    .code("lea r14, [rel rbx + rbx_assert_token_offset]")?
                    .code("mov eax, [r14 + tok_type]")?
                    .code("cmp eax, 0")?
                    .code("jne .cached")?
            } else {
                let label_name = create_offset_label(offset);
                writer
                    .comment_line("retrieving peek token data")?
                    .label(&label_name, false)?
                    .code("lea r14, [rbx + rbx_peek_token_offset]")?
                    .code("mov r9, r14")?
                    .code("test ecx, PEEK_MODE_FLAG")?
                    .code("jnz .increment_peek")?
                    .code("lea r9, [rbx + rbx_assert_token_offset]")?
                    .code("or ecx, PEEK_MODE_FLAG")?
                    .label(".increment_peek", true)?
                    .newline()? // Update byte
                    .code("mov r10, [r9 + tok_byte_offset]")?
                    .code("mov r11, [r9 + tok_byte_length]")?
                    .code("add r10, r11")?
                    .code("mov [r14 + tok_byte_offset], r10")?
                    .newline()?
            }
            .code(&format!(
                "lea r13, [rel {}]",
                create_named_state_label(scan_state)
            ))?
            .code("lea r12, [rel .cached]")?
            .code("jmp scan_handler")?
            .label("cached", true)?;
        }
        _ => {
            match input_type {
                INPUT_TYPE::T05_BYTE => {
                    writer
                        .code("mov r13, 0x0000000100000001")?
                        .comment_line("Load the byte data in the low 8 bits")?
                        .code("mov eax, edx")?
                        .code("and eax, 0xFF")?;
                }
                INPUT_TYPE::T03_CLASS => {
                    writer
                        .code("mov r13, 0x0000010000000000")?
                        .code("mov r13w, dx")?
                        .code("shr r13, 8")?
                        .comment_line(
                            "Load the class data in the high 16 bits",
                        )?
                        .code("mov eax, edx")?
                        .code("shr rax, 16")?;
                }
                INPUT_TYPE::T04_CODEPOINT => {
                    writer
                        .code("mov r13, 0x0000010000000000")?
                        .code("mov r13w, dx")?
                        .code("shr r13, 8")?
                        .comment_line(
                            "Load the codepoint data in the high 32 bits",
                        )?
                        .code("mov rax, rdx")?
                        .code("shr rax, 32")?;
                }
                _ => {}
            };
        }
    }
    Ok(())
}

fn create_branch_handler<W: Write, T: X8664Writer<W>>(
    vals: &BTreeMap<usize, (u32, bool)>,
    is_one_span: bool,
    is_zero_offset: bool,
    is_infallible: bool,
    writer: &mut T,
    local_branch_name: &String,
) -> Result<()>
{
    if is_one_span && is_zero_offset && vals.len() > 5 {
        // Jump table
        writer
            .code("lea r10, [ .table ]")?
            .code("mov r11, r10")?
            .code("shl rax, 1")?
            .code("add r11, rax")?
            .code("xor eax, eax")?
            .code("mov ax, [r11]")?
            .code("add r10, rax")?
            .code("jump r10")?
            .newline()?
            .newline()?
            .write_internal(b"align 2")?
            .label(&format!("table"), true)?;
        for (i, _) in vals {
            writer.code(&format!(
                "DW ( {}_{} - {}.table ) ",
                local_branch_name, i, local_branch_name
            ))?;
        }
    } else if is_infallible {
        // Binary search
        // Sort based on value
        let sorted_val = vals
            .iter()
            .map(|(i, (v, skip))| (v, (i, skip)))
            .collect::<BTreeMap<_, _>>();
    } else {
        // Linear probe
        for (i, (val, skip)) in vals {
            writer.code(&format!("cmp rax, {}", val))?.code(&format!(
                "je {}",
                &format!("{}_{}", local_branch_name, i)
            ))?;
        }
        writer.code(&format!("jmp {}_default", local_branch_name))?;
    }
    Ok(())
}

pub fn compile_from_bytecode<W: Write, T: X8664Writer<W>>(
    output: &BytecodeOutput,
    writer: &mut T,
) -> Result<()>
{
    write_preamble(output.grammar, writer)?;
    let mut offset = FIRST_STATE_OFFSET as usize;

    while offset < output.bytecode.len() {
        offset = write_state(output, writer, offset, None, false)?;
    }

    Ok(())
}

#[cfg(test)]
mod test_x86_generation
{
    use crate::asm::x86_64_asm::compile_from_bytecode;
    use crate::writer::nasm_writer::NasmWriter;
    use crate::writer::x86_64_writer::X8664Writer;
    use hctk::bytecode::compile_bytecode;
    use hctk::debug::generate_disassembly;

    #[test]
    fn test_nasm_output_on_trivial_grammar()
    {
        use hctk::debug::compile_test_grammar;

        let grammar = compile_test_grammar(
            "
@IGNORE g:sp

@EXPORT test as entry

@EXPORT test as banner

@NAME nasm_test

<> test > \\hello \\world 
",
        );

        let output = compile_bytecode(&grammar, 1);

        let mut writer = NasmWriter::new(Vec::<u8>::new());

        let result = compile_from_bytecode(&output, &mut writer);

        // println!("{:#?}", output.state_name_to_offset);

        assert!(result.is_ok());

        println!("\n\n{}\n\n", generate_disassembly(&output, None));
        println!(
            "\n\n{}\n\n",
            String::from_utf8(writer.into_writer()).unwrap()
        );
    }
}
