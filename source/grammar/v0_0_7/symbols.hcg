# Copyright 2022 Anthony Weathersby

@IMPORT ./comments.hcg as cm

@IMPORT ./production_bodies.hcg as pb

@IMPORT ./format.hcg as fm

@IGNORE g:sp g:nl g:tab tk:cm::comment

#######################################################################################################################
######################################  SYMBOLS
########################################################################################################################

<> hcg_symbols > symbol(+)

<> condition_symbol_list > terminal_symbol(+)

<> lexer_symbols > lexer_symbol(+)

<> ignore_symbols > ignore_symbol(+)

<> lexer_symbol > 

        terminal_symbol

<> ignore_symbol > 
        
        terminal_symbol

<> annotated_symbol > symbol    

    |   symbol reference_symbol
        
        f:r { { t_AnnotatedSymbol, c_Symbol, symbol:$1, reference:$2 } }

<> annotated_production_symbol > production_symbol    

    |   production_symbol reference_symbol
        
        f:r { $1 }

<> symbol > 

        symbol \?      
        
        f:r { { t_OptionalSymbol, symbol:$1 } }

    |   \?- literal_symbol    

        f:r { { t_Not_Symbol, c_Symbol, symbol: $2, tok } }
    
    |   \<= terminal_symbol           
        
        f:r { { t_Look_Behind, c_Symbol, symbol: $2, tok } }

    |   \?= symbol
        
        f:r { { t_NonCaptureSymbol, c_Symbol, sym:$2 } }

    |   terminal_symbol

    |   group_symbol

    |   production_symbol

    |   symbol \(+  terminal_symbol?  \)
        
        f:r { { t_List_Production, c_Symbol, terminal_symbol:$3,  symbols:$1,  tok } }

    |   symbol \(* terminal_symbol?  \)
        
        f:r { { t_Optional_List_Production, c_Symbol, terminal_symbol:$3, symbols:$1,  tok } }

<> group_symbol > \( pb::production_bodies \)        
          
        f:r { { t_Group_Production, c_Symbol, bodies:$2,  tok } }  


<> production_token_symbol > 
    
    \tk: production_symbol       
    
        f:r { { t_Production_Token , c_Symbol , c_Token, production:$2,  tok } }

<> production_symbol >

        local_production_symbol
    
    |   imported_production_symbol

<>  terminal_symbol > 

        generated_symbol

    |   literal_symbol

    |   EOF_symbol

    |   fm::format_meta_symbol

    |   production_token_symbol     

<> reference_symbol > tk:reference_symbol_token

        f:r { { t_Reference , c_Symbol, val:str($1) } }

<> reference_symbol_token > \^ identifier

<> EOF_symbol > 
    
    \g:eof
    
        f:r { { t_End_Of_File , c_Symbol , c_Token,  tok } }

<> empty_symbol > 
    
    \$empty
    
        f:r { { t_Empty , c_Symbol ,  tok } }

<> generated_symbol > 
    
    \g: tk:identifier_syms
    
        f:r { { t_Generated , c_Symbol , c_Token, val:str($2),  tok } }

<> literal_symbol > 
    
        \t: tk:defined_symbol
          
        f:r { { t_Exclusive_Literal , c_Symbol , c_Token, val:str($2),  tok } }
    
    |   ( g:sym | g:num )(+\" )

        f:r { { t_Literal , c_Symbol , c_Token, val:str($1),  tok } }

    |   \\ tk:defined_symbol
    
        f:r { { t_Literal , c_Symbol , c_Token, val:str($2),  tok } }  
    

<> defined_symbol > ( g:id | g:sym | g:num )(+)

<> local_production_symbol > 
    
    tk:identifier_syms
        
        f:r { { t_Production_Symbol , c_Symbol, name:str($1),   tok } }

<> imported_production_symbol > 

    tk:identifier_syms \:: tk:identifier_syms
        
        f:r { { t_Production_Import_Symbol , c_Symbol , module:str($1), name:str($3),  tok } } 

<> annotation_identifier > ( g:sym | g:id | g:num )(+\" ) g:sp? f:r { $1 }

<> production_id > tk:identifier_syms

<> identifier > tk:identifier_syms 

<> identifier_syms >  

        identifier_syms (RST g:sp g:nl) g:id
        
        f:r { $1 + $2 }

    |   identifier_syms (RST g:sp g:nl) \_

    |   identifier_syms (RST g:sp g:nl) \-
        
        f:r { $1 + $2 }

    |   identifier_syms (RST g:sp g:nl) g:num      
        
        f:r { $1 + $2 }

    |   \_ 

    |   \- 

    |   g:id

<> sym_delimiter >  g:sp | g:nl | ?=$eof

<> meta_symbol >   
        
        \(EXC condition_symbol_list \)

        f:r { { t_Exclude , c_Symbol , c_Meta, sym: $2, tok } }

    |   \(IGN condition_symbol_list \)    

        f:r { { t_Look_Ignore , c_Symbol , c_Meta,  sym: $2,tok } }

    |   \(RST condition_symbol_list \)

        f:r { { t_Look_Ignore , c_Symbol , c_Meta,   sym: $2, tok } }

<> any_group > \[ t:unordered? annotated_symbol(+) \]
        
    f:r { { t_AnyGroup, c_Symbol, symbols:$3, unordered: bool($2), tok } } 
