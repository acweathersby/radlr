@IMPORT ./script.hcg as ast
@IMPORT ./symbol.hcg as sym
@IMPORT ./syntax.hcg as syn
@IMPORT ./ir.hcg as ir

@NAME sherpa

@IGNORE g:sp g:nl 

@EXPORT grammar as grammar
@EXPORT ast::struct as ast_struct
@EXPORT ast::expression as ast_expression
@EXPORT ir::state as ir


<> grammar > 

        preamble(*) ( production | append_production )(+)

            f:ast {{ t_Grammar, c_Version_1_0, preamble:$1, productions:$2, tok }}

<> preamble >

        export_clause 

        | import_clause

        | name_clause

        | ignore_clause


<> export_clause > 

        t:EXPORT sym::non_terminal (( t:AS | t:as ) sym::identifier)?

            f:ast { { t_Export, c_Preamble, production:$2, reference:$3 } } 

<> import_clause > 

        t:IMPORT ( g:id | g:sym  )(+) g:sp ( \AS | \as ) sym::identifier

            f:ast { { t_Import, c_Preamble, uri: str($2), reference:str($5), tok } } 

<> ignore_clause >

        t:IGNORE t:{  ( sym::terminal_non_terminal | sym::terminal | sym::class )(+) t:}

            f:ast { { t_Ignore, c_Preamble, symbols: $3 } }

<> name_clause >

        t:NAME sym::identifier

            f:ast { { t_Name, c_Preamble, name: str($2) } }

<> production > 

        t:<  (template_name)(*\, )^t \> \lazy ?^l sym::priority?^p sym::non_terminal^n \> rules^r

            f:ast { { t_Production, is_lazy:bool($l), priority:$p, name:str($n), name_sym:$n, rules: $r, template_names:$t, tok } }

<> append_production > 

        t:+> ? sym::priority?^p sym::non_terminal^n \> rules^r

            f:ast { { t_Production, is_append: true, is_lazy:false, priority:$p, name:str($n), name_sym:$n, rules: $r, tok } }

<> template_name >  

    sym::identifier

           f:ast { str(tok) } 

<> rules > 

        rule(+t:| )

<> rule > 

        \! ?^p ( sym::annotated_symbol | any_group )(+)^s ast_definition?^a syntax_definition?^syn recover_definition?^rec

            f:ast { { t_Rule, is_priority:bool($p), symbols:$s, ast_definition:$a, syntax_definition:$syn, recover_definition:$rec, tok } }

<> ast_definition > 

        t::ast ast::body^ast

            f:ast {  { t_Ascript, c_Function, ast: $ast, tok }  }

<> syntax_definition > 

        t::syn syn::declaration

<> recover_definition > 

        t::rec \{ ir::state^state \}

            f:ast { {  t_Recovery, c_Function, state:$state, tok } }


+> sym::symbol > group

<> group > 

        t:( rules t:)        

            f:ast { { t_Group_Production, c_Symbol, rules:$2,  tok } }  

<> any_group > 

        \[ t:unordered ? sym::annotated_symbol(+)^s \]

            f:ast { { t_AnyGroup, unordered: bool($2), symbols:$s, tok } }

