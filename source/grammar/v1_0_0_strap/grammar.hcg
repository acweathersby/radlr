@IMPORT ./script.hcg as ast
@IMPORT ./symbol.hcg as sym
@IMPORT ./syntax.hcg as syn

@NAME sherpa

@IGNORE g:sp g:nl

@EXPORT grammar as grammar
@EXPORT ast::struct as ast_struct
@EXPORT ast::expression as ast_expression


<> grammar > 

        preamble(*) ( production | append_production )(+)

            f:ast {{ t_Grammar, c_Version_1_0, preamble:$1, productions:$2, tok }}

<> preamble >

        export_clause 

        | import_clause

        | name_clause

        | ignore_clause

<> export_clause > 

        t:EXPORT sym::non_terminal (( t:AS | t:as ) sym::identifier)?

            f:ast { { t_Export, c_Preamble, production:$2, reference:$3 } } 

<> import_clause > 

        t:IMPORT ( g:id | g:sym  )(+) ( t:AS | t:as ) sym::identifier

            f:ast { { t_Import, c_Preamble, uri: str($2), reference:str($4), tok } } 

<> ignore_clause >

        t:IGNORE t:{  sym::terminal(+) t:}

            f:ast { { t_Ignore, c_Preamble, symbols: $3 } }

<> name_clause >

        t:NAME sym::identifier

            f:ast { { t_Name, c_Preamble, name: str($2) } }

<> production > 

        t:<  (template_name)(*\, )^t \> \lazy ?^l sym::priority?^p sym::non_terminal^n \> rules^r

            f:ast { { t_Production, is_lazy:bool($l), priority:$p, name:str($n), name_sym:$n, rules: $r, template_names:$t, tok } }

<> append_production > 

        t:+> ?^l sym::priority?^p sym::non_terminal^n \> rules^r

            f:ast { { t_Production, is_append: true, is_lazy:false, priority:$p, name:str($n), name_sym:$n, rules: $r, tok } }

<> template_name >  

    sym::identifier

           f:ast { str(tok) } 

<> rules > 

        rule(+t:| )

<> rule > 

        \! ?^p ( sym::annotated_symbol | any_group )(+)^s ast_definition?^a syntax_definition?^syn

            f:ast { { t_Rule, is_priority:bool($p), symbols:$s, ast_definition:$a, syntax_definition:$syn, tok } }

<> ast_definition > 

        t::ast ast::body^ast

            f:ast {  { t_Ascript, c_Function, ast: $ast, tok }  }

<> syntax_definition > 

        t::syn syn::declaration


+> sym::symbol > group

+> sym::non_terminal > sym::non_terminal^p t:< sym::production_symbol^t t:>

        f:ast { { t_TemplateProductionSymbol, prod_sym:$p, template_productions:$t } }

<> group > 

        t:( rules t:)        

            f:ast { { t_Group_Production, c_Symbol, rules:$2,  tok } }  

<> any_group > 

        \[ t:unordered ? sym::annotated_symbol(+)^s \]

            f:ast { { t_AnyGroup, unordered: bool($2), symbols:$s, tok } }

