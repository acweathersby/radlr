use super::*;
use crate::{journal::Journal, Report};
use ::std::fmt::Display;
use std::{
  fmt::Debug,
  path::PathBuf,
  string::{FromUtf16Error, FromUtf8Error},
  sync::Arc,
};

pub(crate) mod severity {
  /// Severity types of SherpaErrors
  #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
  pub enum SherpaErrorSeverity {
    /// No error at all
    None,
    /// A hint that can be communicated to the user to improve some
    /// aspect of the grammar or parser.
    Hint,
    /// A warning that can be ignored but would yield better results
    /// if heeded.
    Warning,
    /// An error that compromises the integrate of the compile process
    /// and halts progression.
    Critical,
  }
}

pub use severity::SherpaErrorSeverity;

/// Stores every error type that can be generated by a sherpa function. Also wraps common
/// error types.
#[derive(Clone, Debug, Hash)]
pub enum SherpaError {
  /// A general structure for reporting an error that has occurred
  /// within an external source file.
  SourceError {
    /// Location of the error within a source file.
    loc:        Token,
    /// Path to the source file containing the error.
    path:       PathBuf,
    /// A unique identifier for this class of error, in the form `g:id(+)(\- g:id(+))(*)`
    id:         &'static str,
    /// The description of the error
    msg:        String,
    /// An optional inline message that appears inline
    /// within the error location diagram. Set to an empty string
    /// to prevents its display.
    inline_msg: String,
    /// An optional message that appears after the source diagram.
    ps_msg:     String,
    /// The severity of the error.
    severity:   SherpaErrorSeverity,
  },
  /// A general structure for reporting an error that has occurred
  /// within an external source file.
  SourcesError {
    /// A vector of source tuples, comprised of the source
    /// token, the path to source file that generated the token,
    /// and an inline string message which can be an empty string:
    /// An optional inline message that appears inline
    /// within the error location diagram. Set to an empty string
    /// to prevents its display.
    sources:  Vec<(Token, PathBuf, String)>,
    /// A unique identifier for this class of error, in the form `g:id(+)(\- g:id(+))(*)`
    id:       &'static str,
    /// The description of the error
    msg:      String,
    /// An optional message that appears after the source diagram.
    ps_msg:   String,
    /// The severity of the error.
    severity: SherpaErrorSeverity,
  },
  //---------------------------------------------------------------------------
  // ----------------- Generic Error Types ------------------------------------
  //---------------------------------------------------------------------------
  /// Error from an IO operation
  IOError(String),
  /// Generic error
  Error(std::fmt::Error),
  /// Plaintext error message
  Text(String),
  /// Errors stored in a Journal Report
  Report(Box<Report>),
}

use SherpaError::*;

impl From<&Report> for SherpaError {
  fn from(value: &Report) -> Self {
    Self::Report(Box::new(value.clone()))
  }
}

impl SherpaError {
  /// Return the Errors severity
  pub fn get_severity(&self) -> SherpaErrorSeverity {
    match self {
      _ => SherpaErrorSeverity::Critical,
    }
  }

  /// Convert SherpaParseError into SherpaError
  pub fn from_parse_error(err: SherpaParseError, path: PathBuf) -> SherpaError {
    Self::SourceError {
      loc: err.loc,
      path,
      id: "parse-error",
      msg: err.message,
      inline_msg: err.inline_message,
      ps_msg: Default::default(),
      severity: SherpaErrorSeverity::Critical,
    }
  }

  /// Compares the friendly name of an error with a string,
  /// returning `true` if the two match.
  pub fn is(&self, friendly_name: &str) -> bool {
    match self {
      _ => false,
    }
  }

  /// Todo
  pub fn is_critical(&self) -> bool {
    matches!(self.get_severity(), _Critical)
  }

  /// Todo
  pub fn is_hint(&self) -> bool {
    matches!(self.get_severity(), _Hint)
  }

  /// Todo
  pub fn is_warning(&self) -> bool {
    matches!(self.get_severity(), _Warning)
  }
}

impl From<std::io::Error> for SherpaError {
  fn from(err: std::io::Error) -> Self {
    IOError(err.to_string())
  }
}

impl From<std::fmt::Error> for SherpaError {
  fn from(err: std::fmt::Error) -> Self {
    Self::Error(err)
  }
}

impl From<()> for SherpaError {
  fn from(_: ()) -> Self {
    "UNDEFINED".into()
  }
}

impl From<&str> for SherpaError {
  fn from(err: &str) -> Self {
    Text(err.to_string())
  }
}

impl From<String> for SherpaError {
  fn from(err: String) -> Self {
    Text(err)
  }
}

impl From<FromUtf8Error> for SherpaError {
  fn from(err: FromUtf8Error) -> Self {
    Text(err.to_string())
  }
}

impl From<FromUtf16Error> for SherpaError {
  fn from(err: FromUtf16Error) -> Self {
    Text(err.to_string())
  }
}

impl From<SherpaParseError> for SherpaError {
  fn from(err: SherpaParseError) -> Self {
    Self::from_parse_error(err, Default::default())
  }
}

impl Display for SherpaError {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    match self {
      SourceError { msg, id, inline_msg, loc, path, ps_msg, .. } => f.write_fmt(format_args!(
        "\n{} [{}:{}]\n{}\n\n{}\n\n{}\n",
        id,
        path.to_str().unwrap(),
        loc.loc_stub(),
        msg.trim(),
        loc.blame(1, 1, &inline_msg.trim(), BlameColor::RED),
        ps_msg.trim()
      )),
      SourcesError { msg, id, sources, ps_msg, .. } => f.write_fmt(format_args!(
        "\n{}\n{}\n{}\n\n{}\n",
        id,
        msg.trim(),
        sources
          .iter()
          .map(|(tok, path, inline_message)| format!(
            "-- in [{}:{}]\n    {}",
            path.to_str().unwrap(),
            tok.loc_stub(),
            tok.blame(1, 1, inline_message, BlameColor::RED).replace("\n", "\n    ")
          ))
          .collect::<Vec<_>>()
          .join("\n"),
        ps_msg.trim()
      )),
      IOError(err_string) => f.write_fmt(format_args!("\nIO Error: {}", err_string)),
      Text(err_string) => f.write_str(&err_string),
      Report(r) => r.display_errors(f),
      Self::Error(error) => Display::fmt(error, f),
    }
  }
}
#[derive(Default, Debug)]
pub struct ErrorGroups {
  pub hints:    Vec<SherpaError>,
  pub warnings: Vec<SherpaError>,
  pub critical: Vec<SherpaError>,
}

pub trait SherpaErrorContainer {
  /// Returns a sorted set of SherpaErrors represented by ErrorGroups
  fn get_errors_types(&self) -> ErrorGroups;

  fn get_critical(&self) -> Vec<SherpaError> {
    self.get_errors_types().critical
  }

  fn get_warnings(&self) -> Vec<SherpaError> {
    self.get_errors_types().warnings
  }

  fn get_hints(&self) -> Vec<SherpaError> {
    self.get_errors_types().hints
  }

  fn have_errors(&self) -> bool;

  fn have_critical(&self) -> bool;

  fn have_warnings(&self) -> bool;

  fn have_hints(&self) -> bool;
}

impl SherpaErrorContainer for Vec<SherpaError> {
  fn get_errors_types(&self) -> ErrorGroups {
    let mut groups = ErrorGroups { ..Default::default() };
    for error in self {
      match error.get_severity() {
        _Critical => groups.critical.push(error.clone()),
        _Warning => groups.warnings.push(error.clone()),
        _Hint => groups.critical.push(error.clone()),
      }
    }

    groups
  }

  fn have_errors(&self) -> bool {
    !self.is_empty()
  }

  fn have_critical(&self) -> bool {
    self.iter().any(|e| e.is_critical())
  }

  fn have_hints(&self) -> bool {
    self.iter().any(|e| e.is_hint())
  }

  fn have_warnings(&self) -> bool {
    self.iter().any(|e| e.is_warning())
  }
}

impl From<&Vec<SherpaError>> for ErrorGroups {
  fn from(vec: &Vec<SherpaError>) -> Self {
    vec.get_errors_types()
  }
}

pub trait SherpaErrorPrint {
  /// Prints errors to io::stdout stream
  fn debug_print(&self);
  /// Prints errors to io::stderr stream
  fn stderr_print(&self);
}

impl SherpaErrorPrint for Vec<SherpaError> {
  fn debug_print(&self) {
    for error in self {
      eprintln!("{}", error.to_string());
    }
  }

  fn stderr_print(&self) {
    for error in self {
      eprintln!("{}", error.to_string());
    }
  }
}
