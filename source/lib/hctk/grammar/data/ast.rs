// **** DO NOT MODIFY **** DO NOT MODIFY **** DO NOT MODIFY ****
//
// This code has been automatically generated by Hydrocarbon Toolkit
//
// ###################################################################
//
// Copyright 2022 Anthony C. Weathersby
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

use std::cell::UnsafeCell;

use super::ast_node::HCObj;
use super::ast_node::HCObjTrait;
use super::ast_node::ReduceFunction;

use crate::types::Token;

type RF = ReduceFunction<ASTNode>;

type HCO = HCObj<ASTNode>;

#[derive(Debug, Clone)]
pub enum ASTNode {
  NONE,
  Grammar(Box<Grammar>),
  IR_STATE(Box<IR_STATE>),
  ASSERT(Box<ASSERT>),
  DEFAULT(Box<DEFAULT>),
  Num(Box<Num>),
  Production_Symbol(Box<Production_Symbol>),
  Production_Import_Symbol(Box<Production_Import_Symbol>),
  Reduce(Box<Reduce>),
  TokenAssign(Box<TokenAssign>),
  SetProd(Box<SetProd>),
  ForkTo(Box<ForkTo>),
  ScanUntil(Box<ScanUntil>),
  TokenId(Box<TokenId>),
  Skip(Box<Skip>),
  Pass(Box<Pass>),
  Fail(Box<Fail>),
  NotInScope(Box<NotInScope>),
  SetScope(Box<SetScope>),
  Consume(Box<Consume>),
  Ascript(Box<Ascript>),
  Returned(Box<Returned>),
  Referenced(Box<Referenced>),
  AST_Statements(Box<AST_Statements>),
  AST_Struct(Box<AST_Struct>),
  AST_Property(Box<AST_Property>),
  AST_TypeId(Box<AST_TypeId>),
  AST_ClassId(Box<AST_ClassId>),
  AST_Vector(Box<AST_Vector>),
  AST_Member(Box<AST_Member>),
  AST_NamedReference(Box<AST_NamedReference>),
  AST_IndexReference(Box<AST_IndexReference>),
  AST_STRING(Box<AST_STRING>),
  AST_Token(Box<AST_Token>),
  AST_U8(Box<AST_U8>),
  AST_U16(Box<AST_U16>),
  AST_U32(Box<AST_U32>),
  AST_U64(Box<AST_U64>),
  AST_I8(Box<AST_I8>),
  AST_I16(Box<AST_I16>),
  AST_I32(Box<AST_I32>),
  AST_I64(Box<AST_I64>),
  AST_F32(Box<AST_F32>),
  AST_F64(Box<AST_F64>),
  AST_BOOL(Box<AST_BOOL>),
  AST_NUMBER(Box<AST_NUMBER>),
  AST_Add(Box<AST_Add>),
  Reference(Box<Reference>),
  Generated(Box<Generated>),
  Exclusive_Literal(Box<Exclusive_Literal>),
  Literal(Box<Literal>),
  End_Of_File(Box<End_Of_File>),
  Space(Box<Space>),
  NewLine(Box<NewLine>),
  IncreaseIndent(Box<IncreaseIndent>),
  DecreaseIndent(Box<DecreaseIndent>),
  Production_Token(Box<Production_Token>),
  Goto(Box<Goto>),
  FailState(Box<FailState>),
  Symbols(Box<Symbols>),
  AnnotatedSymbol(Box<AnnotatedSymbol>),
  OptionalSymbol(Box<OptionalSymbol>),
  Not_Symbol(Box<Not_Symbol>),
  Look_Behind(Box<Look_Behind>),
  NonCaptureSymbol(Box<NonCaptureSymbol>),
  List_Production(Box<List_Production>),
  Optional_List_Production(Box<Optional_List_Production>),
  Group_Production(Box<Group_Production>),
  Body(Box<Body>),
  Exclude(Box<Exclude>),
  Look_Ignore(Box<Look_Ignore>),
  Empty(Box<Empty>),
  Production(Box<Production>),
  ProductionMerged(Box<ProductionMerged>),
  Ignore(Box<Ignore>),
  Import(Box<Import>),
  Export(Box<Export>),
  Name(Box<Name>),
  Out_Of_Band(Box<Out_Of_Band>),
  Repeat(Box<Repeat>),
  Lazy(Box<Lazy>),
  HASH_NAME(Box<HASH_NAME>),
  FunctionIndexNum(Box<FunctionIndexNum>),
  FunctionIndexWildCard(Box<FunctionIndexWildCard>),
  FunctionIndexId(Box<FunctionIndexId>),
}

impl HCObjTrait for ASTNode {
  fn to_string(&self) -> String {
    String::from("")
    // use ASTNode::*;
    // match self {
    //
    // Grammar(bx) => bx.tok.to_string(),
    //
    // IR_STATE(bx) => bx.tok.to_string(),
    //
    // ASSERT(bx) => bx.tok.to_string(),
    //
    // DEFAULT(bx) => bx.tok.to_string(),
    //
    // Num(bx) => bx.tok.to_string(),
    //
    // Production_Symbol(bx) => bx.tok.to_string(),
    //
    // Production_Import_Symbol(bx) => bx.tok.to_string(),
    //
    // Reduce(bx) => bx.tok.to_string(),
    //
    // TokenAssign(bx) => bx.tok.to_string(),
    //
    // SetProd(bx) => bx.tok.to_string(),
    //
    // ForkTo(bx) => bx.tok.to_string(),
    //
    // ScanUntil(bx) => bx.tok.to_string(),
    //
    // TokenId(bx) => bx.tok.to_string(),
    //
    // Skip(bx) => bx.tok.to_string(),
    //
    // Pass(bx) => bx.tok.to_string(),
    //
    // Fail(bx) => bx.tok.to_string(),
    //
    // NotInScope(bx) => bx.tok.to_string(),
    //
    // SetScope(bx) => bx.tok.to_string(),
    //
    // Consume(bx) => bx.tok.to_string(),
    //
    // Ascript(bx) => bx.tok.to_string(),
    //
    // Returned(bx) => bx.tok.to_string(),
    //
    // Referenced(bx) => bx.tok.to_string(),
    //
    // AST_Statements(bx) => bx.tok.to_string(),
    //
    // AST_Struct(bx) => bx.tok.to_string(),
    //
    // AST_Property(bx) => bx.tok.to_string(),
    //
    // AST_TypeId(bx) => bx.tok.to_string(),
    //
    // AST_ClassId(bx) => bx.tok.to_string(),
    //
    // AST_Vector(bx) => bx.tok.to_string(),
    //
    // AST_Member(bx) => bx.tok.to_string(),
    //
    // AST_NamedReference(bx) => bx.tok.to_string(),
    //
    // AST_IndexReference(bx) => bx.tok.to_string(),
    //
    // AST_STRING(bx) => bx.tok.to_string(),
    //
    // AST_Token(bx) => bx.tok.to_string(),
    //
    // AST_U8(bx) => bx.tok.to_string(),
    //
    // AST_U16(bx) => bx.tok.to_string(),
    //
    // AST_U32(bx) => bx.tok.to_string(),
    //
    // AST_U64(bx) => bx.tok.to_string(),
    //
    // AST_I8(bx) => bx.tok.to_string(),
    //
    // AST_I16(bx) => bx.tok.to_string(),
    //
    // AST_I32(bx) => bx.tok.to_string(),
    //
    // AST_I64(bx) => bx.tok.to_string(),
    //
    // AST_F32(bx) => bx.tok.to_string(),
    //
    // AST_F64(bx) => bx.tok.to_string(),
    //
    // AST_BOOL(bx) => bx.tok.to_string(),
    //
    // AST_NUMBER(bx) => bx.tok.to_string(),
    //
    // AST_Add(bx) => bx.tok.to_string(),
    //
    // Reference(bx) => bx.tok.to_string(),
    //
    // Generated(bx) => bx.tok.to_string(),
    //
    // Exclusive_Literal(bx) => bx.tok.to_string(),
    //
    // Literal(bx) => bx.tok.to_string(),
    //
    // End_Of_File(bx) => bx.tok.to_string(),
    //
    // Space(bx) => bx.tok.to_string(),
    //
    // NewLine(bx) => bx.tok.to_string(),
    //
    // IncreaseIndent(bx) => bx.tok.to_string(),
    //
    // DecreaseIndent(bx) => bx.tok.to_string(),
    //
    // Production_Token(bx) => bx.tok.to_string(),
    //
    // Goto(bx) => bx.tok.to_string(),
    //
    // FailState(bx) => bx.tok.to_string(),
    //
    // Symbols(bx) => bx.tok.to_string(),
    //
    // AnnotatedSymbol(bx) => bx.tok.to_string(),
    //
    // OptionalSymbol(bx) => bx.tok.to_string(),
    //
    // Not_Symbol(bx) => bx.tok.to_string(),
    //
    // Look_Behind(bx) => bx.tok.to_string(),
    //
    // NonCaptureSymbol(bx) => bx.tok.to_string(),
    //
    // List_Production(bx) => bx.tok.to_string(),
    //
    // Optional_List_Production(bx) => bx.tok.to_string(),
    //
    // Group_Production(bx) => bx.tok.to_string(),
    //
    // Body(bx) => bx.tok.to_string(),
    //
    // Exclude(bx) => bx.tok.to_string(),
    //
    // Look_Ignore(bx) => bx.tok.to_string(),
    //
    // Empty(bx) => bx.tok.to_string(),
    //
    // Production(bx) => bx.tok.to_string(),
    //
    // ProductionMerged(bx) => bx.tok.to_string(),
    //
    // Ignore(bx) => bx.tok.to_string(),
    //
    // Import(bx) => bx.tok.to_string(),
    //
    // Export(bx) => bx.tok.to_string(),
    //
    // Name(bx) => bx.tok.to_string(),
    //
    // Out_Of_Band(bx) => bx.tok.to_string(),
    //
    // Repeat(bx) => bx.tok.to_string(),
    //
    // Lazy(bx) => bx.tok.to_string(),
    //
    // HASH_NAME(bx) => bx.tok.to_string(),
    //
    // FunctionIndexNum(bx) => bx.tok.to_string(),
    //
    // FunctionIndexWildCard(bx) => bx.tok.to_string(),
    //
    // FunctionIndexId(bx) => bx.tok.to_string(),
    // _ => String::from(""),
    // }
  }
}

#[derive(Debug)]
pub enum NodeIteration<'a> {
  NONE,
  STOP,
  CONTINUE,
  REPLACE(ASTNode),
  Grammar(&'a mut Grammar),
  IR_STATE(&'a mut IR_STATE),
  ASSERT(&'a mut ASSERT),
  DEFAULT(&'a mut DEFAULT),
  Num(&'a mut Num),
  Production_Symbol(&'a mut Production_Symbol),
  Production_Import_Symbol(&'a mut Production_Import_Symbol),
  Reduce(&'a mut Reduce),
  TokenAssign(&'a mut TokenAssign),
  SetProd(&'a mut SetProd),
  ForkTo(&'a mut ForkTo),
  ScanUntil(&'a mut ScanUntil),
  TokenId(&'a mut TokenId),
  Skip(&'a mut Skip),
  Pass(&'a mut Pass),
  Fail(&'a mut Fail),
  NotInScope(&'a mut NotInScope),
  SetScope(&'a mut SetScope),
  Consume(&'a mut Consume),
  Ascript(&'a mut Ascript),
  Returned(&'a mut Returned),
  Referenced(&'a mut Referenced),
  AST_Statements(&'a mut AST_Statements),
  AST_Struct(&'a mut AST_Struct),
  AST_Property(&'a mut AST_Property),
  AST_TypeId(&'a mut AST_TypeId),
  AST_ClassId(&'a mut AST_ClassId),
  AST_Vector(&'a mut AST_Vector),
  AST_Member(&'a mut AST_Member),
  AST_NamedReference(&'a mut AST_NamedReference),
  AST_IndexReference(&'a mut AST_IndexReference),
  AST_STRING(&'a mut AST_STRING),
  AST_Token(&'a mut AST_Token),
  AST_U8(&'a mut AST_U8),
  AST_U16(&'a mut AST_U16),
  AST_U32(&'a mut AST_U32),
  AST_U64(&'a mut AST_U64),
  AST_I8(&'a mut AST_I8),
  AST_I16(&'a mut AST_I16),
  AST_I32(&'a mut AST_I32),
  AST_I64(&'a mut AST_I64),
  AST_F32(&'a mut AST_F32),
  AST_F64(&'a mut AST_F64),
  AST_BOOL(&'a mut AST_BOOL),
  AST_NUMBER(&'a mut AST_NUMBER),
  AST_Add(&'a mut AST_Add),
  Reference(&'a mut Reference),
  Generated(&'a mut Generated),
  Exclusive_Literal(&'a mut Exclusive_Literal),
  Literal(&'a mut Literal),
  End_Of_File(&'a mut End_Of_File),
  Space(&'a mut Space),
  NewLine(&'a mut NewLine),
  IncreaseIndent(&'a mut IncreaseIndent),
  DecreaseIndent(&'a mut DecreaseIndent),
  Production_Token(&'a mut Production_Token),
  Goto(&'a mut Goto),
  FailState(&'a mut FailState),
  Symbols(&'a mut Symbols),
  AnnotatedSymbol(&'a mut AnnotatedSymbol),
  OptionalSymbol(&'a mut OptionalSymbol),
  Not_Symbol(&'a mut Not_Symbol),
  Look_Behind(&'a mut Look_Behind),
  NonCaptureSymbol(&'a mut NonCaptureSymbol),
  List_Production(&'a mut List_Production),
  Optional_List_Production(&'a mut Optional_List_Production),
  Group_Production(&'a mut Group_Production),
  Body(&'a mut Body),
  Exclude(&'a mut Exclude),
  Look_Ignore(&'a mut Look_Ignore),
  Empty(&'a mut Empty),
  Production(&'a mut Production),
  ProductionMerged(&'a mut ProductionMerged),
  Ignore(&'a mut Ignore),
  Import(&'a mut Import),
  Export(&'a mut Export),
  Name(&'a mut Name),
  Out_Of_Band(&'a mut Out_Of_Band),
  Repeat(&'a mut Repeat),
  Lazy(&'a mut Lazy),
  HASH_NAME(&'a mut HASH_NAME),
  FunctionIndexNum(&'a mut FunctionIndexNum),
  FunctionIndexWildCard(&'a mut FunctionIndexWildCard),
  FunctionIndexId(&'a mut FunctionIndexId),
}

impl<'a> NodeIteration<'a> {
  pub fn name(&self) -> &str {
    use NodeIteration::*;
    match self {
      STOP => "stop",

      Grammar(_0) => "node-Grammar",
      IR_STATE(_0) => "node-IR_STATE",
      ASSERT(_0) => "node-ASSERT",
      DEFAULT(_0) => "node-DEFAULT",
      Num(_0) => "node-Num",
      Production_Symbol(_0) => "node-Production_Symbol",
      Production_Import_Symbol(_0) => "node-Production_Import_Symbol",
      Reduce(_0) => "node-Reduce",
      TokenAssign(_0) => "node-TokenAssign",
      SetProd(_0) => "node-SetProd",
      ForkTo(_0) => "node-ForkTo",
      ScanUntil(_0) => "node-ScanUntil",
      TokenId(_0) => "node-TokenId",
      Skip(_0) => "node-Skip",
      Pass(_0) => "node-Pass",
      Fail(_0) => "node-Fail",
      NotInScope(_0) => "node-NotInScope",
      SetScope(_0) => "node-SetScope",
      Consume(_0) => "node-Consume",
      Ascript(_0) => "node-Ascript",
      Returned(_0) => "node-Returned",
      Referenced(_0) => "node-Referenced",
      AST_Statements(_0) => "node-AST_Statements",
      AST_Struct(_0) => "node-AST_Struct",
      AST_Property(_0) => "node-AST_Property",
      AST_TypeId(_0) => "node-AST_TypeId",
      AST_ClassId(_0) => "node-AST_ClassId",
      AST_Vector(_0) => "node-AST_Vector",
      AST_Member(_0) => "node-AST_Member",
      AST_NamedReference(_0) => "node-AST_NamedReference",
      AST_IndexReference(_0) => "node-AST_IndexReference",
      AST_STRING(_0) => "node-AST_STRING",
      AST_Token(_0) => "node-AST_Token",
      AST_U8(_0) => "node-AST_U8",
      AST_U16(_0) => "node-AST_U16",
      AST_U32(_0) => "node-AST_U32",
      AST_U64(_0) => "node-AST_U64",
      AST_I8(_0) => "node-AST_I8",
      AST_I16(_0) => "node-AST_I16",
      AST_I32(_0) => "node-AST_I32",
      AST_I64(_0) => "node-AST_I64",
      AST_F32(_0) => "node-AST_F32",
      AST_F64(_0) => "node-AST_F64",
      AST_BOOL(_0) => "node-AST_BOOL",
      AST_NUMBER(_0) => "node-AST_NUMBER",
      AST_Add(_0) => "node-AST_Add",
      Reference(_0) => "node-Reference",
      Generated(_0) => "node-Generated",
      Exclusive_Literal(_0) => "node-Exclusive_Literal",
      Literal(_0) => "node-Literal",
      End_Of_File(_0) => "node-End_Of_File",
      Space(_0) => "node-Space",
      NewLine(_0) => "node-NewLine",
      IncreaseIndent(_0) => "node-IncreaseIndent",
      DecreaseIndent(_0) => "node-DecreaseIndent",
      Production_Token(_0) => "node-Production_Token",
      Goto(_0) => "node-Goto",
      FailState(_0) => "node-FailState",
      Symbols(_0) => "node-Symbols",
      AnnotatedSymbol(_0) => "node-AnnotatedSymbol",
      OptionalSymbol(_0) => "node-OptionalSymbol",
      Not_Symbol(_0) => "node-Not_Symbol",
      Look_Behind(_0) => "node-Look_Behind",
      NonCaptureSymbol(_0) => "node-NonCaptureSymbol",
      List_Production(_0) => "node-List_Production",
      Optional_List_Production(_0) => "node-Optional_List_Production",
      Group_Production(_0) => "node-Group_Production",
      Body(_0) => "node-Body",
      Exclude(_0) => "node-Exclude",
      Look_Ignore(_0) => "node-Look_Ignore",
      Empty(_0) => "node-Empty",
      Production(_0) => "node-Production",
      ProductionMerged(_0) => "node-ProductionMerged",
      Ignore(_0) => "node-Ignore",
      Import(_0) => "node-Import",
      Export(_0) => "node-Export",
      Name(_0) => "node-Name",
      Out_Of_Band(_0) => "node-Out_Of_Band",
      Repeat(_0) => "node-Repeat",
      Lazy(_0) => "node-Lazy",
      HASH_NAME(_0) => "node-HASH_NAME",
      FunctionIndexNum(_0) => "node-FunctionIndexNum",
      FunctionIndexWildCard(_0) => "node-FunctionIndexWildCard",
      FunctionIndexId(_0) => "node-FunctionIndexId",
      REPLACE(node) => "replace",
      _ => "unknown",
    }
  }
}

pub trait ASTNodeTraits<'a>
where
  Self: Sized,
{
  fn iterate(
    self: &'a mut Box<Self>,
    _yield: &'a mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>) -> NodeIteration<'a>,
  ) {
    let mut closure =
      |a: &mut NodeIteration<'a>, b: &mut NodeIteration<'a>, ty: u32, c: i32, d: i32| {
        use NodeIteration::*;
        match _yield(a, b) {
          STOP => false,
          REPLACE(node) => match b {
            Grammar(par) => {
              par.Replace(node, c, d);
              true
            }
            IR_STATE(par) => {
              par.Replace(node, c, d);
              true
            }
            ASSERT(par) => {
              par.Replace(node, c, d);
              true
            }
            DEFAULT(par) => {
              par.Replace(node, c, d);
              true
            }
            Num(par) => {
              par.Replace(node, c, d);
              true
            }
            Production_Symbol(par) => {
              par.Replace(node, c, d);
              true
            }
            Production_Import_Symbol(par) => {
              par.Replace(node, c, d);
              true
            }
            Reduce(par) => {
              par.Replace(node, c, d);
              true
            }
            TokenAssign(par) => {
              par.Replace(node, c, d);
              true
            }
            SetProd(par) => {
              par.Replace(node, c, d);
              true
            }
            ForkTo(par) => {
              par.Replace(node, c, d);
              true
            }
            ScanUntil(par) => {
              par.Replace(node, c, d);
              true
            }
            TokenId(par) => {
              par.Replace(node, c, d);
              true
            }
            Skip(par) => {
              par.Replace(node, c, d);
              true
            }
            Pass(par) => {
              par.Replace(node, c, d);
              true
            }
            Fail(par) => {
              par.Replace(node, c, d);
              true
            }
            NotInScope(par) => {
              par.Replace(node, c, d);
              true
            }
            SetScope(par) => {
              par.Replace(node, c, d);
              true
            }
            Consume(par) => {
              par.Replace(node, c, d);
              true
            }
            Ascript(par) => {
              par.Replace(node, c, d);
              true
            }
            Returned(par) => {
              par.Replace(node, c, d);
              true
            }
            Referenced(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_Statements(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_Struct(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_Property(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_TypeId(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_ClassId(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_Vector(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_Member(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_NamedReference(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_IndexReference(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_STRING(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_Token(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_U8(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_U16(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_U32(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_U64(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_I8(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_I16(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_I32(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_I64(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_F32(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_F64(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_BOOL(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_NUMBER(par) => {
              par.Replace(node, c, d);
              true
            }
            AST_Add(par) => {
              par.Replace(node, c, d);
              true
            }
            Reference(par) => {
              par.Replace(node, c, d);
              true
            }
            Generated(par) => {
              par.Replace(node, c, d);
              true
            }
            Exclusive_Literal(par) => {
              par.Replace(node, c, d);
              true
            }
            Literal(par) => {
              par.Replace(node, c, d);
              true
            }
            End_Of_File(par) => {
              par.Replace(node, c, d);
              true
            }
            Space(par) => {
              par.Replace(node, c, d);
              true
            }
            NewLine(par) => {
              par.Replace(node, c, d);
              true
            }
            IncreaseIndent(par) => {
              par.Replace(node, c, d);
              true
            }
            DecreaseIndent(par) => {
              par.Replace(node, c, d);
              true
            }
            Production_Token(par) => {
              par.Replace(node, c, d);
              true
            }
            Goto(par) => {
              par.Replace(node, c, d);
              true
            }
            FailState(par) => {
              par.Replace(node, c, d);
              true
            }
            Symbols(par) => {
              par.Replace(node, c, d);
              true
            }
            AnnotatedSymbol(par) => {
              par.Replace(node, c, d);
              true
            }
            OptionalSymbol(par) => {
              par.Replace(node, c, d);
              true
            }
            Not_Symbol(par) => {
              par.Replace(node, c, d);
              true
            }
            Look_Behind(par) => {
              par.Replace(node, c, d);
              true
            }
            NonCaptureSymbol(par) => {
              par.Replace(node, c, d);
              true
            }
            List_Production(par) => {
              par.Replace(node, c, d);
              true
            }
            Optional_List_Production(par) => {
              par.Replace(node, c, d);
              true
            }
            Group_Production(par) => {
              par.Replace(node, c, d);
              true
            }
            Body(par) => {
              par.Replace(node, c, d);
              true
            }
            Exclude(par) => {
              par.Replace(node, c, d);
              true
            }
            Look_Ignore(par) => {
              par.Replace(node, c, d);
              true
            }
            Empty(par) => {
              par.Replace(node, c, d);
              true
            }
            Production(par) => {
              par.Replace(node, c, d);
              true
            }
            ProductionMerged(par) => {
              par.Replace(node, c, d);
              true
            }
            Ignore(par) => {
              par.Replace(node, c, d);
              true
            }
            Import(par) => {
              par.Replace(node, c, d);
              true
            }
            Export(par) => {
              par.Replace(node, c, d);
              true
            }
            Name(par) => {
              par.Replace(node, c, d);
              true
            }
            Out_Of_Band(par) => {
              par.Replace(node, c, d);
              true
            }
            Repeat(par) => {
              par.Replace(node, c, d);
              true
            }
            Lazy(par) => {
              par.Replace(node, c, d);
              true
            }
            HASH_NAME(par) => {
              par.Replace(node, c, d);
              true
            }
            FunctionIndexNum(par) => {
              par.Replace(node, c, d);
              true
            }
            FunctionIndexWildCard(par) => {
              par.Replace(node, c, d);
              true
            }
            FunctionIndexId(par) => {
              par.Replace(node, c, d);
              true
            }
            _ => true,
          },
          _ => true,
        }
      };

    self.Iterate(&mut closure, &mut NodeIteration::NONE, 0, 0)
  }
  fn Replace(&mut self, node: ASTNode, i: i32, j: i32) -> ASTNode {
    ASTNode::NONE
  }
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  );
  fn Token(&self) -> Token;
  fn Type() -> u32;
  fn GetType(&self) -> u32;

  // fn serialize(ByteWriter) -> none
  // fn deserialize(ByteReader) -> Self
}

impl<'a> ASTNodeTraits<'a> for ASTNode
where
  Self: Sized,
{
  fn Replace(&mut self, n: ASTNode, i: i32, j: i32) -> ASTNode {
    use ASTNode::*;
    match self {
      Grammar(node) => node.as_mut().Replace(n, i, j),
      IR_STATE(node) => node.as_mut().Replace(n, i, j),
      ASSERT(node) => node.as_mut().Replace(n, i, j),
      DEFAULT(node) => node.as_mut().Replace(n, i, j),
      Num(node) => node.as_mut().Replace(n, i, j),
      Production_Symbol(node) => node.as_mut().Replace(n, i, j),
      Production_Import_Symbol(node) => node.as_mut().Replace(n, i, j),
      Reduce(node) => node.as_mut().Replace(n, i, j),
      TokenAssign(node) => node.as_mut().Replace(n, i, j),
      SetProd(node) => node.as_mut().Replace(n, i, j),
      ForkTo(node) => node.as_mut().Replace(n, i, j),
      ScanUntil(node) => node.as_mut().Replace(n, i, j),
      TokenId(node) => node.as_mut().Replace(n, i, j),
      Skip(node) => node.as_mut().Replace(n, i, j),
      Pass(node) => node.as_mut().Replace(n, i, j),
      Fail(node) => node.as_mut().Replace(n, i, j),
      NotInScope(node) => node.as_mut().Replace(n, i, j),
      SetScope(node) => node.as_mut().Replace(n, i, j),
      Consume(node) => node.as_mut().Replace(n, i, j),
      Ascript(node) => node.as_mut().Replace(n, i, j),
      Returned(node) => node.as_mut().Replace(n, i, j),
      Referenced(node) => node.as_mut().Replace(n, i, j),
      AST_Statements(node) => node.as_mut().Replace(n, i, j),
      AST_Struct(node) => node.as_mut().Replace(n, i, j),
      AST_Property(node) => node.as_mut().Replace(n, i, j),
      AST_TypeId(node) => node.as_mut().Replace(n, i, j),
      AST_ClassId(node) => node.as_mut().Replace(n, i, j),
      AST_Vector(node) => node.as_mut().Replace(n, i, j),
      AST_Member(node) => node.as_mut().Replace(n, i, j),
      AST_NamedReference(node) => node.as_mut().Replace(n, i, j),
      AST_IndexReference(node) => node.as_mut().Replace(n, i, j),
      AST_STRING(node) => node.as_mut().Replace(n, i, j),
      AST_Token(node) => node.as_mut().Replace(n, i, j),
      AST_U8(node) => node.as_mut().Replace(n, i, j),
      AST_U16(node) => node.as_mut().Replace(n, i, j),
      AST_U32(node) => node.as_mut().Replace(n, i, j),
      AST_U64(node) => node.as_mut().Replace(n, i, j),
      AST_I8(node) => node.as_mut().Replace(n, i, j),
      AST_I16(node) => node.as_mut().Replace(n, i, j),
      AST_I32(node) => node.as_mut().Replace(n, i, j),
      AST_I64(node) => node.as_mut().Replace(n, i, j),
      AST_F32(node) => node.as_mut().Replace(n, i, j),
      AST_F64(node) => node.as_mut().Replace(n, i, j),
      AST_BOOL(node) => node.as_mut().Replace(n, i, j),
      AST_NUMBER(node) => node.as_mut().Replace(n, i, j),
      AST_Add(node) => node.as_mut().Replace(n, i, j),
      Reference(node) => node.as_mut().Replace(n, i, j),
      Generated(node) => node.as_mut().Replace(n, i, j),
      Exclusive_Literal(node) => node.as_mut().Replace(n, i, j),
      Literal(node) => node.as_mut().Replace(n, i, j),
      End_Of_File(node) => node.as_mut().Replace(n, i, j),
      Space(node) => node.as_mut().Replace(n, i, j),
      NewLine(node) => node.as_mut().Replace(n, i, j),
      IncreaseIndent(node) => node.as_mut().Replace(n, i, j),
      DecreaseIndent(node) => node.as_mut().Replace(n, i, j),
      Production_Token(node) => node.as_mut().Replace(n, i, j),
      Goto(node) => node.as_mut().Replace(n, i, j),
      FailState(node) => node.as_mut().Replace(n, i, j),
      Symbols(node) => node.as_mut().Replace(n, i, j),
      AnnotatedSymbol(node) => node.as_mut().Replace(n, i, j),
      OptionalSymbol(node) => node.as_mut().Replace(n, i, j),
      Not_Symbol(node) => node.as_mut().Replace(n, i, j),
      Look_Behind(node) => node.as_mut().Replace(n, i, j),
      NonCaptureSymbol(node) => node.as_mut().Replace(n, i, j),
      List_Production(node) => node.as_mut().Replace(n, i, j),
      Optional_List_Production(node) => node.as_mut().Replace(n, i, j),
      Group_Production(node) => node.as_mut().Replace(n, i, j),
      Body(node) => node.as_mut().Replace(n, i, j),
      Exclude(node) => node.as_mut().Replace(n, i, j),
      Look_Ignore(node) => node.as_mut().Replace(n, i, j),
      Empty(node) => node.as_mut().Replace(n, i, j),
      Production(node) => node.as_mut().Replace(n, i, j),
      ProductionMerged(node) => node.as_mut().Replace(n, i, j),
      Ignore(node) => node.as_mut().Replace(n, i, j),
      Import(node) => node.as_mut().Replace(n, i, j),
      Export(node) => node.as_mut().Replace(n, i, j),
      Name(node) => node.as_mut().Replace(n, i, j),
      Out_Of_Band(node) => node.as_mut().Replace(n, i, j),
      Repeat(node) => node.as_mut().Replace(n, i, j),
      Lazy(node) => node.as_mut().Replace(n, i, j),
      HASH_NAME(node) => node.as_mut().Replace(n, i, j),
      FunctionIndexNum(node) => node.as_mut().Replace(n, i, j),
      FunctionIndexWildCard(node) => node.as_mut().Replace(n, i, j),
      FunctionIndexId(node) => node.as_mut().Replace(n, i, j),
      _ => ASTNode::NONE,
    }
  }

  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    use ASTNode::*;
    match self {
      Grammar(node) => node.as_mut().Iterate(_yield, parent, i, j),
      IR_STATE(node) => node.as_mut().Iterate(_yield, parent, i, j),
      ASSERT(node) => node.as_mut().Iterate(_yield, parent, i, j),
      DEFAULT(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Num(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Production_Symbol(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Production_Import_Symbol(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Reduce(node) => node.as_mut().Iterate(_yield, parent, i, j),
      TokenAssign(node) => node.as_mut().Iterate(_yield, parent, i, j),
      SetProd(node) => node.as_mut().Iterate(_yield, parent, i, j),
      ForkTo(node) => node.as_mut().Iterate(_yield, parent, i, j),
      ScanUntil(node) => node.as_mut().Iterate(_yield, parent, i, j),
      TokenId(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Skip(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Pass(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Fail(node) => node.as_mut().Iterate(_yield, parent, i, j),
      NotInScope(node) => node.as_mut().Iterate(_yield, parent, i, j),
      SetScope(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Consume(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Ascript(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Returned(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Referenced(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_Statements(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_Struct(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_Property(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_TypeId(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_ClassId(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_Vector(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_Member(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_NamedReference(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_IndexReference(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_STRING(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_Token(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_U8(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_U16(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_U32(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_U64(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_I8(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_I16(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_I32(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_I64(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_F32(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_F64(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_BOOL(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_NUMBER(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AST_Add(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Reference(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Generated(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Exclusive_Literal(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Literal(node) => node.as_mut().Iterate(_yield, parent, i, j),
      End_Of_File(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Space(node) => node.as_mut().Iterate(_yield, parent, i, j),
      NewLine(node) => node.as_mut().Iterate(_yield, parent, i, j),
      IncreaseIndent(node) => node.as_mut().Iterate(_yield, parent, i, j),
      DecreaseIndent(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Production_Token(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Goto(node) => node.as_mut().Iterate(_yield, parent, i, j),
      FailState(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Symbols(node) => node.as_mut().Iterate(_yield, parent, i, j),
      AnnotatedSymbol(node) => node.as_mut().Iterate(_yield, parent, i, j),
      OptionalSymbol(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Not_Symbol(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Look_Behind(node) => node.as_mut().Iterate(_yield, parent, i, j),
      NonCaptureSymbol(node) => node.as_mut().Iterate(_yield, parent, i, j),
      List_Production(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Optional_List_Production(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Group_Production(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Body(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Exclude(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Look_Ignore(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Empty(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Production(node) => node.as_mut().Iterate(_yield, parent, i, j),
      ProductionMerged(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Ignore(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Import(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Export(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Name(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Out_Of_Band(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Repeat(node) => node.as_mut().Iterate(_yield, parent, i, j),
      Lazy(node) => node.as_mut().Iterate(_yield, parent, i, j),
      HASH_NAME(node) => node.as_mut().Iterate(_yield, parent, i, j),
      FunctionIndexNum(node) => node.as_mut().Iterate(_yield, parent, i, j),
      FunctionIndexWildCard(node) => node.as_mut().Iterate(_yield, parent, i, j),
      FunctionIndexId(node) => node.as_mut().Iterate(_yield, parent, i, j),
      _ => {}
    }
  }

  fn Token(&self) -> Token {
    use ASTNode::*;
    match self {
      Grammar(node) => node.as_ref().Token(),
      IR_STATE(node) => node.as_ref().Token(),
      ASSERT(node) => node.as_ref().Token(),
      DEFAULT(node) => node.as_ref().Token(),
      Num(node) => node.as_ref().Token(),
      Production_Symbol(node) => node.as_ref().Token(),
      Production_Import_Symbol(node) => node.as_ref().Token(),
      Reduce(node) => node.as_ref().Token(),
      TokenAssign(node) => node.as_ref().Token(),
      SetProd(node) => node.as_ref().Token(),
      ForkTo(node) => node.as_ref().Token(),
      ScanUntil(node) => node.as_ref().Token(),
      TokenId(node) => node.as_ref().Token(),
      Skip(node) => node.as_ref().Token(),
      Pass(node) => node.as_ref().Token(),
      Fail(node) => node.as_ref().Token(),
      NotInScope(node) => node.as_ref().Token(),
      SetScope(node) => node.as_ref().Token(),
      Consume(node) => node.as_ref().Token(),
      Ascript(node) => node.as_ref().Token(),
      Returned(node) => node.as_ref().Token(),
      Referenced(node) => node.as_ref().Token(),
      AST_Statements(node) => node.as_ref().Token(),
      AST_Struct(node) => node.as_ref().Token(),
      AST_Property(node) => node.as_ref().Token(),
      AST_TypeId(node) => node.as_ref().Token(),
      AST_ClassId(node) => node.as_ref().Token(),
      AST_Vector(node) => node.as_ref().Token(),
      AST_Member(node) => node.as_ref().Token(),
      AST_NamedReference(node) => node.as_ref().Token(),
      AST_IndexReference(node) => node.as_ref().Token(),
      AST_STRING(node) => node.as_ref().Token(),
      AST_Token(node) => node.as_ref().Token(),
      AST_U8(node) => node.as_ref().Token(),
      AST_U16(node) => node.as_ref().Token(),
      AST_U32(node) => node.as_ref().Token(),
      AST_U64(node) => node.as_ref().Token(),
      AST_I8(node) => node.as_ref().Token(),
      AST_I16(node) => node.as_ref().Token(),
      AST_I32(node) => node.as_ref().Token(),
      AST_I64(node) => node.as_ref().Token(),
      AST_F32(node) => node.as_ref().Token(),
      AST_F64(node) => node.as_ref().Token(),
      AST_BOOL(node) => node.as_ref().Token(),
      AST_NUMBER(node) => node.as_ref().Token(),
      AST_Add(node) => node.as_ref().Token(),
      Reference(node) => node.as_ref().Token(),
      Generated(node) => node.as_ref().Token(),
      Exclusive_Literal(node) => node.as_ref().Token(),
      Literal(node) => node.as_ref().Token(),
      End_Of_File(node) => node.as_ref().Token(),
      Space(node) => node.as_ref().Token(),
      NewLine(node) => node.as_ref().Token(),
      IncreaseIndent(node) => node.as_ref().Token(),
      DecreaseIndent(node) => node.as_ref().Token(),
      Production_Token(node) => node.as_ref().Token(),
      Goto(node) => node.as_ref().Token(),
      FailState(node) => node.as_ref().Token(),
      Symbols(node) => node.as_ref().Token(),
      AnnotatedSymbol(node) => node.as_ref().Token(),
      OptionalSymbol(node) => node.as_ref().Token(),
      Not_Symbol(node) => node.as_ref().Token(),
      Look_Behind(node) => node.as_ref().Token(),
      NonCaptureSymbol(node) => node.as_ref().Token(),
      List_Production(node) => node.as_ref().Token(),
      Optional_List_Production(node) => node.as_ref().Token(),
      Group_Production(node) => node.as_ref().Token(),
      Body(node) => node.as_ref().Token(),
      Exclude(node) => node.as_ref().Token(),
      Look_Ignore(node) => node.as_ref().Token(),
      Empty(node) => node.as_ref().Token(),
      Production(node) => node.as_ref().Token(),
      ProductionMerged(node) => node.as_ref().Token(),
      Ignore(node) => node.as_ref().Token(),
      Import(node) => node.as_ref().Token(),
      Export(node) => node.as_ref().Token(),
      Name(node) => node.as_ref().Token(),
      Out_Of_Band(node) => node.as_ref().Token(),
      Repeat(node) => node.as_ref().Token(),
      Lazy(node) => node.as_ref().Token(),
      HASH_NAME(node) => node.as_ref().Token(),
      FunctionIndexNum(node) => node.as_ref().Token(),
      FunctionIndexWildCard(node) => node.as_ref().Token(),
      FunctionIndexId(node) => node.as_ref().Token(),
      _ => Token::empty(),
    }
  }

  fn GetType(&self) -> u32 {
    use ASTNode::*;
    match self {
      Grammar(node) => node.as_ref().GetType(),
      IR_STATE(node) => node.as_ref().GetType(),
      ASSERT(node) => node.as_ref().GetType(),
      DEFAULT(node) => node.as_ref().GetType(),
      Num(node) => node.as_ref().GetType(),
      Production_Symbol(node) => node.as_ref().GetType(),
      Production_Import_Symbol(node) => node.as_ref().GetType(),
      Reduce(node) => node.as_ref().GetType(),
      TokenAssign(node) => node.as_ref().GetType(),
      SetProd(node) => node.as_ref().GetType(),
      ForkTo(node) => node.as_ref().GetType(),
      ScanUntil(node) => node.as_ref().GetType(),
      TokenId(node) => node.as_ref().GetType(),
      Skip(node) => node.as_ref().GetType(),
      Pass(node) => node.as_ref().GetType(),
      Fail(node) => node.as_ref().GetType(),
      NotInScope(node) => node.as_ref().GetType(),
      SetScope(node) => node.as_ref().GetType(),
      Consume(node) => node.as_ref().GetType(),
      Ascript(node) => node.as_ref().GetType(),
      Returned(node) => node.as_ref().GetType(),
      Referenced(node) => node.as_ref().GetType(),
      AST_Statements(node) => node.as_ref().GetType(),
      AST_Struct(node) => node.as_ref().GetType(),
      AST_Property(node) => node.as_ref().GetType(),
      AST_TypeId(node) => node.as_ref().GetType(),
      AST_ClassId(node) => node.as_ref().GetType(),
      AST_Vector(node) => node.as_ref().GetType(),
      AST_Member(node) => node.as_ref().GetType(),
      AST_NamedReference(node) => node.as_ref().GetType(),
      AST_IndexReference(node) => node.as_ref().GetType(),
      AST_STRING(node) => node.as_ref().GetType(),
      AST_Token(node) => node.as_ref().GetType(),
      AST_U8(node) => node.as_ref().GetType(),
      AST_U16(node) => node.as_ref().GetType(),
      AST_U32(node) => node.as_ref().GetType(),
      AST_U64(node) => node.as_ref().GetType(),
      AST_I8(node) => node.as_ref().GetType(),
      AST_I16(node) => node.as_ref().GetType(),
      AST_I32(node) => node.as_ref().GetType(),
      AST_I64(node) => node.as_ref().GetType(),
      AST_F32(node) => node.as_ref().GetType(),
      AST_F64(node) => node.as_ref().GetType(),
      AST_BOOL(node) => node.as_ref().GetType(),
      AST_NUMBER(node) => node.as_ref().GetType(),
      AST_Add(node) => node.as_ref().GetType(),
      Reference(node) => node.as_ref().GetType(),
      Generated(node) => node.as_ref().GetType(),
      Exclusive_Literal(node) => node.as_ref().GetType(),
      Literal(node) => node.as_ref().GetType(),
      End_Of_File(node) => node.as_ref().GetType(),
      Space(node) => node.as_ref().GetType(),
      NewLine(node) => node.as_ref().GetType(),
      IncreaseIndent(node) => node.as_ref().GetType(),
      DecreaseIndent(node) => node.as_ref().GetType(),
      Production_Token(node) => node.as_ref().GetType(),
      Goto(node) => node.as_ref().GetType(),
      FailState(node) => node.as_ref().GetType(),
      Symbols(node) => node.as_ref().GetType(),
      AnnotatedSymbol(node) => node.as_ref().GetType(),
      OptionalSymbol(node) => node.as_ref().GetType(),
      Not_Symbol(node) => node.as_ref().GetType(),
      Look_Behind(node) => node.as_ref().GetType(),
      NonCaptureSymbol(node) => node.as_ref().GetType(),
      List_Production(node) => node.as_ref().GetType(),
      Optional_List_Production(node) => node.as_ref().GetType(),
      Group_Production(node) => node.as_ref().GetType(),
      Body(node) => node.as_ref().GetType(),
      Exclude(node) => node.as_ref().GetType(),
      Look_Ignore(node) => node.as_ref().GetType(),
      Empty(node) => node.as_ref().GetType(),
      Production(node) => node.as_ref().GetType(),
      ProductionMerged(node) => node.as_ref().GetType(),
      Ignore(node) => node.as_ref().GetType(),
      Import(node) => node.as_ref().GetType(),
      Export(node) => node.as_ref().GetType(),
      Name(node) => node.as_ref().GetType(),
      Out_Of_Band(node) => node.as_ref().GetType(),
      Repeat(node) => node.as_ref().GetType(),
      Lazy(node) => node.as_ref().GetType(),
      HASH_NAME(node) => node.as_ref().GetType(),
      FunctionIndexNum(node) => node.as_ref().GetType(),
      FunctionIndexWildCard(node) => node.as_ref().GetType(),
      FunctionIndexId(node) => node.as_ref().GetType(),
      _ => 0,
    }
  }

  fn Type() -> u32 {
    0
  }
}

#[derive(Debug, Clone)]
pub struct Grammar {
  pub preamble: Vec<ASTNode>, // VECTOR
  pub content:  Vec<ASTNode>, // VECTOR
  pub tok:      Token,        // TOKEN
}

impl Grammar {
  pub fn new(_preamble: Vec<ASTNode>, _content: Vec<ASTNode>, _tok: Token) -> Box<Self> {
    Box::new(Grammar { preamble: _preamble, content: _content, tok: _tok })
  }

  fn replace_preamble(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Ignore(_) | ASTNode::Import(_) | ASTNode::Export(_) | ASTNode::Name(_) => {
        if index as usize >= self.preamble.len() {
          self.preamble.push(child);
          None
        } else {
          self.preamble.push(child);
          let node = self.preamble.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.preamble.len() {
          let node = self.preamble.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }

  fn replace_content(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Production(_)
      | ASTNode::ProductionMerged(_)
      | ASTNode::Out_Of_Band(_)
      | ASTNode::IR_STATE(_) => {
        if index as usize >= self.content.len() {
          self.content.push(child);
          None
        } else {
          self.content.push(child);
          let node = self.content.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.content.len() {
          let node = self.content.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Grammar
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Grammar(*mut_me), parent, 360454, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).preamble.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).preamble[j];

        match child {
          ASTNode::Ignore(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Import(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Export(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Name(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 0, j as i32)
            };
          }
          _ => {}
        }
      }
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).content.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).content[j];

        match child {
          ASTNode::Production(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 1, j as i32)
            };
          }

          ASTNode::ProductionMerged(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 1, j as i32)
            };
          }

          ASTNode::Out_Of_Band(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 1, j as i32)
            };
          }

          ASTNode::IR_STATE(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Grammar(*mut_me), 1, j as i32)
            };
          }
          _ => {}
        }
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_preamble(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      1 => {
        if let Some(old) = self.replace_content(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 360454;
  }

  fn GetType(&self) -> u32 {
    return 360454;
  }
}

#[derive(Debug, Clone)]
pub struct IR_STATE {
  pub id:           String,                 // STRING
  pub scanner:      String,                 // STRING
  pub instructions: Vec<ASTNode>,           // VECTOR
  pub fail:         Option<Box<FailState>>, // FailState
  pub symbol_meta:  Option<Box<Symbols>>,   // Symbols
  pub prod:         ASTNode,                // Production_Symbol | Production_Import_Symbol
}

impl IR_STATE {
  pub fn new(
    _id: String,
    _scanner: String,
    _instructions: Vec<ASTNode>,
    _fail: Option<Box<FailState>>,
    _symbol_meta: Option<Box<Symbols>>,
    _prod: ASTNode,
  ) -> Box<Self> {
    Box::new(IR_STATE {
      id:           _id,
      scanner:      _scanner,
      instructions: _instructions,
      fail:         _fail,
      symbol_meta:  _symbol_meta,
      prod:         _prod,
    })
  }

  fn replace_instructions(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::ASSERT(_)
      | ASTNode::DEFAULT(_)
      | ASTNode::Repeat(_)
      | ASTNode::Reduce(_)
      | ASTNode::TokenAssign(_)
      | ASTNode::SetProd(_)
      | ASTNode::ForkTo(_)
      | ASTNode::ScanUntil(_)
      | ASTNode::TokenId(_)
      | ASTNode::Skip(_)
      | ASTNode::Pass(_)
      | ASTNode::Fail(_)
      | ASTNode::NotInScope(_)
      | ASTNode::SetScope(_)
      | ASTNode::Consume(_)
      | ASTNode::Goto(_)
      | ASTNode::Lazy(_) => {
        if index as usize >= self.instructions.len() {
          self.instructions.push(child);
          None
        } else {
          self.instructions.push(child);
          let node = self.instructions.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.instructions.len() {
          let node = self.instructions.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }

  fn replace_fail(&mut self, child: ASTNode) -> Option<ASTNode> {
    match child {
      ASTNode::NONE => {
        if self.fail.is_some() {
          let old = std::mem::replace(&mut self.fail, None);
          if let Some(old_node) = old {
            return Some(ASTNode::FailState(old_node));
          }
        }
      }

      ASTNode::FailState(child) => {
        if self.fail.is_none() {
          self.fail = Some(child);
        } else {
          let old = std::mem::replace(&mut self.fail, Some(child));

          if let Some(old_node) = old {
            return Some(ASTNode::FailState(old_node));
          }
        }
      }
      _ => {}
    }
    None
  }

  fn replace_symbol_meta(&mut self, child: ASTNode) -> Option<ASTNode> {
    match child {
      ASTNode::NONE => {
        if self.symbol_meta.is_some() {
          let old = std::mem::replace(&mut self.symbol_meta, None);
          if let Some(old_node) = old {
            return Some(ASTNode::Symbols(old_node));
          }
        }
      }

      ASTNode::Symbols(child) => {
        if self.symbol_meta.is_none() {
          self.symbol_meta = Some(child);
        } else {
          let old = std::mem::replace(&mut self.symbol_meta, Some(child));

          if let Some(old_node) = old {
            return Some(ASTNode::Symbols(old_node));
          }
        }
      }
      _ => {}
    }
    None
  }

  fn replace_prod(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.prod, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::Production_Symbol(_) => {
        return Some(std::mem::replace(&mut self.prod, child));
      }

      ASTNode::Production_Import_Symbol(_) => {
        return Some(std::mem::replace(&mut self.prod, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for IR_STATE
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::IR_STATE(*mut_me), parent, 393240, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).instructions.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).instructions[j];

        match child {
          ASTNode::ASSERT(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }

          ASTNode::DEFAULT(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Repeat(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Reduce(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }

          ASTNode::TokenAssign(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }

          ASTNode::SetProd(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }

          ASTNode::ForkTo(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }

          ASTNode::ScanUntil(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }

          ASTNode::TokenId(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Skip(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Pass(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Fail(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }

          ASTNode::NotInScope(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }

          ASTNode::SetScope(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Consume(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Goto(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Lazy(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me), 0, j as i32)
            };
          }
          _ => {}
        }
      }
    }

    unsafe {
      let reference = node.get();
      if let Some(child) = &mut (*reference).fail
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me_b), 1, 0);
      }
    }

    unsafe {
      let reference = node.get();
      if let Some(child) = &mut (*reference).symbol_meta
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me_b), 2, 0);
      }
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).prod
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::IR_STATE(*mut_me_b), 3, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_instructions(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      1 => {
        if let Some(old) = self.replace_fail(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      2 => {
        if let Some(old) = self.replace_symbol_meta(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      3 => {
        if let Some(old) = self.replace_prod(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 393240;
  }

  fn GetType(&self) -> u32 {
    return 393240;
  }
}

#[derive(Debug, Clone)]
pub struct ASSERT {
  pub is_peek:      bool,         // BOOL
  pub mode:         String,       // STRING
  pub ids:          Vec<ASTNode>, // VECTOR
  pub instructions: Vec<ASTNode>, // VECTOR
  pub is_skip:      bool,         // BOOL
}

impl ASSERT {
  pub fn new(
    _is_peek: bool,
    _mode: String,
    _ids: Vec<ASTNode>,
    _instructions: Vec<ASTNode>,
    _is_skip: bool,
  ) -> Box<Self> {
    Box::new(ASSERT {
      is_peek:      _is_peek,
      mode:         _mode,
      ids:          _ids,
      instructions: _instructions,
      is_skip:      _is_skip,
    })
  }

  fn replace_ids(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Production_Symbol(_) | ASTNode::Production_Import_Symbol(_) | ASTNode::Num(_) => {
        if index as usize >= self.ids.len() {
          self.ids.push(child);
          None
        } else {
          self.ids.push(child);
          let node = self.ids.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.ids.len() {
          let node = self.ids.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }

  fn replace_instructions(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Repeat(_)
      | ASTNode::Reduce(_)
      | ASTNode::TokenAssign(_)
      | ASTNode::SetProd(_)
      | ASTNode::ForkTo(_)
      | ASTNode::ScanUntil(_)
      | ASTNode::TokenId(_)
      | ASTNode::Skip(_)
      | ASTNode::Pass(_)
      | ASTNode::Fail(_)
      | ASTNode::NotInScope(_)
      | ASTNode::SetScope(_)
      | ASTNode::Consume(_)
      | ASTNode::Goto(_)
      | ASTNode::Lazy(_) => {
        if index as usize >= self.instructions.len() {
          self.instructions.push(child);
          None
        } else {
          self.instructions.push(child);
          let node = self.instructions.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.instructions.len() {
          let node = self.instructions.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for ASSERT
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::ASSERT(*mut_me), parent, 426088, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).ids.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).ids[j];

        match child {
          ASTNode::Production_Symbol(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Production_Import_Symbol(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Num(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 0, j as i32)
            };
          }
          _ => {}
        }
      }
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).instructions.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).instructions[j];

        match child {
          ASTNode::Repeat(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)
            };
          }

          ASTNode::Reduce(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)
            };
          }

          ASTNode::TokenAssign(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)
            };
          }

          ASTNode::SetProd(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)
            };
          }

          ASTNode::ForkTo(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)
            };
          }

          ASTNode::ScanUntil(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)
            };
          }

          ASTNode::TokenId(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)
            };
          }

          ASTNode::Skip(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)
            };
          }

          ASTNode::Pass(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)
            };
          }

          ASTNode::Fail(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)
            };
          }

          ASTNode::NotInScope(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)
            };
          }

          ASTNode::SetScope(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)
            };
          }

          ASTNode::Consume(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)
            };
          }

          ASTNode::Goto(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)
            };
          }

          ASTNode::Lazy(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ASSERT(*mut_me), 1, j as i32)
            };
          }
          _ => {}
        }
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_ids(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      1 => {
        if let Some(old) = self.replace_instructions(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 426088;
  }

  fn GetType(&self) -> u32 {
    return 426088;
  }
}

#[derive(Debug, Clone)]
pub struct DEFAULT {
  pub instructions: Vec<ASTNode>, // VECTOR
}

impl DEFAULT {
  pub fn new(_instructions: Vec<ASTNode>) -> Box<Self> {
    Box::new(DEFAULT { instructions: _instructions })
  }

  fn replace_instructions(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Repeat(_)
      | ASTNode::Reduce(_)
      | ASTNode::TokenAssign(_)
      | ASTNode::SetProd(_)
      | ASTNode::ForkTo(_)
      | ASTNode::ScanUntil(_)
      | ASTNode::TokenId(_)
      | ASTNode::Skip(_)
      | ASTNode::Pass(_)
      | ASTNode::Fail(_)
      | ASTNode::NotInScope(_)
      | ASTNode::SetScope(_)
      | ASTNode::Consume(_)
      | ASTNode::Goto(_)
      | ASTNode::Lazy(_) => {
        if index as usize >= self.instructions.len() {
          self.instructions.push(child);
          None
        } else {
          self.instructions.push(child);
          let node = self.instructions.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.instructions.len() {
          let node = self.instructions.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for DEFAULT
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::DEFAULT(*mut_me), parent, 458856, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).instructions.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).instructions[j];

        match child {
          ASTNode::Repeat(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::DEFAULT(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Reduce(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::DEFAULT(*mut_me), 0, j as i32)
            };
          }

          ASTNode::TokenAssign(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::DEFAULT(*mut_me), 0, j as i32)
            };
          }

          ASTNode::SetProd(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::DEFAULT(*mut_me), 0, j as i32)
            };
          }

          ASTNode::ForkTo(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::DEFAULT(*mut_me), 0, j as i32)
            };
          }

          ASTNode::ScanUntil(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::DEFAULT(*mut_me), 0, j as i32)
            };
          }

          ASTNode::TokenId(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::DEFAULT(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Skip(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::DEFAULT(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Pass(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::DEFAULT(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Fail(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::DEFAULT(*mut_me), 0, j as i32)
            };
          }

          ASTNode::NotInScope(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::DEFAULT(*mut_me), 0, j as i32)
            };
          }

          ASTNode::SetScope(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::DEFAULT(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Consume(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::DEFAULT(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Goto(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::DEFAULT(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Lazy(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::DEFAULT(*mut_me), 0, j as i32)
            };
          }
          _ => {}
        }
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_instructions(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 458856;
  }

  fn GetType(&self) -> u32 {
    return 458856;
  }
}

#[derive(Debug, Clone)]
pub struct Num {
  pub val: i64, // I64
}

impl Num {
  pub fn new(_val: i64) -> Box<Self> {
    Box::new(Num { val: _val })
  }
}

impl<'a> ASTNodeTraits<'a> for Num
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Num(*mut_me), parent, 491520, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 491520;
  }

  fn GetType(&self) -> u32 {
    return 491520;
  }
}

#[derive(Debug, Clone)]
pub struct Production_Symbol {
  pub name: String, // STRING
  pub tok:  Token,  // TOKEN
}

impl Production_Symbol {
  pub fn new(_name: String, _tok: Token) -> Box<Self> {
    Box::new(Production_Symbol { name: _name, tok: _tok })
  }
}

impl<'a> ASTNodeTraits<'a> for Production_Symbol
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Production_Symbol(*mut_me), parent, 524416, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 524416;
  }

  fn GetType(&self) -> u32 {
    return 524416;
  }
}

#[derive(Debug, Clone)]
pub struct Production_Import_Symbol {
  pub module: String, // STRING
  pub name:   String, // STRING
  pub tok:    Token,  // TOKEN
}

impl Production_Import_Symbol {
  pub fn new(_module: String, _name: String, _tok: Token) -> Box<Self> {
    Box::new(Production_Import_Symbol { module: _module, name: _name, tok: _tok })
  }
}

impl<'a> ASTNodeTraits<'a> for Production_Import_Symbol
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Production_Import_Symbol(*mut_me), parent, 557184, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 557184;
  }

  fn GetType(&self) -> u32 {
    return 557184;
  }
}

#[derive(Debug, Clone)]
pub struct Reduce {
  pub len:       i32,     // I32
  pub body_id:   i32,     // I32
  pub reduce_fn: ASTNode, // Ascript | Returned | Referenced
}

impl Reduce {
  pub fn new(_len: i32, _body_id: i32, _reduce_fn: ASTNode) -> Box<Self> {
    Box::new(Reduce { len: _len, body_id: _body_id, reduce_fn: _reduce_fn })
  }

  fn replace_reduce_fn(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.reduce_fn, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::Ascript(_) => {
        return Some(std::mem::replace(&mut self.reduce_fn, child));
      }

      ASTNode::Returned(_) => {
        return Some(std::mem::replace(&mut self.reduce_fn, child));
      }

      ASTNode::Referenced(_) => {
        return Some(std::mem::replace(&mut self.reduce_fn, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Reduce
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Reduce(*mut_me), parent, 589864, i, j) {
        return;
      };
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).reduce_fn
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::Reduce(*mut_me_b), 0, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_reduce_fn(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 589864;
  }

  fn GetType(&self) -> u32 {
    return 589864;
  }
}

#[derive(Debug, Clone)]
pub struct TokenAssign {
  pub ids: Vec<ASTNode>, // VECTOR
}

impl TokenAssign {
  pub fn new(_ids: Vec<ASTNode>) -> Box<Self> {
    Box::new(TokenAssign { ids: _ids })
  }

  fn replace_ids(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Num(_) => {
        if index as usize >= self.ids.len() {
          self.ids.push(child);
          None
        } else {
          self.ids.push(child);
          let node = self.ids.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.ids.len() {
          let node = self.ids.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for TokenAssign
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::TokenAssign(*mut_me), parent, 622632, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).ids.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).ids[j];

        if let ASTNode::Num(child) = child {
          unsafe {
            let mut_me = node.get();
            child.Iterate(_yield, &mut NodeIteration::TokenAssign(*mut_me), 0, j as i32)
          };
        }
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_ids(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 622632;
  }

  fn GetType(&self) -> u32 {
    return 622632;
  }
}

#[derive(Debug, Clone)]
pub struct SetProd {
  pub id: ASTNode, // Production_Symbol | Production_Import_Symbol | Num
}

impl SetProd {
  pub fn new(_id: ASTNode) -> Box<Self> {
    Box::new(SetProd { id: _id })
  }

  fn replace_id(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.id, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::Production_Symbol(_) => {
        return Some(std::mem::replace(&mut self.id, child));
      }

      ASTNode::Production_Import_Symbol(_) => {
        return Some(std::mem::replace(&mut self.id, child));
      }

      ASTNode::Num(_) => {
        return Some(std::mem::replace(&mut self.id, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for SetProd
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::SetProd(*mut_me), parent, 655400, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).id).Iterate(_yield, &mut NodeIteration::SetProd(*mut_me_b), 0, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_id(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 655400;
  }

  fn GetType(&self) -> u32 {
    return 655400;
  }
}

#[derive(Debug, Clone)]
pub struct ForkTo {
  pub states:        Vec<ASTNode>, // VECTOR
  pub production_id: Box<Num>,     // Num
}

impl ForkTo {
  pub fn new(_states: Vec<ASTNode>, _production_id: Box<Num>) -> Box<Self> {
    Box::new(ForkTo { states: _states, production_id: _production_id })
  }

  fn replace_states(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Production_Symbol(_)
      | ASTNode::Production_Import_Symbol(_)
      | ASTNode::HASH_NAME(_) => {
        if index as usize >= self.states.len() {
          self.states.push(child);
          None
        } else {
          self.states.push(child);
          let node = self.states.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.states.len() {
          let node = self.states.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }

  fn replace_production_id(&mut self, child: ASTNode) -> Option<ASTNode> {
    if let ASTNode::Num(child) = child {
      return Some(ASTNode::Num(std::mem::replace(&mut self.production_id, child)));
    } else {
      return None;
    }
  }
}

impl<'a> ASTNodeTraits<'a> for ForkTo
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::ForkTo(*mut_me), parent, 688168, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).states.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).states[j];

        match child {
          ASTNode::Production_Symbol(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ForkTo(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Production_Import_Symbol(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ForkTo(*mut_me), 0, j as i32)
            };
          }

          ASTNode::HASH_NAME(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::ForkTo(*mut_me), 0, j as i32)
            };
          }
          _ => {}
        }
      }
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).production_id).Iterate(_yield, &mut NodeIteration::ForkTo(*mut_me_b), 1, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_states(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      1 => {
        if let Some(old) = self.replace_production_id(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 688168;
  }

  fn GetType(&self) -> u32 {
    return 688168;
  }
}

#[derive(Debug, Clone)]
pub struct ScanUntil {
  pub ids: Vec<ASTNode>,    // VECTOR
  pub SCAN_BACKWARDS: bool, // BOOL
}

impl ScanUntil {
  pub fn new(_ids: Vec<ASTNode>, _SCAN_BACKWARDS: bool) -> Box<Self> {
    Box::new(ScanUntil { ids: _ids, SCAN_BACKWARDS: _SCAN_BACKWARDS })
  }

  fn replace_ids(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Num(_) => {
        if index as usize >= self.ids.len() {
          self.ids.push(child);
          None
        } else {
          self.ids.push(child);
          let node = self.ids.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.ids.len() {
          let node = self.ids.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for ScanUntil
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::ScanUntil(*mut_me), parent, 720936, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).ids.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).ids[j];

        if let ASTNode::Num(child) = child {
          unsafe {
            let mut_me = node.get();
            child.Iterate(_yield, &mut NodeIteration::ScanUntil(*mut_me), 0, j as i32)
          };
        }
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_ids(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 720936;
  }

  fn GetType(&self) -> u32 {
    return 720936;
  }
}

#[derive(Debug, Clone)]
pub struct TokenId {
  pub id: Box<Num>, // Num
}

impl TokenId {
  pub fn new(_id: Box<Num>) -> Box<Self> {
    Box::new(TokenId { id: _id })
  }

  fn replace_id(&mut self, child: ASTNode) -> Option<ASTNode> {
    if let ASTNode::Num(child) = child {
      return Some(ASTNode::Num(std::mem::replace(&mut self.id, child)));
    } else {
      return None;
    }
  }
}

impl<'a> ASTNodeTraits<'a> for TokenId
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::TokenId(*mut_me), parent, 753704, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).id).Iterate(_yield, &mut NodeIteration::TokenId(*mut_me_b), 0, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_id(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 753704;
  }

  fn GetType(&self) -> u32 {
    return 753704;
  }
}

#[derive(Debug, Clone)]
pub struct Skip {}

impl Skip {
  pub fn new() -> Box<Self> {
    Box::new(Skip {})
  }
}

impl<'a> ASTNodeTraits<'a> for Skip
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Skip(*mut_me), parent, 786472, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 786472;
  }

  fn GetType(&self) -> u32 {
    return 786472;
  }
}

#[derive(Debug, Clone)]
pub struct Pass {}

impl Pass {
  pub fn new() -> Box<Self> {
    Box::new(Pass {})
  }
}

impl<'a> ASTNodeTraits<'a> for Pass
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Pass(*mut_me), parent, 819240, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 819240;
  }

  fn GetType(&self) -> u32 {
    return 819240;
  }
}

#[derive(Debug, Clone)]
pub struct Fail {}

impl Fail {
  pub fn new() -> Box<Self> {
    Box::new(Fail {})
  }
}

impl<'a> ASTNodeTraits<'a> for Fail
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Fail(*mut_me), parent, 852008, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 852008;
  }

  fn GetType(&self) -> u32 {
    return 852008;
  }
}

#[derive(Debug, Clone)]
pub struct NotInScope {
  pub ids: Vec<ASTNode>, // VECTOR
}

impl NotInScope {
  pub fn new(_ids: Vec<ASTNode>) -> Box<Self> {
    Box::new(NotInScope { ids: _ids })
  }

  fn replace_ids(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Production_Symbol(_) | ASTNode::Production_Import_Symbol(_) | ASTNode::Num(_) => {
        if index as usize >= self.ids.len() {
          self.ids.push(child);
          None
        } else {
          self.ids.push(child);
          let node = self.ids.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.ids.len() {
          let node = self.ids.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for NotInScope
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::NotInScope(*mut_me), parent, 884776, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).ids.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).ids[j];

        match child {
          ASTNode::Production_Symbol(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::NotInScope(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Production_Import_Symbol(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::NotInScope(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Num(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::NotInScope(*mut_me), 0, j as i32)
            };
          }
          _ => {}
        }
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_ids(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 884776;
  }

  fn GetType(&self) -> u32 {
    return 884776;
  }
}

#[derive(Debug, Clone)]
pub struct SetScope {
  pub scope: i64, // I64
}

impl SetScope {
  pub fn new(_scope: i64) -> Box<Self> {
    Box::new(SetScope { scope: _scope })
  }
}

impl<'a> ASTNodeTraits<'a> for SetScope
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::SetScope(*mut_me), parent, 917544, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 917544;
  }

  fn GetType(&self) -> u32 {
    return 917544;
  }
}

#[derive(Debug, Clone)]
pub struct Consume {
  pub EMPTY: bool, // BOOL
}

impl Consume {
  pub fn new(_EMPTY: bool) -> Box<Self> {
    Box::new(Consume { EMPTY: _EMPTY })
  }
}

impl<'a> ASTNodeTraits<'a> for Consume
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Consume(*mut_me), parent, 950312, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 950312;
  }

  fn GetType(&self) -> u32 {
    return 950312;
  }
}

#[derive(Debug, Clone)]
pub struct Ascript {
  pub ast: ASTNode, // AST_Statements | AST_Struct
  pub tok: Token,   // TOKEN
}

impl Ascript {
  pub fn new(_ast: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(Ascript { ast: _ast, tok: _tok })
  }

  fn replace_ast(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.ast, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_Statements(_) => {
        return Some(std::mem::replace(&mut self.ast, child));
      }

      ASTNode::AST_Struct(_) => {
        return Some(std::mem::replace(&mut self.ast, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Ascript
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Ascript(*mut_me), parent, 983296, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).ast).Iterate(_yield, &mut NodeIteration::Ascript(*mut_me_b), 0, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_ast(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 983296;
  }

  fn GetType(&self) -> u32 {
    return 983296;
  }
}

#[derive(Debug, Clone)]
pub struct Returned {
  pub txt: String, // STRING
  pub tok: Token,  // TOKEN
}

impl Returned {
  pub fn new(_txt: String, _tok: Token) -> Box<Self> {
    Box::new(Returned { txt: _txt, tok: _tok })
  }
}

impl<'a> ASTNodeTraits<'a> for Returned
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Returned(*mut_me), parent, 1016064, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1016064;
  }

  fn GetType(&self) -> u32 {
    return 1016064;
  }
}

#[derive(Debug, Clone)]
pub struct Referenced {
  pub reference: Box<Reference>, // Reference
  pub tok:       Token,          // TOKEN
}

impl Referenced {
  pub fn new(_reference: Box<Reference>, _tok: Token) -> Box<Self> {
    Box::new(Referenced { reference: _reference, tok: _tok })
  }

  fn replace_reference(&mut self, child: ASTNode) -> Option<ASTNode> {
    if let ASTNode::Reference(child) = child {
      return Some(ASTNode::Reference(std::mem::replace(&mut self.reference, child)));
    } else {
      return None;
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Referenced
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Referenced(*mut_me), parent, 1048832, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).reference).Iterate(_yield, &mut NodeIteration::Referenced(*mut_me_b), 0, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_reference(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1048832;
  }

  fn GetType(&self) -> u32 {
    return 1048832;
  }
}

#[derive(Debug, Clone)]
pub struct AST_Statements {
  pub statements: Vec<ASTNode>, // VECTOR
  pub tok:        Token,        // TOKEN
}

impl AST_Statements {
  pub fn new(_statements: Vec<ASTNode>, _tok: Token) -> Box<Self> {
    Box::new(AST_Statements { statements: _statements, tok: _tok })
  }

  fn replace_statements(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::AST_Add(_)
      | ASTNode::AST_Vector(_)
      | ASTNode::AST_Member(_)
      | ASTNode::AST_NamedReference(_)
      | ASTNode::AST_IndexReference(_)
      | ASTNode::AST_STRING(_)
      | ASTNode::AST_U8(_)
      | ASTNode::AST_U16(_)
      | ASTNode::AST_U32(_)
      | ASTNode::AST_U64(_)
      | ASTNode::AST_I8(_)
      | ASTNode::AST_I16(_)
      | ASTNode::AST_I32(_)
      | ASTNode::AST_I64(_)
      | ASTNode::AST_F32(_)
      | ASTNode::AST_F64(_)
      | ASTNode::AST_BOOL(_)
      | ASTNode::AST_NUMBER(_)
      | ASTNode::AST_Token(_) => {
        if index as usize >= self.statements.len() {
          self.statements.push(child);
          None
        } else {
          self.statements.push(child);
          let node = self.statements.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.statements.len() {
          let node = self.statements.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_Statements
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_Statements(*mut_me), parent, 1081344, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).statements.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).statements[j];

        match child {
          ASTNode::AST_Add(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_Vector(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_Member(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_NamedReference(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_IndexReference(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_STRING(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_U8(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_U16(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_U32(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_U64(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_I8(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_I16(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_I32(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_I64(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_F32(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_F64(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_BOOL(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_NUMBER(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_Token(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Statements(*mut_me), 0, j as i32)
            };
          }
          _ => {}
        }
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_statements(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1081344;
  }

  fn GetType(&self) -> u32 {
    return 1081344;
  }
}

#[derive(Debug, Clone)]
pub struct AST_Struct {
  pub props: Vec<ASTNode>, // VECTOR
  pub tok:   Token,        // TOKEN
}

impl AST_Struct {
  pub fn new(_props: Vec<ASTNode>, _tok: Token) -> Box<Self> {
    Box::new(AST_Struct { props: _props, tok: _tok })
  }

  fn replace_props(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::AST_Property(_)
      | ASTNode::AST_TypeId(_)
      | ASTNode::AST_ClassId(_)
      | ASTNode::AST_Token(_) => {
        if index as usize >= self.props.len() {
          self.props.push(child);
          None
        } else {
          self.props.push(child);
          let node = self.props.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.props.len() {
          let node = self.props.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_Struct
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_Struct(*mut_me), parent, 1114112, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).props.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).props[j];

        match child {
          ASTNode::AST_Property(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Struct(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_TypeId(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Struct(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_ClassId(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Struct(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_Token(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Struct(*mut_me), 0, j as i32)
            };
          }
          _ => {}
        }
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_props(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1114112;
  }

  fn GetType(&self) -> u32 {
    return 1114112;
  }
}

#[derive(Debug, Clone)]
pub struct AST_Property {
  pub id:    String,  // STRING
  pub value: ASTNode, /* AST_Vector | AST_Member | AST_NamedReference | AST_IndexReference | AST_STRING | AST_U8 | AST_U16 | AST_U32 | AST_U64 | AST_I8 | AST_I16 | AST_I32 | AST_I64 | AST_F32 | AST_F64 | AST_BOOL | AST_NUMBER | AST_Token | AST_Struct */
  pub tok:   Token,   // TOKEN
}

impl AST_Property {
  pub fn new(_id: String, _value: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(AST_Property { id: _id, value: _value, tok: _tok })
  }

  fn replace_value(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.value, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_Vector(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_Member(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_NamedReference(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_IndexReference(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_STRING(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_U8(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_U16(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_U32(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_U64(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_I8(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_I16(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_I32(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_I64(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_F32(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_F64(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_BOOL(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_NUMBER(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_Token(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_Struct(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_Property
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_Property(*mut_me), parent, 1146880, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).value).Iterate(_yield, &mut NodeIteration::AST_Property(*mut_me_b), 0, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_value(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1146880;
  }

  fn GetType(&self) -> u32 {
    return 1146880;
  }
}

#[derive(Debug, Clone)]
pub struct AST_TypeId {
  pub value: String, // STRING
  pub tok:   Token,  // TOKEN
}

impl AST_TypeId {
  pub fn new(_value: String, _tok: Token) -> Box<Self> {
    Box::new(AST_TypeId { value: _value, tok: _tok })
  }
}

impl<'a> ASTNodeTraits<'a> for AST_TypeId
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_TypeId(*mut_me), parent, 1179648, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1179648;
  }

  fn GetType(&self) -> u32 {
    return 1179648;
  }
}

#[derive(Debug, Clone)]
pub struct AST_ClassId {
  pub value: String, // STRING
  pub tok:   Token,  // TOKEN
}

impl AST_ClassId {
  pub fn new(_value: String, _tok: Token) -> Box<Self> {
    Box::new(AST_ClassId { value: _value, tok: _tok })
  }
}

impl<'a> ASTNodeTraits<'a> for AST_ClassId
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_ClassId(*mut_me), parent, 1212416, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1212416;
  }

  fn GetType(&self) -> u32 {
    return 1212416;
  }
}

#[derive(Debug, Clone)]
pub struct AST_Vector {
  pub initializer: Vec<ASTNode>, // VECTOR
  pub tok:         Token,        // TOKEN
}

impl AST_Vector {
  pub fn new(_initializer: Vec<ASTNode>, _tok: Token) -> Box<Self> {
    Box::new(AST_Vector { initializer: _initializer, tok: _tok })
  }

  fn replace_initializer(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::AST_Vector(_)
      | ASTNode::AST_Member(_)
      | ASTNode::AST_NamedReference(_)
      | ASTNode::AST_IndexReference(_)
      | ASTNode::AST_STRING(_)
      | ASTNode::AST_U8(_)
      | ASTNode::AST_U16(_)
      | ASTNode::AST_U32(_)
      | ASTNode::AST_U64(_)
      | ASTNode::AST_I8(_)
      | ASTNode::AST_I16(_)
      | ASTNode::AST_I32(_)
      | ASTNode::AST_I64(_)
      | ASTNode::AST_F32(_)
      | ASTNode::AST_F64(_)
      | ASTNode::AST_BOOL(_)
      | ASTNode::AST_NUMBER(_)
      | ASTNode::AST_Token(_) => {
        if index as usize >= self.initializer.len() {
          self.initializer.push(child);
          None
        } else {
          self.initializer.push(child);
          let node = self.initializer.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.initializer.len() {
          let node = self.initializer.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_Vector
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_Vector(*mut_me), parent, 1245184, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).initializer.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).initializer[j];

        match child {
          ASTNode::AST_Vector(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_Member(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_NamedReference(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_IndexReference(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_STRING(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_U8(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_U16(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_U32(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_U64(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_I8(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_I16(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_I32(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_I64(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_F32(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_F64(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_BOOL(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_NUMBER(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }

          ASTNode::AST_Token(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::AST_Vector(*mut_me), 0, j as i32)
            };
          }
          _ => {}
        }
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_initializer(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1245184;
  }

  fn GetType(&self) -> u32 {
    return 1245184;
  }
}

#[derive(Debug, Clone)]
pub struct AST_Member {
  pub reference: ASTNode, // AST_NamedReference | AST_IndexReference
  pub property:  Token,   // TOKEN
}

impl AST_Member {
  pub fn new(_reference: ASTNode, _property: Token) -> Box<Self> {
    Box::new(AST_Member { reference: _reference, property: _property })
  }

  fn replace_reference(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.reference, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_NamedReference(_) => {
        return Some(std::mem::replace(&mut self.reference, child));
      }

      ASTNode::AST_IndexReference(_) => {
        return Some(std::mem::replace(&mut self.reference, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_Member
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_Member(*mut_me), parent, 1277952, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).reference).Iterate(_yield, &mut NodeIteration::AST_Member(*mut_me_b), 0, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_reference(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 1277952;
  }

  fn GetType(&self) -> u32 {
    return 1277952;
  }
}

#[derive(Debug, Clone)]
pub struct AST_NamedReference {
  pub value: String, // STRING
  pub tok:   Token,  // TOKEN
}

impl AST_NamedReference {
  pub fn new(_value: String, _tok: Token) -> Box<Self> {
    Box::new(AST_NamedReference { value: _value, tok: _tok })
  }
}

impl<'a> ASTNodeTraits<'a> for AST_NamedReference
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_NamedReference(*mut_me), parent, 1310720, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1310720;
  }

  fn GetType(&self) -> u32 {
    return 1310720;
  }
}

#[derive(Debug, Clone)]
pub struct AST_IndexReference {
  pub value: f64,   // F64
  pub tok:   Token, // TOKEN
}

impl AST_IndexReference {
  pub fn new(_value: f64, _tok: Token) -> Box<Self> {
    Box::new(AST_IndexReference { value: _value, tok: _tok })
  }
}

impl<'a> ASTNodeTraits<'a> for AST_IndexReference
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_IndexReference(*mut_me), parent, 1343488, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1343488;
  }

  fn GetType(&self) -> u32 {
    return 1343488;
  }
}

#[derive(Debug, Clone)]
pub struct AST_STRING {
  pub value: ASTNode, // AST_Token | AST_Member | AST_NamedReference | AST_IndexReference
  pub tok:   Token,   // TOKEN
}

impl AST_STRING {
  pub fn new(_value: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(AST_STRING { value: _value, tok: _tok })
  }

  fn replace_value(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.value, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_Token(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_Member(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_NamedReference(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }

      ASTNode::AST_IndexReference(_) => {
        return Some(std::mem::replace(&mut self.value, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_STRING
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_STRING(*mut_me), parent, 1376256, i, j) {
        return;
      };
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).value
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::AST_STRING(*mut_me_b), 0, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_value(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1376256;
  }

  fn GetType(&self) -> u32 {
    return 1376256;
  }
}

#[derive(Debug, Clone)]
pub struct AST_Token {}

impl AST_Token {
  pub fn new() -> Box<Self> {
    Box::new(AST_Token {})
  }
}

impl<'a> ASTNodeTraits<'a> for AST_Token
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_Token(*mut_me), parent, 1409024, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 1409024;
  }

  fn GetType(&self) -> u32 {
    return 1409024;
  }
}

#[derive(Debug, Clone)]
pub struct AST_U8 {
  pub initializer: ASTNode, // AST_Token | AST_Member | AST_NamedReference | AST_IndexReference
  pub tok:         Token,   // TOKEN
}

impl AST_U8 {
  pub fn new(_initializer: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(AST_U8 { initializer: _initializer, tok: _tok })
  }

  fn replace_initializer(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.initializer, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_Token(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_Member(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_NamedReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_IndexReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_U8
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_U8(*mut_me), parent, 1441792, i, j) {
        return;
      };
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).initializer
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::AST_U8(*mut_me_b), 0, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_initializer(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1441792;
  }

  fn GetType(&self) -> u32 {
    return 1441792;
  }
}

#[derive(Debug, Clone)]
pub struct AST_U16 {
  pub initializer: ASTNode, // AST_Token | AST_Member | AST_NamedReference | AST_IndexReference
  pub tok:         Token,   // TOKEN
}

impl AST_U16 {
  pub fn new(_initializer: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(AST_U16 { initializer: _initializer, tok: _tok })
  }

  fn replace_initializer(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.initializer, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_Token(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_Member(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_NamedReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_IndexReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_U16
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_U16(*mut_me), parent, 1474560, i, j) {
        return;
      };
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).initializer
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::AST_U16(*mut_me_b), 0, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_initializer(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1474560;
  }

  fn GetType(&self) -> u32 {
    return 1474560;
  }
}

#[derive(Debug, Clone)]
pub struct AST_U32 {
  pub initializer: ASTNode, // AST_Token | AST_Member | AST_NamedReference | AST_IndexReference
  pub tok:         Token,   // TOKEN
}

impl AST_U32 {
  pub fn new(_initializer: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(AST_U32 { initializer: _initializer, tok: _tok })
  }

  fn replace_initializer(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.initializer, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_Token(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_Member(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_NamedReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_IndexReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_U32
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_U32(*mut_me), parent, 1507328, i, j) {
        return;
      };
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).initializer
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::AST_U32(*mut_me_b), 0, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_initializer(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1507328;
  }

  fn GetType(&self) -> u32 {
    return 1507328;
  }
}

#[derive(Debug, Clone)]
pub struct AST_U64 {
  pub initializer: ASTNode, // AST_Token | AST_Member | AST_NamedReference | AST_IndexReference
  pub tok:         Token,   // TOKEN
}

impl AST_U64 {
  pub fn new(_initializer: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(AST_U64 { initializer: _initializer, tok: _tok })
  }

  fn replace_initializer(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.initializer, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_Token(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_Member(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_NamedReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_IndexReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_U64
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_U64(*mut_me), parent, 1540096, i, j) {
        return;
      };
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).initializer
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::AST_U64(*mut_me_b), 0, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_initializer(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1540096;
  }

  fn GetType(&self) -> u32 {
    return 1540096;
  }
}

#[derive(Debug, Clone)]
pub struct AST_I8 {
  pub initializer: ASTNode, // AST_Token | AST_Member | AST_NamedReference | AST_IndexReference
  pub tok:         Token,   // TOKEN
}

impl AST_I8 {
  pub fn new(_initializer: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(AST_I8 { initializer: _initializer, tok: _tok })
  }

  fn replace_initializer(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.initializer, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_Token(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_Member(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_NamedReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_IndexReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_I8
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_I8(*mut_me), parent, 1572864, i, j) {
        return;
      };
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).initializer
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::AST_I8(*mut_me_b), 0, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_initializer(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1572864;
  }

  fn GetType(&self) -> u32 {
    return 1572864;
  }
}

#[derive(Debug, Clone)]
pub struct AST_I16 {
  pub initializer: ASTNode, // AST_Token | AST_Member | AST_NamedReference | AST_IndexReference
  pub tok:         Token,   // TOKEN
}

impl AST_I16 {
  pub fn new(_initializer: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(AST_I16 { initializer: _initializer, tok: _tok })
  }

  fn replace_initializer(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.initializer, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_Token(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_Member(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_NamedReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_IndexReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_I16
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_I16(*mut_me), parent, 1605632, i, j) {
        return;
      };
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).initializer
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::AST_I16(*mut_me_b), 0, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_initializer(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1605632;
  }

  fn GetType(&self) -> u32 {
    return 1605632;
  }
}

#[derive(Debug, Clone)]
pub struct AST_I32 {
  pub initializer: ASTNode, // AST_Token | AST_Member | AST_NamedReference | AST_IndexReference
  pub tok:         Token,   // TOKEN
}

impl AST_I32 {
  pub fn new(_initializer: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(AST_I32 { initializer: _initializer, tok: _tok })
  }

  fn replace_initializer(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.initializer, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_Token(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_Member(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_NamedReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_IndexReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_I32
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_I32(*mut_me), parent, 1638400, i, j) {
        return;
      };
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).initializer
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::AST_I32(*mut_me_b), 0, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_initializer(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1638400;
  }

  fn GetType(&self) -> u32 {
    return 1638400;
  }
}

#[derive(Debug, Clone)]
pub struct AST_I64 {
  pub initializer: ASTNode, // AST_Token | AST_Member | AST_NamedReference | AST_IndexReference
  pub tok:         Token,   // TOKEN
}

impl AST_I64 {
  pub fn new(_initializer: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(AST_I64 { initializer: _initializer, tok: _tok })
  }

  fn replace_initializer(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.initializer, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_Token(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_Member(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_NamedReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_IndexReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_I64
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_I64(*mut_me), parent, 1671168, i, j) {
        return;
      };
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).initializer
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::AST_I64(*mut_me_b), 0, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_initializer(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1671168;
  }

  fn GetType(&self) -> u32 {
    return 1671168;
  }
}

#[derive(Debug, Clone)]
pub struct AST_F32 {
  pub initializer: ASTNode, // AST_Token | AST_Member | AST_NamedReference | AST_IndexReference
  pub tok:         Token,   // TOKEN
}

impl AST_F32 {
  pub fn new(_initializer: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(AST_F32 { initializer: _initializer, tok: _tok })
  }

  fn replace_initializer(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.initializer, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_Token(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_Member(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_NamedReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_IndexReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_F32
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_F32(*mut_me), parent, 1703936, i, j) {
        return;
      };
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).initializer
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::AST_F32(*mut_me_b), 0, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_initializer(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1703936;
  }

  fn GetType(&self) -> u32 {
    return 1703936;
  }
}

#[derive(Debug, Clone)]
pub struct AST_F64 {
  pub initializer: ASTNode, // AST_Token | AST_Member | AST_NamedReference | AST_IndexReference
  pub tok:         Token,   // TOKEN
}

impl AST_F64 {
  pub fn new(_initializer: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(AST_F64 { initializer: _initializer, tok: _tok })
  }

  fn replace_initializer(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.initializer, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_Token(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_Member(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_NamedReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_IndexReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_F64
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_F64(*mut_me), parent, 1736704, i, j) {
        return;
      };
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).initializer
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::AST_F64(*mut_me_b), 0, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_initializer(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1736704;
  }

  fn GetType(&self) -> u32 {
    return 1736704;
  }
}

#[derive(Debug, Clone)]
pub struct AST_BOOL {
  pub initializer: ASTNode, // AST_Token | AST_Member | AST_NamedReference | AST_IndexReference
  pub tok:         Token,   // TOKEN
  pub value:       bool,    // BOOL | BOOL
}

impl AST_BOOL {
  pub fn new(_initializer: ASTNode, _tok: Token, _value: bool) -> Box<Self> {
    Box::new(AST_BOOL { initializer: _initializer, tok: _tok, value: _value })
  }

  fn replace_initializer(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.initializer, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_Token(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_Member(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_NamedReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }

      ASTNode::AST_IndexReference(_) => {
        return Some(std::mem::replace(&mut self.initializer, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_BOOL
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_BOOL(*mut_me), parent, 1769472, i, j) {
        return;
      };
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).initializer
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::AST_BOOL(*mut_me_b), 0, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_initializer(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1769472;
  }

  fn GetType(&self) -> u32 {
    return 1769472;
  }
}

#[derive(Debug, Clone)]
pub struct AST_NUMBER {
  pub value: f64, // F64
}

impl AST_NUMBER {
  pub fn new(_value: f64) -> Box<Self> {
    Box::new(AST_NUMBER { value: _value })
  }
}

impl<'a> ASTNodeTraits<'a> for AST_NUMBER
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_NUMBER(*mut_me), parent, 1802240, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 1802240;
  }

  fn GetType(&self) -> u32 {
    return 1802240;
  }
}

#[derive(Debug, Clone)]
pub struct AST_Add {
  pub left:  ASTNode, // AST_Member | AST_NamedReference | AST_IndexReference
  pub right: ASTNode, /* AST_Vector | AST_Member | AST_NamedReference | AST_IndexReference | AST_STRING | AST_U8 | AST_U16 | AST_U32 | AST_U64 | AST_I8 | AST_I16 | AST_I32 | AST_I64 | AST_F32 | AST_F64 | AST_BOOL | AST_NUMBER | AST_Token */
  pub tok:   Token,   // TOKEN
}

impl AST_Add {
  pub fn new(_left: ASTNode, _right: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(AST_Add { left: _left, right: _right, tok: _tok })
  }

  fn replace_left(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.left, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_Member(_) => {
        return Some(std::mem::replace(&mut self.left, child));
      }

      ASTNode::AST_NamedReference(_) => {
        return Some(std::mem::replace(&mut self.left, child));
      }

      ASTNode::AST_IndexReference(_) => {
        return Some(std::mem::replace(&mut self.left, child));
      }
      _ => None,
    }
  }

  fn replace_right(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.right, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::AST_Vector(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_Member(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_NamedReference(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_IndexReference(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_STRING(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_U8(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_U16(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_U32(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_U64(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_I8(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_I16(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_I32(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_I64(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_F32(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_F64(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_BOOL(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_NUMBER(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }

      ASTNode::AST_Token(_) => {
        return Some(std::mem::replace(&mut self.right, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AST_Add
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AST_Add(*mut_me), parent, 1835008, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).left).Iterate(_yield, &mut NodeIteration::AST_Add(*mut_me_b), 0, 0);
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).right).Iterate(_yield, &mut NodeIteration::AST_Add(*mut_me_b), 1, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_left(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      1 => {
        if let Some(old) = self.replace_right(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1835008;
  }

  fn GetType(&self) -> u32 {
    return 1835008;
  }
}

#[derive(Debug, Clone)]
pub struct Reference {
  pub val: String, // STRING
}

impl Reference {
  pub fn new(_val: String) -> Box<Self> {
    Box::new(Reference { val: _val })
  }
}

impl<'a> ASTNodeTraits<'a> for Reference
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Reference(*mut_me), parent, 1867904, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 1867904;
  }

  fn GetType(&self) -> u32 {
    return 1867904;
  }
}

#[derive(Debug, Clone)]
pub struct Generated {
  pub val: String, // STRING
  pub tok: Token,  // TOKEN
}

impl Generated {
  pub fn new(_val: String, _tok: Token) -> Box<Self> {
    Box::new(Generated { val: _val, tok: _tok })
  }
}

impl<'a> ASTNodeTraits<'a> for Generated
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Generated(*mut_me), parent, 1901184, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1901184;
  }

  fn GetType(&self) -> u32 {
    return 1901184;
  }
}

#[derive(Debug, Clone)]
pub struct Exclusive_Literal {
  pub val: String, // STRING
  pub tok: Token,  // TOKEN
}

impl Exclusive_Literal {
  pub fn new(_val: String, _tok: Token) -> Box<Self> {
    Box::new(Exclusive_Literal { val: _val, tok: _tok })
  }
}

impl<'a> ASTNodeTraits<'a> for Exclusive_Literal
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Exclusive_Literal(*mut_me), parent, 1933952, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1933952;
  }

  fn GetType(&self) -> u32 {
    return 1933952;
  }
}

#[derive(Debug, Clone)]
pub struct Literal {
  pub val: String, // STRING
  pub tok: Token,  // TOKEN
}

impl Literal {
  pub fn new(_val: String, _tok: Token) -> Box<Self> {
    Box::new(Literal { val: _val, tok: _tok })
  }
}

impl<'a> ASTNodeTraits<'a> for Literal
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Literal(*mut_me), parent, 1966720, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1966720;
  }

  fn GetType(&self) -> u32 {
    return 1966720;
  }
}

#[derive(Debug, Clone)]
pub struct End_Of_File {
  pub tok: Token, // TOKEN
}

impl End_Of_File {
  pub fn new(_tok: Token) -> Box<Self> {
    Box::new(End_Of_File { tok: _tok })
  }
}

impl<'a> ASTNodeTraits<'a> for End_Of_File
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::End_Of_File(*mut_me), parent, 1999488, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 1999488;
  }

  fn GetType(&self) -> u32 {
    return 1999488;
  }
}

#[derive(Debug, Clone)]
pub struct Space {
  pub position: i16, // I16
}

impl Space {
  pub fn new(_position: i16) -> Box<Self> {
    Box::new(Space { position: _position })
  }
}

impl<'a> ASTNodeTraits<'a> for Space
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Space(*mut_me), parent, 2034688, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2034688;
  }

  fn GetType(&self) -> u32 {
    return 2034688;
  }
}

#[derive(Debug, Clone)]
pub struct NewLine {
  pub position: i16, // I16
}

impl NewLine {
  pub fn new(_position: i16) -> Box<Self> {
    Box::new(NewLine { position: _position })
  }
}

impl<'a> ASTNodeTraits<'a> for NewLine
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::NewLine(*mut_me), parent, 2067456, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2067456;
  }

  fn GetType(&self) -> u32 {
    return 2067456;
  }
}

#[derive(Debug, Clone)]
pub struct IncreaseIndent {
  pub position: i16, // I16
}

impl IncreaseIndent {
  pub fn new(_position: i16) -> Box<Self> {
    Box::new(IncreaseIndent { position: _position })
  }
}

impl<'a> ASTNodeTraits<'a> for IncreaseIndent
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::IncreaseIndent(*mut_me), parent, 2100224, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2100224;
  }

  fn GetType(&self) -> u32 {
    return 2100224;
  }
}

#[derive(Debug, Clone)]
pub struct DecreaseIndent {
  pub position: i16, // I16
}

impl DecreaseIndent {
  pub fn new(_position: i16) -> Box<Self> {
    Box::new(DecreaseIndent { position: _position })
  }
}

impl<'a> ASTNodeTraits<'a> for DecreaseIndent
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::DecreaseIndent(*mut_me), parent, 2132992, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2132992;
  }

  fn GetType(&self) -> u32 {
    return 2132992;
  }
}

#[derive(Debug, Clone)]
pub struct Production_Token {
  pub production: ASTNode, // Production_Symbol | Production_Import_Symbol
  pub tok:        Token,   // TOKEN
}

impl Production_Token {
  pub fn new(_production: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(Production_Token { production: _production, tok: _tok })
  }

  fn replace_production(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.production, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::Production_Symbol(_) => {
        return Some(std::mem::replace(&mut self.production, child));
      }

      ASTNode::Production_Import_Symbol(_) => {
        return Some(std::mem::replace(&mut self.production, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Production_Token
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Production_Token(*mut_me), parent, 2163328, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).production).Iterate(
        _yield,
        &mut NodeIteration::Production_Token(*mut_me_b),
        0,
        0,
      );
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_production(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 2163328;
  }

  fn GetType(&self) -> u32 {
    return 2163328;
  }
}

#[derive(Debug, Clone)]
pub struct Goto {
  pub state: ASTNode, // Production_Symbol | Production_Import_Symbol | HASH_NAME
}

impl Goto {
  pub fn new(_state: ASTNode) -> Box<Self> {
    Box::new(Goto { state: _state })
  }

  fn replace_state(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.state, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::Production_Symbol(_) => {
        return Some(std::mem::replace(&mut self.state, child));
      }

      ASTNode::Production_Import_Symbol(_) => {
        return Some(std::mem::replace(&mut self.state, child));
      }

      ASTNode::HASH_NAME(_) => {
        return Some(std::mem::replace(&mut self.state, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Goto
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Goto(*mut_me), parent, 2195496, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).state).Iterate(_yield, &mut NodeIteration::Goto(*mut_me_b), 0, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_state(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2195496;
  }

  fn GetType(&self) -> u32 {
    return 2195496;
  }
}

#[derive(Debug, Clone)]
pub struct FailState {
  pub id:           String,                 // STRING
  pub instructions: Vec<ASTNode>,           // VECTOR
  pub symbol_meta:  Option<Box<Symbols>>,   // Symbols
  pub fail:         Option<Box<FailState>>, // FailState
}

impl FailState {
  pub fn new(
    _id: String,
    _instructions: Vec<ASTNode>,
    _symbol_meta: Option<Box<Symbols>>,
    _fail: Option<Box<FailState>>,
  ) -> Box<Self> {
    Box::new(FailState {
      id:           _id,
      instructions: _instructions,
      symbol_meta:  _symbol_meta,
      fail:         _fail,
    })
  }

  fn replace_instructions(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::ASSERT(_)
      | ASTNode::DEFAULT(_)
      | ASTNode::Repeat(_)
      | ASTNode::Reduce(_)
      | ASTNode::TokenAssign(_)
      | ASTNode::SetProd(_)
      | ASTNode::ForkTo(_)
      | ASTNode::ScanUntil(_)
      | ASTNode::TokenId(_)
      | ASTNode::Skip(_)
      | ASTNode::Pass(_)
      | ASTNode::Fail(_)
      | ASTNode::NotInScope(_)
      | ASTNode::SetScope(_)
      | ASTNode::Consume(_)
      | ASTNode::Goto(_)
      | ASTNode::Lazy(_) => {
        if index as usize >= self.instructions.len() {
          self.instructions.push(child);
          None
        } else {
          self.instructions.push(child);
          let node = self.instructions.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.instructions.len() {
          let node = self.instructions.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }

  fn replace_symbol_meta(&mut self, child: ASTNode) -> Option<ASTNode> {
    match child {
      ASTNode::NONE => {
        if self.symbol_meta.is_some() {
          let old = std::mem::replace(&mut self.symbol_meta, None);
          if let Some(old_node) = old {
            return Some(ASTNode::Symbols(old_node));
          }
        }
      }

      ASTNode::Symbols(child) => {
        if self.symbol_meta.is_none() {
          self.symbol_meta = Some(child);
        } else {
          let old = std::mem::replace(&mut self.symbol_meta, Some(child));

          if let Some(old_node) = old {
            return Some(ASTNode::Symbols(old_node));
          }
        }
      }
      _ => {}
    }
    None
  }

  fn replace_fail(&mut self, child: ASTNode) -> Option<ASTNode> {
    match child {
      ASTNode::NONE => {
        if self.fail.is_some() {
          let old = std::mem::replace(&mut self.fail, None);
          if let Some(old_node) = old {
            return Some(ASTNode::FailState(old_node));
          }
        }
      }

      ASTNode::FailState(child) => {
        if self.fail.is_none() {
          self.fail = Some(child);
        } else {
          let old = std::mem::replace(&mut self.fail, Some(child));

          if let Some(old_node) = old {
            return Some(ASTNode::FailState(old_node));
          }
        }
      }
      _ => {}
    }
    None
  }
}

impl<'a> ASTNodeTraits<'a> for FailState
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::FailState(*mut_me), parent, 2232328, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).instructions.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).instructions[j];

        match child {
          ASTNode::ASSERT(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }

          ASTNode::DEFAULT(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Repeat(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Reduce(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }

          ASTNode::TokenAssign(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }

          ASTNode::SetProd(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }

          ASTNode::ForkTo(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }

          ASTNode::ScanUntil(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }

          ASTNode::TokenId(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Skip(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Pass(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Fail(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }

          ASTNode::NotInScope(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }

          ASTNode::SetScope(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Consume(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Goto(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Lazy(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me), 0, j as i32)
            };
          }
          _ => {}
        }
      }
    }

    unsafe {
      let reference = node.get();
      if let Some(child) = &mut (*reference).symbol_meta
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me_b), 1, 0);
      }
    }

    unsafe {
      let reference = node.get();
      if let Some(child) = &mut (*reference).fail
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::FailState(*mut_me_b), 2, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_instructions(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      1 => {
        if let Some(old) = self.replace_symbol_meta(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      2 => {
        if let Some(old) = self.replace_fail(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2232328;
  }

  fn GetType(&self) -> u32 {
    return 2232328;
  }
}

#[derive(Debug, Clone)]
pub struct Symbols {
  pub expected: Vec<ASTNode>, // VECTOR
  pub skipped:  Vec<ASTNode>, // VECTOR
}

impl Symbols {
  pub fn new(_expected: Vec<ASTNode>, _skipped: Vec<ASTNode>) -> Box<Self> {
    Box::new(Symbols { expected: _expected, skipped: _skipped })
  }

  fn replace_expected(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Num(_) => {
        if index as usize >= self.expected.len() {
          self.expected.push(child);
          None
        } else {
          self.expected.push(child);
          let node = self.expected.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.expected.len() {
          let node = self.expected.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }

  fn replace_skipped(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Num(_) => {
        if index as usize >= self.skipped.len() {
          self.skipped.push(child);
          None
        } else {
          self.skipped.push(child);
          let node = self.skipped.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.skipped.len() {
          let node = self.skipped.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Symbols
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Symbols(*mut_me), parent, 2261000, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).expected.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).expected[j];

        if let ASTNode::Num(child) = child {
          unsafe {
            let mut_me = node.get();
            child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 0, j as i32)
          };
        }
      }
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).skipped.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).skipped[j];

        if let ASTNode::Num(child) = child {
          unsafe {
            let mut_me = node.get();
            child.Iterate(_yield, &mut NodeIteration::Symbols(*mut_me), 1, j as i32)
          };
        }
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_expected(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      1 => {
        if let Some(old) = self.replace_skipped(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2261000;
  }

  fn GetType(&self) -> u32 {
    return 2261000;
  }
}

#[derive(Debug, Clone)]
pub struct AnnotatedSymbol {
  pub symbol:    ASTNode, /* OptionalSymbol | Not_Symbol | Look_Behind | NonCaptureSymbol | List_Production | Optional_List_Production | Generated | Exclusive_Literal | Literal | End_Of_File | Space | NewLine | IncreaseIndent | DecreaseIndent | Production_Token | Group_Production | Production_Symbol | Production_Import_Symbol */
  pub reference: Box<Reference>, // Reference
}

impl AnnotatedSymbol {
  pub fn new(_symbol: ASTNode, _reference: Box<Reference>) -> Box<Self> {
    Box::new(AnnotatedSymbol { symbol: _symbol, reference: _reference })
  }

  fn replace_symbol(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.symbol, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::OptionalSymbol(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Not_Symbol(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Look_Behind(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::NonCaptureSymbol(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::List_Production(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Optional_List_Production(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Generated(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Exclusive_Literal(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Literal(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::End_Of_File(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Space(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::NewLine(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::IncreaseIndent(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::DecreaseIndent(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Production_Token(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Group_Production(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Production_Symbol(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Production_Import_Symbol(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }
      _ => None,
    }
  }

  fn replace_reference(&mut self, child: ASTNode) -> Option<ASTNode> {
    if let ASTNode::Reference(child) = child {
      return Some(ASTNode::Reference(std::mem::replace(&mut self.reference, child)));
    } else {
      return None;
    }
  }
}

impl<'a> ASTNodeTraits<'a> for AnnotatedSymbol
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::AnnotatedSymbol(*mut_me), parent, 2293888, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).symbol).Iterate(_yield, &mut NodeIteration::AnnotatedSymbol(*mut_me_b), 0, 0);
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).reference).Iterate(_yield, &mut NodeIteration::AnnotatedSymbol(*mut_me_b), 1, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_symbol(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      1 => {
        if let Some(old) = self.replace_reference(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2293888;
  }

  fn GetType(&self) -> u32 {
    return 2293888;
  }
}

#[derive(Debug, Clone)]
pub struct OptionalSymbol {
  pub symbol: ASTNode, /* OptionalSymbol | Not_Symbol | Look_Behind | NonCaptureSymbol | List_Production | Optional_List_Production | Generated | Exclusive_Literal | Literal | End_Of_File | Space | NewLine | IncreaseIndent | DecreaseIndent | Production_Token | Group_Production | Production_Symbol | Production_Import_Symbol */
}

impl OptionalSymbol {
  pub fn new(_symbol: ASTNode) -> Box<Self> {
    Box::new(OptionalSymbol { symbol: _symbol })
  }

  fn replace_symbol(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.symbol, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::OptionalSymbol(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Not_Symbol(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Look_Behind(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::NonCaptureSymbol(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::List_Production(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Optional_List_Production(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Generated(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Exclusive_Literal(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Literal(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::End_Of_File(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Space(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::NewLine(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::IncreaseIndent(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::DecreaseIndent(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Production_Token(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Group_Production(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Production_Symbol(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Production_Import_Symbol(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for OptionalSymbol
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::OptionalSymbol(*mut_me), parent, 2326528, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).symbol).Iterate(_yield, &mut NodeIteration::OptionalSymbol(*mut_me_b), 0, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_symbol(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2326528;
  }

  fn GetType(&self) -> u32 {
    return 2326528;
  }
}

#[derive(Debug, Clone)]
pub struct Not_Symbol {
  pub symbol: ASTNode, // Exclusive_Literal | Literal
  pub tok:    Token,   // TOKEN
}

impl Not_Symbol {
  pub fn new(_symbol: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(Not_Symbol { symbol: _symbol, tok: _tok })
  }

  fn replace_symbol(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.symbol, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::Exclusive_Literal(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Literal(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Not_Symbol
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Not_Symbol(*mut_me), parent, 2359424, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).symbol).Iterate(_yield, &mut NodeIteration::Not_Symbol(*mut_me_b), 0, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_symbol(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 2359424;
  }

  fn GetType(&self) -> u32 {
    return 2359424;
  }
}

#[derive(Debug, Clone)]
pub struct Look_Behind {
  pub symbol: ASTNode, /* Generated | Exclusive_Literal | Literal | End_Of_File | Space | NewLine | IncreaseIndent | DecreaseIndent | Production_Token */
  pub tok:    Token,   // TOKEN
}

impl Look_Behind {
  pub fn new(_symbol: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(Look_Behind { symbol: _symbol, tok: _tok })
  }

  fn replace_symbol(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.symbol, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::Generated(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Exclusive_Literal(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Literal(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::End_Of_File(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Space(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::NewLine(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::IncreaseIndent(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::DecreaseIndent(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Production_Token(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Look_Behind
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Look_Behind(*mut_me), parent, 2392192, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).symbol).Iterate(_yield, &mut NodeIteration::Look_Behind(*mut_me_b), 0, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_symbol(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 2392192;
  }

  fn GetType(&self) -> u32 {
    return 2392192;
  }
}

#[derive(Debug, Clone)]
pub struct NonCaptureSymbol {
  pub sym: ASTNode, /* OptionalSymbol | Not_Symbol | Look_Behind | NonCaptureSymbol | List_Production | Optional_List_Production | Generated | Exclusive_Literal | Literal | End_Of_File | Space | NewLine | IncreaseIndent | DecreaseIndent | Production_Token | Group_Production | Production_Symbol | Production_Import_Symbol */
}

impl NonCaptureSymbol {
  pub fn new(_sym: ASTNode) -> Box<Self> {
    Box::new(NonCaptureSymbol { sym: _sym })
  }

  fn replace_sym(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.sym, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::OptionalSymbol(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::Not_Symbol(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::Look_Behind(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::NonCaptureSymbol(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::List_Production(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::Optional_List_Production(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::Generated(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::Exclusive_Literal(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::Literal(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::End_Of_File(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::Space(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::NewLine(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::IncreaseIndent(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::DecreaseIndent(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::Production_Token(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::Group_Production(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::Production_Symbol(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }

      ASTNode::Production_Import_Symbol(_) => {
        return Some(std::mem::replace(&mut self.sym, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for NonCaptureSymbol
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::NonCaptureSymbol(*mut_me), parent, 2424960, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).sym).Iterate(_yield, &mut NodeIteration::NonCaptureSymbol(*mut_me_b), 0, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_sym(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2424960;
  }

  fn GetType(&self) -> u32 {
    return 2424960;
  }
}

#[derive(Debug, Clone)]
pub struct List_Production {
  pub terminal_symbol: ASTNode, /* Generated | Exclusive_Literal | Literal | End_Of_File | Space | NewLine | IncreaseIndent | DecreaseIndent | Production_Token */
  pub symbols: ASTNode, /* OptionalSymbol | Not_Symbol | Look_Behind | NonCaptureSymbol | List_Production | Optional_List_Production | Generated | Exclusive_Literal | Literal | End_Of_File | Space | NewLine | IncreaseIndent | DecreaseIndent | Production_Token | Group_Production | Production_Symbol | Production_Import_Symbol */
  pub tok: Token,       // TOKEN
}

impl List_Production {
  pub fn new(_terminal_symbol: ASTNode, _symbols: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(List_Production { terminal_symbol: _terminal_symbol, symbols: _symbols, tok: _tok })
  }

  fn replace_terminal_symbol(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.terminal_symbol, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::Generated(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }

      ASTNode::Exclusive_Literal(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }

      ASTNode::Literal(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }

      ASTNode::End_Of_File(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }

      ASTNode::Space(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }

      ASTNode::NewLine(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }

      ASTNode::IncreaseIndent(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }

      ASTNode::DecreaseIndent(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }

      ASTNode::Production_Token(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }
      _ => None,
    }
  }

  fn replace_symbols(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.symbols, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::OptionalSymbol(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Not_Symbol(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Look_Behind(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::NonCaptureSymbol(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::List_Production(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Optional_List_Production(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Generated(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Exclusive_Literal(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Literal(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::End_Of_File(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Space(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::NewLine(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::IncreaseIndent(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::DecreaseIndent(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Production_Token(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Group_Production(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Production_Symbol(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Production_Import_Symbol(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for List_Production
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::List_Production(*mut_me), parent, 2457728, i, j) {
        return;
      };
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).terminal_symbol
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::List_Production(*mut_me_b), 0, 0);
      }
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).symbols).Iterate(_yield, &mut NodeIteration::List_Production(*mut_me_b), 1, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_terminal_symbol(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      1 => {
        if let Some(old) = self.replace_symbols(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 2457728;
  }

  fn GetType(&self) -> u32 {
    return 2457728;
  }
}

#[derive(Debug, Clone)]
pub struct Optional_List_Production {
  pub terminal_symbol: ASTNode, /* Generated | Exclusive_Literal | Literal | End_Of_File | Space | NewLine | IncreaseIndent | DecreaseIndent | Production_Token */
  pub symbols: ASTNode, /* OptionalSymbol | Not_Symbol | Look_Behind | NonCaptureSymbol | List_Production | Optional_List_Production | Generated | Exclusive_Literal | Literal | End_Of_File | Space | NewLine | IncreaseIndent | DecreaseIndent | Production_Token | Group_Production | Production_Symbol | Production_Import_Symbol */
  pub tok: Token,       // TOKEN
}

impl Optional_List_Production {
  pub fn new(_terminal_symbol: ASTNode, _symbols: ASTNode, _tok: Token) -> Box<Self> {
    Box::new(Optional_List_Production {
      terminal_symbol: _terminal_symbol,
      symbols: _symbols,
      tok: _tok,
    })
  }

  fn replace_terminal_symbol(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.terminal_symbol, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::Generated(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }

      ASTNode::Exclusive_Literal(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }

      ASTNode::Literal(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }

      ASTNode::End_Of_File(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }

      ASTNode::Space(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }

      ASTNode::NewLine(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }

      ASTNode::IncreaseIndent(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }

      ASTNode::DecreaseIndent(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }

      ASTNode::Production_Token(_) => {
        return Some(std::mem::replace(&mut self.terminal_symbol, child));
      }
      _ => None,
    }
  }

  fn replace_symbols(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.symbols, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::OptionalSymbol(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Not_Symbol(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Look_Behind(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::NonCaptureSymbol(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::List_Production(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Optional_List_Production(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Generated(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Exclusive_Literal(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Literal(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::End_Of_File(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Space(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::NewLine(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::IncreaseIndent(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::DecreaseIndent(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Production_Token(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Group_Production(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Production_Symbol(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }

      ASTNode::Production_Import_Symbol(_) => {
        return Some(std::mem::replace(&mut self.symbols, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Optional_List_Production
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Optional_List_Production(*mut_me), parent, 2490496, i, j) {
        return;
      };
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).terminal_symbol
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::Optional_List_Production(*mut_me_b), 0, 0);
      }
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).symbols).Iterate(
        _yield,
        &mut NodeIteration::Optional_List_Production(*mut_me_b),
        1,
        0,
      );
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_terminal_symbol(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      1 => {
        if let Some(old) = self.replace_symbols(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 2490496;
  }

  fn GetType(&self) -> u32 {
    return 2490496;
  }
}

#[derive(Debug, Clone)]
pub struct Group_Production {
  pub bodies: Vec<ASTNode>, // VECTOR
  pub tok:    Token,        // TOKEN
}

impl Group_Production {
  pub fn new(_bodies: Vec<ASTNode>, _tok: Token) -> Box<Self> {
    Box::new(Group_Production { bodies: _bodies, tok: _tok })
  }

  fn replace_bodies(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Body(_) => {
        if index as usize >= self.bodies.len() {
          self.bodies.push(child);
          None
        } else {
          self.bodies.push(child);
          let node = self.bodies.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.bodies.len() {
          let node = self.bodies.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Group_Production
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Group_Production(*mut_me), parent, 2523264, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).bodies.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).bodies[j];

        if let ASTNode::Body(child) = child {
          unsafe {
            let mut_me = node.get();
            child.Iterate(_yield, &mut NodeIteration::Group_Production(*mut_me), 0, j as i32)
          };
        }
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_bodies(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 2523264;
  }

  fn GetType(&self) -> u32 {
    return 2523264;
  }
}

#[derive(Debug, Clone)]
pub struct Body {
  pub priority: bool,                    // BOOL
  pub symbols: Vec<ASTNode>,             // VECTOR
  pub reference: Option<Box<Reference>>, // Reference
  pub reduce_function: ASTNode,          // Ascript | Returned | Referenced
  pub tok: Token,                        // TOKEN
}

impl Body {
  pub fn new(
    _priority: bool,
    _symbols: Vec<ASTNode>,
    _reference: Option<Box<Reference>>,
    _reduce_function: ASTNode,
    _tok: Token,
  ) -> Box<Self> {
    Box::new(Body {
      priority: _priority,
      symbols: _symbols,
      reference: _reference,
      reduce_function: _reduce_function,
      tok: _tok,
    })
  }

  fn replace_symbols(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::AnnotatedSymbol(_)
      | ASTNode::OptionalSymbol(_)
      | ASTNode::Not_Symbol(_)
      | ASTNode::Look_Behind(_)
      | ASTNode::NonCaptureSymbol(_)
      | ASTNode::List_Production(_)
      | ASTNode::Optional_List_Production(_)
      | ASTNode::Generated(_)
      | ASTNode::Exclusive_Literal(_)
      | ASTNode::Literal(_)
      | ASTNode::End_Of_File(_)
      | ASTNode::Space(_)
      | ASTNode::NewLine(_)
      | ASTNode::IncreaseIndent(_)
      | ASTNode::DecreaseIndent(_)
      | ASTNode::Production_Token(_)
      | ASTNode::Group_Production(_)
      | ASTNode::Production_Symbol(_)
      | ASTNode::Production_Import_Symbol(_)
      | ASTNode::Exclude(_)
      | ASTNode::Look_Ignore(_) => {
        if index as usize >= self.symbols.len() {
          self.symbols.push(child);
          None
        } else {
          self.symbols.push(child);
          let node = self.symbols.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.symbols.len() {
          let node = self.symbols.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }

  fn replace_reference(&mut self, child: ASTNode) -> Option<ASTNode> {
    match child {
      ASTNode::NONE => {
        if self.reference.is_some() {
          let old = std::mem::replace(&mut self.reference, None);
          if let Some(old_node) = old {
            return Some(ASTNode::Reference(old_node));
          }
        }
      }

      ASTNode::Reference(child) => {
        if self.reference.is_none() {
          self.reference = Some(child);
        } else {
          let old = std::mem::replace(&mut self.reference, Some(child));

          if let Some(old_node) = old {
            return Some(ASTNode::Reference(old_node));
          }
        }
      }
      _ => {}
    }
    None
  }

  fn replace_reduce_function(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.reduce_function, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::Ascript(_) => {
        return Some(std::mem::replace(&mut self.reduce_function, child));
      }

      ASTNode::Returned(_) => {
        return Some(std::mem::replace(&mut self.reduce_function, child));
      }

      ASTNode::Referenced(_) => {
        return Some(std::mem::replace(&mut self.reduce_function, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Body
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Body(*mut_me), parent, 2564096, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).symbols.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).symbols[j];

        match child {
          ASTNode::AnnotatedSymbol(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::OptionalSymbol(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Not_Symbol(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Look_Behind(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::NonCaptureSymbol(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::List_Production(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Optional_List_Production(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Generated(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Exclusive_Literal(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Literal(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::End_Of_File(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Space(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::NewLine(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::IncreaseIndent(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::DecreaseIndent(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Production_Token(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Group_Production(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Production_Symbol(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Production_Import_Symbol(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Exclude(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Look_Ignore(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Body(*mut_me), 0, j as i32)
            };
          }
          _ => {}
        }
      }
    }

    unsafe {
      let reference = node.get();
      if let Some(child) = &mut (*reference).reference
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::Body(*mut_me_b), 1, 0);
      }
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).reduce_function
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::Body(*mut_me_b), 2, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_symbols(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      1 => {
        if let Some(old) = self.replace_reference(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      2 => {
        if let Some(old) = self.replace_reduce_function(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 2564096;
  }

  fn GetType(&self) -> u32 {
    return 2564096;
  }
}

#[derive(Debug, Clone)]
pub struct Exclude {
  pub sym: Vec<ASTNode>, // VECTOR
  pub tok: Token,        // TOKEN
}

impl Exclude {
  pub fn new(_sym: Vec<ASTNode>, _tok: Token) -> Box<Self> {
    Box::new(Exclude { sym: _sym, tok: _tok })
  }

  fn replace_sym(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Generated(_)
      | ASTNode::Exclusive_Literal(_)
      | ASTNode::Literal(_)
      | ASTNode::End_Of_File(_)
      | ASTNode::Space(_)
      | ASTNode::NewLine(_)
      | ASTNode::IncreaseIndent(_)
      | ASTNode::DecreaseIndent(_)
      | ASTNode::Production_Token(_) => {
        if index as usize >= self.sym.len() {
          self.sym.push(child);
          None
        } else {
          self.sym.push(child);
          let node = self.sym.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.sym.len() {
          let node = self.sym.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Exclude
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Exclude(*mut_me), parent, 2589824, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).sym.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).sym[j];

        match child {
          ASTNode::Generated(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Exclusive_Literal(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Literal(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)
            };
          }

          ASTNode::End_Of_File(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Space(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)
            };
          }

          ASTNode::NewLine(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)
            };
          }

          ASTNode::IncreaseIndent(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)
            };
          }

          ASTNode::DecreaseIndent(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Production_Token(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Exclude(*mut_me), 0, j as i32)
            };
          }
          _ => {}
        }
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_sym(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 2589824;
  }

  fn GetType(&self) -> u32 {
    return 2589824;
  }
}

#[derive(Debug, Clone)]
pub struct Look_Ignore {
  pub sym: Vec<ASTNode>, // VECTOR
  pub tok: Token,        // TOKEN
}

impl Look_Ignore {
  pub fn new(_sym: Vec<ASTNode>, _tok: Token) -> Box<Self> {
    Box::new(Look_Ignore { sym: _sym, tok: _tok })
  }

  fn replace_sym(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Generated(_)
      | ASTNode::Exclusive_Literal(_)
      | ASTNode::Literal(_)
      | ASTNode::End_Of_File(_)
      | ASTNode::Space(_)
      | ASTNode::NewLine(_)
      | ASTNode::IncreaseIndent(_)
      | ASTNode::DecreaseIndent(_)
      | ASTNode::Production_Token(_) => {
        if index as usize >= self.sym.len() {
          self.sym.push(child);
          None
        } else {
          self.sym.push(child);
          let node = self.sym.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.sym.len() {
          let node = self.sym.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Look_Ignore
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Look_Ignore(*mut_me), parent, 2622592, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).sym.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).sym[j];

        match child {
          ASTNode::Generated(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Exclusive_Literal(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Literal(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)
            };
          }

          ASTNode::End_Of_File(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Space(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)
            };
          }

          ASTNode::NewLine(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)
            };
          }

          ASTNode::IncreaseIndent(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)
            };
          }

          ASTNode::DecreaseIndent(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Production_Token(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Look_Ignore(*mut_me), 0, j as i32)
            };
          }
          _ => {}
        }
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_sym(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 2622592;
  }

  fn GetType(&self) -> u32 {
    return 2622592;
  }
}

#[derive(Debug, Clone)]
pub struct Empty {
  pub tok: Token, // TOKEN
}

impl Empty {
  pub fn new(_tok: Token) -> Box<Self> {
    Box::new(Empty { tok: _tok })
  }
}

impl<'a> ASTNodeTraits<'a> for Empty
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Empty(*mut_me), parent, 2654336, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 2654336;
  }

  fn GetType(&self) -> u32 {
    return 2654336;
  }
}

#[derive(Debug, Clone)]
pub struct Production {
  pub priority: bool,         // BOOL
  pub symbol:   ASTNode,      // Production_Symbol | Production_Import_Symbol
  pub bodies:   Vec<ASTNode>, // VECTOR
  pub LAZY:     bool,         // BOOL
  pub tok:      Token,        // TOKEN
}

impl Production {
  pub fn new(
    _priority: bool,
    _symbol: ASTNode,
    _bodies: Vec<ASTNode>,
    _LAZY: bool,
    _tok: Token,
  ) -> Box<Self> {
    Box::new(Production {
      priority: _priority,
      symbol:   _symbol,
      bodies:   _bodies,
      LAZY:     _LAZY,
      tok:      _tok,
    })
  }

  fn replace_symbol(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.symbol, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::Production_Symbol(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Production_Import_Symbol(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }
      _ => None,
    }
  }

  fn replace_bodies(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Body(_) => {
        if index as usize >= self.bodies.len() {
          self.bodies.push(child);
          None
        } else {
          self.bodies.push(child);
          let node = self.bodies.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.bodies.len() {
          let node = self.bodies.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Production
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Production(*mut_me), parent, 2695168, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).symbol).Iterate(_yield, &mut NodeIteration::Production(*mut_me_b), 0, 0);
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).bodies.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).bodies[j];

        if let ASTNode::Body(child) = child {
          unsafe {
            let mut_me = node.get();
            child.Iterate(_yield, &mut NodeIteration::Production(*mut_me), 1, j as i32)
          };
        }
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_symbol(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      1 => {
        if let Some(old) = self.replace_bodies(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 2695168;
  }

  fn GetType(&self) -> u32 {
    return 2695168;
  }
}

#[derive(Debug, Clone)]
pub struct ProductionMerged {
  pub symbol: ASTNode,      // Production_Symbol | Production_Import_Symbol
  pub bodies: Vec<ASTNode>, // VECTOR
  pub tok:    Token,        // TOKEN
}

impl ProductionMerged {
  pub fn new(_symbol: ASTNode, _bodies: Vec<ASTNode>, _tok: Token) -> Box<Self> {
    Box::new(ProductionMerged { symbol: _symbol, bodies: _bodies, tok: _tok })
  }

  fn replace_symbol(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.symbol, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::Production_Symbol(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }

      ASTNode::Production_Import_Symbol(_) => {
        return Some(std::mem::replace(&mut self.symbol, child));
      }
      _ => None,
    }
  }

  fn replace_bodies(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Body(_) => {
        if index as usize >= self.bodies.len() {
          self.bodies.push(child);
          None
        } else {
          self.bodies.push(child);
          let node = self.bodies.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.bodies.len() {
          let node = self.bodies.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for ProductionMerged
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::ProductionMerged(*mut_me), parent, 2727936, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).symbol).Iterate(_yield, &mut NodeIteration::ProductionMerged(*mut_me_b), 0, 0);
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).bodies.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).bodies[j];

        if let ASTNode::Body(child) = child {
          unsafe {
            let mut_me = node.get();
            child.Iterate(_yield, &mut NodeIteration::ProductionMerged(*mut_me), 1, j as i32)
          };
        }
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_symbol(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      1 => {
        if let Some(old) = self.replace_bodies(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 2727936;
  }

  fn GetType(&self) -> u32 {
    return 2727936;
  }
}

#[derive(Debug, Clone)]
pub struct Ignore {
  pub symbols: Vec<ASTNode>, // VECTOR
}

impl Ignore {
  pub fn new(_symbols: Vec<ASTNode>) -> Box<Self> {
    Box::new(Ignore { symbols: _symbols })
  }

  fn replace_symbols(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
    match &child {
      ASTNode::Generated(_)
      | ASTNode::Exclusive_Literal(_)
      | ASTNode::Literal(_)
      | ASTNode::End_Of_File(_)
      | ASTNode::Space(_)
      | ASTNode::NewLine(_)
      | ASTNode::IncreaseIndent(_)
      | ASTNode::DecreaseIndent(_)
      | ASTNode::Production_Token(_) => {
        if index as usize >= self.symbols.len() {
          self.symbols.push(child);
          None
        } else {
          self.symbols.push(child);
          let node = self.symbols.swap_remove(index as usize);
          Some(node)
        }
      }
      ASTNode::NONE => {
        if (index as usize) < self.symbols.len() {
          let node = self.symbols.remove(index as usize);
          Some(node)
        } else {
          None
        }
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Ignore
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Ignore(*mut_me), parent, 2768896, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_a = node.get();
      for j in 0..(*mut_me_a).symbols.len() {
        let mut_me_b = node.get();
        let child = &mut (*mut_me_b).symbols[j];

        match child {
          ASTNode::Generated(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Exclusive_Literal(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Literal(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)
            };
          }

          ASTNode::End_Of_File(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Space(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)
            };
          }

          ASTNode::NewLine(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)
            };
          }

          ASTNode::IncreaseIndent(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)
            };
          }

          ASTNode::DecreaseIndent(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)
            };
          }

          ASTNode::Production_Token(child) => {
            unsafe {
              let mut_me = node.get();
              child.Iterate(_yield, &mut NodeIteration::Ignore(*mut_me), 0, j as i32)
            };
          }
          _ => {}
        }
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_symbols(child, j) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2768896;
  }

  fn GetType(&self) -> u32 {
    return 2768896;
  }
}

#[derive(Debug, Clone)]
pub struct Import {
  pub uri:       String, // STRING | STRING
  pub reference: Token,  // TOKEN
  pub tok:       Token,  // TOKEN
}

impl Import {
  pub fn new(_uri: String, _reference: Token, _tok: Token) -> Box<Self> {
    Box::new(Import { uri: _uri, reference: _reference, tok: _tok })
  }
}

impl<'a> ASTNodeTraits<'a> for Import
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Import(*mut_me), parent, 2801664, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    self.tok.clone()
  }

  fn Type() -> u32 {
    return 2801664;
  }

  fn GetType(&self) -> u32 {
    return 2801664;
  }
}

#[derive(Debug, Clone)]
pub struct Export {
  pub production: ASTNode, // Production_Symbol | Production_Import_Symbol
  pub reference:  Token,   // TOKEN
}

impl Export {
  pub fn new(_production: ASTNode, _reference: Token) -> Box<Self> {
    Box::new(Export { production: _production, reference: _reference })
  }

  fn replace_production(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.production, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::Production_Symbol(_) => {
        return Some(std::mem::replace(&mut self.production, child));
      }

      ASTNode::Production_Import_Symbol(_) => {
        return Some(std::mem::replace(&mut self.production, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Export
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Export(*mut_me), parent, 2834432, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).production).Iterate(_yield, &mut NodeIteration::Export(*mut_me_b), 0, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_production(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2834432;
  }

  fn GetType(&self) -> u32 {
    return 2834432;
  }
}

#[derive(Debug, Clone)]
pub struct Name {
  pub name: String, // STRING
}

impl Name {
  pub fn new(_name: String) -> Box<Self> {
    Box::new(Name { name: _name })
  }
}

impl<'a> ASTNodeTraits<'a> for Name
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Name(*mut_me), parent, 2867200, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2867200;
  }

  fn GetType(&self) -> u32 {
    return 2867200;
  }
}

#[derive(Debug, Clone)]
pub struct Out_Of_Band {
  pub reference:  Option<Box<Reference>>, // Reference
  pub txt:        String,                 // STRING
  pub production: ASTNode,                // Production_Symbol | Production_Import_Symbol
  pub index:      Token,                  // TOKEN
}

impl Out_Of_Band {
  pub fn new(
    _reference: Option<Box<Reference>>,
    _txt: String,
    _production: ASTNode,
    _index: Token,
  ) -> Box<Self> {
    Box::new(Out_Of_Band {
      reference:  _reference,
      txt:        _txt,
      production: _production,
      index:      _index,
    })
  }

  fn replace_reference(&mut self, child: ASTNode) -> Option<ASTNode> {
    match child {
      ASTNode::NONE => {
        if self.reference.is_some() {
          let old = std::mem::replace(&mut self.reference, None);
          if let Some(old_node) = old {
            return Some(ASTNode::Reference(old_node));
          }
        }
      }

      ASTNode::Reference(child) => {
        if self.reference.is_none() {
          self.reference = Some(child);
        } else {
          let old = std::mem::replace(&mut self.reference, Some(child));

          if let Some(old_node) = old {
            return Some(ASTNode::Reference(old_node));
          }
        }
      }
      _ => {}
    }
    None
  }

  fn replace_production(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.production, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::Production_Symbol(_) => {
        return Some(std::mem::replace(&mut self.production, child));
      }

      ASTNode::Production_Import_Symbol(_) => {
        return Some(std::mem::replace(&mut self.production, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Out_Of_Band
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Out_Of_Band(*mut_me), parent, 2883840, i, j) {
        return;
      };
    }

    unsafe {
      let reference = node.get();
      if let Some(child) = &mut (*reference).reference
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::Out_Of_Band(*mut_me_b), 0, 0);
      }
    }

    unsafe {
      let reference = node.get();
      if let child = &mut (*reference).production
      // HAS_NULL:true
      {
        let mut_me_b = node.get();
        child.Iterate(_yield, &mut NodeIteration::Out_Of_Band(*mut_me_b), 1, 0);
      }
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_reference(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      1 => {
        if let Some(old) = self.replace_production(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2883840;
  }

  fn GetType(&self) -> u32 {
    return 2883840;
  }
}

#[derive(Debug, Clone)]
pub struct Repeat {}

impl Repeat {
  pub fn new() -> Box<Self> {
    Box::new(Repeat {})
  }
}

impl<'a> ASTNodeTraits<'a> for Repeat
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Repeat(*mut_me), parent, 2916392, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2916392;
  }

  fn GetType(&self) -> u32 {
    return 2916392;
  }
}

#[derive(Debug, Clone)]
pub struct Lazy {
  pub cp_start: Token,   // TOKEN
  pub cp_end:   Token,   // TOKEN
  pub state:    ASTNode, // Production_Symbol | Production_Import_Symbol | HASH_NAME
}

impl Lazy {
  pub fn new(_cp_start: Token, _cp_end: Token, _state: ASTNode) -> Box<Self> {
    Box::new(Lazy { cp_start: _cp_start, cp_end: _cp_end, state: _state })
  }

  fn replace_state(&mut self, child: ASTNode) -> Option<ASTNode> {
    match &child {
      ASTNode::NONE => {
        let old = std::mem::replace(&mut self.state, ASTNode::NONE);
        return Some(old);
      }

      ASTNode::Production_Symbol(_) => {
        return Some(std::mem::replace(&mut self.state, child));
      }

      ASTNode::Production_Import_Symbol(_) => {
        return Some(std::mem::replace(&mut self.state, child));
      }

      ASTNode::HASH_NAME(_) => {
        return Some(std::mem::replace(&mut self.state, child));
      }
      _ => None,
    }
  }
}

impl<'a> ASTNodeTraits<'a> for Lazy
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::Lazy(*mut_me), parent, 2949160, i, j) {
        return;
      };
    }

    unsafe {
      let mut_me_b = node.get();
      let mut_me_d = node.get();

      ((*mut_me_d).state).Iterate(_yield, &mut NodeIteration::Lazy(*mut_me_b), 0, 0);
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      0 => {
        if let Some(old) = self.replace_state(child) {
          return old;
        } else {
          return ASTNode::NONE;
        }
      }
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2949160;
  }

  fn GetType(&self) -> u32 {
    return 2949160;
  }
}

#[derive(Debug, Clone)]
pub struct HASH_NAME {
  pub val: String, // STRING
}

impl HASH_NAME {
  pub fn new(_val: String) -> Box<Self> {
    Box::new(HASH_NAME { val: _val })
  }
}

impl<'a> ASTNodeTraits<'a> for HASH_NAME
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::HASH_NAME(*mut_me), parent, 2981888, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 2981888;
  }

  fn GetType(&self) -> u32 {
    return 2981888;
  }
}

#[derive(Debug, Clone)]
pub struct FunctionIndexNum {
  pub value: f64, // F64
}

impl FunctionIndexNum {
  pub fn new(_value: f64) -> Box<Self> {
    Box::new(FunctionIndexNum { value: _value })
  }
}

impl<'a> ASTNodeTraits<'a> for FunctionIndexNum
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::FunctionIndexNum(*mut_me), parent, 3014656, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 3014656;
  }

  fn GetType(&self) -> u32 {
    return 3014656;
  }
}

#[derive(Debug, Clone)]
pub struct FunctionIndexWildCard {}

impl FunctionIndexWildCard {
  pub fn new() -> Box<Self> {
    Box::new(FunctionIndexWildCard {})
  }
}

impl<'a> ASTNodeTraits<'a> for FunctionIndexWildCard
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::FunctionIndexWildCard(*mut_me), parent, 3047424, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 3047424;
  }

  fn GetType(&self) -> u32 {
    return 3047424;
  }
}

#[derive(Debug, Clone)]
pub struct FunctionIndexId {
  pub value: String, // STRING
}

impl FunctionIndexId {
  pub fn new(_value: String) -> Box<Self> {
    Box::new(FunctionIndexId { value: _value })
  }
}

impl<'a> ASTNodeTraits<'a> for FunctionIndexId
where
  Self: Sized,
{
  fn Iterate(
    &'a mut self,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
  ) {
    let node = UnsafeCell::from(self);

    unsafe {
      let mut_me = node.get();

      if !_yield(&mut NodeIteration::FunctionIndexId(*mut_me), parent, 3080192, i, j) {
        return;
      };
    }
  }

  fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
    match i {
      _ => {}
    };

    ASTNode::NONE
  }

  fn Token(&self) -> Token {
    Token::empty()
  }

  fn Type() -> u32 {
    return 3080192;
  }

  fn GetType(&self) -> u32 {
    return 3080192;
  }
}

/// ```
/// {
///
/// t_Grammar,
///
/// c_Grammar,
///
/// c_Version_7,
///
/// preamble:$1,
///
/// content:$2,
///
/// tok
/// }
/// ```
fn _fn0(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODES/*aa00*/(mut r_0) = v0 { 
 if let HCO::NODES/*aa00*/(mut r_1) = v1 { 
 let mut ref_0 = ASTNode::Grammar(Grammar::new(
        r_0,
        r_1,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
}
/// ```
/// {
///
/// t_Grammar,
///
/// c_Grammar,
///
/// c_Version_7,
///
/// preamble:$NULL,
///
/// content:$1,
///
/// tok
/// }
/// ```
fn _fn1(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  if let HCO::NODES/*aa00*/(mut r_0) = v0 { 
 let mut ref_0 = ASTNode::Grammar(Grammar::new(
        Vec::new(),
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// {
///
/// t_IR_STATE,
///
/// c_IR,
///
/// c_IrState,
///
/// id:$1,
///
/// scanner:$2,
///
/// instructions:$3,
///
/// fail:$4,
///
/// symbol_meta:$5
/// }
/// ```
fn _fn2(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v4 = args.remove(i - 0);
  let mut v3 = args.remove(i - 1);
  let mut v2 = args.remove(i - 2);
  let mut v1 = args.remove(i - 3);
  let mut v0 = args.remove(i - 4);
  if let HCO::NODES/*aa00*/(mut r_0) = v2 { 
 if let HCO::NODE/*aaRR*/(r_1) = v3 { 
 if let ASTNode::FailState(r_2) = r_1 { 
 if let HCO::NODE/*aaRR*/(r_3) = v4 { 
 if let ASTNode::Symbols(r_4) = r_3 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        /* AAA */v0.to_string(),
        /* AAA */v1.to_string(),
        r_0,
        Some(r_2),
        Some(r_4),
        ASTNode::NONE,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } } } }
}
/// ```
/// {
///
/// t_IR_STATE,
///
/// c_IR,
///
/// c_IrState,
///
/// id:$1,
///
/// scanner:$NULL,
///
/// instructions:$2,
///
/// fail:$3,
///
/// symbol_meta:$4
/// }
/// ```
fn _fn3(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::NODES/*aa00*/(mut r_0) = v1 { 
 if let HCO::NODE/*aaRR*/(r_1) = v2 { 
 if let ASTNode::FailState(r_2) = r_1 { 
 if let HCO::NODE/*aaRR*/(r_3) = v3 { 
 if let ASTNode::Symbols(r_4) = r_3 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        /* AAA */v0.to_string(),
        String::from(""),
        r_0,
        Some(r_2),
        Some(r_4),
        ASTNode::NONE,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } } } }
}
/// ```
/// {
///
/// t_IR_STATE,
///
/// c_IR,
///
/// c_IrState,
///
/// id:$1,
///
/// scanner:$2,
///
/// instructions:$3,
///
/// fail:$NULL,
///
/// symbol_meta:$4
/// }
/// ```
fn _fn4(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::NODES/*aa00*/(mut r_0) = v2 { 
 if let HCO::NODE/*aaRR*/(r_1) = v3 { 
 if let ASTNode::Symbols(r_2) = r_1 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        /* AAA */v0.to_string(),
        /* AAA */v1.to_string(),
        r_0,
        None /* WTF2 */,
        Some(r_2),
        ASTNode::NONE,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } }
}
/// ```
/// {
///
/// t_IR_STATE,
///
/// c_IR,
///
/// c_IrState,
///
/// id:$1,
///
/// scanner:$2,
///
/// instructions:$3,
///
/// fail:$4,
///
/// symbol_meta:$NULL
/// }
/// ```
fn _fn5(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::NODES/*aa00*/(mut r_0) = v2 { 
 if let HCO::NODE/*aaRR*/(r_1) = v3 { 
 if let ASTNode::FailState(r_2) = r_1 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        /* AAA */v0.to_string(),
        /* AAA */v1.to_string(),
        r_0,
        Some(r_2),
        None /* WTF2 */,
        ASTNode::NONE,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } }
}
/// ```
/// {
///
/// t_IR_STATE,
///
/// c_IR,
///
/// c_IrState,
///
/// id:$1,
///
/// scanner:$NULL,
///
/// instructions:$2,
///
/// fail:$NULL,
///
/// symbol_meta:$3
/// }
/// ```
fn _fn6(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODES/*aa00*/(mut r_0) = v1 { 
 if let HCO::NODE/*aaRR*/(r_1) = v2 { 
 if let ASTNode::Symbols(r_2) = r_1 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        /* AAA */v0.to_string(),
        String::from(""),
        r_0,
        None /* WTF2 */,
        Some(r_2),
        ASTNode::NONE,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } }
}
/// ```
/// {
///
/// t_IR_STATE,
///
/// c_IR,
///
/// c_IrState,
///
/// id:$1,
///
/// scanner:$NULL,
///
/// instructions:$2,
///
/// fail:$3,
///
/// symbol_meta:$NULL
/// }
/// ```
fn _fn7(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODES/*aa00*/(mut r_0) = v1 { 
 if let HCO::NODE/*aaRR*/(r_1) = v2 { 
 if let ASTNode::FailState(r_2) = r_1 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        /* AAA */v0.to_string(),
        String::from(""),
        r_0,
        Some(r_2),
        None /* WTF2 */,
        ASTNode::NONE,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } }
}
/// ```
/// {
///
/// t_IR_STATE,
///
/// c_IR,
///
/// c_IrState,
///
/// id:$1,
///
/// scanner:$2,
///
/// instructions:$3,
///
/// fail:$NULL,
///
/// symbol_meta:$NULL
/// }
/// ```
fn _fn8(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODES/*aa00*/(mut r_0) = v2 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        /* AAA */v0.to_string(),
        /* AAA */v1.to_string(),
        r_0,
        None /* WTF2 */,
        None /* WTF2 */,
        ASTNode::NONE,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// {
///
/// t_IR_STATE,
///
/// c_IR,
///
/// c_IrState,
///
/// id:$1,
///
/// scanner:$NULL,
///
/// instructions:$2,
///
/// fail:$NULL,
///
/// symbol_meta:$NULL
/// }
/// ```
fn _fn9(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODES/*aa00*/(mut r_0) = v1 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        /* AAA */v0.to_string(),
        String::from(""),
        r_0,
        None /* WTF2 */,
        None /* WTF2 */,
        ASTNode::NONE,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// {
///
/// t_ASSERT,
///
/// c_IR,
///
/// c_IR_Instruction,
///
/// is_peek:bool($2),
///
/// c_IR_Branch,
///
/// mode:str($3),
///
/// ids:$4,
///
/// instructions:$6
/// }
/// ```
fn _fn10(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v6 = args.remove(i - 0);
  let mut v5 = args.remove(i - 1);
  let mut v4 = args.remove(i - 2);
  let mut v3 = args.remove(i - 3);
  let mut v2 = args.remove(i - 4);
  let mut v1 = args.remove(i - 5);
  let mut v0 = args.remove(i - 6);
  if let HCO::TOKEN(r_0) = v1 {
    if let HCO::TOKEN(r_1) = v2 {
      if let HCO::NODES/*aa00*/(mut r_2) = v3 { 
 if let HCO::NODES/*aa00*/(mut r_3) = v5 { 
 let mut ref_0 = ASTNode::ASSERT(ASSERT::new(
        /* AAA */true,
        /* AAA */r_1.to_string(),
        r_2,
        r_3,
        false,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
    }
  }
}
/// ```
/// {
///
/// t_ASSERT,
///
/// c_IR,
///
/// c_IR_Instruction,
///
/// c_IR_Branch,
///
/// ids:$2,
///
/// is_skip:true
/// }
/// ```
fn _fn11(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODES/*aa00*/(mut r_0) = v1 { 
 let mut ref_0 = ASTNode::ASSERT(ASSERT::new(
        false,
        String::from(""),
        r_0,
        Vec::new(),
        /* AAA */true,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// {
///
/// t_DEFAULT,
///
/// c_IR,
///
/// c_IR_Instruction,
///
/// c_IR_Branch,
///
/// instructions:$3
/// }
/// ```
fn _fn12(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::NODES/*aa00*/(mut r_0) = v2 { 
 let mut ref_0 = ASTNode::DEFAULT(DEFAULT::new(
        r_0,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// {
///
/// t_ASSERT,
///
/// c_IR,
///
/// c_IR_Instruction,
///
/// is_peek:bool($NULL),
///
/// c_IR_Branch,
///
/// mode:str($2),
///
/// ids:$3,
///
/// instructions:$5
/// }
/// ```
fn _fn13(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v5 = args.remove(i - 0);
  let mut v4 = args.remove(i - 1);
  let mut v3 = args.remove(i - 2);
  let mut v2 = args.remove(i - 3);
  let mut v1 = args.remove(i - 4);
  let mut v0 = args.remove(i - 5);
  if let HCO::TOKEN(r_0) = v1 {
    if let HCO::NODES/*aa00*/(mut r_1) = v2 { 
 if let HCO::NODES/*aa00*/(mut r_2) = v4 { 
 let mut ref_0 = ASTNode::ASSERT(ASSERT::new(
        /* AAA */false,
        /* AAA */r_0.to_string(),
        r_1,
        r_2,
        false,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
  }
}
/// ```
/// { t_Num, val:i64($1) }
/// ```
fn _fn14(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  if let HCO::TOKEN(r_0) = v0 {
    let mut ref_0 = ASTNode::Num(Num::new(/* AAA */ r_0.to_i64()));
    args.push(HCO::NODE/*aa99*/(ref_0))
  }
}
/// ```
/// { t_Production_Symbol, c_Symbol, name:str($1), tok }
/// ```
fn _fn15(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  if let HCO::TOKEN(r_0) = v0 {
    let mut ref_0 = ASTNode::Production_Symbol(Production_Symbol::new(
      // AAA
      r_0.to_string(),
      // AAA
      tok,
    ));
    args.push(HCO::NODE/*aa99*/(ref_0))
  }
}
/// ```
/// {
///
/// t_Production_Import_Symbol,
///
/// c_Symbol,
///
/// module:str($1),
///
/// name:str($3),
///
/// tok
/// }
/// ```
fn _fn16(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::TOKEN(r_0) = v0 {
    if let HCO::TOKEN(r_1) = v2 {
      let mut ref_0 = ASTNode::Production_Import_Symbol(Production_Import_Symbol::new(
        // AAA
        r_0.to_string(),
        // AAA
        r_1.to_string(),
        // AAA
        tok,
      ));
      args.push(HCO::NODE/*aa99*/(ref_0))
    }
  }
}
/// ```
/// {
///
/// t_Reduce,
///
/// c_IR,
///
/// c_IR_Instruction,
///
/// len:i32($2),
///
/// body_id:i32($6)
/// }
/// ```
fn _fn17(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v5 = args.remove(i - 0);
  let mut v4 = args.remove(i - 1);
  let mut v3 = args.remove(i - 2);
  let mut v2 = args.remove(i - 3);
  let mut v1 = args.remove(i - 4);
  let mut v0 = args.remove(i - 5);
  if let HCO::TOKEN(r_0) = v1 {
    if let HCO::TOKEN(r_1) = v5 {
      let mut ref_0 = ASTNode::Reduce(Reduce::new(
        // AAA
        r_0.to_i32(),
        // AAA
        r_1.to_i32(),
        ASTNode::NONE,
      ));
      args.push(HCO::NODE/*aa99*/(ref_0))
    }
  }
}
/// ```
/// {
///
/// t_Reduce,
///
/// c_IR,
///
/// c_IR_Instruction,
///
/// len:i32(-1),
///
/// reduce_fn:$2
/// }
/// ```
fn _fn18(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::Reduce(Reduce::new(
        /* AAA */1.0 as i32,
        0i32,
        r_0,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_TokenAssign, c_IR, c_IR_Instruction, ids:$3 }
/// ```
fn _fn19(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODES/*aa00*/(mut r_0) = v2 { 
 let mut ref_0 = ASTNode::TokenAssign(TokenAssign::new(
        r_0,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_SetProd, c_IR, c_IR_Instruction, id:$4 }
/// ```
fn _fn20(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::NODE/*aaRR*/(r_0) = v3 { 
 let mut ref_0 = ASTNode::SetProd(SetProd::new(
        r_0,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// {
///
/// t_ForkTo,
///
/// c_IR,
///
/// c_IR_Instruction,
///
/// states:$4,
///
/// production_id:$9
/// }
/// ```
fn _fn21(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v8 = args.remove(i - 0);
  let mut v7 = args.remove(i - 1);
  let mut v6 = args.remove(i - 2);
  let mut v5 = args.remove(i - 3);
  let mut v4 = args.remove(i - 4);
  let mut v3 = args.remove(i - 5);
  let mut v2 = args.remove(i - 6);
  let mut v1 = args.remove(i - 7);
  let mut v0 = args.remove(i - 8);
  if let HCO::NODES/*aa00*/(mut r_0) = v3 { 
 if let HCO::NODE/*aaRR*/(r_1) = v8 { 
 if let ASTNode::Num(r_2) = r_1 { 
 let mut ref_0 = ASTNode::ForkTo(ForkTo::new(
        r_0,
        r_2,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } }
}
/// ```
/// {
///
/// t_ScanUntil,
///
/// c_IR,
///
/// c_IR_Instruction,
///
/// ids:$4,
///
/// SCAN_BACKWARDS:bool($2)
/// }
/// ```
fn _fn22(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::NODES/*aa00*/(mut r_0) = v3 { 
 if let HCO::TOKEN(r_1) = v1 { 
 let mut ref_0 = ASTNode::ScanUntil(ScanUntil::new(
        r_0,
        /* AAA */true,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
}
/// ```
/// { t_TokenId, c_IR, c_IR_Instruction, id:$5 }
/// ```
fn _fn23(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v4 = args.remove(i - 0);
  let mut v3 = args.remove(i - 1);
  let mut v2 = args.remove(i - 2);
  let mut v1 = args.remove(i - 3);
  let mut v0 = args.remove(i - 4);
  if let HCO::NODE/*aaRR*/(r_0) = v4 { 
 if let ASTNode::Num(r_1) = r_0 { 
 let mut ref_0 = ASTNode::TokenId(TokenId::new(
        r_1,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
}
/// ```
/// { t_Skip, c_IR, c_IR_Instruction }
/// ```
fn _fn24(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::Skip(Skip::new());
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_Pass, c_IR, c_IR_Instruction }
/// ```
fn _fn25(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::Pass(Pass::new());
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_Fail, c_IR, c_IR_Instruction }
/// ```
fn _fn26(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::Fail(Fail::new());
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_NotInScope, c_IR, c_IR_Instruction, ids:$5 }
/// ```
fn _fn27(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v5 = args.remove(i - 0);
  let mut v4 = args.remove(i - 1);
  let mut v3 = args.remove(i - 2);
  let mut v2 = args.remove(i - 3);
  let mut v1 = args.remove(i - 4);
  let mut v0 = args.remove(i - 5);
  if let HCO::NODES/*aa00*/(mut r_0) = v4 { 
 let mut ref_0 = ASTNode::NotInScope(NotInScope::new(
        r_0,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_SetScope, c_IR, c_IR_Instruction, scope:i64($1) }
/// ```
fn _fn28(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::TOKEN(r_0) = v0 {
    let mut ref_0 = ASTNode::SetScope(SetScope::new(/* AAA */ r_0.to_i64()));
    args.push(HCO::NODE/*aa99*/(ref_0))
  }
}
/// ```
/// { t_Consume, c_IR, c_IR_Instruction, EMPTY:bool($2) }
/// ```
fn _fn29(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::TOKEN(r_0) = v1 {
    let mut ref_0 = ASTNode::Consume(Consume::new(/* AAA */ true));
    args.push(HCO::NODE/*aa99*/(ref_0))
  }
}
/// ```
/// {
///
/// t_ScanUntil,
///
/// c_IR,
///
/// c_IR_Instruction,
///
/// ids:$3,
///
/// SCAN_BACKWARDS:bool($NULL)
/// }
/// ```
fn _fn30(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODES/*aa00*/(mut r_0) = v2 { 
 let mut ref_0 = ASTNode::ScanUntil(ScanUntil::new(
        r_0,
        /* AAA */false,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_Consume, c_IR, c_IR_Instruction, EMPTY:bool($NULL) }
/// ```
fn _fn31(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::Consume(Consume::new(/* AAA */ false));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_Ascript, c_Function, ast:$3, tok }
/// ```
fn _fn32(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::NODE/*aaRR*/(r_0) = v2 { 
 let mut ref_0 = ASTNode::Ascript(Ascript::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_Returned, c_Function, txt:str($3), tok }
/// ```
fn _fn33(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::TOKEN(r_0) = v2 {
    let mut ref_0 =
      ASTNode::Returned(Returned::new(/* AAA */ r_0.to_string(), /* AAA */ tok));
    args.push(HCO::NODE/*aa99*/(ref_0))
  }
}
/// ```
/// { t_Referenced, c_Function, reference:$3, tok }
/// ```
fn _fn34(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODE/*aaRR*/(r_0) = v2 { 
 if let ASTNode::Reference(r_1) = r_0 { 
 let mut ref_0 = ASTNode::Referenced(Referenced::new(
        r_1,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
}
/// ```
/// { t_AST_Statements, statements:$1, tok }
/// ```
fn _fn35(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  if let HCO::NODES/*aa00*/(mut r_0) = v0 { 
 let mut ref_0 = ASTNode::AST_Statements(AST_Statements::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_Struct, props:$2, tok }
/// ```
fn _fn36(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODES/*aa00*/(mut r_0) = v1 { 
 let mut ref_0 = ASTNode::AST_Struct(AST_Struct::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_Property, id:str($1), value:$3, tok }
/// ```
fn _fn37(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODE/*aaRR*/(r_0) = v2 { 
 let mut ref_0 = ASTNode::AST_Property(AST_Property::new(
        /* AAA */v0.to_string(),
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_TypeId, value:str($1), tok }
/// ```
fn _fn38(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  if let HCO::TOKEN(r_0) = v0 {
    let mut ref_0 =
      ASTNode::AST_TypeId(AST_TypeId::new(/* AAA */ r_0.to_string(), /* AAA */ tok));
    args.push(HCO::NODE/*aa99*/(ref_0))
  }
}
/// ```
/// { t_AST_ClassId, value:str($1), tok }
/// ```
fn _fn39(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  if let HCO::TOKEN(r_0) = v0 {
    let mut ref_0 =
      ASTNode::AST_ClassId(AST_ClassId::new(/* AAA */ r_0.to_string(), /* AAA */ tok));
    args.push(HCO::NODE/*aa99*/(ref_0))
  }
}
/// ```
/// { t_AST_Vector, initializer:$2, tok }
/// ```
fn _fn40(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODES/*aa00*/(mut r_0) = v1 { 
 let mut ref_0 = ASTNode::AST_Vector(AST_Vector::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_Vector, initializer:$NULL, tok }
/// ```
fn _fn41(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  let mut ref_0 = ASTNode::AST_Vector(AST_Vector::new(Vec::new(), /* AAA */ tok));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_Member, reference:$1, property:$3 }
/// ```
fn _fn42(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODE/*aaRR*/(r_0) = v0 { 
 let mut ref_0 = ASTNode::AST_Member(AST_Member::new(
        r_0,
        /* AAA */v2.Token(),
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_NamedReference, value:str($2), tok }
/// ```
fn _fn43(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  let mut ref_0 = ASTNode::AST_NamedReference(AST_NamedReference::new(
    // AAA
    v1.to_string(),
    // AAA
    tok,
  ));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_IndexReference, value:f64($2), tok }
/// ```
fn _fn44(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::TOKEN(r_0) = v1 {
    let mut ref_0 = ASTNode::AST_IndexReference(AST_IndexReference::new(
      // AAA
      r_0.to_f64(),
      // AAA
      tok,
    ));
    args.push(HCO::NODE/*aa99*/(ref_0))
  }
}
/// ```
/// { t_AST_STRING, value:$2, tok }
/// ```
fn _fn45(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::AST_STRING(AST_STRING::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_STRING, value:$NULL, tok }
/// ```
fn _fn46(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::AST_STRING(AST_STRING::new(ASTNode::NONE, /* AAA */ tok));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_Token }
/// ```
fn _fn47(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::AST_Token(AST_Token::new());
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_U8, initializer:$2, tok }
/// ```
fn _fn48(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::AST_U8(AST_U8::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_U16, initializer:$2, tok }
/// ```
fn _fn49(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::AST_U16(AST_U16::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_U32, initializer:$2, tok }
/// ```
fn _fn50(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::AST_U32(AST_U32::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_U64, initializer:$2, tok }
/// ```
fn _fn51(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::AST_U64(AST_U64::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_I8, initializer:$2, tok }
/// ```
fn _fn52(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::AST_I8(AST_I8::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_I16, initializer:$2, tok }
/// ```
fn _fn53(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::AST_I16(AST_I16::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_I32, initializer:$2, tok }
/// ```
fn _fn54(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::AST_I32(AST_I32::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_I64, initializer:$2, tok }
/// ```
fn _fn55(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::AST_I64(AST_I64::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_F32, initializer:$2, tok }
/// ```
fn _fn56(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::AST_F32(AST_F32::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_F64, initializer:$2, tok }
/// ```
fn _fn57(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::AST_F64(AST_F64::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_U8, initializer:$NULL, tok }
/// ```
fn _fn58(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::AST_U8(AST_U8::new(ASTNode::NONE, /* AAA */ tok));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_U16, initializer:$NULL, tok }
/// ```
fn _fn59(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::AST_U16(AST_U16::new(ASTNode::NONE, /* AAA */ tok));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_U32, initializer:$NULL, tok }
/// ```
fn _fn60(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::AST_U32(AST_U32::new(ASTNode::NONE, /* AAA */ tok));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_U64, initializer:$NULL, tok }
/// ```
fn _fn61(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::AST_U64(AST_U64::new(ASTNode::NONE, /* AAA */ tok));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_I8, initializer:$NULL, tok }
/// ```
fn _fn62(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::AST_I8(AST_I8::new(ASTNode::NONE, /* AAA */ tok));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_I16, initializer:$NULL, tok }
/// ```
fn _fn63(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::AST_I16(AST_I16::new(ASTNode::NONE, /* AAA */ tok));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_I32, initializer:$NULL, tok }
/// ```
fn _fn64(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::AST_I32(AST_I32::new(ASTNode::NONE, /* AAA */ tok));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_I64, initializer:$NULL, tok }
/// ```
fn _fn65(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::AST_I64(AST_I64::new(ASTNode::NONE, /* AAA */ tok));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_F32, initializer:$NULL, tok }
/// ```
fn _fn66(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::AST_F32(AST_F32::new(ASTNode::NONE, /* AAA */ tok));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_F64, initializer:$NULL, tok }
/// ```
fn _fn67(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::AST_F64(AST_F64::new(ASTNode::NONE, /* AAA */ tok));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_BOOL, initializer:$2, tok }
/// ```
fn _fn68(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::AST_BOOL(AST_BOOL::new(
        r_0,
        /* AAA */tok,
        false,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AST_BOOL, initializer:$NULL, tok }
/// ```
fn _fn69(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::AST_BOOL(AST_BOOL::new(ASTNode::NONE, /* AAA */ tok, false));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_BOOL, value:true }
/// ```
fn _fn70(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 =
    ASTNode::AST_BOOL(AST_BOOL::new(ASTNode::NONE, Token::empty(), /* AAA */ true));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_BOOL, value:false }
/// ```
fn _fn71(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 =
    ASTNode::AST_BOOL(AST_BOOL::new(ASTNode::NONE, Token::empty(), /* AAA */ false));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_AST_NUMBER, value:f64($1) }
/// ```
fn _fn72(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  if let HCO::TOKEN(r_0) = v0 {
    let mut ref_0 = ASTNode::AST_NUMBER(AST_NUMBER::new(/* AAA */ r_0.to_f64()));
    args.push(HCO::NODE/*aa99*/(ref_0))
  }
}
/// ```
/// { t_AST_Add, left:$1, right:$3, tok }
/// ```
fn _fn73(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODE/*aaRR*/(r_0) = v0 { 
 if let HCO::NODE/*aaRR*/(r_1) = v2 { 
 let mut ref_0 = ASTNode::AST_Add(AST_Add::new(
        r_0,
        r_1,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
}
/// ```
/// { t_Reference, c_Symbol, val:str($1) }
/// ```
fn _fn74(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  if let HCO::TOKEN(r_0) = v0 {
    let mut ref_0 = ASTNode::Reference(Reference::new(/* AAA */ r_0.to_string()));
    args.push(HCO::NODE/*aa99*/(ref_0))
  }
}
/// ```
/// { t_Generated, c_Symbol, c_Token, val:str($2), tok }
/// ```
fn _fn75(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::TOKEN(r_0) = v1 {
    let mut ref_0 =
      ASTNode::Generated(Generated::new(/* AAA */ r_0.to_string(), /* AAA */ tok));
    args.push(HCO::NODE/*aa99*/(ref_0))
  }
}
/// ```
/// {
///
/// t_Exclusive_Literal,
///
/// c_Symbol,
///
/// c_Token,
///
/// val:str($2),
///
/// tok
/// }
/// ```
fn _fn76(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::TOKEN(r_0) = v1 {
    let mut ref_0 = ASTNode::Exclusive_Literal(Exclusive_Literal::new(
      // AAA
      r_0.to_string(),
      // AAA
      tok,
    ));
    args.push(HCO::NODE/*aa99*/(ref_0))
  }
}
/// ```
/// { t_Literal, c_Symbol, c_Token, val:str($1), tok }
/// ```
fn _fn77(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::Literal(Literal::new(/* AAA */ v0.to_string(), /* AAA */ tok));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_Literal, c_Symbol, c_Token, val:str($2), tok }
/// ```
fn _fn78(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::TOKEN(r_0) = v1 {
    let mut ref_0 =
      ASTNode::Literal(Literal::new(/* AAA */ r_0.to_string(), /* AAA */ tok));
    args.push(HCO::NODE/*aa99*/(ref_0))
  }
}
/// ```
/// { t_End_Of_File, c_Symbol, c_Token, tok }
/// ```
fn _fn79(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::End_Of_File(End_Of_File::new(/* AAA */ tok));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_Space, c_Meta, c_Format, position:i16(0) }
/// ```
fn _fn80(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::Space(Space::new(/* AAA */ 0.0 as i16));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_NewLine, c_Meta, c_Format, position:i16(0) }
/// ```
fn _fn81(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::NewLine(NewLine::new(/* AAA */ 0.0 as i16));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_IncreaseIndent, c_Meta, c_Format, position:i16(0) }
/// ```
fn _fn82(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::IncreaseIndent(IncreaseIndent::new(/* AAA */ 0.0 as i16));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_DecreaseIndent, c_Meta, c_Format, position:i16(0) }
/// ```
fn _fn83(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::DecreaseIndent(DecreaseIndent::new(/* AAA */ 0.0 as i16));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// {
///
/// t_Production_Token,
///
/// c_Symbol,
///
/// c_Token,
///
/// production:$2,
///
/// tok
/// }
/// ```
fn _fn84(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::Production_Token(Production_Token::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_Goto, c_IR, c_IR_Instruction, state:$2 }
/// ```
fn _fn85(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::Goto(Goto::new(
        r_0,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// {
///
/// t_FailState,
///
/// c_IR,
///
/// c_IR_State,
///
/// id:$3,
///
/// instructions:$4,
///
/// symbol_meta:$6,
///
/// fail:$5
/// }
/// ```
fn _fn86(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v5 = args.remove(i - 0);
  let mut v4 = args.remove(i - 1);
  let mut v3 = args.remove(i - 2);
  let mut v2 = args.remove(i - 3);
  let mut v1 = args.remove(i - 4);
  let mut v0 = args.remove(i - 5);
  if let HCO::NODES/*aa00*/(mut r_0) = v3 { 
 if let HCO::NODE/*aaRR*/(r_1) = v5 { 
 if let ASTNode::Symbols(r_2) = r_1 { 
 if let HCO::NODE/*aaRR*/(r_3) = v4 { 
 if let ASTNode::FailState(r_4) = r_3 { 
 let mut ref_0 = ASTNode::FailState(FailState::new(
        /* AAA */v2.to_string(),
        r_0,
        Some(r_2),
        Some(r_4),
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } } } }
}
/// ```
/// {
///
/// t_FailState,
///
/// c_IR,
///
/// c_IR_State,
///
/// id:$3,
///
/// instructions:$4,
///
/// symbol_meta:$5,
///
/// fail:$NULL
/// }
/// ```
fn _fn87(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v4 = args.remove(i - 0);
  let mut v3 = args.remove(i - 1);
  let mut v2 = args.remove(i - 2);
  let mut v1 = args.remove(i - 3);
  let mut v0 = args.remove(i - 4);
  if let HCO::NODES/*aa00*/(mut r_0) = v3 { 
 if let HCO::NODE/*aaRR*/(r_1) = v4 { 
 if let ASTNode::Symbols(r_2) = r_1 { 
 let mut ref_0 = ASTNode::FailState(FailState::new(
        /* AAA */v2.to_string(),
        r_0,
        Some(r_2),
        None /* WTF2 */,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } }
}
/// ```
/// {
///
/// t_FailState,
///
/// c_IR,
///
/// c_IR_State,
///
/// id:$3,
///
/// instructions:$4,
///
/// symbol_meta:$NULL,
///
/// fail:$5
/// }
/// ```
fn _fn88(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v4 = args.remove(i - 0);
  let mut v3 = args.remove(i - 1);
  let mut v2 = args.remove(i - 2);
  let mut v1 = args.remove(i - 3);
  let mut v0 = args.remove(i - 4);
  if let HCO::NODES/*aa00*/(mut r_0) = v3 { 
 if let HCO::NODE/*aaRR*/(r_1) = v4 { 
 if let ASTNode::FailState(r_2) = r_1 { 
 let mut ref_0 = ASTNode::FailState(FailState::new(
        /* AAA */v2.to_string(),
        r_0,
        None /* WTF2 */,
        Some(r_2),
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } }
}
/// ```
/// {
///
/// t_FailState,
///
/// c_IR,
///
/// c_IR_State,
///
/// id:$3,
///
/// instructions:$4,
///
/// symbol_meta:$NULL,
///
/// fail:$NULL
/// }
/// ```
fn _fn89(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::NODES/*aa00*/(mut r_0) = v3 { 
 let mut ref_0 = ASTNode::FailState(FailState::new(
        /* AAA */v2.to_string(),
        r_0,
        None /* WTF2 */,
        None /* WTF2 */,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_Symbols, c_IR, expected:$3, skipped:$4 }
/// ```
fn _fn90(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::NODES/*aa00*/(mut r_0) = v2 { 
 if let HCO::NODES/*aa00*/(mut r_1) = v3 { 
 let mut ref_0 = ASTNode::Symbols(Symbols::new(
        r_0,
        r_1,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
}
/// ```
/// { t_Symbols, c_IR, expected:$3, skipped:$NULL }
/// ```
fn _fn91(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODES/*aa00*/(mut r_0) = v2 { 
 let mut ref_0 = ASTNode::Symbols(Symbols::new(
        r_0,
        Vec::new(),
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_AnnotatedSymbol, c_Symbol, symbol:$1, reference:$2 }
/// ```
fn _fn92(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v0 { 
 if let HCO::NODE/*aaRR*/(r_1) = v1 { 
 if let ASTNode::Reference(r_2) = r_1 { 
 let mut ref_0 = ASTNode::AnnotatedSymbol(AnnotatedSymbol::new(
        r_0,
        r_2,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } }
}
/// ```
/// { t_OptionalSymbol, symbol:$1 }
/// ```
fn _fn93(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v0 { 
 let mut ref_0 = ASTNode::OptionalSymbol(OptionalSymbol::new(
        r_0,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_Not_Symbol, c_Symbol, symbol:$2, tok }
/// ```
fn _fn94(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::Not_Symbol(Not_Symbol::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_Look_Behind, c_Symbol, symbol:$2, tok }
/// ```
fn _fn95(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::Look_Behind(Look_Behind::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_NonCaptureSymbol, c_Symbol, sym:$2 }
/// ```
fn _fn96(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 let mut ref_0 = ASTNode::NonCaptureSymbol(NonCaptureSymbol::new(
        r_0,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// {
///
/// t_List_Production,
///
/// c_Symbol,
///
/// terminal_symbol:$3,
///
/// symbols:$1,
///
/// tok
/// }
/// ```
fn _fn97(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::NODE/*aaRR*/(r_0) = v2 { 
 if let HCO::NODE/*aaRR*/(r_1) = v0 { 
 let mut ref_0 = ASTNode::List_Production(List_Production::new(
        r_0,
        r_1,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
}
/// ```
/// {
///
/// t_Optional_List_Production,
///
/// c_Symbol,
///
/// terminal_symbol:$3,
///
/// symbols:$1,
///
/// tok
/// }
/// ```
fn _fn98(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::NODE/*aaRR*/(r_0) = v2 { 
 if let HCO::NODE/*aaRR*/(r_1) = v0 { 
 let mut ref_0 = ASTNode::Optional_List_Production(Optional_List_Production::new(
        r_0,
        r_1,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
}
/// ```
/// {
///
/// t_List_Production,
///
/// c_Symbol,
///
/// terminal_symbol:$NULL,
///
/// symbols:$1,
///
/// tok
/// }
/// ```
fn _fn99(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODE/*aaRR*/(r_0) = v0 { 
 let mut ref_0 = ASTNode::List_Production(List_Production::new(
        ASTNode::NONE,
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// {
///
/// t_Optional_List_Production,
///
/// c_Symbol,
///
/// terminal_symbol:$NULL,
///
/// symbols:$1,
///
/// tok
/// }
/// ```
fn _fn100(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODE/*aaRR*/(r_0) = v0 { 
 let mut ref_0 = ASTNode::Optional_List_Production(Optional_List_Production::new(
        ASTNode::NONE,
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_Group_Production, c_Symbol, bodies:$2, tok }
/// ```
fn _fn101(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODES/*aa00*/(mut r_0) = v1 { 
 let mut ref_0 = ASTNode::Group_Production(Group_Production::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// {
///
/// t_Body,
///
/// c_Production,
///
/// priority:bool($1),
///
/// symbols:$3,
///
/// reference:$2,
///
/// reduce_function:$4,
///
/// tok
/// }
/// ```
fn _fn102(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::TOKEN(r_0) = v0 {
    if let HCO::NODES/*aa00*/(mut r_1) = v2 { 
 if let HCO::NODE/*aaRR*/(r_2) = v1 { 
 if let ASTNode::Reference(r_3) = r_2 { 
 if let HCO::NODE/*aaRR*/(r_4) = v3 { 
 let mut ref_0 = ASTNode::Body(Body::new(
        /* AAA */true,
        r_1,
        Some(r_3),
        r_4,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } } }
  }
}
/// ```
/// {
///
/// t_Body,
///
/// c_Production,
///
/// priority:bool($NULL),
///
/// symbols:$2,
///
/// reference:$1,
///
/// reduce_function:$3,
///
/// tok
/// }
/// ```
fn _fn103(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODES/*aa00*/(mut r_0) = v1 { 
 if let HCO::NODE/*aaRR*/(r_1) = v0 { 
 if let ASTNode::Reference(r_2) = r_1 { 
 if let HCO::NODE/*aaRR*/(r_3) = v2 { 
 let mut ref_0 = ASTNode::Body(Body::new(
        /* AAA */false,
        r_0,
        Some(r_2),
        r_3,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } } }
}
/// ```
/// {
///
/// t_Body,
///
/// c_Production,
///
/// priority:bool($1),
///
/// symbols:$2,
///
/// reference:$NULL,
///
/// reduce_function:$3,
///
/// tok
/// }
/// ```
fn _fn104(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::TOKEN(r_0) = v0 {
    if let HCO::NODES/*aa00*/(mut r_1) = v1 { 
 if let HCO::NODE/*aaRR*/(r_2) = v2 { 
 let mut ref_0 = ASTNode::Body(Body::new(
        /* AAA */true,
        r_1,
        None /* WTF2 */,
        r_2,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
  }
}
/// ```
/// {
///
/// t_Body,
///
/// c_Production,
///
/// priority:bool($1),
///
/// symbols:$3,
///
/// reference:$2,
///
/// reduce_function:$NULL,
///
/// tok
/// }
/// ```
fn _fn105(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::TOKEN(r_0) = v0 {
    if let HCO::NODES/*aa00*/(mut r_1) = v2 { 
 if let HCO::NODE/*aaRR*/(r_2) = v1 { 
 if let ASTNode::Reference(r_3) = r_2 { 
 let mut ref_0 = ASTNode::Body(Body::new(
        /* AAA */true,
        r_1,
        Some(r_3),
        ASTNode::NONE,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } }
  }
}
/// ```
/// {
///
/// t_Body,
///
/// c_Production,
///
/// priority:bool($NULL),
///
/// symbols:$1,
///
/// reference:$NULL,
///
/// reduce_function:$2,
///
/// tok
/// }
/// ```
fn _fn106(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODES/*aa00*/(mut r_0) = v0 { 
 if let HCO::NODE/*aaRR*/(r_1) = v1 { 
 let mut ref_0 = ASTNode::Body(Body::new(
        /* AAA */false,
        r_0,
        None /* WTF2 */,
        r_1,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
}
/// ```
/// {
///
/// t_Body,
///
/// c_Production,
///
/// priority:bool($NULL),
///
/// symbols:$2,
///
/// reference:$1,
///
/// reduce_function:$NULL,
///
/// tok
/// }
/// ```
fn _fn107(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODES/*aa00*/(mut r_0) = v1 { 
 if let HCO::NODE/*aaRR*/(r_1) = v0 { 
 if let ASTNode::Reference(r_2) = r_1 { 
 let mut ref_0 = ASTNode::Body(Body::new(
        /* AAA */false,
        r_0,
        Some(r_2),
        ASTNode::NONE,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } }
}
/// ```
/// {
///
/// t_Body,
///
/// c_Production,
///
/// priority:bool($1),
///
/// symbols:$2,
///
/// reference:$NULL,
///
/// reduce_function:$NULL,
///
/// tok
/// }
/// ```
fn _fn108(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::TOKEN(r_0) = v0 {
    if let HCO::NODES/*aa00*/(mut r_1) = v1 { 
 let mut ref_0 = ASTNode::Body(Body::new(
        /* AAA */true,
        r_1,
        None /* WTF2 */,
        ASTNode::NONE,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
  }
}
/// ```
/// {
///
/// t_Body,
///
/// c_Production,
///
/// priority:bool($NULL),
///
/// symbols:$1,
///
/// reference:$NULL,
///
/// reduce_function:$NULL,
///
/// tok
/// }
/// ```
fn _fn109(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  if let HCO::NODES/*aa00*/(mut r_0) = v0 { 
 let mut ref_0 = ASTNode::Body(Body::new(
        /* AAA */false,
        r_0,
        None /* WTF2 */,
        ASTNode::NONE,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_Exclude, c_Symbol, c_Meta, sym:$2, tok }
/// ```
fn _fn110(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODES/*aa00*/(mut r_0) = v1 { 
 let mut ref_0 = ASTNode::Exclude(Exclude::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_Look_Ignore, c_Symbol, c_Meta, sym:$2, tok }
/// ```
fn _fn111(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODES/*aa00*/(mut r_0) = v1 { 
 let mut ref_0 = ASTNode::Look_Ignore(Look_Ignore::new(
        r_0,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_Empty, c_Symbol, tok }
/// ```
fn _fn112(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::Empty(Empty::new(/* AAA */ tok));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// {
///
/// t_Production,
///
/// c_Production,
///
/// priority:bool($3),
///
/// symbol:$s,
///
/// bodies:$b,
///
/// LAZY:bool($l),
///
/// tok
/// }
/// ```
fn _fn113(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v5 = args.remove(i - 0);
  let mut v4 = args.remove(i - 1);
  let mut v3 = args.remove(i - 2);
  let mut v2 = args.remove(i - 3);
  let mut v1 = args.remove(i - 4);
  let mut v0 = args.remove(i - 5);
  if let HCO::TOKEN(r_0) = v2 {
    if let HCO::NODE/*aaRR*/(r_1) = v3 { 
 if let HCO::NODES/*aa00*/(mut r_2) = v5 { 
 if let HCO::TOKEN(r_3) = v1 { 
 let mut ref_0 = ASTNode::Production(Production::new(
        /* AAA */true,
        r_1,
        r_2,
        /* AAA */true,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } }
  }
}
/// ```
/// {
///
/// t_ProductionMerged,
///
/// c_Production,
///
/// symbol:$2,
///
/// bodies:$4,
///
/// tok
/// }
/// ```
fn _fn114(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 if let HCO::NODES/*aa00*/(mut r_1) = v3 { 
 let mut ref_0 = ASTNode::ProductionMerged(ProductionMerged::new(
        r_0,
        r_1,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
}
/// ```
/// {
///
/// t_Production,
///
/// c_Production,
///
/// priority:bool($2),
///
/// symbol:$s,
///
/// bodies:$b,
///
/// LAZY:bool($l),
///
/// tok
/// }
/// ```
fn _fn115(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v4 = args.remove(i - 0);
  let mut v3 = args.remove(i - 1);
  let mut v2 = args.remove(i - 2);
  let mut v1 = args.remove(i - 3);
  let mut v0 = args.remove(i - 4);
  if let HCO::TOKEN(r_0) = v1 {
    if let HCO::NODE/*aaRR*/(r_1) = v2 { 
 if let HCO::NODES/*aa00*/(mut r_2) = v4 { 
 let mut ref_0 = ASTNode::Production(Production::new(
        /* AAA */true,
        r_1,
        r_2,
        /* AAA */false,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
  }
}
/// ```
/// {
///
/// t_Production,
///
/// c_Production,
///
/// priority:bool($NULL),
///
/// symbol:$s,
///
/// bodies:$b,
///
/// LAZY:bool($l),
///
/// tok
/// }
/// ```
fn _fn116(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v4 = args.remove(i - 0);
  let mut v3 = args.remove(i - 1);
  let mut v2 = args.remove(i - 2);
  let mut v1 = args.remove(i - 3);
  let mut v0 = args.remove(i - 4);
  if let HCO::NODE/*aaRR*/(r_0) = v2 { 
 if let HCO::NODES/*aa00*/(mut r_1) = v4 { 
 if let HCO::TOKEN(r_2) = v1 { 
 let mut ref_0 = ASTNode::Production(Production::new(
        /* AAA */false,
        r_0,
        r_1,
        /* AAA */true,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } }
}
/// ```
/// {
///
/// t_Production,
///
/// c_Production,
///
/// priority:bool($NULL),
///
/// symbol:$s,
///
/// bodies:$b,
///
/// LAZY:bool($l),
///
/// tok
/// }
/// ```
fn _fn117(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 if let HCO::NODES/*aa00*/(mut r_1) = v3 { 
 let mut ref_0 = ASTNode::Production(Production::new(
        /* AAA */false,
        r_0,
        r_1,
        /* AAA */false,
        /* AAA */tok,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
}
/// ```
/// { t_Ignore, c_Preamble, symbols:$2 }
/// ```
fn _fn118(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODES/*aa00*/(mut r_0) = v1 { 
 let mut ref_0 = ASTNode::Ignore(Ignore::new(
        r_0,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// { t_Import, c_Preamble, uri:$2, reference:$4, tok }
/// ```
fn _fn119(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  let mut ref_0 = ASTNode::Import(Import::new(
    // AAA
    v1.to_string(),
    // AAA
    v3.Token(),
    // AAA
    tok,
  ));
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_Export, c_Preamble, production:$2, reference:$4 }
/// ```
fn _fn120(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 if let HCO::TOKEN(r_1) = v3 { 
 let mut ref_0 = ASTNode::Export(Export::new(
        r_0,
        /* AAA */r_1,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
}
/// ```
/// { t_Name, c_Preamble, name:str($2) }
/// ```
fn _fn121(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::TOKEN(r_0) = v1 {
    let mut ref_0 = ASTNode::Name(Name::new(/* AAA */ r_0.to_string()));
    args.push(HCO::NODE/*aa99*/(ref_0))
  }
}
/// ```
/// { t_Out_Of_Band, c_Function, reference:$2, txt:str($3) }
/// ```
fn _fn122(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 if let ASTNode::Reference(r_1) = r_0 { 
 if let HCO::TOKEN(r_2) = v2 { 
 let mut ref_0 = ASTNode::Out_Of_Band(Out_Of_Band::new(
        Some(r_1),
        /* AAA */r_2.to_string(),
        ASTNode::NONE,
        Token::empty(),
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } }
}
/// ```
/// {
///
/// t_Out_Of_Band,
///
/// c_Function,
///
/// production:$2,
///
/// index:$3,
///
/// txt:str($4)
/// }
/// ```
fn _fn123(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::TOKEN(r_0) = v3 {
    if let HCO::NODE/*aaRR*/(r_1) = v1 { 
 let mut ref_0 = ASTNode::Out_Of_Band(Out_Of_Band::new(
        None /* WTF2 */,
        /* AAA */r_0.to_string(),
        r_1,
        /* AAA */v2.Token(),
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
  }
}
/// ```
/// {
///
/// t_Out_Of_Band,
///
/// c_Function,
///
/// production:$2,
///
/// index:$3,
///
/// reference:$4
/// }
/// ```
fn _fn124(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::NODE/*aaRR*/(r_0) = v3 { 
 if let ASTNode::Reference(r_1) = r_0 { 
 if let HCO::NODE/*aaRR*/(r_2) = v1 { 
 let mut ref_0 = ASTNode::Out_Of_Band(Out_Of_Band::new(
        Some(r_1),
        String::from(""),
        r_2,
        /* AAA */v2.Token(),
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } }
}
/// ```
/// {
///
/// t_Out_Of_Band,
///
/// c_Function,
///
/// production:$2,
///
/// index:$NULL,
///
/// txt:str($3)
/// }
/// ```
fn _fn125(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::TOKEN(r_0) = v2 {
    if let HCO::NODE/*aaRR*/(r_1) = v1 { 
 let mut ref_0 = ASTNode::Out_Of_Band(Out_Of_Band::new(
        None /* WTF2 */,
        /* AAA */r_0.to_string(),
        r_1,
        Token::empty(),
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
  }
}
/// ```
/// {
///
/// t_Out_Of_Band,
///
/// c_Function,
///
/// production:$2,
///
/// index:$NULL,
///
/// reference:$3
/// }
/// ```
fn _fn126(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODE/*aaRR*/(r_0) = v2 { 
 if let ASTNode::Reference(r_1) = r_0 { 
 if let HCO::NODE/*aaRR*/(r_2) = v1 { 
 let mut ref_0 = ASTNode::Out_Of_Band(Out_Of_Band::new(
        Some(r_1),
        String::from(""),
        r_2,
        Token::empty(),
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } }
}
/// ```
/// {
///
/// t_IR_STATE,
///
/// c_IR,
///
/// c_IrState,
///
/// prod:$3,
///
/// instructions:$5,
///
/// fail:$6,
///
/// symbol_meta:$7
/// }
/// ```
fn _fn127(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v7 = args.remove(i - 0);
  let mut v6 = args.remove(i - 1);
  let mut v5 = args.remove(i - 2);
  let mut v4 = args.remove(i - 3);
  let mut v3 = args.remove(i - 4);
  let mut v2 = args.remove(i - 5);
  let mut v1 = args.remove(i - 6);
  let mut v0 = args.remove(i - 7);
  if let HCO::NODES/*aa00*/(mut r_0) = v4 { 
 if let HCO::NODE/*aaRR*/(r_1) = v5 { 
 if let ASTNode::FailState(r_2) = r_1 { 
 if let HCO::NODE/*aaRR*/(r_3) = v6 { 
 if let ASTNode::Symbols(r_4) = r_3 { 
 if let HCO::NODE/*aaRR*/(r_5) = v2 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        String::from(""),
        String::from(""),
        r_0,
        Some(r_2),
        Some(r_4),
        r_5,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } } } } }
}
/// ```
/// {
///
/// t_IR_STATE,
///
/// c_IR,
///
/// c_IrState,
///
/// prod:$3,
///
/// instructions:$5,
///
/// fail:$NULL,
///
/// symbol_meta:$6
/// }
/// ```
fn _fn128(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v6 = args.remove(i - 0);
  let mut v5 = args.remove(i - 1);
  let mut v4 = args.remove(i - 2);
  let mut v3 = args.remove(i - 3);
  let mut v2 = args.remove(i - 4);
  let mut v1 = args.remove(i - 5);
  let mut v0 = args.remove(i - 6);
  if let HCO::NODES/*aa00*/(mut r_0) = v4 { 
 if let HCO::NODE/*aaRR*/(r_1) = v5 { 
 if let ASTNode::Symbols(r_2) = r_1 { 
 if let HCO::NODE/*aaRR*/(r_3) = v2 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        String::from(""),
        String::from(""),
        r_0,
        None /* WTF2 */,
        Some(r_2),
        r_3,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } } }
}
/// ```
/// {
///
/// t_IR_STATE,
///
/// c_IR,
///
/// c_IrState,
///
/// prod:$3,
///
/// instructions:$5,
///
/// fail:$6,
///
/// symbol_meta:$NULL
/// }
/// ```
fn _fn129(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v6 = args.remove(i - 0);
  let mut v5 = args.remove(i - 1);
  let mut v4 = args.remove(i - 2);
  let mut v3 = args.remove(i - 3);
  let mut v2 = args.remove(i - 4);
  let mut v1 = args.remove(i - 5);
  let mut v0 = args.remove(i - 6);
  if let HCO::NODES/*aa00*/(mut r_0) = v4 { 
 if let HCO::NODE/*aaRR*/(r_1) = v5 { 
 if let ASTNode::FailState(r_2) = r_1 { 
 if let HCO::NODE/*aaRR*/(r_3) = v2 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        String::from(""),
        String::from(""),
        r_0,
        Some(r_2),
        None /* WTF2 */,
        r_3,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } } } }
}
/// ```
/// {
///
/// t_IR_STATE,
///
/// c_IR,
///
/// c_IrState,
///
/// prod:$3,
///
/// instructions:$5,
///
/// fail:$NULL,
///
/// symbol_meta:$NULL
/// }
/// ```
fn _fn130(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v5 = args.remove(i - 0);
  let mut v4 = args.remove(i - 1);
  let mut v3 = args.remove(i - 2);
  let mut v2 = args.remove(i - 3);
  let mut v1 = args.remove(i - 4);
  let mut v0 = args.remove(i - 5);
  if let HCO::NODES/*aa00*/(mut r_0) = v4 { 
 if let HCO::NODE/*aaRR*/(r_1) = v2 { 
 let mut ref_0 = ASTNode::IR_STATE(IR_STATE::new(
        String::from(""),
        String::from(""),
        r_0,
        None /* WTF2 */,
        None /* WTF2 */,
        r_1,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) } }
}
/// ```
/// { t_Repeat, c_IR, c_IR_Instruction }
/// ```
fn _fn131(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  let mut ref_0 = ASTNode::Repeat(Repeat::new());
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// {
///
/// t_Lazy,
///
/// c_IR,
///
/// c_IR_Instruction,
///
/// cp_start:$3,
///
/// cp_end:$4,
///
/// state:$6
/// }
/// ```
fn _fn132(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v5 = args.remove(i - 0);
  let mut v4 = args.remove(i - 1);
  let mut v3 = args.remove(i - 2);
  let mut v2 = args.remove(i - 3);
  let mut v1 = args.remove(i - 4);
  let mut v0 = args.remove(i - 5);
  if let HCO::TOKEN(r_0) = v2 {
    if let HCO::TOKEN(r_1) = v3 {
      if let HCO::NODE/*aaRR*/(r_2) = v5 { 
 let mut ref_0 = ASTNode::Lazy(Lazy::new(
        /* AAA */r_0,
        /* AAA */r_1,
        r_2,
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
    }
  }
}
/// ```
/// { t_HASH_NAME, val:str($1) }
/// ```
fn _fn133(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  if let HCO::TOKEN(r_0) = v0 {
    let mut ref_0 = ASTNode::HASH_NAME(HASH_NAME::new(/* AAA */ r_0.to_string()));
    args.push(HCO::NODE/*aa99*/(ref_0))
  }
}
/// ```
/// { t_FunctionIndexNum, value:f64($1) }
/// ```
fn _fn134(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  if let HCO::TOKEN(r_0) = v0 {
    let mut ref_0 = ASTNode::FunctionIndexNum(FunctionIndexNum::new(/* AAA */ r_0.to_f64()));
    args.push(HCO::NODE/*aa99*/(ref_0))
  }
}
/// ```
/// { t_FunctionIndexWildCard }
/// ```
fn _fn135(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  let mut ref_0 = ASTNode::FunctionIndexWildCard(FunctionIndexWildCard::new());
  args.push(HCO::NODE/*aa99*/(ref_0))
}
/// ```
/// { t_FunctionIndexId, value:str($1) }
/// ```
fn _fn136(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  if let HCO::NODE/*aaRR*/(r_0) = v0 { 
 let mut ref_0 = ASTNode::FunctionIndexId(FunctionIndexId::new(
        /* AAA */r_0.to_string(),
    ) 
);;
 args.push(HCO::NODE/*aa99*/(ref_0)) }
}
/// ```
/// str($3)
/// ```
fn _fn137(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::TOKEN(r_0) = v2 {
    args.push(HCO::STRING(r_0.to_string()))
  }
}
/// ```
/// $2
/// ```
fn _fn138(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);

  if let HCO::NODES/*aa00*/(mut r_0) = v1 { 

                                args.push(HCO::NODES/*aa22*/(r_0)); }
}
/// ```
/// [$1]
/// ```
fn _fn139(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);

  let mut ref_0: Vec<Token> = Vec::new();
  if let HCO::TOKEN(r_0) = v0 {
    ref_0.push(/* RR7 */ r_0);

    args.push(HCO::TOKENS(ref_0));
  }
}
/// ```
/// $__first__+$__last__
/// ```
fn _fn140(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);

  if let HCO::TOKENS(mut r_0) = v0 {
    if let HCO::TOKEN(r_1) = v1 {
      r_0.push(/* UX4 TOKEN */ r_1);

      args.push(HCO::TOKENS(r_0));
    }
  }
}
/// ```
/// $1+$2
/// ```
fn _fn141(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::TOKEN(r_0) = v1 {
    args.push(HCO::STRING(v0.to_string() + &r_0.to_string()))
  }
}
/// ```
/// $1+$3+[$4]
/// ```
fn _fn142(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);

  let mut ref_0: Vec<ASTNode> = Vec::new();
  if let HCO::NODE/*aaRR*/(r_0) = v3 { 
ref_0.push(/*RR6*/r_0);
 if let HCO::NODES/*aa00*/(mut r_1) = v0 { 
 if let HCO::NODES/*aa00*/(mut r_2) = v2 { 
r_1.append(&mut r_2);
ref_0.append(&mut r_1);

                                args.push(HCO::NODES/*aa22*/(ref_0)); } } }
}
/// ```
/// $1+[$2]
/// ```
fn _fn143(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);

  let mut ref_0: Vec<ASTNode> = Vec::new();
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
ref_0.push(/*RR6*/r_0);
 if let HCO::NODES/*aa00*/(mut r_1) = v0 { 
ref_0.append(&mut r_1);

                                args.push(HCO::NODES/*aa22*/(ref_0)); } }
}
/// ```
/// [$1]
/// ```
fn _fn144(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);

  let mut ref_0: Vec<ASTNode> = Vec::new();
  if let HCO::NODE/*aaRR*/(r_0) = v0 { 
ref_0.push(/*RR6*/r_0);

                                args.push(HCO::NODES/*aa22*/(ref_0)); }
}
/// ```
/// $1+$3+[$NULL]
/// ```
fn _fn145(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);

  let mut ref_0: Vec<ASTNode> = Vec::new();
  if let HCO::NODES/*aa00*/(mut r_0) = v0 { 
 if let HCO::NODES/*aa00*/(mut r_1) = v2 { 
r_0.append(&mut r_1);
ref_0.append(&mut r_0);

                                args.push(HCO::NODES/*aa22*/(ref_0)); } }
}
/// ```
/// $1+[$NULL]
/// ```
fn _fn146(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);

  let mut ref_0: Vec<ASTNode> = Vec::new();
  if let HCO::NODES/*aa00*/(mut r_0) = v0 { 
ref_0.append(&mut r_0);

                                args.push(HCO::NODES/*aa22*/(ref_0)); }
}
/// ```
/// $NULL+[$NULL]
/// ```
fn _fn147(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);

  args.push(/* RR1 */ HCO::OBJECTS(vec![]));
}
/// ```
/// $2
/// ```
fn _fn148(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 args.push(HCO::NODE/*aa99*/(r_0)) }
}
/// ```
/// $__first__+$__last__
/// ```
fn _fn149(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);

  if let HCO::NODES/*aa00*/(mut r_0) = v0 { 
 if let HCO::NODE/*aaRR*/(r_1) = v2 { 
r_0.push(/*UX2*/r_1);

                                args.push(HCO::NODES/*aa22*/(r_0)); } }
}
/// ```
/// $3
/// ```
fn _fn150(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v3 = args.remove(i - 0);
  let mut v2 = args.remove(i - 1);
  let mut v1 = args.remove(i - 2);
  let mut v0 = args.remove(i - 3);
  if let HCO::NODE/*aaRR*/(r_0) = v2 { 
 args.push(HCO::NODE/*aa99*/(r_0)) }
}
/// ```
/// $1+$2
/// ```
fn _fn151(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);

  if let HCO::NODES/*aa00*/(mut r_0) = v0 { 
 if let HCO::NODES/*aa00*/(mut r_1) = v1 { 
r_0.append(&mut r_1);

                                args.push(HCO::NODES/*aa22*/(r_0)); } }
}
/// ```
/// $1
/// ```
fn _fn152(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);

  if let HCO::NODES/*aa00*/(mut r_0) = v0 { 

                                args.push(HCO::NODES/*aa22*/(r_0)); }
}
/// ```
/// $__first__+$__last__
/// ```
fn _fn153(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);

  if let HCO::NODES/*aa00*/(mut r_0) = v0 { 
 if let HCO::NODE/*aaRR*/(r_1) = v1 { 
r_0.push(/*UX2*/r_1);

                                args.push(HCO::NODES/*aa22*/(r_0)); } }
}
/// ```
/// $1
/// ```
fn _fn154(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v0 { 
 args.push(HCO::NODE/*aa99*/(r_0)) }
}
/// ```
/// [$1]
/// ```
fn _fn155(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);

  let mut ref_0: Vec<Token> = Vec::new();
  ref_0.push(/* RR7 */ v0.Token());

  args.push(HCO::TOKENS(ref_0));
}
/// ```
/// $__first__+$__last__
/// ```
fn _fn156(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);

  if let HCO::TOKENS(mut r_0) = v0 {
    r_0.push(/* UX1 */ v1.Token());

    args.push(HCO::TOKENS(r_0));
  }
}
/// ```
/// $__first__+$__last__
/// ```
fn _fn157(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);

  if let HCO::TOKENS(mut r_0) = v0 {
    if let HCO::TOKEN(v1) = v1 {
      r_0.push(/* UX4 PRODUCTION */ v1);
    }

    args.push(HCO::TOKENS(r_0));
  }
}
/// ```
/// $2
/// ```
fn _fn158(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
 args.push(HCO::NODE/*aa99*/(r_0)) }
}
/// ```
/// str($1)
/// ```
fn _fn159(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v0 = args.remove(i - 0);
  if let HCO::TOKEN(r_0) = v0 {
    args.push(HCO::STRING(r_0.to_string()))
  }
}
/// ```
/// $2
/// ```
fn _fn160(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);

  if let HCO::NODES/*aa00*/(mut r_0) = v1 { 

                                args.push(HCO::NODES/*aa22*/(r_0)); }
}
/// ```
/// [$2]
/// ```
fn _fn161(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);

  let mut ref_0: Vec<ASTNode> = Vec::new();
  if let HCO::NODE/*aaRR*/(r_0) = v1 { 
ref_0.push(/*RR6*/r_0);

                                args.push(HCO::NODES/*aa22*/(ref_0)); }
}
/// ```
/// ```
fn _fn162(args: &mut Vec<HCO>, tok: Token) {}
/// ```
/// ```
fn _fn163(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v1 = args.remove(i - 0);
  let mut v0 = args.remove(i - 1);
  args.push(v1);
}
/// ```
/// ```
fn _fn164(args: &mut Vec<HCO>, tok: Token) {
  let mut i = args.len() - 1;
  let mut v2 = args.remove(i - 0);
  let mut v1 = args.remove(i - 1);
  let mut v0 = args.remove(i - 2);
  args.push(v2);
}

pub const FunctionMaps: [RF; 348] = [
  _fn162, _fn0, _fn1, _fn162, _fn162, _fn162, _fn163, _fn162, _fn162, _fn162, _fn162, _fn162,
  _fn163, _fn162, _fn164, _fn2, _fn3, _fn4, _fn5, _fn6, _fn7, _fn8, _fn9, _fn137, _fn163, _fn162,
  _fn162, _fn162, _fn162, _fn163, _fn163, _fn163, _fn137, _fn162, _fn162, _fn10, _fn11, _fn12,
  _fn10, _fn10, _fn10, _fn10, _fn13, _fn13, _fn13, _fn13, _fn13, _fn138, _fn14, _fn139, _fn140,
  _fn162, _fn162, _fn15, _fn141, _fn163, _fn141, _fn141, _fn162, _fn162, _fn162, _fn16, _fn142,
  _fn143, _fn144, _fn143, _fn145, _fn146, _fn146, _fn144, _fn147, _fn17, _fn18, _fn19, _fn20,
  _fn21, _fn22, _fn23, _fn24, _fn25, _fn26, _fn27, _fn28, _fn29, _fn20, _fn23, _fn30, _fn31, _fn32,
  _fn33, _fn34, _fn33, _fn34, _fn162, _fn162, _fn35, _fn36, _fn37, _fn37, _fn38, _fn39, _fn162,
  _fn162, _fn163, _fn163, _fn163, _fn163, _fn162, _fn162, _fn162, _fn162, _fn162, _fn162, _fn162,
  _fn162, _fn40, _fn162, _fn41, _fn162, _fn42, _fn43, _fn44, _fn139, _fn140, _fn45, _fn46, _fn148,
  _fn148, _fn47, _fn47, _fn48, _fn49, _fn50, _fn51, _fn52, _fn53, _fn54, _fn55, _fn56, _fn57,
  _fn58, _fn59, _fn60, _fn61, _fn62, _fn63, _fn64, _fn65, _fn66, _fn67, _fn68, _fn69, _fn70, _fn71,
  _fn72, _fn163, _fn163, _fn144, _fn149, _fn162, _fn162, _fn73, _fn162, _fn164, _fn162, _fn162,
  _fn163, _fn163, _fn162, _fn162, _fn162, _fn162, _fn162, _fn162, _fn162, _fn74, _fn163, _fn162,
  _fn138, _fn150, _fn150, _fn162, _fn162, _fn162, _fn162, _fn162, _fn75, _fn76, _fn77, _fn78,
  _fn139, _fn140, _fn139, _fn139, _fn140, _fn140, _fn79, _fn162, _fn162, _fn162, _fn162, _fn80,
  _fn81, _fn82, _fn83, _fn84, _fn85, _fn86, _fn87, _fn88, _fn89, _fn90, _fn91, _fn162, _fn92,
  _fn93, _fn94, _fn95, _fn96, _fn162, _fn162, _fn162, _fn97, _fn98, _fn99, _fn100, _fn101, _fn144,
  _fn149, _fn102, _fn103, _fn104, _fn105, _fn106, _fn107, _fn108, _fn109, _fn151, _fn152, _fn147,
  _fn144, _fn144, _fn138, _fn110, _fn111, _fn111, _fn144, _fn153, _fn112, _fn113, _fn114, _fn115,
  _fn116, _fn117, _fn162, _fn154, _fn144, _fn153, _fn162, _fn162, _fn162, _fn162, _fn118, _fn144,
  _fn153, _fn162, _fn119, _fn119, _fn120, _fn120, _fn163, _fn162, _fn121, _fn144, _fn144, _fn144,
  _fn153, _fn153, _fn153, _fn122, _fn123, _fn124, _fn125, _fn126, _fn164, _fn127, _fn128, _fn129,
  _fn130, _fn162, _fn155, _fn156, _fn155, _fn156, _fn155, _fn157, _fn139, _fn140, _fn144, _fn153,
  _fn144, _fn153, _fn144, _fn153, _fn144, _fn149, _fn144, _fn149, _fn131, _fn132, _fn144, _fn153,
  _fn144, _fn153, _fn144, _fn153, _fn144, _fn149, _fn144, _fn149, _fn144, _fn153, _fn133, _fn158,
  _fn159, _fn141, _fn159, _fn141, _fn160, _fn159, _fn141, _fn159, _fn141, _fn139, _fn140, _fn139,
  _fn139, _fn140, _fn140, _fn161, _fn149, _fn161, _fn161, _fn149, _fn149, _fn134, _fn135, _fn136,
];
