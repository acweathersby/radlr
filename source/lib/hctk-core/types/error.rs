use super::*;
use crate::types::Token;
use ::std::fmt::Display;
use std::path::Path;
use std::path::PathBuf;
use std::sync::Arc;

/// Severity types of an HCErrors
pub enum ErrorType {
  Warning,
  Hint,
  Critical,
}

/// Stores every error type that can be generated by a HCTK function. Also wraps common
/// error types.
#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub enum HCError {
  //---------------------------------------------------------------------------
  // ----------------- Transition Errors --------------------------------------
  //---------------------------------------------------------------------------
  /// Warning when a fork state is generated for items that have ambiguous production calls.
  transition_err_ambiguous_production {
    source_production: Production,
    body_refs:         Vec<(Arc<GrammarRef>, Token)>,
  },
  /// Error occurs when a scanner parse path cannot be made
  /// unambiguous due two Generic symbol types.
  transition_err_invalid_generics {
    /// The root Symbols that whose combination lead to this error
    root_symbols: Vec<SymbolID>,
    /// The item chain, from the root item to
    /// the leaf, for each branch
    chains:       Vec<Vec<Item>>,
  },

  //---------------------------------------------------------------------------
  // ----------------- Grammar Load Errors ------------------------------------
  //---------------------------------------------------------------------------
  /// A path specified in one grammar file does map to a valid file
  load_err_invalid_grammar_path {
    path: PathBuf,
    reference_token: Option<Token>,
  },

  // An imported grammar path referenced in another grammar does not exist
  load_err_invalid_dependency {
    requestor: PathBuf,
    path:      PathBuf,
    tok:       Token,
    err:       Option<Box<HCError>>,
  },
  //---------------------------------------------------------------------------
  // ----------------- Grammar Compile Errors -------------------------------------------
  //---------------------------------------------------------------------------
  grammar_err_location {
    message: String,
    inline_message: String,
    loc: Token,
    path: PathBuf,
  },

  grammar_err_multi_location {
    message:   String,
    locations: Vec<HCError>,
  },
  //---------------------------------------------------------------------------
  // ----------------- Runtime Errors -------------------------------------------
  //---------------------------------------------------------------------------
  rt_err_parse_error {
    production: u32,
    tok:        Token,
    source:     Option<Arc<Vec<u8>>>,
  },
  rt_err_invalid_parse {
    message: String,
    inline_message: String,
    loc: Token,
    last_production: u32,
  },

  //---------------------------------------------------------------------------
  // ----------------- Ir Error Types -----------------------------------------
  //---------------------------------------------------------------------------
  ir_err_bad_parse,
  ir_warn_not_parsed,

  //---------------------------------------------------------------------------
  // ----------------- Generic Error Types ------------------------------------
  //---------------------------------------------------------------------------
  UNDEFINED,
  IOError(String),
  Error(std::fmt::Error),
  Text(String),
  Many {
    message: String,
    errors:  Vec<HCError>,
  },
}

use ErrorType::*;
use HCError::*;

impl HCError {
  pub fn get_error_type(&self) -> ErrorType {
    match self {
      transition_err_ambiguous_production { .. } => Warning,
      _ => Critical,
    }
  }

  pub fn is_critical(&self) -> bool {
    matches!(self.get_error_type(), Critical)
  }

  pub fn is_hint(&self) -> bool {
    matches!(self.get_error_type(), Hint)
  }

  pub fn is_warning(&self) -> bool {
    matches!(self.get_error_type(), Warning)
  }
}

impl From<std::io::Error> for HCError {
  fn from(err: std::io::Error) -> Self {
    IOError(err.to_string())
  }
}

impl From<std::fmt::Error> for HCError {
  fn from(err: std::fmt::Error) -> Self {
    Self::Error(err)
  }
}

impl From<()> for HCError {
  fn from(err: ()) -> Self {
    UNDEFINED
  }
}

impl From<&str> for HCError {
  fn from(err: &str) -> Self {
    Text(err.to_string())
  }
}

impl From<String> for HCError {
  fn from(err: String) -> Self {
    Text(err)
  }
}

impl Display for HCError {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    match self {
      UNDEFINED => f.write_str("\nAn unknown error has occurred "),
      transition_err_invalid_generics { .. } => f.write_str("\nTransition_InvalidGenerics Error"),
      load_err_invalid_grammar_path { .. } => f.write_str("\nLoad_InvalidGrammarPath Error"),
      load_err_invalid_dependency { path, requestor, tok, err } => f.write_fmt(format_args!(
        "\nThe import grammar path [{}], referenced in [{}:{}], does not exist: \n{}",
        path.to_str().unwrap_or(""),
        requestor.to_str().unwrap_or(""),
        tok.clone().get_line() + 1,
        tok.blame(
          1,
          1,
          &err.as_ref().unwrap_or(&Box::new(HCError::UNDEFINED)).to_string(),
          BlameColor::Red
        )
      )),
      IOError(err_string) => f.write_fmt(format_args!("\nIO Error: {}", err_string)),
      Text(err_string) => f.write_str(&err_string),
      Self::Error(err) => err.fmt(f),
      ir_warn_not_parsed => f.write_str("\nIRNode has not been parsed"),
      ir_err_bad_parse => f.write_str("\nErrors occurred during while parsing IRNode code"),
      grammar_err_location { message, inline_message, loc, path } => {
        let Range { start_line, start_column, .. } = loc.get_range();
        f.write_fmt(format_args!(
          "\n[{}:{}:{}]\n   {}\n{}",
          path.to_str().unwrap(),
          start_line,
          start_column,
          message,
          loc.blame(1, 1, &inline_message, BlameColor::Red),
        ))
      }
      grammar_err_multi_location { message, locations } => f.write_fmt(format_args!(
        "\n{}\n{}",
        message,
        locations.iter().map(|s| format!("{}", s)).collect::<Vec<_>>().join("\n"),
      )),
      rt_err_invalid_parse { message, inline_message, loc, last_production } => f.write_fmt(
        format_args!("{}\n{}", message, loc.blame(1, 1, inline_message, BlameColor::Red)),
      ),
      rt_err_parse_error { production, tok, source } => {
        let mut tok = tok.clone();
        if tok.is_empty() {
          tok = tok.to_length(1);
        }
        f.write_str(&tok.blame(0, 0, "Unexpected Token", BlameColor::Red))
      }
      Many { message, errors } => f.write_fmt(format_args!(
        "\n{} \n-------------------\n {}",
        message,
        errors.iter().map(|e| e.to_string()).collect::<Vec<_>>().join("\n")
      )),
      transition_err_ambiguous_production { source_production, body_refs } => {
        f.write_fmt(format_args!(
          "In the parse path of {}, these production lead to an ambiguous parse:\n{}",
          source_production.name,
          body_refs
            .iter()
            .map(|(grammar_ref, tok)| {
              let Range { start_line, start_column, .. } = tok.get_range();
              format!(
                "[{}:{}:{}]\n{}",
                grammar_ref.path.to_str().unwrap(),
                start_line,
                start_column,
                tok.blame(1, 1, "conflicts with other productions", BlameColor::Red)
              )
            })
            .collect::<Vec<_>>()
            .join("\n")
        ))
      }
    }
  }
}
#[derive(Default, Debug)]
pub struct ErrorGroups {
  pub hints:    Vec<HCError>,
  pub warnings: Vec<HCError>,
  pub critical: Vec<HCError>,
}

pub trait ErrorGroup {
  /// Returns a sorted set of HCErrors represented by ErrorGroups
  fn get_errors_types(&self) -> ErrorGroups;

  fn get_critical(&self) -> Vec<HCError> {
    self.get_errors_types().critical
  }

  fn get_warnings(&self) -> Vec<HCError> {
    self.get_errors_types().warnings
  }

  fn get_hints(&self) -> Vec<HCError> {
    self.get_errors_types().hints
  }

  fn have_errors(&self) -> bool;

  fn have_critical(&self) -> bool;

  fn have_warnings(&self) -> bool;

  fn have_hints(&self) -> bool;
}

impl ErrorGroup for Vec<HCError> {
  fn get_errors_types(&self) -> ErrorGroups {
    let mut groups = ErrorGroups { ..Default::default() };
    for error in self {
      match error.get_error_type() {
        Critical => groups.critical.push(error.clone()),
        Warning => groups.warnings.push(error.clone()),
        Hint => groups.critical.push(error.clone()),
      }
    }

    groups
  }

  fn have_errors(&self) -> bool {
    !self.is_empty()
  }

  fn have_critical(&self) -> bool {
    self.iter().any(|e| e.is_critical())
  }

  fn have_hints(&self) -> bool {
    self.iter().any(|e| e.is_hint())
  }

  fn have_warnings(&self) -> bool {
    self.iter().any(|e| e.is_warning())
  }
}

impl From<&Vec<HCError>> for ErrorGroups {
  fn from(vec: &Vec<HCError>) -> Self {
    vec.get_errors_types()
  }
}
